!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
$argv	.\test\releasetest.tcl	/^  process_options $argv$/;"	p
$argv	.\tool\omittest.tcl	/^  process_options $argv$/;"	p
ACCEPT	.\tool\lemon.c	/^  ACCEPT,$/;"	e	enum:e_action	file:
ADDR	.\src\vdbe.h	156;"	d
AGGREGATE	.\src\sqliteInt.h	1455;"	d
AGGREGATE2	.\src\sqliteInt.h	1458;"	d
ALTER	.\tool\mkkeywordhash.c	55;"	d	file:
ALTER	.\tool\mkkeywordhash.c	57;"	d	file:
ALWAYS	.\ext\fts3\fts3Int.h	135;"	d
ALWAYS	.\ext\fts5\fts5Int.h	35;"	d
ALWAYS	.\ext\misc\spellfix.c	25;"	d	file:
ALWAYS	.\src\sqliteInt.h	380;"	d
ALWAYS	.\src\sqliteInt.h	383;"	d
ALWAYS	.\src\sqliteInt.h	386;"	d
ALWAYS	.\tool\mkkeywordhash.c	59;"	d	file:
AMATCH_COL_COMMAND	.\ext\misc\amatch.c	910;"	d	file:
AMATCH_COL_DISTANCE	.\ext\misc\amatch.c	908;"	d	file:
AMATCH_COL_LANGUAGE	.\ext\misc\amatch.c	909;"	d	file:
AMATCH_COL_NWORD	.\ext\misc\amatch.c	911;"	d	file:
AMATCH_COL_WORD	.\ext\misc\amatch.c	907;"	d	file:
AMATCH_MX_COST	.\ext\misc\amatch.c	461;"	d	file:
AMATCH_MX_LANGID	.\ext\misc\amatch.c	460;"	d	file:
AMATCH_MX_LENGTH	.\ext\misc\amatch.c	459;"	d	file:
ANALYZE	.\tool\mkkeywordhash.c	61;"	d	file:
ANALYZE	.\tool\mkkeywordhash.c	63;"	d	file:
AND	.\ext\fts5\test\fts5_common.tcl	/^proc AND {args} {$/;"	p
ASSERT_SZLEAF_OK	.\ext\fts5\fts5_index.c	483;"	d	file:
ASSERT_VALID_DOCLIST	.\ext\fts2\fts2.c	734;"	d	file:
ASSERT_VALID_DOCLIST	.\ext\fts2\fts2.c	736;"	d	file:
ASSERT_VALID_INTERIOR_BLOCK	.\ext\fts2\fts2.c	4155;"	d	file:
ASSERT_VALID_INTERIOR_BLOCK	.\ext\fts2\fts2.c	4157;"	d	file:
ASSERT_VALID_LEAF_NODE	.\ext\fts2\fts2.c	4558;"	d	file:
ASSERT_VALID_LEAF_NODE	.\ext\fts2\fts2.c	4560;"	d	file:
ASYNC_CLOSE	.\ext\async\sqlite3async.c	401;"	d	file:
ASYNC_COND_QUEUE	.\ext\async\sqlite3async.c	243;"	d	file:
ASYNC_DELETE	.\ext\async\sqlite3async.c	402;"	d	file:
ASYNC_MUTEX_LOCK	.\ext\async\sqlite3async.c	238;"	d	file:
ASYNC_MUTEX_QUEUE	.\ext\async\sqlite3async.c	239;"	d	file:
ASYNC_MUTEX_WRITER	.\ext\async\sqlite3async.c	240;"	d	file:
ASYNC_NOOP	.\ext\async\sqlite3async.c	397;"	d	file:
ASYNC_OPENEXCLUSIVE	.\ext\async\sqlite3async.c	403;"	d	file:
ASYNC_SYNC	.\ext\async\sqlite3async.c	399;"	d	file:
ASYNC_TRACE	.\ext\async\sqlite3async.c	47;"	d	file:
ASYNC_TRACE	.\ext\async\sqlite3async.c	58;"	d	file:
ASYNC_TRUNCATE	.\ext\async\sqlite3async.c	400;"	d	file:
ASYNC_UNLOCK	.\ext\async\sqlite3async.c	404;"	d	file:
ASYNC_WRITE	.\ext\async\sqlite3async.c	398;"	d	file:
ATTACH	.\tool\mkkeywordhash.c	66;"	d	file:
ATTACH	.\tool\mkkeywordhash.c	68;"	d	file:
AUTOINCR	.\tool\mkkeywordhash.c	71;"	d	file:
AUTOINCR	.\tool\mkkeywordhash.c	73;"	d	file:
AUTOVACUUM	.\tool\mkkeywordhash.c	137;"	d	file:
AUTOVACUUM	.\tool\mkkeywordhash.c	139;"	d	file:
Action_add	.\tool\lemon.c	/^void Action_add($/;"	f
Action_new	.\tool\lemon.c	/^static struct action *Action_new(void){$/;"	f	file:
Action_sort	.\tool\lemon.c	/^static struct action *Action_sort($/;"	f	file:
AdjustTree	.\ext\rtree\rtree.c	/^static int AdjustTree($/;"	f	file:
AggInfo	.\src\sqliteInt.h	/^struct AggInfo {$/;"	s
AggInfo	.\src\sqliteInt.h	/^typedef struct AggInfo AggInfo;$/;"	t	typeref:struct:AggInfo
AggInfo_col	.\src\sqliteInt.h	/^  struct AggInfo_col {    \/* For each column used in source tables *\/$/;"	s	struct:AggInfo
AggInfo_func	.\src\sqliteInt.h	/^  struct AggInfo_func {   \/* For each aggregate function *\/$/;"	s	struct:AggInfo
ApplyCostMultiplier	.\src\where.c	2147;"	d	file:
ApplyCostMultiplier	.\src\where.c	2149;"	d	file:
Argv0	.\src\shell.c	/^static char *Argv0;$/;"	v	file:
ArraySize	.\ext\fts5\fts5Int.h	32;"	d
ArraySize	.\src\shell.c	607;"	d	file:
ArraySize	.\src\sqliteInt.h	851;"	d
ArraySize	.\tool\offsets.c	17;"	d	file:
AsciiTokenizer	.\ext\fts5\fts5_tokenize.c	/^struct AsciiTokenizer {$/;"	s	file:
AsciiTokenizer	.\ext\fts5\fts5_tokenize.c	/^typedef struct AsciiTokenizer AsciiTokenizer;$/;"	t	typeref:struct:AsciiTokenizer	file:
AsyncFile	.\ext\async\sqlite3async.c	/^struct AsyncFile {$/;"	s	file:
AsyncFile	.\ext\async\sqlite3async.c	/^typedef struct AsyncFile AsyncFile;$/;"	t	typeref:struct:AsyncFile	file:
AsyncFileData	.\ext\async\sqlite3async.c	/^struct AsyncFileData {$/;"	s	file:
AsyncFileData	.\ext\async\sqlite3async.c	/^typedef struct AsyncFileData AsyncFileData;$/;"	t	typeref:struct:AsyncFileData	file:
AsyncFileLock	.\ext\async\sqlite3async.c	/^struct AsyncFileLock {$/;"	s	file:
AsyncFileLock	.\ext\async\sqlite3async.c	/^typedef struct AsyncFileLock AsyncFileLock;$/;"	t	typeref:struct:AsyncFileLock	file:
AsyncLock	.\ext\async\sqlite3async.c	/^struct AsyncLock {$/;"	s	file:
AsyncLock	.\ext\async\sqlite3async.c	/^typedef struct AsyncLock AsyncLock;$/;"	t	typeref:struct:AsyncLock	file:
AsyncPrimitives	.\ext\async\sqlite3async.c	/^static struct AsyncPrimitives {$/;"	s	file:
AsyncWrite	.\ext\async\sqlite3async.c	/^struct AsyncWrite {$/;"	s	file:
AsyncWrite	.\ext\async\sqlite3async.c	/^typedef struct AsyncWrite AsyncWrite;$/;"	t	typeref:struct:AsyncWrite	file:
AuthContext	.\src\sqliteInt.h	/^struct AuthContext {$/;"	s
AuthContext	.\src\sqliteInt.h	/^typedef struct AuthContext AuthContext;$/;"	t	typeref:struct:AuthContext
AutoincInfo	.\src\sqliteInt.h	/^struct AutoincInfo {$/;"	s
AutoincInfo	.\src\sqliteInt.h	/^typedef struct AutoincInfo AutoincInfo;$/;"	t	typeref:struct:AutoincInfo
AuxData	.\src\vdbeInt.h	/^struct AuxData {$/;"	s
AuxData	.\src\vdbeInt.h	/^typedef struct AuxData AuxData;$/;"	t	typeref:struct:AuxData
BEGIN_TIMER	.\src\shell.c	226;"	d	file:
BEGIN_TIMER	.\src\shell.c	305;"	d	file:
BEGIN_TIMER	.\src\shell.c	310;"	d	file:
BITVEC_HASH	.\src\bitvec.c	67;"	d	file:
BITVEC_MXHASH	.\src\bitvec.c	62;"	d	file:
BITVEC_NBIT	.\src\bitvec.c	56;"	d	file:
BITVEC_NELEM	.\src\bitvec.c	54;"	d	file:
BITVEC_NINT	.\src\bitvec.c	59;"	d	file:
BITVEC_NPTR	.\src\bitvec.c	69;"	d	file:
BITVEC_SZ	.\src\bitvec.c	40;"	d	file:
BITVEC_SZELEM	.\src\bitvec.c	52;"	d	file:
BITVEC_TELEM	.\src\bitvec.c	50;"	d	file:
BITVEC_USIZE	.\src\bitvec.c	44;"	d	file:
BLOBSIZE	.\src\test_onefile.c	90;"	d	file:
BLOCKSIZE	.\src\test_onefile.c	89;"	d	file:
BLOCK_DELETE_ALL_STMT	.\ext\fts2\fts2.c	/^  BLOCK_DELETE_ALL_STMT,$/;"	e	enum:fulltext_statement	file:
BLOCK_DELETE_STMT	.\ext\fts2\fts2.c	/^  BLOCK_DELETE_STMT,$/;"	e	enum:fulltext_statement	file:
BLOCK_INSERT_STMT	.\ext\fts2\fts2.c	/^  BLOCK_INSERT_STMT,$/;"	e	enum:fulltext_statement	file:
BLOCK_SELECT_STMT	.\ext\fts2\fts2.c	/^  BLOCK_SELECT_STMT,$/;"	e	enum:fulltext_statement	file:
BMS	.\src\sqliteInt.h	2268;"	d
BTALLOC_ANY	.\src\btree.c	49;"	d	file:
BTALLOC_EXACT	.\src\btree.c	50;"	d	file:
BTALLOC_LE	.\src\btree.c	51;"	d	file:
BTCF_AtLast	.\src\btreeInt.h	540;"	d
BTCF_Incrblob	.\src\btreeInt.h	541;"	d
BTCF_Multiple	.\src\btreeInt.h	542;"	d
BTCF_ValidNKey	.\src\btreeInt.h	538;"	d
BTCF_ValidOvfl	.\src\btreeInt.h	539;"	d
BTCF_WriteFlag	.\src\btreeInt.h	537;"	d
BTCURSOR_MAX_DEPTH	.\src\btreeInt.h	486;"	d
BTREE_APPLICATION_ID	.\src\btree.h	149;"	d
BTREE_AUTOVACUUM_FULL	.\src\btree.h	33;"	d
BTREE_AUTOVACUUM_INCR	.\src\btree.h	34;"	d
BTREE_AUTOVACUUM_NONE	.\src\btree.h	32;"	d
BTREE_BLOBKEY	.\src\btree.h	112;"	d
BTREE_BULKLOAD	.\src\btree.h	165;"	d
BTREE_DATA_VERSION	.\src\btree.h	150;"	d
BTREE_DEFAULT_CACHE_SIZE	.\src\btree.h	144;"	d
BTREE_FILE_FORMAT	.\src\btree.h	143;"	d
BTREE_FREE_PAGE_COUNT	.\src\btree.h	141;"	d
BTREE_INCR_VACUUM	.\src\btree.h	148;"	d
BTREE_INTKEY	.\src\btree.h	111;"	d
BTREE_LARGEST_ROOT_PAGE	.\src\btree.h	145;"	d
BTREE_MEMORY	.\src\btree.h	60;"	d
BTREE_OMIT_JOURNAL	.\src\btree.h	59;"	d
BTREE_SCHEMA_VERSION	.\src\btree.h	142;"	d
BTREE_SEEK_EQ	.\src\btree.h	166;"	d
BTREE_SINGLE	.\src\btree.h	61;"	d
BTREE_TEXT_ENCODING	.\src\btree.h	146;"	d
BTREE_UNORDERED	.\src\btree.h	62;"	d
BTREE_USER_VERSION	.\src\btree.h	147;"	d
BTS_EXCLUSIVE	.\src\btreeInt.h	460;"	d
BTS_INITIALLY_EMPTY	.\src\btreeInt.h	458;"	d
BTS_NO_WAL	.\src\btreeInt.h	459;"	d
BTS_PAGESIZE_FIXED	.\src\btreeInt.h	456;"	d
BTS_PENDING	.\src\btreeInt.h	461;"	d
BTS_READ_ONLY	.\src\btreeInt.h	455;"	d
BTS_SECURE_DELETE	.\src\btreeInt.h	457;"	d
BYTESWAP32	.\src\wal.c	581;"	d	file:
BenignMallocHooks	.\src\fault.c	/^static SQLITE_WSD struct BenignMallocHooks {$/;"	s	file:
BenignMallocHooks	.\src\fault.c	/^typedef struct BenignMallocHooks BenignMallocHooks;$/;"	t	typeref:struct:BenignMallocHooks	file:
BinaryOp	.\test\fuzz_common.tcl	/^proc BinaryOp {} {$/;"	p
BitFlagAllTest	.\ext\fts5\fts5_main.c	230;"	d	file:
BitFlagTest	.\ext\fts5\fts5_main.c	231;"	d	file:
Bitmask	.\src\sqliteInt.h	/^typedef u64 Bitmask;$/;"	t
Bitvec	.\src\bitvec.c	/^struct Bitvec {$/;"	s	file:
Bitvec	.\src\sqliteInt.h	/^typedef struct Bitvec Bitvec;$/;"	t	typeref:struct:Bitvec
Blob	.\ext\fts3\fts3_write.c	/^struct Blob {$/;"	s	file:
Blob	.\ext\fts3\fts3_write.c	/^typedef struct Blob Blob;$/;"	t	typeref:struct:Blob	file:
Blob	.\test\fuzzcheck.c	/^struct Blob {$/;"	s	file:
Blob	.\test\fuzzcheck.c	/^typedef struct Blob Blob;$/;"	t	typeref:struct:Blob	file:
Bool	.\src\vdbeInt.h	/^typedef unsigned Bool;$/;"	t
Boolean	.\tool\lemon.c	/^typedef enum {LEMON_FALSE=0, LEMON_TRUE} Boolean;$/;"	t	typeref:enum:__anon33	file:
Box	.\src\test_rtree.c	/^  struct Box {$/;"	s	struct:Circle	file:
BtCursor	.\src\btree.h	/^typedef struct BtCursor BtCursor;$/;"	t	typeref:struct:BtCursor
BtCursor	.\src\btreeInt.h	/^struct BtCursor {$/;"	s
BtLock	.\src\btreeInt.h	/^struct BtLock {$/;"	s
BtLock	.\src\btreeInt.h	/^typedef struct BtLock BtLock;$/;"	t	typeref:struct:BtLock
BtShared	.\src\btree.h	/^typedef struct BtShared BtShared;$/;"	t	typeref:struct:BtShared
BtShared	.\src\btreeInt.h	/^struct BtShared {$/;"	s
Btree	.\src\btree.h	/^typedef struct Btree Btree;$/;"	t	typeref:struct:Btree
Btree	.\src\btreeInt.h	/^struct Btree {$/;"	s
BusyHandler	.\src\sqliteInt.h	/^struct BusyHandler {$/;"	s
BusyHandler	.\src\sqliteInt.h	/^typedef struct BusyHandler BusyHandler;$/;"	t	typeref:struct:BusyHandler
ByteRangeLockPB2	.\src\os_unix.c	/^struct ByteRangeLockPB2$/;"	s	file:
CACHE_STALE	.\src\vdbeInt.h	160;"	d
CALLGRINDTEST1_NROW	.\test\threadtest3.c	1248;"	d	file:
CASE	.\ext\fts5\fts5_tcl.c	259;"	d	file:
CASE	.\ext\fts5\fts5_tcl.c	438;"	d	file:
CAST	.\tool\mkkeywordhash.c	76;"	d	file:
CAST	.\tool\mkkeywordhash.c	78;"	d	file:
CCLASS_B	.\ext\misc\spellfix.c	53;"	d	file:
CCLASS_C	.\ext\misc\spellfix.c	54;"	d	file:
CCLASS_D	.\ext\misc\spellfix.c	55;"	d	file:
CCLASS_DIGIT	.\ext\misc\spellfix.c	61;"	d	file:
CCLASS_H	.\ext\misc\spellfix.c	56;"	d	file:
CCLASS_L	.\ext\misc\spellfix.c	57;"	d	file:
CCLASS_M	.\ext\misc\spellfix.c	59;"	d	file:
CCLASS_OTHER	.\ext\misc\spellfix.c	63;"	d	file:
CCLASS_R	.\ext\misc\spellfix.c	58;"	d	file:
CCLASS_SILENT	.\ext\misc\spellfix.c	51;"	d	file:
CCLASS_SPACE	.\ext\misc\spellfix.c	62;"	d	file:
CCLASS_VOWEL	.\ext\misc\spellfix.c	52;"	d	file:
CCLASS_Y	.\ext\misc\spellfix.c	60;"	d	file:
CHECKPOINT_STARVATION_FRAMELIMIT	.\test\tt3_checkpoint.c	42;"	d	file:
CHECKPOINT_STARVATION_READMS	.\test\tt3_checkpoint.c	45;"	d	file:
CHECK_PAGE	.\src\pager.c	1202;"	d	file:
CHECK_PAGE	.\src\pager.c	1213;"	d	file:
CHUNK	.\autoconf\tea\win\nmakehlp.c	55;"	d	file:
CHUNK_MAX	.\ext\fts1\fts1.c	1038;"	d	file:
CHUNK_MAX	.\ext\fts1\fulltext.c	525;"	d	file:
CInstIter	.\ext\fts5\fts5_aux.c	/^struct CInstIter {$/;"	s	file:
CInstIter	.\ext\fts5\fts5_aux.c	/^typedef struct CInstIter CInstIter;$/;"	t	typeref:struct:CInstIter	file:
CLEAR	.\ext\fts2\fts2.c	395;"	d	file:
CLEARBIT	.\src\bitvec.c	303;"	d	file:
CLOSURE_COL_DEPTH	.\ext\misc\closure.c	560;"	d	file:
CLOSURE_COL_ID	.\ext\misc\closure.c	559;"	d	file:
CLOSURE_COL_IDCOLUMN	.\ext\misc\closure.c	563;"	d	file:
CLOSURE_COL_PARENTCOLUMN	.\ext\misc\closure.c	564;"	d	file:
CLOSURE_COL_ROOT	.\ext\misc\closure.c	561;"	d	file:
CLOSURE_COL_TABLENAME	.\ext\misc\closure.c	562;"	d	file:
CODEC1	.\src\pager.c	413;"	d	file:
CODEC1	.\src\pager.c	419;"	d	file:
CODEC2	.\src\pager.c	415;"	d	file:
CODEC2	.\src\pager.c	420;"	d	file:
COLFLAG_HIDDEN	.\src\sqliteInt.h	1516;"	d
COLFLAG_PRIMKEY	.\src\sqliteInt.h	1515;"	d
COLNAME_COLUMN	.\src\vdbe.h	139;"	d
COLNAME_DATABASE	.\src\vdbe.h	137;"	d
COLNAME_DECLTYPE	.\src\vdbe.h	136;"	d
COLNAME_N	.\src\vdbe.h	141;"	d
COLNAME_N	.\src\vdbe.h	144;"	d
COLNAME_N	.\src\vdbe.h	146;"	d
COLNAME_NAME	.\src\vdbe.h	135;"	d
COLNAME_TABLE	.\src\vdbe.h	138;"	d
COLUMN_MASK	.\src\fkey.c	1049;"	d	file:
COMPLETE	.\tool\lemon.c	/^  COMPLETE,$/;"	e	enum:cfgstatus	file:
COMPOUND	.\tool\mkkeywordhash.c	81;"	d	file:
COMPOUND	.\tool\mkkeywordhash.c	83;"	d	file:
CONFLICT	.\tool\mkkeywordhash.c	86;"	d	file:
CONFLICT	.\tool\mkkeywordhash.c	88;"	d	file:
CONTENT_DELETE_STMT	.\ext\fts1\fts1.c	/^  CONTENT_DELETE_STMT,$/;"	e	enum:fulltext_statement	file:
CONTENT_DELETE_STMT	.\ext\fts1\fulltext.c	/^  CONTENT_DELETE_STMT,$/;"	e	enum:fulltext_statement	file:
CONTENT_DELETE_STMT	.\ext\fts2\fts2.c	/^  CONTENT_DELETE_STMT,$/;"	e	enum:fulltext_statement	file:
CONTENT_EXISTS_STMT	.\ext\fts2\fts2.c	/^  CONTENT_EXISTS_STMT,$/;"	e	enum:fulltext_statement	file:
CONTENT_INSERT_STMT	.\ext\fts1\fts1.c	/^  CONTENT_INSERT_STMT,$/;"	e	enum:fulltext_statement	file:
CONTENT_INSERT_STMT	.\ext\fts1\fulltext.c	/^  CONTENT_INSERT_STMT,$/;"	e	enum:fulltext_statement	file:
CONTENT_INSERT_STMT	.\ext\fts2\fts2.c	/^  CONTENT_INSERT_STMT,$/;"	e	enum:fulltext_statement	file:
CONTENT_SELECT_STMT	.\ext\fts1\fts1.c	/^  CONTENT_SELECT_STMT,$/;"	e	enum:fulltext_statement	file:
CONTENT_SELECT_STMT	.\ext\fts1\fulltext.c	/^  CONTENT_SELECT_STMT,$/;"	e	enum:fulltext_statement	file:
CONTENT_SELECT_STMT	.\ext\fts2\fts2.c	/^  CONTENT_SELECT_STMT,$/;"	e	enum:fulltext_statement	file:
CONTENT_UPDATE_STMT	.\ext\fts1\fts1.c	/^  CONTENT_UPDATE_STMT,$/;"	e	enum:fulltext_statement	file:
CONTENT_UPDATE_STMT	.\ext\fts2\fts2.c	/^  CONTENT_UPDATE_STMT,$/;"	e	enum:fulltext_statement	file:
CORRUPT_DB	.\src\sqliteInt.h	3008;"	d
CR_OK	.\tool\checkSpacing.c	14;"	d	file:
CTE	.\tool\mkkeywordhash.c	142;"	d	file:
CTE	.\tool\mkkeywordhash.c	144;"	d	file:
CTIMEOPT_VAL	.\src\ctime.c	34;"	d	file:
CTIMEOPT_VAL_	.\src\ctime.c	33;"	d	file:
CTRL_FREE	.\src\mem5.c	84;"	d	file:
CTRL_LOGSIZE	.\src\mem5.c	83;"	d	file:
CURSOR_FAULT	.\src\btreeInt.h	578;"	d
CURSOR_INVALID	.\src\btreeInt.h	574;"	d
CURSOR_REQUIRESEEK	.\src\btreeInt.h	577;"	d
CURSOR_SKIPNEXT	.\src\btreeInt.h	576;"	d
CURSOR_VALID	.\src\btreeInt.h	575;"	d
CellArray	.\src\btree.c	/^struct CellArray {$/;"	s	file:
CellArray	.\src\btree.c	/^typedef struct CellArray CellArray;$/;"	t	typeref:struct:CellArray	file:
CellInfo	.\src\btreeInt.h	/^struct CellInfo {$/;"	s
CellInfo	.\src\btreeInt.h	/^typedef struct CellInfo CellInfo;$/;"	t	typeref:struct:CellInfo
Check	.\test\fuzz_common.tcl	/^proc Check {} {$/;"	p
CheckForCompilerFeature	.\autoconf\tea\win\nmakehlp.c	/^CheckForCompilerFeature($/;"	f	file:
CheckForLinkerFeature	.\autoconf\tea\win\nmakehlp.c	/^CheckForLinkerFeature($/;"	f	file:
CheckpointStarvationCtx	.\test\tt3_checkpoint.c	/^struct CheckpointStarvationCtx {$/;"	s	file:
CheckpointStarvationCtx	.\test\tt3_checkpoint.c	/^typedef struct CheckpointStarvationCtx CheckpointStarvationCtx;$/;"	t	typeref:struct:CheckpointStarvationCtx	file:
ChooseLeaf	.\ext\rtree\rtree.c	/^static int ChooseLeaf($/;"	f	file:
Circle	.\src\test_rtree.c	/^struct Circle {$/;"	s	file:
Circle	.\src\test_rtree.c	/^typedef struct Circle Circle;$/;"	t	typeref:struct:Circle	file:
Cksum	.\tool\showwal.c	/^struct Cksum {$/;"	s	file:
Cksum	.\tool\showwal.c	/^typedef struct Cksum Cksum;$/;"	t	typeref:struct:Cksum	file:
Cleanup	.\src\vdbeaux.c	/^static void Cleanup(Vdbe *p){$/;"	f	file:
CollSeq	.\src\sqliteInt.h	/^struct CollSeq {$/;"	s
CollSeq	.\src\sqliteInt.h	/^typedef struct CollSeq CollSeq;$/;"	t	typeref:struct:CollSeq
Coltype	.\test\fuzz_common.tcl	/^proc Coltype {} {$/;"	p
Column	.\src\sqliteInt.h	/^struct Column {$/;"	s
Column	.\src\sqliteInt.h	/^typedef struct Column Column;$/;"	t	typeref:struct:Column
Column	.\test\fuzz_common.tcl	/^proc Column {} {$/;"	p
CompressTables	.\tool\lemon.c	/^void CompressTables(struct lemon *lemp)$/;"	f
ConfigPrint	.\tool\lemon.c	/^void ConfigPrint(FILE *fp, struct config *cfp){$/;"	f
Configcmp	.\tool\lemon.c	/^int Configcmp(const char *_a,const char *_b)$/;"	f
Configlist_add	.\tool\lemon.c	/^struct config *Configlist_add($/;"	f
Configlist_addbasis	.\tool\lemon.c	/^struct config *Configlist_addbasis(struct rule *rp, int dot)$/;"	f
Configlist_basis	.\tool\lemon.c	/^struct config *Configlist_basis(){$/;"	f
Configlist_closure	.\tool\lemon.c	/^void Configlist_closure(struct lemon *lemp)$/;"	f
Configlist_eat	.\tool\lemon.c	/^void Configlist_eat(struct config *cfp)$/;"	f
Configlist_init	.\tool\lemon.c	/^void Configlist_init(){$/;"	f
Configlist_reset	.\tool\lemon.c	/^void Configlist_reset(){$/;"	f
Configlist_return	.\tool\lemon.c	/^struct config *Configlist_return(){$/;"	f
Configlist_sort	.\tool\lemon.c	/^void Configlist_sort(){$/;"	f
Configlist_sortbasis	.\tool\lemon.c	/^void Configlist_sortbasis(){$/;"	f
Configtable_clear	.\tool\lemon.c	/^void Configtable_clear(int(*f)(struct config *))$/;"	f
Configtable_find	.\tool\lemon.c	/^struct config *Configtable_find(struct config *key)$/;"	f
Configtable_init	.\tool\lemon.c	/^void Configtable_init(){$/;"	f
Configtable_insert	.\tool\lemon.c	/^int Configtable_insert(struct config *data)$/;"	f
ConstFactorOk	.\src\sqliteInt.h	1330;"	d
CountCtx	.\src\func.c	/^struct CountCtx {$/;"	s	file:
CountCtx	.\src\func.c	/^typedef struct CountCtx CountCtx;$/;"	t	typeref:struct:CountCtx	file:
CrashFile	.\src\test6.c	/^struct CrashFile {$/;"	s	file:
CrashFile	.\src\test6.c	/^typedef struct CrashFile CrashFile;$/;"	t	typeref:struct:CrashFile	file:
CrashFileVtab	.\src\test6.c	/^static const sqlite3_io_methods CrashFileVtab = {$/;"	v	file:
CrashGlobal	.\src\test6.c	/^struct CrashGlobal {$/;"	s	file:
CrashGlobal	.\src\test6.c	/^typedef struct CrashGlobal CrashGlobal;$/;"	t	typeref:struct:CrashGlobal	file:
CreateFunctionV2	.\src\test1.c	/^struct CreateFunctionV2 {$/;"	s	file:
CreateFunctionV2	.\src\test1.c	/^typedef struct CreateFunctionV2 CreateFunctionV2;$/;"	t	typeref:struct:CreateFunctionV2	file:
CreateOrDropTableOrView	.\test\fuzz_common.tcl	/^proc CreateOrDropTableOrView {} {$/;"	p
CreateProcess	.\autoconf\ltmain.sh	/^   CreateProcess().  We must quote the arguments since Win32 CreateProcess()$/;"	f
CreateTable	.\test\fuzz_common.tcl	/^proc CreateTable {} {$/;"	p
CreateView	.\test\fuzz_common.tcl	/^proc CreateView {} {$/;"	p
CsrFlagClear	.\ext\fts5\fts5_main.c	238;"	d	file:
CsrFlagSet	.\ext\fts5\fts5_main.c	237;"	d	file:
CsrFlagTest	.\ext\fts5\fts5_main.c	239;"	d	file:
Cte	.\src\sqliteInt.h	/^  struct Cte {                    \/* For each CTE in the WITH clause.... *\/$/;"	s	struct:With
Cube	.\src\test_rtree.c	/^struct Cube {$/;"	s	file:
Cube	.\src\test_rtree.c	/^typedef struct Cube Cube;$/;"	t	typeref:struct:Cube	file:
D	.\src\date.c	/^  int Y, M, D;       \/* Year, month, and day *\/$/;"	m	struct:DateTime	file:
DATABASE_FILE	.\src\test_onefile.c	125;"	d	file:
DB_Empty	.\src\sqliteInt.h	1043;"	d
DB_FILE	.\test\threadtest2.c	28;"	d	file:
DB_SchemaLoaded	.\src\sqliteInt.h	1041;"	d
DB_UnresetViews	.\src\sqliteInt.h	1042;"	d
DCOORD	.\ext\rtree\rtree.c	258;"	d	file:
DCOORD	.\ext\rtree\rtree.c	260;"	d	file:
DEBUG_COLUMN_NAMES	.\tool\sqldiff.c	43;"	d	file:
DEBUG_DIFF_SQL	.\tool\sqldiff.c	44;"	d	file:
DEFAULT_SECTOR_SIZE	.\src\test_multiplex.c	69;"	d	file:
DEFAULT_TIMEOUT	.\mptest\mptest.c	89;"	d	file:
DEVSYM_MAX_PATHNAME	.\src\test_devsym.c	25;"	d	file:
DEVSYM_VFS_NAME	.\src\test_devsym.c	30;"	d	file:
DFUNCTION	.\src\sqliteInt.h	1443;"	d
DIRECT_MODE	.\src\pager.c	5988;"	d	file:
DLCollector	.\ext\fts2\fts2.c	/^typedef struct DLCollector {$/;"	s	file:
DLCollector	.\ext\fts2\fts2.c	/^} DLCollector;$/;"	t	typeref:struct:DLCollector	file:
DLReader	.\ext\fts2\fts2.c	/^typedef struct DLReader {$/;"	s	file:
DLReader	.\ext\fts2\fts2.c	/^} DLReader;$/;"	t	typeref:struct:DLReader	file:
DLWriter	.\ext\fts2\fts2.c	/^typedef struct DLWriter {$/;"	s	file:
DLWriter	.\ext\fts2\fts2.c	/^} DLWriter;$/;"	t	typeref:struct:DLWriter	file:
DL_DEFAULT	.\ext\fts1\fts1.c	231;"	d	file:
DL_DEFAULT	.\ext\fts2\fts2.c	371;"	d	file:
DL_DOCIDS	.\ext\fts1\fts1.c	/^  DL_DOCIDS,              \/* docids only *\/$/;"	e	enum:DocListType	file:
DL_DOCIDS	.\ext\fts1\fulltext.c	/^  DL_DOCIDS,              \/* docids only *\/$/;"	e	enum:DocListType	file:
DL_DOCIDS	.\ext\fts2\fts2.c	/^  DL_DOCIDS,              \/* docids only *\/$/;"	e	enum:DocListType	file:
DL_POSITIONS	.\ext\fts1\fts1.c	/^  DL_POSITIONS,           \/* docids + positions *\/$/;"	e	enum:DocListType	file:
DL_POSITIONS	.\ext\fts1\fulltext.c	/^  DL_POSITIONS,           \/* docids + positions *\/$/;"	e	enum:DocListType	file:
DL_POSITIONS	.\ext\fts2\fts2.c	/^  DL_POSITIONS,           \/* docids + positions *\/$/;"	e	enum:DocListType	file:
DL_POSITIONS_OFFSETS	.\ext\fts1\fts1.c	/^  DL_POSITIONS_OFFSETS    \/* docids + positions + offsets *\/$/;"	e	enum:DocListType	file:
DL_POSITIONS_OFFSETS	.\ext\fts1\fulltext.c	/^  DL_POSITIONS_OFFSETS    \/* docids + positions + offsets *\/$/;"	e	enum:DocListType	file:
DL_POSITIONS_OFFSETS	.\ext\fts2\fts2.c	/^  DL_POSITIONS_OFFSETS    \/* docids + positions + offsets *\/$/;"	e	enum:DocListType	file:
DOCID_CMP	.\ext\fts3\fts3.c	2435;"	d	file:
DOTLOCK_SUFFIX	.\src\os_unix.c	2065;"	d	file:
DO_OS_MALLOC_TEST	.\src\os.c	46;"	d	file:
DO_OS_MALLOC_TEST	.\src\os.c	53;"	d	file:
DataBuffer	.\ext\fts2\fts2.c	/^typedef struct DataBuffer {$/;"	s	file:
DataBuffer	.\ext\fts2\fts2.c	/^} DataBuffer;$/;"	t	typeref:struct:DataBuffer	file:
DateTime	.\src\date.c	/^struct DateTime {$/;"	s	file:
DateTime	.\src\date.c	/^typedef struct DateTime DateTime;$/;"	t	typeref:struct:DateTime	file:
Db	.\src\sqliteInt.h	/^struct Db {$/;"	s
Db	.\src\sqliteInt.h	/^typedef struct Db Db;$/;"	t	typeref:struct:Db
DbBusyHandler	.\src\tclsqlite.c	/^static int DbBusyHandler(void *cd, int nTries){$/;"	f	file:
DbClearProperty	.\src\sqliteInt.h	1029;"	d
DbCommitHandler	.\src\tclsqlite.c	/^static int DbCommitHandler(void *cd){$/;"	f	file:
DbDeleteCmd	.\src\tclsqlite.c	/^static void DbDeleteCmd(void *db){$/;"	f	file:
DbEvalContext	.\src\tclsqlite.c	/^struct DbEvalContext {$/;"	s	file:
DbEvalContext	.\src\tclsqlite.c	/^typedef struct DbEvalContext DbEvalContext;$/;"	t	typeref:struct:DbEvalContext	file:
DbEvalNextCmd	.\src\tclsqlite.c	/^static int DbEvalNextCmd($/;"	f	file:
DbFixer	.\src\sqliteInt.h	/^struct DbFixer {$/;"	s
DbFixer	.\src\sqliteInt.h	/^typedef struct DbFixer DbFixer;$/;"	t	typeref:struct:DbFixer
DbHasAnyProperty	.\src\sqliteInt.h	1027;"	d
DbHasProperty	.\src\sqliteInt.h	1026;"	d
DbMain	.\src\tclsqlite.c	/^static int DbMain(void *cd, Tcl_Interp *interp, int objc,Tcl_Obj *const*objv){$/;"	f	file:
DbMaskAllZero	.\src\sqliteInt.h	2634;"	d
DbMaskAllZero	.\src\sqliteInt.h	2641;"	d
DbMaskNonZero	.\src\sqliteInt.h	2635;"	d
DbMaskNonZero	.\src\sqliteInt.h	2642;"	d
DbMaskSet	.\src\sqliteInt.h	2633;"	d
DbMaskSet	.\src\sqliteInt.h	2640;"	d
DbMaskTest	.\src\sqliteInt.h	2631;"	d
DbMaskTest	.\src\sqliteInt.h	2638;"	d
DbMaskZero	.\src\sqliteInt.h	2632;"	d
DbMaskZero	.\src\sqliteInt.h	2639;"	d
DbObjCmd	.\src\tclsqlite.c	/^static int DbObjCmd(void *cd, Tcl_Interp *interp, int objc,Tcl_Obj *const*objv){$/;"	f	file:
DbObjCmdAdaptor	.\src\tclsqlite.c	/^static int DbObjCmdAdaptor($/;"	f	file:
DbPage	.\src\pager.h	/^typedef struct PgHdr DbPage;$/;"	t	typeref:struct:PgHdr
DbProfileHandler	.\src\tclsqlite.c	/^static void DbProfileHandler(void *cd, const char *zSql, sqlite_uint64 tm){$/;"	f	file:
DbProgressHandler	.\src\tclsqlite.c	/^static int DbProgressHandler(void *cd){$/;"	f	file:
DbRollbackHandler	.\src\tclsqlite.c	/^static void DbRollbackHandler(void *clientData){$/;"	f	file:
DbSetProperty	.\src\sqliteInt.h	1028;"	d
DbTraceHandler	.\src\tclsqlite.c	/^static void DbTraceHandler(void *cd, const char *zSql){$/;"	f	file:
DbTransPostCmd	.\src\tclsqlite.c	/^static int DbTransPostCmd($/;"	f	file:
DbUnlockNotify	.\src\tclsqlite.c	/^static void DbUnlockNotify(void **apArg, int nArg){$/;"	f	file:
DbUpdateHandler	.\src\tclsqlite.c	/^static void DbUpdateHandler($/;"	f	file:
DbUseNre	.\src\tclsqlite.c	/^static int DbUseNre(void){$/;"	f	file:
DbUseNre	.\src\tclsqlite.c	1548;"	d	file:
DbWalHandler	.\src\tclsqlite.c	/^static int DbWalHandler($/;"	f	file:
Deephemeralize	.\src\vdbe.c	163;"	d	file:
Delete	.\test\fuzz_common.tcl	/^proc Delete {} {$/;"	p
DemoFile	.\src\test_demovfs.c	/^struct DemoFile {$/;"	s	file:
DemoFile	.\src\test_demovfs.c	/^typedef struct DemoFile DemoFile;$/;"	t	typeref:struct:DemoFile	file:
DevsymGlobal	.\src\test_devsym.c	/^struct DevsymGlobal {$/;"	s	file:
DistinctCtx	.\src\select.c	/^struct DistinctCtx {$/;"	s	file:
DistinctCtx	.\src\select.c	/^typedef struct DistinctCtx DistinctCtx;$/;"	t	typeref:struct:DistinctCtx	file:
DocList	.\ext\fts1\fts1.c	/^typedef struct DocList {$/;"	s	file:
DocList	.\ext\fts1\fts1.c	/^} DocList;$/;"	t	typeref:struct:DocList	file:
DocList	.\ext\fts1\fulltext.c	/^typedef struct DocList {$/;"	s	file:
DocList	.\ext\fts1\fulltext.c	/^} DocList;$/;"	t	typeref:struct:DocList	file:
DocListMerge	.\ext\fts1\fulltext.c	/^typedef struct DocListMerge {$/;"	s	file:
DocListMerge	.\ext\fts1\fulltext.c	/^} DocListMerge;$/;"	t	typeref:struct:DocListMerge	file:
DocListReader	.\ext\fts1\fts1.c	/^typedef struct DocListReader {$/;"	s	file:
DocListReader	.\ext\fts1\fts1.c	/^} DocListReader;$/;"	t	typeref:struct:DocListReader	file:
DocListReader	.\ext\fts1\fulltext.c	/^typedef struct DocListReader {$/;"	s	file:
DocListReader	.\ext\fts1\fulltext.c	/^} DocListReader;$/;"	t	typeref:struct:DocListReader	file:
DocListType	.\ext\fts1\fts1.c	/^typedef enum DocListType {$/;"	g	file:
DocListType	.\ext\fts1\fts1.c	/^} DocListType;$/;"	t	typeref:enum:DocListType	file:
DocListType	.\ext\fts1\fulltext.c	/^typedef enum DocListType {$/;"	g	file:
DocListType	.\ext\fts1\fulltext.c	/^} DocListType;$/;"	t	typeref:enum:DocListType	file:
DocListType	.\ext\fts2\fts2.c	/^typedef enum DocListType {$/;"	g	file:
DocListType	.\ext\fts2\fts2.c	/^} DocListType;$/;"	t	typeref:enum:DocListType	file:
DropTable	.\test\fuzz_common.tcl	/^proc DropTable {} {$/;"	p
DropView	.\test\fuzz_common.tcl	/^proc DropView {} {$/;"	p
EIGHT_BYTE_ALIGNMENT	.\src\sqliteInt.h	738;"	d
EIGHT_BYTE_ALIGNMENT	.\src\sqliteInt.h	740;"	d
ENC	.\src\sqliteInt.h	1257;"	d
END_TIMER	.\src\shell.c	227;"	d	file:
END_TIMER	.\src\shell.c	306;"	d	file:
END_TIMER	.\src\shell.c	311;"	d	file:
ENVIRONMENT_VARIABLE1_NAME	.\src\test_sqllog.c	89;"	d	file:
ENVIRONMENT_VARIABLE2_NAME	.\src\test_sqllog.c	90;"	d	file:
EP_Agg	.\src\sqliteInt.h	2124;"	d
EP_Alias	.\src\sqliteInt.h	2145;"	d
EP_CanBeNull	.\src\sqliteInt.h	2143;"	d
EP_Collate	.\src\sqliteInt.h	2131;"	d
EP_ConstFunc	.\src\sqliteInt.h	2142;"	d
EP_DblQuoted	.\src\sqliteInt.h	2129;"	d
EP_Distinct	.\src\sqliteInt.h	2127;"	d
EP_Error	.\src\sqliteInt.h	2126;"	d
EP_FromJoin	.\src\sqliteInt.h	2123;"	d
EP_Generic	.\src\sqliteInt.h	2132;"	d
EP_InfixFunc	.\src\sqliteInt.h	2130;"	d
EP_IntValue	.\src\sqliteInt.h	2133;"	d
EP_MemToken	.\src\sqliteInt.h	2139;"	d
EP_NoReduce	.\src\sqliteInt.h	2140;"	d
EP_Propagate	.\src\sqliteInt.h	2150;"	d
EP_Reduced	.\src\sqliteInt.h	2136;"	d
EP_Resolved	.\src\sqliteInt.h	2125;"	d
EP_Skip	.\src\sqliteInt.h	2135;"	d
EP_Static	.\src\sqliteInt.h	2138;"	d
EP_Subquery	.\src\sqliteInt.h	2144;"	d
EP_TokenOnly	.\src\sqliteInt.h	2137;"	d
EP_Unlikely	.\src\sqliteInt.h	2141;"	d
EP_VarSelect	.\src\sqliteInt.h	2128;"	d
EP_xIsSelect	.\src\sqliteInt.h	2134;"	d
ERROR	.\tool\lemon.c	/^  ERROR,$/;"	e	enum:e_action	file:
EXCLUSIVE_LOCK	.\src\os.h	89;"	d
EXPLAIN	.\tool\mkkeywordhash.c	91;"	d	file:
EXPLAIN	.\tool\mkkeywordhash.c	93;"	d	file:
EXPRDUP_REDUCE	.\src\sqliteInt.h	2184;"	d
EXPR_FULLSIZE	.\src\sqliteInt.h	2176;"	d
EXPR_REDUCEDSIZE	.\src\sqliteInt.h	2177;"	d
EXPR_TOKENONLYSIZE	.\src\sqliteInt.h	2178;"	d
EXTRA_SIZE	.\src\btreeInt.h	310;"	d
EchoModule	.\src\test8.c	/^struct EchoModule {$/;"	s	file:
EchoModule	.\src\test8.c	/^typedef struct EchoModule EchoModule;$/;"	t	typeref:struct:EchoModule	file:
EditDist3Config	.\ext\misc\spellfix.c	/^struct EditDist3Config {$/;"	s	file:
EditDist3Config	.\ext\misc\spellfix.c	/^typedef struct EditDist3Config EditDist3Config;$/;"	t	typeref:struct:EditDist3Config	file:
EditDist3Cost	.\ext\misc\spellfix.c	/^struct EditDist3Cost {$/;"	s	file:
EditDist3Cost	.\ext\misc\spellfix.c	/^typedef struct EditDist3Cost EditDist3Cost;$/;"	t	typeref:struct:EditDist3Cost	file:
EditDist3From	.\ext\misc\spellfix.c	/^struct EditDist3From {$/;"	s	file:
EditDist3From	.\ext\misc\spellfix.c	/^typedef struct EditDist3From EditDist3From;$/;"	t	typeref:struct:EditDist3From	file:
EditDist3FromString	.\ext\misc\spellfix.c	/^struct EditDist3FromString {$/;"	s	file:
EditDist3FromString	.\ext\misc\spellfix.c	/^typedef struct EditDist3FromString EditDist3FromString;$/;"	t	typeref:struct:EditDist3FromString	file:
EditDist3Lang	.\ext\misc\spellfix.c	/^struct EditDist3Lang {$/;"	s	file:
EditDist3Lang	.\ext\misc\spellfix.c	/^typedef struct EditDist3Lang EditDist3Lang;$/;"	t	typeref:struct:EditDist3Lang	file:
EditDist3Point	.\ext\misc\spellfix.c	/^typedef struct EditDist3Point EditDist3Point;$/;"	t	typeref:struct:EditDist3Point	file:
EditDist3To	.\ext\misc\spellfix.c	/^struct EditDist3To {$/;"	s	file:
EditDist3To	.\ext\misc\spellfix.c	/^typedef struct EditDist3To EditDist3To;$/;"	t	typeref:struct:EditDist3To	file:
EditDist3ToString	.\ext\misc\spellfix.c	/^struct EditDist3ToString {$/;"	s	file:
EditDist3ToString	.\ext\misc\spellfix.c	/^typedef struct EditDist3ToString EditDist3ToString;$/;"	t	typeref:struct:EditDist3ToString	file:
Err	.\autoconf\tea\win\nmakehlp.c	/^pipeinfo Err = {INVALID_HANDLE_VALUE, '\\0'};$/;"	v
Error	.\test\threadtest3.c	/^struct Error {$/;"	s	file:
Error	.\test\threadtest3.c	/^typedef struct Error Error;$/;"	t	typeref:struct:Error	file:
ErrorMsg	.\tool\lemon.c	/^void ErrorMsg(const char *filename, int lineno, const char *format, ...){$/;"	f
EvalEvent	.\src\test_thread.c	/^struct EvalEvent {$/;"	s	file:
EvalEvent	.\src\test_thread.c	/^typedef struct EvalEvent EvalEvent;$/;"	t	typeref:struct:EvalEvent	file:
EvalResult	.\ext\misc\eval.c	/^struct EvalResult {$/;"	s	file:
EvalResult	.\tool\fuzzershell.c	/^struct EvalResult {$/;"	s	file:
Exit	.\test\threadtest1.c	/^static void Exit(int rc){$/;"	f	file:
ExpandBlob	.\src\vdbeInt.h	502;"	d
ExpandBlob	.\src\vdbeInt.h	505;"	d
Explain	.\src\vdbeInt.h	/^struct Explain {$/;"	s
Explain	.\src\vdbeInt.h	/^typedef struct Explain Explain;$/;"	t	typeref:struct:Explain
Expr	.\src\sqliteInt.h	/^struct Expr {$/;"	s
Expr	.\src\sqliteInt.h	/^typedef struct Expr Expr;$/;"	t	typeref:struct:Expr
Expr	.\test\fuzz_common.tcl	/^proc Expr { {c {}} } {$/;"	p
ExprClearProperty	.\src\sqliteInt.h	2159;"	d
ExprHasAllProperty	.\src\sqliteInt.h	2157;"	d
ExprHasProperty	.\src\sqliteInt.h	2156;"	d
ExprList	.\src\sqliteInt.h	/^struct ExprList {$/;"	s
ExprList	.\src\sqliteInt.h	/^typedef struct ExprList ExprList;$/;"	t	typeref:struct:ExprList
ExprList_item	.\src\sqliteInt.h	/^  struct ExprList_item { \/* For each expression in the list *\/$/;"	s	struct:ExprList
ExprSetProperty	.\src\sqliteInt.h	2158;"	d
ExprSetVVAProperty	.\src\sqliteInt.h	2166;"	d
ExprSetVVAProperty	.\src\sqliteInt.h	2168;"	d
ExprSpan	.\src\sqliteInt.h	/^struct ExprSpan {$/;"	s
ExprSpan	.\src\sqliteInt.h	/^typedef struct ExprSpan ExprSpan;$/;"	t	typeref:struct:ExprSpan
F1	.\src\tclsqlite.c	3219;"	d	file:
F1	.\test\threadtest3.c	146;"	d	file:
F2	.\src\tclsqlite.c	3220;"	d	file:
F2	.\test\threadtest3.c	147;"	d	file:
F3	.\src\tclsqlite.c	3221;"	d	file:
F3	.\test\threadtest3.c	148;"	d	file:
F4	.\src\tclsqlite.c	3222;"	d	file:
F4	.\test\threadtest3.c	149;"	d	file:
F5tApi	.\ext\fts5\fts5_tcl.c	/^struct F5tApi {$/;"	s	file:
F5tApi	.\ext\fts5\fts5_tcl.c	/^typedef struct F5tApi F5tApi;$/;"	t	typeref:struct:F5tApi	file:
F5tAuxData	.\ext\fts5\fts5_tcl.c	/^struct F5tAuxData {$/;"	s	file:
F5tAuxData	.\ext\fts5\fts5_tcl.c	/^typedef struct F5tAuxData F5tAuxData;$/;"	t	typeref:struct:F5tAuxData	file:
F5tFunction	.\ext\fts5\fts5_tcl.c	/^struct F5tFunction {$/;"	s	file:
F5tFunction	.\ext\fts5\fts5_tcl.c	/^typedef struct F5tFunction F5tFunction;$/;"	t	typeref:struct:F5tFunction	file:
F5tTokenizeCtx	.\ext\fts5\fts5_tcl.c	/^struct F5tTokenizeCtx {$/;"	s	file:
F5tTokenizeCtx	.\ext\fts5\fts5_tcl.c	/^typedef struct F5tTokenizeCtx F5tTokenizeCtx;$/;"	t	typeref:struct:F5tTokenizeCtx	file:
F5tTokenizerCb	.\ext\fts5\fts5_tcl.c	/^typedef struct F5tTokenizerCb F5tTokenizerCb;$/;"	t	typeref:struct:F5tTokenizerCb	file:
F5tTokenizerContext	.\ext\fts5\fts5_tcl.c	/^struct F5tTokenizerContext {$/;"	s	file:
F5tTokenizerContext	.\ext\fts5\fts5_tcl.c	/^typedef struct F5tTokenizerContext F5tTokenizerContext;$/;"	t	typeref:struct:F5tTokenizerContext	file:
F5tTokenizerInstance	.\ext\fts5\fts5_tcl.c	/^struct F5tTokenizerInstance {$/;"	s	file:
F5tTokenizerInstance	.\ext\fts5\fts5_tcl.c	/^typedef struct F5tTokenizerInstance F5tTokenizerInstance;$/;"	t	typeref:struct:F5tTokenizerInstance	file:
F5tTokenizerModule	.\ext\fts5\fts5_tcl.c	/^struct F5tTokenizerModule {$/;"	s	file:
F5tTokenizerModule	.\ext\fts5\fts5_tcl.c	/^typedef struct F5tTokenizerModule F5tTokenizerModule;$/;"	t	typeref:struct:F5tTokenizerModule	file:
FAULT_INJECT_NONE	.\src\test_vfs.c	61;"	d	file:
FAULT_INJECT_PERSISTENT	.\src\test_vfs.c	63;"	d	file:
FAULT_INJECT_TRANSIENT	.\src\test_vfs.c	62;"	d	file:
FILEHANDLEID	.\src\pager.c	132;"	d	file:
FILE_ATTRIBUTE_MASK	.\src\os_win.c	219;"	d	file:
FILE_FLAG_MASK	.\src\os_win.c	215;"	d	file:
FINAL_INS_COST_DIV	.\ext\misc\spellfix.c	305;"	d	file:
FKEY	.\tool\mkkeywordhash.c	96;"	d	file:
FKEY	.\tool\mkkeywordhash.c	98;"	d	file:
FKey	.\src\sqliteInt.h	/^struct FKey {$/;"	s
FKey	.\src\sqliteInt.h	/^typedef struct FKey FKey;$/;"	t	typeref:struct:FKey
FLAG_INTERN	.\src\printf.c	62;"	d	file:
FLAG_SIGNED	.\src\printf.c	61;"	d	file:
FLAG_STRING	.\src\printf.c	63;"	d	file:
FOREGUARD	.\src\mem2.c	68;"	d	file:
FOUR_BYTE_INT	.\src\vdbeaux.c	3108;"	d	file:
FOUR_BYTE_UINT	.\src\vdbeaux.c	3107;"	d	file:
FS_VFS_NAME	.\src\test_onefile.c	95;"	d	file:
FTS1_HASH_BINARY	.\ext\fts1\fts1_hash.h	71;"	d
FTS1_HASH_STRING	.\ext\fts1\fts1_hash.h	70;"	d
FTS1_ROTOR_MASK	.\ext\fts1\fts1.c	2205;"	d	file:
FTS1_ROTOR_SZ	.\ext\fts1\fts1.c	2204;"	d	file:
FTS2_HASH_BINARY	.\ext\fts2\fts2_hash.h	69;"	d
FTS2_HASH_STRING	.\ext\fts2\fts2_hash.h	68;"	d
FTS2_ROTOR_MASK	.\ext\fts2\fts2.c	3071;"	d	file:
FTS2_ROTOR_SZ	.\ext\fts2\fts2.c	3070;"	d	file:
FTS3_AUX_SCHEMA	.\ext\fts3\fts3_aux.c	49;"	d	file:
FTS3_DOCID_SEARCH	.\ext\fts3\fts3Int.h	335;"	d
FTS3_EVAL_FILTER	.\ext\fts3\fts3Int.h	315;"	d
FTS3_EVAL_MATCHINFO	.\ext\fts3\fts3Int.h	317;"	d
FTS3_EVAL_NEXT	.\ext\fts3\fts3Int.h	316;"	d
FTS3_FULLSCAN_SEARCH	.\ext\fts3\fts3Int.h	334;"	d
FTS3_FULLTEXT_SEARCH	.\ext\fts3\fts3Int.h	336;"	d
FTS3_HASH_BINARY	.\ext\fts3\fts3_hash.h	69;"	d
FTS3_HASH_STRING	.\ext\fts3\fts3_hash.h	68;"	d
FTS3_HAVE_DOCID_GE	.\ext\fts3\fts3Int.h	345;"	d
FTS3_HAVE_DOCID_LE	.\ext\fts3\fts3Int.h	346;"	d
FTS3_HAVE_LANGID	.\ext\fts3\fts3Int.h	344;"	d
FTS3_MATCHINFO_AVGLENGTH	.\ext\fts3\fts3_snippet.c	26;"	d	file:
FTS3_MATCHINFO_DEFAULT	.\ext\fts3\fts3_snippet.c	36;"	d	file:
FTS3_MATCHINFO_HITS	.\ext\fts3\fts3_snippet.c	29;"	d	file:
FTS3_MATCHINFO_LCS	.\ext\fts3\fts3_snippet.c	28;"	d	file:
FTS3_MATCHINFO_LENGTH	.\ext\fts3\fts3_snippet.c	27;"	d	file:
FTS3_MATCHINFO_LHITS	.\ext\fts3\fts3_snippet.c	30;"	d	file:
FTS3_MATCHINFO_LHITS_BM	.\ext\fts3\fts3_snippet.c	31;"	d	file:
FTS3_MATCHINFO_NCOL	.\ext\fts3\fts3_snippet.c	24;"	d	file:
FTS3_MATCHINFO_NDOC	.\ext\fts3\fts3_snippet.c	25;"	d	file:
FTS3_MATCHINFO_NPHRASE	.\ext\fts3\fts3_snippet.c	23;"	d	file:
FTS3_MAX_PENDING_DATA	.\ext\fts3\fts3Int.h	69;"	d
FTS3_MERGE_COUNT	.\ext\fts3\fts3Int.h	59;"	d
FTS3_NODE_CHUNKSIZE	.\ext\fts3\fts3_write.c	62;"	d	file:
FTS3_NODE_CHUNKSIZE	.\ext\fts3\fts3_write.c	65;"	d	file:
FTS3_NODE_CHUNK_THRESHOLD	.\ext\fts3\fts3_write.c	63;"	d	file:
FTS3_NODE_CHUNK_THRESHOLD	.\ext\fts3\fts3_write.c	66;"	d	file:
FTS3_NODE_PADDING	.\ext\fts3\fts3_write.c	40;"	d	file:
FTS3_SEGCURSOR_ALL	.\ext\fts3\fts3Int.h	490;"	d
FTS3_SEGCURSOR_PENDING	.\ext\fts3\fts3Int.h	489;"	d
FTS3_SEGDIR_MAXLEVEL	.\ext\fts3\fts3Int.h	107;"	d
FTS3_SEGDIR_MAXLEVEL_STR	.\ext\fts3\fts3Int.h	108;"	d
FTS3_SEGMENT_COLUMN_FILTER	.\ext\fts3\fts3Int.h	502;"	d
FTS3_SEGMENT_FIRST	.\ext\fts3\fts3Int.h	505;"	d
FTS3_SEGMENT_IGNORE_EMPTY	.\ext\fts3\fts3Int.h	501;"	d
FTS3_SEGMENT_PREFIX	.\ext\fts3\fts3Int.h	503;"	d
FTS3_SEGMENT_REQUIRE_POS	.\ext\fts3\fts3Int.h	500;"	d
FTS3_SEGMENT_SCAN	.\ext\fts3\fts3Int.h	504;"	d
FTS3_TERMS_SCHEMA	.\ext\fts3\fts3_term.c	52;"	d	file:
FTS3_TOK_SCHEMA	.\ext\fts3\fts3_tokenize_vtab.c	146;"	d	file:
FTS3_VARINT_MAX	.\ext\fts3\fts3Int.h	90;"	d
FTS4AUX_EQ_CONSTRAINT	.\ext\fts3\fts3_aux.c	142;"	d	file:
FTS4AUX_EQ_CONSTRAINT	.\ext\fts3\fts3_term.c	137;"	d	file:
FTS4AUX_GE_CONSTRAINT	.\ext\fts3\fts3_aux.c	143;"	d	file:
FTS4AUX_GE_CONSTRAINT	.\ext\fts3\fts3_term.c	138;"	d	file:
FTS4AUX_LE_CONSTRAINT	.\ext\fts3\fts3_aux.c	144;"	d	file:
FTS4AUX_LE_CONSTRAINT	.\ext\fts3\fts3_term.c	139;"	d	file:
FTS5CSR_EOF	.\ext\fts5\fts5_main.c	226;"	d	file:
FTS5CSR_FREE_ZRANK	.\ext\fts5\fts5_main.c	227;"	d	file:
FTS5CSR_REQUIRE_CONTENT	.\ext\fts5\fts5_main.c	223;"	d	file:
FTS5CSR_REQUIRE_DOCSIZE	.\ext\fts5\fts5_main.c	224;"	d	file:
FTS5CSR_REQUIRE_INST	.\ext\fts5\fts5_main.c	225;"	d	file:
FTS5CSR_REQUIRE_RESEEK	.\ext\fts5\fts5_main.c	228;"	d	file:
FTS5INDEX_QUERY_DESC	.\ext\fts5\fts5Int.h	308;"	d
FTS5INDEX_QUERY_PREFIX	.\ext\fts5\fts5Int.h	307;"	d
FTS5INDEX_QUERY_SCAN	.\ext\fts5\fts5Int.h	310;"	d
FTS5INDEX_QUERY_TEST_NOIDX	.\ext\fts5\fts5Int.h	309;"	d
FTS5_AVERAGES_ROWID	.\ext\fts5\fts5_index.c	213;"	d	file:
FTS5_BEGIN	.\ext\fts5\fts5_main.c	249;"	d	file:
FTS5_BI_MATCH	.\ext\fts5\fts5_main.c	210;"	d	file:
FTS5_BI_ORDER_DESC	.\ext\fts5\fts5_main.c	218;"	d	file:
FTS5_BI_ORDER_RANK	.\ext\fts5\fts5_main.c	216;"	d	file:
FTS5_BI_ORDER_ROWID	.\ext\fts5\fts5_main.c	217;"	d	file:
FTS5_BI_RANK	.\ext\fts5\fts5_main.c	211;"	d	file:
FTS5_BI_ROWID_EQ	.\ext\fts5\fts5_main.c	212;"	d	file:
FTS5_BI_ROWID_GE	.\ext\fts5\fts5_main.c	214;"	d	file:
FTS5_BI_ROWID_LE	.\ext\fts5\fts5_main.c	213;"	d	file:
FTS5_COMMIT	.\ext\fts5\fts5_main.c	251;"	d	file:
FTS5_CONTENT_EXTERNAL	.\ext\fts5\fts5Int.h	179;"	d
FTS5_CONTENT_NONE	.\ext\fts5\fts5Int.h	178;"	d
FTS5_CONTENT_NORMAL	.\ext\fts5\fts5Int.h	177;"	d
FTS5_CORRUPT	.\ext\fts5\fts5Int.h	65;"	d
FTS5_CORRUPT	.\ext\fts5\fts5Int.h	68;"	d
FTS5_CURRENT_VERSION	.\ext\fts5\fts5Int.h	175;"	d
FTS5_DATA_DLI_B	.\ext\fts5\fts5_index.c	228;"	d	file:
FTS5_DATA_HEIGHT_B	.\ext\fts5\fts5_index.c	229;"	d	file:
FTS5_DATA_ID_B	.\ext\fts5\fts5_index.c	227;"	d	file:
FTS5_DATA_PADDING	.\ext\fts5\fts5_index.c	258;"	d	file:
FTS5_DATA_PAGE_B	.\ext\fts5\fts5_index.c	230;"	d	file:
FTS5_DATA_ZERO_PADDING	.\ext\fts5\fts5_index.c	257;"	d	file:
FTS5_DEFAULT_AUTOMERGE	.\ext\fts5\fts5_config.c	21;"	d	file:
FTS5_DEFAULT_CRISISMERGE	.\ext\fts5\fts5_config.c	22;"	d	file:
FTS5_DEFAULT_NEARDIST	.\ext\fts5\fts5Int.h	57;"	d
FTS5_DEFAULT_PAGE_SIZE	.\ext\fts5\fts5_config.c	20;"	d	file:
FTS5_DEFAULT_RANK	.\ext\fts5\fts5Int.h	58;"	d
FTS5_DLIDX_ROWID	.\ext\fts5\fts5_index.c	240;"	d	file:
FTS5_EOF	.\ext\fts5\fts5_expr.c	23;"	d	file:
FTS5_HASHENTRYSIZE	.\ext\fts5\fts5_hash.c	75;"	d	file:
FTS5_HDR	.\main.mk	/^FTS5_HDR = \\$/;"	m
FTS5_LARGEST_INT64	.\ext\fts5\fts5_expr.c	25;"	d	file:
FTS5_LOOKAHEAD_EOF	.\ext\fts5\fts5_expr.c	482;"	d	file:
FTS5_MAIN_PREFIX	.\ext\fts5\fts5_index.c	51;"	d	file:
FTS5_MAX_PAGE_SIZE	.\ext\fts5\fts5_config.c	25;"	d	file:
FTS5_MAX_PREFIX_INDEXES	.\ext\fts5\fts5Int.h	55;"	d
FTS5_MAX_SEGMENT	.\ext\fts5\fts5_index.c	245;"	d	file:
FTS5_MIN_DLIDX_SIZE	.\ext\fts5\fts5_index.c	49;"	d	file:
FTS5_NOINLINE	.\ext\fts5\fts5_varint.c	281;"	d	file:
FTS5_NOINLINE	.\ext\fts5\fts5_varint.c	283;"	d	file:
FTS5_OPT_WORK_UNIT	.\ext\fts5\fts5_index.c	46;"	d	file:
FTS5_PLAN_MATCH	.\ext\fts5\fts5_main.c	436;"	d	file:
FTS5_PLAN_ROWID	.\ext\fts5\fts5_main.c	441;"	d	file:
FTS5_PLAN_SCAN	.\ext\fts5\fts5_main.c	440;"	d	file:
FTS5_PLAN_SORTED_MATCH	.\ext\fts5\fts5_main.c	439;"	d	file:
FTS5_PLAN_SOURCE	.\ext\fts5\fts5_main.c	437;"	d	file:
FTS5_PLAN_SPECIAL	.\ext\fts5\fts5_main.c	438;"	d	file:
FTS5_PORTER_MAX_TOKEN	.\ext\fts5\fts5_tokenize.c	494;"	d	file:
FTS5_POS2COLUMN	.\ext\fts5\fts5Int.h	251;"	d
FTS5_POS2OFFSET	.\ext\fts5\fts5Int.h	252;"	d
FTS5_RANK_NAME	.\ext\fts5\fts5Int.h	61;"	d
FTS5_RELEASE	.\ext\fts5\fts5_main.c	254;"	d	file:
FTS5_ROLLBACK	.\ext\fts5\fts5_main.c	252;"	d	file:
FTS5_ROLLBACKTO	.\ext\fts5\fts5_main.c	255;"	d	file:
FTS5_ROWID_NAME	.\ext\fts5\fts5Int.h	62;"	d
FTS5_SAVEPOINT	.\ext\fts5\fts5_main.c	253;"	d	file:
FTS5_SEGITER_ONETERM	.\ext\fts5\fts5_index.c	487;"	d	file:
FTS5_SEGITER_REVERSE	.\ext\fts5\fts5_index.c	488;"	d	file:
FTS5_SEGMENT_ROWID	.\ext\fts5\fts5_index.c	239;"	d	file:
FTS5_SRC	.\main.mk	/^FTS5_SRC = \\$/;"	m
FTS5_STMT_DELETE_CONTENT	.\ext\fts5\fts5_storage.c	41;"	d	file:
FTS5_STMT_DELETE_DOCSIZE	.\ext\fts5\fts5_storage.c	43;"	d	file:
FTS5_STMT_INSERT_CONTENT	.\ext\fts5\fts5_storage.c	39;"	d	file:
FTS5_STMT_LOOKUP	.\ext\fts5\fts5Int.h	540;"	d
FTS5_STMT_LOOKUP_DOCSIZE	.\ext\fts5\fts5_storage.c	44;"	d	file:
FTS5_STMT_REPLACE_CONFIG	.\ext\fts5\fts5_storage.c	45;"	d	file:
FTS5_STMT_REPLACE_CONTENT	.\ext\fts5\fts5_storage.c	40;"	d	file:
FTS5_STMT_REPLACE_DOCSIZE	.\ext\fts5\fts5_storage.c	42;"	d	file:
FTS5_STMT_SCAN	.\ext\fts5\fts5_storage.c	46;"	d	file:
FTS5_STMT_SCAN_ASC	.\ext\fts5\fts5Int.h	538;"	d
FTS5_STMT_SCAN_DESC	.\ext\fts5\fts5Int.h	539;"	d
FTS5_STRUCTURE_ROWID	.\ext\fts5\fts5_index.c	214;"	d	file:
FTS5_SYNC	.\ext\fts5\fts5_main.c	250;"	d	file:
FTS5_TOKENIZE_AUX	.\ext\fts5\fts5.h	467;"	d
FTS5_TOKENIZE_DOCUMENT	.\ext\fts5\fts5.h	466;"	d
FTS5_TOKENIZE_PREFIX	.\ext\fts5\fts5.h	465;"	d
FTS5_TOKENIZE_QUERY	.\ext\fts5\fts5.h	464;"	d
FTS5_TOKEN_COLOCATED	.\ext\fts5\fts5.h	471;"	d
FTS5_VOCAB_COL	.\ext\fts5\fts5_vocab.c	70;"	d	file:
FTS5_VOCAB_COL_SCHEMA	.\ext\fts5\fts5_vocab.c	73;"	d	file:
FTS5_VOCAB_ROW	.\ext\fts5\fts5_vocab.c	71;"	d	file:
FTS5_VOCAB_ROW_SCHEMA	.\ext\fts5\fts5_vocab.c	74;"	d	file:
FTS5_WORK_UNIT	.\ext\fts5\fts5_index.c	47;"	d	file:
FTSQUERY_AND	.\ext\fts3\fts3Int.h	450;"	d
FTSQUERY_NEAR	.\ext\fts3\fts3Int.h	448;"	d
FTSQUERY_NOT	.\ext\fts3\fts3Int.h	449;"	d
FTSQUERY_OR	.\ext\fts3\fts3Int.h	451;"	d
FTSQUERY_PHRASE	.\ext\fts3\fts3Int.h	452;"	d
FTS_CORRUPT_VTAB	.\ext\fts3\fts3Int.h	183;"	d
FTS_CORRUPT_VTAB	.\ext\fts3\fts3Int.h	185;"	d
FTS_MAX_APPENDABLE_HEIGHT	.\ext\fts3\fts3_write.c	28;"	d	file:
FTS_STAT_AUTOINCRMERGE	.\ext\fts3\fts3_write.c	75;"	d	file:
FTS_STAT_DOCTOTAL	.\ext\fts3\fts3_write.c	73;"	d	file:
FTS_STAT_INCRMERGEHINT	.\ext\fts3\fts3_write.c	74;"	d	file:
FULLY_WITHIN	.\ext\rtree\sqlite3rtree.h	110;"	d
FUNCTION	.\src\sqliteInt.h	1437;"	d
FUNCTION2	.\src\sqliteInt.h	1446;"	d
FUNC_PERFECT_MATCH	.\src\callback.c	250;"	d	file:
FUZZCHECK_OPT	.\main.mk	/^FUZZCHECK_OPT = -DSQLITE_ENABLE_JSON1$/;"	m
FUZZDATA	.\main.mk	/^FUZZDATA = \\$/;"	m
FUZZERSHELL_OPT	.\main.mk	/^FUZZERSHELL_OPT = -DSQLITE_ENABLE_JSON1$/;"	m
FUZZER_HASH	.\ext\misc\fuzzer.c	235;"	d	file:
FUZZER_MX_COST	.\ext\misc\fuzzer.c	186;"	d	file:
FUZZER_MX_LENGTH	.\ext\misc\fuzzer.c	184;"	d	file:
FUZZER_MX_OUTPUT_LENGTH	.\ext\misc\fuzzer.c	187;"	d	file:
FUZZER_MX_RULEID	.\ext\misc\fuzzer.c	185;"	d	file:
FUZZER_NQUEUE	.\ext\misc\fuzzer.c	236;"	d	file:
F_OK	.\src\test_demovfs.c	483;"	d	file:
FileChunk	.\src\memjournal.c	/^struct FileChunk {$/;"	s	file:
FileChunk	.\src\memjournal.c	/^typedef struct FileChunk FileChunk;$/;"	t	typeref:struct:FileChunk	file:
FilePoint	.\src\memjournal.c	/^struct FilePoint {$/;"	s	file:
FilePoint	.\src\memjournal.c	/^typedef struct FilePoint FilePoint;$/;"	t	typeref:struct:FilePoint	file:
FindActions	.\tool\lemon.c	/^void FindActions(struct lemon *lemp)$/;"	f
FindFirstSets	.\tool\lemon.c	/^void FindFirstSets(struct lemon *lemp)$/;"	f
FindFollowSets	.\tool\lemon.c	/^void FindFollowSets(struct lemon *lemp)$/;"	f
FindLinks	.\tool\lemon.c	/^void FindLinks(struct lemon *lemp)$/;"	f
FindRulePrecedences	.\tool\lemon.c	/^void FindRulePrecedences(struct lemon *xp)$/;"	f
FindStates	.\tool\lemon.c	/^void FindStates(struct lemon *lemp)$/;"	f
Fts3Cursor	.\ext\fts3\fts3Int.h	/^struct Fts3Cursor {$/;"	s
Fts3Cursor	.\ext\fts3\fts3Int.h	/^typedef struct Fts3Cursor Fts3Cursor;$/;"	t	typeref:struct:Fts3Cursor
Fts3DeferredToken	.\ext\fts3\fts3Int.h	/^typedef struct Fts3DeferredToken Fts3DeferredToken;$/;"	t	typeref:struct:Fts3DeferredToken
Fts3DeferredToken	.\ext\fts3\fts3_write.c	/^struct Fts3DeferredToken {$/;"	s	file:
Fts3Doclist	.\ext\fts3\fts3Int.h	/^struct Fts3Doclist {$/;"	s
Fts3Doclist	.\ext\fts3\fts3Int.h	/^typedef struct Fts3Doclist Fts3Doclist;$/;"	t	typeref:struct:Fts3Doclist
Fts3Expr	.\ext\fts3\fts3Int.h	/^struct Fts3Expr {$/;"	s
Fts3Expr	.\ext\fts3\fts3Int.h	/^typedef struct Fts3Expr Fts3Expr;$/;"	t	typeref:struct:Fts3Expr
Fts3Hash	.\ext\fts3\fts3_hash.h	/^struct Fts3Hash {$/;"	s
Fts3Hash	.\ext\fts3\fts3_hash.h	/^typedef struct Fts3Hash Fts3Hash;$/;"	t	typeref:struct:Fts3Hash
Fts3HashElem	.\ext\fts3\fts3_hash.h	/^struct Fts3HashElem {$/;"	s
Fts3HashElem	.\ext\fts3\fts3_hash.h	/^typedef struct Fts3HashElem Fts3HashElem;$/;"	t	typeref:struct:Fts3HashElem
Fts3Index	.\ext\fts3\fts3Int.h	/^  struct Fts3Index {$/;"	s	struct:Fts3Table
Fts3MultiSegReader	.\ext\fts3\fts3Int.h	/^struct Fts3MultiSegReader {$/;"	s
Fts3MultiSegReader	.\ext\fts3\fts3Int.h	/^typedef struct Fts3MultiSegReader Fts3MultiSegReader;$/;"	t	typeref:struct:Fts3MultiSegReader
Fts3Phrase	.\ext\fts3\fts3Int.h	/^struct Fts3Phrase {$/;"	s
Fts3Phrase	.\ext\fts3\fts3Int.h	/^typedef struct Fts3Phrase Fts3Phrase;$/;"	t	typeref:struct:Fts3Phrase
Fts3PhraseToken	.\ext\fts3\fts3Int.h	/^struct Fts3PhraseToken {$/;"	s
Fts3PhraseToken	.\ext\fts3\fts3Int.h	/^typedef struct Fts3PhraseToken Fts3PhraseToken;$/;"	t	typeref:struct:Fts3PhraseToken
Fts3SegFilter	.\ext\fts3\fts3Int.h	/^struct Fts3SegFilter {$/;"	s
Fts3SegFilter	.\ext\fts3\fts3Int.h	/^typedef struct Fts3SegFilter Fts3SegFilter;$/;"	t	typeref:struct:Fts3SegFilter
Fts3SegReader	.\ext\fts3\fts3Int.h	/^typedef struct Fts3SegReader Fts3SegReader;$/;"	t	typeref:struct:Fts3SegReader
Fts3SegReader	.\ext\fts3\fts3_write.c	/^struct Fts3SegReader {$/;"	s	file:
Fts3Table	.\ext\fts3\fts3Int.h	/^struct Fts3Table {$/;"	s
Fts3Table	.\ext\fts3\fts3Int.h	/^typedef struct Fts3Table Fts3Table;$/;"	t	typeref:struct:Fts3Table
Fts3TokenAndCost	.\ext\fts3\fts3.c	/^struct Fts3TokenAndCost {$/;"	s	file:
Fts3TokenAndCost	.\ext\fts3\fts3.c	/^typedef struct Fts3TokenAndCost Fts3TokenAndCost;$/;"	t	typeref:struct:Fts3TokenAndCost	file:
Fts3auxColstats	.\ext\fts3\fts3_aux.c	/^  struct Fts3auxColstats {$/;"	s	struct:Fts3auxCursor	file:
Fts3auxCursor	.\ext\fts3\fts3_aux.c	/^struct Fts3auxCursor {$/;"	s	file:
Fts3auxCursor	.\ext\fts3\fts3_aux.c	/^typedef struct Fts3auxCursor Fts3auxCursor;$/;"	t	typeref:struct:Fts3auxCursor	file:
Fts3auxTable	.\ext\fts3\fts3_aux.c	/^struct Fts3auxTable {$/;"	s	file:
Fts3auxTable	.\ext\fts3\fts3_aux.c	/^typedef struct Fts3auxTable Fts3auxTable;$/;"	t	typeref:struct:Fts3auxTable	file:
Fts3termCursor	.\ext\fts3\fts3_term.c	/^struct Fts3termCursor {$/;"	s	file:
Fts3termCursor	.\ext\fts3\fts3_term.c	/^typedef struct Fts3termCursor Fts3termCursor;$/;"	t	typeref:struct:Fts3termCursor	file:
Fts3termTable	.\ext\fts3\fts3_term.c	/^struct Fts3termTable {$/;"	s	file:
Fts3termTable	.\ext\fts3\fts3_term.c	/^typedef struct Fts3termTable Fts3termTable;$/;"	t	typeref:struct:Fts3termTable	file:
Fts3tokCursor	.\ext\fts3\fts3_tokenize_vtab.c	/^struct Fts3tokCursor {$/;"	s	file:
Fts3tokCursor	.\ext\fts3\fts3_tokenize_vtab.c	/^typedef struct Fts3tokCursor Fts3tokCursor;$/;"	t	typeref:struct:Fts3tokCursor	file:
Fts3tokTable	.\ext\fts3\fts3_tokenize_vtab.c	/^struct Fts3tokTable {$/;"	s	file:
Fts3tokTable	.\ext\fts3\fts3_tokenize_vtab.c	/^typedef struct Fts3tokTable Fts3tokTable;$/;"	t	typeref:struct:Fts3tokTable	file:
Fts5Auxdata	.\ext\fts5\fts5_main.c	/^struct Fts5Auxdata {$/;"	s	file:
Fts5Auxdata	.\ext\fts5\fts5_main.c	/^typedef struct Fts5Auxdata Fts5Auxdata;$/;"	t	typeref:struct:Fts5Auxdata	file:
Fts5Auxiliary	.\ext\fts5\fts5_main.c	/^struct Fts5Auxiliary {$/;"	s	file:
Fts5Auxiliary	.\ext\fts5\fts5_main.c	/^typedef struct Fts5Auxiliary Fts5Auxiliary;$/;"	t	typeref:struct:Fts5Auxiliary	file:
Fts5Bm25Data	.\ext\fts5\fts5_aux.c	/^struct Fts5Bm25Data {$/;"	s	file:
Fts5Bm25Data	.\ext\fts5\fts5_aux.c	/^typedef struct Fts5Bm25Data Fts5Bm25Data;$/;"	t	typeref:struct:Fts5Bm25Data	file:
Fts5Buffer	.\ext\fts5\fts5Int.h	/^struct Fts5Buffer {$/;"	s
Fts5Buffer	.\ext\fts5\fts5Int.h	/^typedef struct Fts5Buffer Fts5Buffer;$/;"	t	typeref:struct:Fts5Buffer
Fts5CResult	.\ext\fts5\fts5_index.c	/^struct Fts5CResult {$/;"	s	file:
Fts5CResult	.\ext\fts5\fts5_index.c	/^typedef struct Fts5CResult Fts5CResult;$/;"	t	typeref:struct:Fts5CResult	file:
Fts5Colset	.\ext\fts5\fts5Int.h	/^struct Fts5Colset {$/;"	s
Fts5Colset	.\ext\fts5\fts5Int.h	/^typedef struct Fts5Colset Fts5Colset;$/;"	t	typeref:struct:Fts5Colset
Fts5Config	.\ext\fts5\fts5Int.h	/^struct Fts5Config {$/;"	s
Fts5Config	.\ext\fts5\fts5Int.h	/^typedef struct Fts5Config Fts5Config;$/;"	t	typeref:struct:Fts5Config
Fts5Context	.\ext\fts5\fts5.h	/^typedef struct Fts5Context Fts5Context;$/;"	t	typeref:struct:Fts5Context
Fts5Cursor	.\ext\fts5\fts5_main.c	/^struct Fts5Cursor {$/;"	s	file:
Fts5Cursor	.\ext\fts5\fts5_main.c	/^typedef struct Fts5Cursor Fts5Cursor;$/;"	t	typeref:struct:Fts5Cursor	file:
Fts5Data	.\ext\fts5\fts5_index.c	/^struct Fts5Data {$/;"	s	file:
Fts5Data	.\ext\fts5\fts5_index.c	/^typedef struct Fts5Data Fts5Data;$/;"	t	typeref:struct:Fts5Data	file:
Fts5DlidxIter	.\ext\fts5\fts5_index.c	/^struct Fts5DlidxIter {$/;"	s	file:
Fts5DlidxIter	.\ext\fts5\fts5_index.c	/^typedef struct Fts5DlidxIter Fts5DlidxIter;$/;"	t	typeref:struct:Fts5DlidxIter	file:
Fts5DlidxLvl	.\ext\fts5\fts5_index.c	/^struct Fts5DlidxLvl {$/;"	s	file:
Fts5DlidxLvl	.\ext\fts5\fts5_index.c	/^typedef struct Fts5DlidxLvl Fts5DlidxLvl;$/;"	t	typeref:struct:Fts5DlidxLvl	file:
Fts5DlidxWriter	.\ext\fts5\fts5_index.c	/^struct Fts5DlidxWriter {$/;"	s	file:
Fts5DlidxWriter	.\ext\fts5\fts5_index.c	/^typedef struct Fts5DlidxWriter Fts5DlidxWriter;$/;"	t	typeref:struct:Fts5DlidxWriter	file:
Fts5DoclistIter	.\ext\fts5\fts5_index.c	/^struct Fts5DoclistIter {$/;"	s	file:
Fts5DoclistIter	.\ext\fts5\fts5_index.c	/^typedef struct Fts5DoclistIter Fts5DoclistIter;$/;"	t	typeref:struct:Fts5DoclistIter	file:
Fts5Expr	.\ext\fts5\fts5Int.h	/^typedef struct Fts5Expr Fts5Expr;$/;"	t	typeref:struct:Fts5Expr
Fts5Expr	.\ext\fts5\fts5_expr.c	/^struct Fts5Expr {$/;"	s	file:
Fts5ExprNearset	.\ext\fts5\fts5Int.h	/^typedef struct Fts5ExprNearset Fts5ExprNearset;$/;"	t	typeref:struct:Fts5ExprNearset
Fts5ExprNearset	.\ext\fts5\fts5_expr.c	/^struct Fts5ExprNearset {$/;"	s	file:
Fts5ExprNode	.\ext\fts5\fts5Int.h	/^typedef struct Fts5ExprNode Fts5ExprNode;$/;"	t	typeref:struct:Fts5ExprNode
Fts5ExprNode	.\ext\fts5\fts5_expr.c	/^struct Fts5ExprNode {$/;"	s	file:
Fts5ExprPhrase	.\ext\fts5\fts5Int.h	/^typedef struct Fts5ExprPhrase Fts5ExprPhrase;$/;"	t	typeref:struct:Fts5ExprPhrase
Fts5ExprPhrase	.\ext\fts5\fts5_expr.c	/^struct Fts5ExprPhrase {$/;"	s	file:
Fts5ExprTerm	.\ext\fts5\fts5_expr.c	/^struct Fts5ExprTerm {$/;"	s	file:
Fts5ExprTerm	.\ext\fts5\fts5_expr.c	/^typedef struct Fts5ExprTerm Fts5ExprTerm;$/;"	t	typeref:struct:Fts5ExprTerm	file:
Fts5ExtensionApi	.\ext\fts5\fts5.h	/^struct Fts5ExtensionApi {$/;"	s
Fts5ExtensionApi	.\ext\fts5\fts5.h	/^typedef struct Fts5ExtensionApi Fts5ExtensionApi;$/;"	t	typeref:struct:Fts5ExtensionApi
Fts5FlushCtx	.\ext\fts5\fts5_index.c	/^struct Fts5FlushCtx {$/;"	s	file:
Fts5FlushCtx	.\ext\fts5\fts5_index.c	/^typedef struct Fts5FlushCtx Fts5FlushCtx;$/;"	t	typeref:struct:Fts5FlushCtx	file:
Fts5Global	.\ext\fts5\fts5Int.h	/^typedef struct Fts5Global Fts5Global;$/;"	t	typeref:struct:Fts5Global
Fts5Global	.\ext\fts5\fts5_main.c	/^struct Fts5Global {$/;"	s	file:
Fts5Hash	.\ext\fts5\fts5Int.h	/^typedef struct Fts5Hash Fts5Hash;$/;"	t	typeref:struct:Fts5Hash
Fts5Hash	.\ext\fts5\fts5_hash.c	/^struct Fts5Hash {$/;"	s	file:
Fts5HashEntry	.\ext\fts5\fts5_hash.c	/^struct Fts5HashEntry {$/;"	s	file:
Fts5HashEntry	.\ext\fts5\fts5_hash.c	/^typedef struct Fts5HashEntry Fts5HashEntry;$/;"	t	typeref:struct:Fts5HashEntry	file:
Fts5Index	.\ext\fts5\fts5Int.h	/^typedef struct Fts5Index Fts5Index;$/;"	t	typeref:struct:Fts5Index
Fts5Index	.\ext\fts5\fts5_index.c	/^struct Fts5Index {$/;"	s	file:
Fts5IndexIter	.\ext\fts5\fts5Int.h	/^typedef struct Fts5IndexIter Fts5IndexIter;$/;"	t	typeref:struct:Fts5IndexIter
Fts5IndexIter	.\ext\fts5\fts5_index.c	/^struct Fts5IndexIter {$/;"	s	file:
Fts5InsertCtx	.\ext\fts5\fts5_storage.c	/^struct Fts5InsertCtx {$/;"	s	file:
Fts5InsertCtx	.\ext\fts5\fts5_storage.c	/^typedef struct Fts5InsertCtx Fts5InsertCtx;$/;"	t	typeref:struct:Fts5InsertCtx	file:
Fts5IntegrityCtx	.\ext\fts5\fts5_storage.c	/^struct Fts5IntegrityCtx {$/;"	s	file:
Fts5IntegrityCtx	.\ext\fts5\fts5_storage.c	/^typedef struct Fts5IntegrityCtx Fts5IntegrityCtx;$/;"	t	typeref:struct:Fts5IntegrityCtx	file:
Fts5LookaheadReader	.\ext\fts5\fts5_expr.c	/^struct Fts5LookaheadReader {$/;"	s	file:
Fts5LookaheadReader	.\ext\fts5\fts5_expr.c	/^typedef struct Fts5LookaheadReader Fts5LookaheadReader;$/;"	t	typeref:struct:Fts5LookaheadReader	file:
Fts5MatchPhrase	.\ext\fts5\fts5_main.c	/^struct Fts5MatchPhrase {$/;"	s	file:
Fts5MatchinfoCtx	.\ext\fts5\fts5_test_mi.c	/^struct Fts5MatchinfoCtx {$/;"	s	file:
Fts5MatchinfoCtx	.\ext\fts5\fts5_test_mi.c	/^typedef struct Fts5MatchinfoCtx Fts5MatchinfoCtx;$/;"	t	typeref:struct:Fts5MatchinfoCtx	file:
Fts5NearTrimmer	.\ext\fts5\fts5_expr.c	/^struct Fts5NearTrimmer {$/;"	s	file:
Fts5NearTrimmer	.\ext\fts5\fts5_expr.c	/^typedef struct Fts5NearTrimmer Fts5NearTrimmer;$/;"	t	typeref:struct:Fts5NearTrimmer	file:
Fts5NodeIsString	.\ext\fts5\fts5_expr.c	73;"	d	file:
Fts5PageWriter	.\ext\fts5\fts5_index.c	/^struct Fts5PageWriter {$/;"	s	file:
Fts5PageWriter	.\ext\fts5\fts5_index.c	/^typedef struct Fts5PageWriter Fts5PageWriter;$/;"	t	typeref:struct:Fts5PageWriter	file:
Fts5Parse	.\ext\fts5\fts5Int.h	/^typedef struct Fts5Parse Fts5Parse;$/;"	t	typeref:struct:Fts5Parse
Fts5Parse	.\ext\fts5\fts5_expr.c	/^struct Fts5Parse {$/;"	s	file:
Fts5PhraseIter	.\ext\fts5\fts5.h	/^struct Fts5PhraseIter {$/;"	s
Fts5PhraseIter	.\ext\fts5\fts5.h	/^typedef struct Fts5PhraseIter Fts5PhraseIter;$/;"	t	typeref:struct:Fts5PhraseIter
Fts5PoslistReader	.\ext\fts5\fts5Int.h	/^struct Fts5PoslistReader {$/;"	s
Fts5PoslistReader	.\ext\fts5\fts5Int.h	/^typedef struct Fts5PoslistReader Fts5PoslistReader;$/;"	t	typeref:struct:Fts5PoslistReader
Fts5PoslistWriter	.\ext\fts5\fts5Int.h	/^struct Fts5PoslistWriter {$/;"	s
Fts5PoslistWriter	.\ext\fts5\fts5Int.h	/^typedef struct Fts5PoslistWriter Fts5PoslistWriter;$/;"	t	typeref:struct:Fts5PoslistWriter
Fts5SegIter	.\ext\fts5\fts5_index.c	/^struct Fts5SegIter {$/;"	s	file:
Fts5SegIter	.\ext\fts5\fts5_index.c	/^typedef struct Fts5SegIter Fts5SegIter;$/;"	t	typeref:struct:Fts5SegIter	file:
Fts5SegWriter	.\ext\fts5\fts5_index.c	/^struct Fts5SegWriter {$/;"	s	file:
Fts5SegWriter	.\ext\fts5\fts5_index.c	/^typedef struct Fts5SegWriter Fts5SegWriter;$/;"	t	typeref:struct:Fts5SegWriter	file:
Fts5Sorter	.\ext\fts5\fts5_main.c	/^struct Fts5Sorter {$/;"	s	file:
Fts5Sorter	.\ext\fts5\fts5_main.c	/^typedef struct Fts5Sorter Fts5Sorter;$/;"	t	typeref:struct:Fts5Sorter	file:
Fts5Storage	.\ext\fts5\fts5Int.h	/^typedef struct Fts5Storage Fts5Storage;$/;"	t	typeref:struct:Fts5Storage
Fts5Storage	.\ext\fts5\fts5_storage.c	/^struct Fts5Storage {$/;"	s	file:
Fts5Structure	.\ext\fts5\fts5_index.c	/^struct Fts5Structure {$/;"	s	file:
Fts5Structure	.\ext\fts5\fts5_index.c	/^typedef struct Fts5Structure Fts5Structure;$/;"	t	typeref:struct:Fts5Structure	file:
Fts5StructureLevel	.\ext\fts5\fts5_index.c	/^struct Fts5StructureLevel {$/;"	s	file:
Fts5StructureLevel	.\ext\fts5\fts5_index.c	/^typedef struct Fts5StructureLevel Fts5StructureLevel;$/;"	t	typeref:struct:Fts5StructureLevel	file:
Fts5StructureSegment	.\ext\fts5\fts5_index.c	/^struct Fts5StructureSegment {$/;"	s	file:
Fts5StructureSegment	.\ext\fts5\fts5_index.c	/^typedef struct Fts5StructureSegment Fts5StructureSegment;$/;"	t	typeref:struct:Fts5StructureSegment	file:
Fts5Table	.\ext\fts5\fts5_main.c	/^struct Fts5Table {$/;"	s	file:
Fts5Table	.\ext\fts5\fts5_main.c	/^typedef struct Fts5Table Fts5Table;$/;"	t	typeref:struct:Fts5Table	file:
Fts5Token	.\ext\fts5\fts5Int.h	/^struct Fts5Token {$/;"	s
Fts5Token	.\ext\fts5\fts5Int.h	/^typedef struct Fts5Token Fts5Token;$/;"	t	typeref:struct:Fts5Token
Fts5Tokenizer	.\ext\fts5\fts5.h	/^typedef struct Fts5Tokenizer Fts5Tokenizer;$/;"	t	typeref:struct:Fts5Tokenizer
Fts5TokenizerModule	.\ext\fts5\fts5_main.c	/^struct Fts5TokenizerModule {$/;"	s	file:
Fts5TokenizerModule	.\ext\fts5\fts5_main.c	/^typedef struct Fts5TokenizerModule Fts5TokenizerModule;$/;"	t	typeref:struct:Fts5TokenizerModule	file:
Fts5TransactionState	.\ext\fts5\fts5_main.c	/^struct Fts5TransactionState {$/;"	s	file:
Fts5VocabCursor	.\ext\fts5\fts5_vocab.c	/^struct Fts5VocabCursor {$/;"	s	file:
Fts5VocabCursor	.\ext\fts5\fts5_vocab.c	/^typedef struct Fts5VocabCursor Fts5VocabCursor;$/;"	t	typeref:struct:Fts5VocabCursor	file:
Fts5VocabTable	.\ext\fts5\fts5_vocab.c	/^struct Fts5VocabTable {$/;"	s	file:
Fts5VocabTable	.\ext\fts5\fts5_vocab.c	/^typedef struct Fts5VocabTable Fts5VocabTable;$/;"	t	typeref:struct:Fts5VocabTable	file:
Fts5tcl_Init	.\ext\fts5\fts5_tcl.c	/^int Fts5tcl_Init(Tcl_Interp *interp){$/;"	f
FuncDef	.\src\sqliteInt.h	/^struct FuncDef {$/;"	s
FuncDef	.\src\sqliteInt.h	/^typedef struct FuncDef FuncDef;$/;"	t	typeref:struct:FuncDef
FuncDefHash	.\src\sqliteInt.h	/^struct FuncDefHash {$/;"	s
FuncDefHash	.\src\sqliteInt.h	/^typedef struct FuncDefHash FuncDefHash;$/;"	t	typeref:struct:FuncDefHash
FuncDestructor	.\src\sqliteInt.h	/^struct FuncDestructor {$/;"	s
FuncDestructor	.\src\sqliteInt.h	/^typedef struct FuncDestructor FuncDestructor;$/;"	t	typeref:struct:FuncDestructor
GCC_VERSION	.\src\sqliteInt.h	65;"	d
GCC_VERSION	.\src\sqliteInt.h	67;"	d
GETPID	.\mptest\mptest.c	51;"	d	file:
GETPID	.\mptest\mptest.c	53;"	d	file:
GETPID	.\src\tclsqlite.c	55;"	d	file:
GETPID	.\src\tclsqlite.c	61;"	d	file:
GETPROCTIMES	.\src\shell.c	/^typedef BOOL (WINAPI *GETPROCTIMES)(HANDLE, LPFILETIME, LPFILETIME,$/;"	t	file:
GETVARINT_INIT	.\ext\fts3\fts3.c	343;"	d	file:
GETVARINT_STEP	.\ext\fts3\fts3.c	340;"	d	file:
GLOBAL	.\src\sqliteInt.h	884;"	d
GLOBAL	.\src\sqliteInt.h	890;"	d
GState	.\tool\offsets.c	/^struct GState {$/;"	s	file:
GState	.\tool\offsets.c	/^typedef struct GState GState;$/;"	t	typeref:struct:GState	file:
GetVersionFromFile	.\autoconf\tea\win\nmakehlp.c	/^GetVersionFromFile($/;"	f	file:
Global	.\mptest\mptest.c	/^static struct Global {$/;"	s	file:
Global	.\test\speedtest1.c	/^static struct Global {$/;"	s	file:
GlobalData	.\tool\showdb.c	/^static struct GlobalData {$/;"	s	file:
GlobalVars	.\test\fuzzcheck.c	/^static struct GlobalVars {$/;"	s	file:
GlobalVars	.\tool\fuzzershell.c	/^struct GlobalVars {$/;"	s	file:
GlobalVars	.\tool\sqldiff.c	/^struct GlobalVars {$/;"	s	file:
HANDLE_TO_WINFILE	.\src\os_win.c	2022;"	d	file:
HASHSIZE	.\ext\rtree\rtree.c	99;"	d	file:
HASHTABLE_HASH_1	.\src\wal.c	495;"	d	file:
HASHTABLE_NPAGE	.\src\wal.c	494;"	d	file:
HASHTABLE_NPAGE_ONE	.\src\wal.c	503;"	d	file:
HASHTABLE_NSLOT	.\src\wal.c	496;"	d	file:
HASH_BINARY	.\ext\fts1\ft_hash.h	78;"	d
HASH_STRING	.\ext\fts1\ft_hash.h	77;"	d
HAS_TIMER	.\src\shell.c	228;"	d	file:
HAS_TIMER	.\src\shell.c	307;"	d	file:
HAS_TIMER	.\src\shell.c	312;"	d	file:
HAVE_FULLFSYNC	.\src\os_unix.c	3412;"	d	file:
HAVE_FULLFSYNC	.\src\os_unix.c	3414;"	d	file:
HAVE_GETHOSTUUID	.\src\os_unix.c	98;"	d	file:
HAVE_LOCALTIME_S	.\src\date.c	417;"	d	file:
HAVE_LOCALTIME_S	.\src\date.c	418;"	d	file:
HAVE_MREMAP	.\src\os_unix.c	301;"	d	file:
HAVE_MREMAP	.\src\os_unix.c	303;"	d	file:
HAVE_UTIME	.\src\vxworks.h	25;"	d
HDR	.\main.mk	/^HDR = \\$/;"	m
HasRowid	.\src\sqliteInt.h	1706;"	d
Hash	.\ext\fts1\ft_hash.h	/^struct Hash {$/;"	s
Hash	.\ext\fts1\ft_hash.h	/^typedef struct Hash Hash;$/;"	t	typeref:struct:Hash
Hash	.\src\hash.h	/^struct Hash {$/;"	s
Hash	.\src\hash.h	/^typedef struct Hash Hash;$/;"	t	typeref:struct:Hash
HashClear	.\ext\fts1\ft_hash.c	/^void HashClear(Hash *pH){$/;"	f
HashCount	.\ext\fts1\ft_hash.h	109;"	d
HashData	.\ext\fts1\ft_hash.h	102;"	d
HashElem	.\ext\fts1\ft_hash.h	/^struct HashElem {$/;"	s
HashElem	.\ext\fts1\ft_hash.h	/^typedef struct HashElem HashElem;$/;"	t	typeref:struct:HashElem
HashElem	.\src\hash.h	/^struct HashElem {$/;"	s
HashElem	.\src\hash.h	/^typedef struct HashElem HashElem;$/;"	t	typeref:struct:HashElem
HashFind	.\ext\fts1\ft_hash.c	/^void *HashFind(const Hash *pH, const void *pKey, int nKey){$/;"	f
HashFirst	.\ext\fts1\ft_hash.h	100;"	d
HashInit	.\ext\fts1\ft_hash.c	/^void HashInit(Hash *pNew, int keyClass, int copyKey){$/;"	f
HashInsert	.\ext\fts1\ft_hash.c	/^void *HashInsert(Hash *pH, const void *pKey, int nKey, void *data){$/;"	f
HashKey	.\ext\fts1\ft_hash.h	103;"	d
HashKeysize	.\ext\fts1\ft_hash.h	104;"	d
HashNext	.\ext\fts1\ft_hash.h	101;"	d
HighlightContext	.\ext\fts5\fts5_aux.c	/^struct HighlightContext {$/;"	s	file:
HighlightContext	.\ext\fts5\fts5_aux.c	/^typedef struct HighlightContext HighlightContext;$/;"	t	typeref:struct:HighlightContext	file:
INCOMPLETE	.\tool\lemon.c	/^  INCOMPLETE$/;"	e	enum:cfgstatus	file:
INCRINIT_NORMAL	.\src\vdbesort.c	2062;"	d	file:
INCRINIT_ROOT	.\src\vdbesort.c	2064;"	d	file:
INCRINIT_TASK	.\src\vdbesort.c	2063;"	d	file:
INITIALIZE	.\tool\lemon.c	/^  INITIALIZE,$/;"	e	enum:e_state	file:
INST_MAX_PATHNAME	.\src\test_osinst.c	86;"	d	file:
INT16_TYPE	.\src\sqliteInt.h	583;"	d
INT16_TYPE	.\src\sqliteInt.h	585;"	d
INT2PTR	.\test\threadtest3.c	71;"	d	file:
INT8_TYPE	.\src\sqliteInt.h	597;"	d
INT8_TYPE	.\src\sqliteInt.h	599;"	d
INTERFACE	.\src\lempar.c	28;"	d	file:
INTERFACE	.\tool\lempar.c	22;"	d	file:
INTERIOR_MAX	.\ext\fts2\fts2.c	4043;"	d	file:
INTERIOR_MIN_TERMS	.\ext\fts2\fts2.c	4050;"	d	file:
INVALID_FILE_ATTRIBUTES	.\src\os_win.c	211;"	d	file:
INVALID_SET_FILE_POINTER	.\src\os_win.c	2374;"	d	file:
IN_DECLARE_VTAB	.\src\sqliteInt.h	2770;"	d
IN_DECLARE_VTAB	.\src\sqliteInt.h	2772;"	d
IN_INDEX_EPH	.\src\sqliteInt.h	3857;"	d
IN_INDEX_INDEX_ASC	.\src\sqliteInt.h	3858;"	d
IN_INDEX_INDEX_DESC	.\src\sqliteInt.h	3859;"	d
IN_INDEX_LOOP	.\src\sqliteInt.h	3866;"	d
IN_INDEX_MEMBERSHIP	.\src\sqliteInt.h	3865;"	d
IN_INDEX_NOOP	.\src\sqliteInt.h	3860;"	d
IN_INDEX_NOOP_OK	.\src\sqliteInt.h	3864;"	d
IN_INDEX_ROWID	.\src\sqliteInt.h	3856;"	d
IN_RHS	.\tool\lemon.c	/^  IN_RHS,$/;"	e	enum:e_state	file:
IOMETHODS	.\src\os_unix.c	4988;"	d	file:
IOTRACE	.\src\sqliteInt.h	3915;"	d
IOTRACE	.\src\sqliteInt.h	3919;"	d
ISAUTOVACUUM	.\src\btreeInt.h	657;"	d
ISAUTOVACUUM	.\src\btreeInt.h	659;"	d
ISOPT	.\tool\lemon.c	1778;"	d	file:
IS_BIG_INT	.\src\sqliteInt.h	421;"	d
IS_LOCK_ERROR	.\src\os_unix.c	160;"	d	file:
IcuCursor	.\ext\fts2\fts2_icu.c	/^struct IcuCursor {$/;"	s	file:
IcuCursor	.\ext\fts2\fts2_icu.c	/^typedef struct IcuCursor IcuCursor;$/;"	t	typeref:struct:IcuCursor	file:
IcuCursor	.\ext\fts3\fts3_icu.c	/^struct IcuCursor {$/;"	s	file:
IcuCursor	.\ext\fts3\fts3_icu.c	/^typedef struct IcuCursor IcuCursor;$/;"	t	typeref:struct:IcuCursor	file:
IcuTokenizer	.\ext\fts2\fts2_icu.c	/^struct IcuTokenizer {$/;"	s	file:
IcuTokenizer	.\ext\fts2\fts2_icu.c	/^typedef struct IcuTokenizer IcuTokenizer;$/;"	t	typeref:struct:IcuTokenizer	file:
IcuTokenizer	.\ext\fts3\fts3_icu.c	/^struct IcuTokenizer {$/;"	s	file:
IcuTokenizer	.\ext\fts3\fts3_icu.c	/^typedef struct IcuTokenizer IcuTokenizer;$/;"	t	typeref:struct:IcuTokenizer	file:
IdChar	.\ext\fts1\fts1.c	1559;"	d	file:
IdChar	.\ext\fts2\fts2.c	2427;"	d	file:
IdChar	.\src\complete.c	27;"	d	file:
IdChar	.\src\complete.c	31;"	d	file:
IdChar	.\src\tokenize.c	103;"	d	file:
IdChar	.\src\tokenize.c	85;"	d	file:
IdList	.\src\sqliteInt.h	/^struct IdList {$/;"	s
IdList	.\src\sqliteInt.h	/^typedef struct IdList IdList;$/;"	t	typeref:struct:IdList
IdList_item	.\src\sqliteInt.h	/^  struct IdList_item {$/;"	s	struct:IdList
Identifier	.\test\fuzz_common.tcl	/^proc Identifier {} {$/;"	p
IfNotOmitAV	.\src\btree.c	60;"	d	file:
IfNotOmitAV	.\src\btree.c	62;"	d	file:
IgnorableOrderby	.\src\sqliteInt.h	2555;"	d
ImportCtx	.\src\shell.c	/^struct ImportCtx {$/;"	s	file:
ImportCtx	.\src\shell.c	/^typedef struct ImportCtx ImportCtx;$/;"	t	typeref:struct:ImportCtx	file:
InLoop	.\src\whereInt.h	/^      struct InLoop {$/;"	s	struct:WhereLevel::__anon26::__anon27
IncrMerger	.\src\vdbesort.c	/^struct IncrMerger {$/;"	s	file:
IncrMerger	.\src\vdbesort.c	/^typedef struct IncrMerger IncrMerger;       \/* Read & merge multiple PMAs *\/$/;"	t	typeref:struct:IncrMerger	file:
Incrblob	.\src\vdbeblob.c	/^struct Incrblob {$/;"	s	file:
Incrblob	.\src\vdbeblob.c	/^typedef struct Incrblob Incrblob;$/;"	t	typeref:struct:Incrblob	file:
IncrblobChannel	.\src\tclsqlite.c	/^struct IncrblobChannel {$/;"	s	file:
IncrblobChannel	.\src\tclsqlite.c	/^typedef struct IncrblobChannel IncrblobChannel;$/;"	t	typeref:struct:IncrblobChannel	file:
IncrblobChannelType	.\src\tclsqlite.c	/^static Tcl_ChannelType IncrblobChannelType = {$/;"	v	file:
IncrmergeWriter	.\ext\fts3\fts3_write.c	/^struct IncrmergeWriter {$/;"	s	file:
IncrmergeWriter	.\ext\fts3\fts3_write.c	/^typedef struct IncrmergeWriter IncrmergeWriter;$/;"	t	typeref:struct:IncrmergeWriter	file:
Index	.\src\sqliteInt.h	/^struct Index {$/;"	s
Index	.\src\sqliteInt.h	/^typedef struct Index Index;$/;"	t	typeref:struct:Index
IndexSample	.\src\sqliteInt.h	/^struct IndexSample {$/;"	s
IndexSample	.\src\sqliteInt.h	/^typedef struct IndexSample IndexSample;$/;"	t	typeref:struct:IndexSample
InitData	.\src\sqliteInt.h	/^} InitData;$/;"	t	typeref:struct:__anon21
Insert	.\test\fuzz_common.tcl	/^proc Insert {} {$/;"	p
IntegrityCk	.\src\btreeInt.h	/^struct IntegrityCk {$/;"	s
IntegrityCk	.\src\btreeInt.h	/^typedef struct IntegrityCk IntegrityCk;$/;"	t	typeref:struct:IntegrityCk
InteriorBlock	.\ext\fts2\fts2.c	/^typedef struct InteriorBlock {$/;"	s	file:
InteriorBlock	.\ext\fts2\fts2.c	/^} InteriorBlock;$/;"	t	typeref:struct:InteriorBlock	file:
InteriorReader	.\ext\fts2\fts2.c	/^typedef struct InteriorReader {$/;"	s	file:
InteriorReader	.\ext\fts2\fts2.c	/^} InteriorReader;$/;"	t	typeref:struct:InteriorReader	file:
InteriorWriter	.\ext\fts2\fts2.c	/^typedef struct InteriorWriter {$/;"	s	file:
InteriorWriter	.\ext\fts2\fts2.c	/^} InteriorWriter;$/;"	t	typeref:struct:InteriorWriter	file:
InterpAndScript	.\src\test_superlock.c	/^struct InterpAndScript {$/;"	s	file:
InterpAndScript	.\src\test_superlock.c	/^typedef struct InterpAndScript InterpAndScript;$/;"	t	typeref:struct:InterpAndScript	file:
IsDigit	.\src\shell.c	136;"	d	file:
IsHiddenColumn	.\src\sqliteInt.h	1699;"	d
IsHiddenColumn	.\src\sqliteInt.h	1702;"	d
IsIn	.\autoconf\tea\win\nmakehlp.c	/^IsIn($/;"	f	file:
IsPowerOfTwo	.\src\sqliteInt.h	856;"	d
IsPrimaryKeyIndex	.\src\sqliteInt.h	1916;"	d
IsSpace	.\src\shell.c	135;"	d	file:
IsStat3	.\src\analyze.c	147;"	d	file:
IsStat3	.\src\analyze.c	150;"	d	file:
IsStat3	.\src\analyze.c	153;"	d	file:
IsStat34	.\src\analyze.c	157;"	d	file:
IsStat4	.\src\analyze.c	146;"	d	file:
IsStat4	.\src\analyze.c	149;"	d	file:
IsStat4	.\src\analyze.c	152;"	d	file:
IsUniqueIndex	.\src\sqliteInt.h	1919;"	d
IsVirtual	.\src\sqliteInt.h	1698;"	d
IsVirtual	.\src\sqliteInt.h	1701;"	d
JEACH_ATOM	.\ext\misc\json1.c	1550;"	d	file:
JEACH_FULLKEY	.\ext\misc\json1.c	1553;"	d	file:
JEACH_ID	.\ext\misc\json1.c	1551;"	d	file:
JEACH_JSON	.\ext\misc\json1.c	1555;"	d	file:
JEACH_KEY	.\ext\misc\json1.c	1547;"	d	file:
JEACH_PARENT	.\ext\misc\json1.c	1552;"	d	file:
JEACH_PATH	.\ext\misc\json1.c	1554;"	d	file:
JEACH_ROOT	.\ext\misc\json1.c	1556;"	d	file:
JEACH_TYPE	.\ext\misc\json1.c	1549;"	d	file:
JEACH_VALUE	.\ext\misc\json1.c	1548;"	d	file:
JNODE_APPEND	.\ext\misc\json1.c	136;"	d	file:
JNODE_ESCAPE	.\ext\misc\json1.c	133;"	d	file:
JNODE_LABEL	.\ext\misc\json1.c	137;"	d	file:
JNODE_RAW	.\ext\misc\json1.c	132;"	d	file:
JNODE_REMOVE	.\ext\misc\json1.c	134;"	d	file:
JNODE_REPLACE	.\ext\misc\json1.c	135;"	d	file:
JOURNAL_CHUNKSIZE	.\src\memjournal.c	32;"	d	file:
JOURNAL_FILE	.\src\test_onefile.c	126;"	d	file:
JOURNAL_HDR_SZ	.\src\pager.c	770;"	d	file:
JOURNAL_PG_SZ	.\src\pager.c	764;"	d	file:
JSON_ARRAY	.\ext\misc\json1.c	117;"	d	file:
JSON_FALSE	.\ext\misc\json1.c	113;"	d	file:
JSON_INT	.\ext\misc\json1.c	114;"	d	file:
JSON_NOINLINE	.\ext\misc\json1.c	624;"	d	file:
JSON_NOINLINE	.\ext\misc\json1.c	626;"	d	file:
JSON_NOINLINE	.\ext\misc\json1.c	628;"	d	file:
JSON_NULL	.\ext\misc\json1.c	111;"	d	file:
JSON_OBJECT	.\ext\misc\json1.c	118;"	d	file:
JSON_REAL	.\ext\misc\json1.c	115;"	d	file:
JSON_STRING	.\ext\misc\json1.c	116;"	d	file:
JSON_SUBTYPE	.\ext\misc\json1.c	121;"	d	file:
JSON_TRUE	.\ext\misc\json1.c	112;"	d	file:
JT_CROSS	.\src\sqliteInt.h	2336;"	d
JT_ERROR	.\src\sqliteInt.h	2341;"	d
JT_INNER	.\src\sqliteInt.h	2335;"	d
JT_LEFT	.\src\sqliteInt.h	2338;"	d
JT_MAX_PATHNAME	.\src\test_journal.c	104;"	d	file:
JT_NATURAL	.\src\sqliteInt.h	2337;"	d
JT_OUTER	.\src\sqliteInt.h	2340;"	d
JT_RIGHT	.\src\sqliteInt.h	2339;"	d
JT_VFS_NAME	.\src\test_journal.c	109;"	d	file:
JournalFile	.\src\journal.c	/^struct JournalFile {$/;"	s	file:
JournalFile	.\src\journal.c	/^typedef struct JournalFile JournalFile;$/;"	t	typeref:struct:JournalFile	file:
JournalFileMethods	.\src\journal.c	/^static struct sqlite3_io_methods JournalFileMethods = {$/;"	v	typeref:struct:sqlite3_io_methods	file:
JsonEachCursor	.\ext\misc\json1.c	/^struct JsonEachCursor {$/;"	s	file:
JsonEachCursor	.\ext\misc\json1.c	/^typedef struct JsonEachCursor JsonEachCursor;$/;"	t	typeref:struct:JsonEachCursor	file:
JsonNode	.\ext\misc\json1.c	/^struct JsonNode {$/;"	s	file:
JsonNode	.\ext\misc\json1.c	/^typedef struct JsonNode JsonNode;$/;"	t	typeref:struct:JsonNode	file:
JsonParse	.\ext\misc\json1.c	/^struct JsonParse {$/;"	s	file:
JsonParse	.\ext\misc\json1.c	/^typedef struct JsonParse JsonParse;$/;"	t	typeref:struct:JsonParse	file:
JsonString	.\ext\misc\json1.c	/^struct JsonString {$/;"	s	file:
JsonString	.\ext\misc\json1.c	/^typedef struct JsonString JsonString;$/;"	t	typeref:struct:JsonString	file:
JtGlobal	.\src\test_journal.c	/^struct JtGlobal {$/;"	s	file:
KeyClass	.\src\sqliteInt.h	/^typedef struct KeyClass KeyClass;$/;"	t	typeref:struct:KeyClass
KeyInfo	.\src\sqliteInt.h	/^struct KeyInfo {$/;"	s
KeyInfo	.\src\sqliteInt.h	/^typedef struct KeyInfo KeyInfo;$/;"	t	typeref:struct:KeyInfo
Keyword	.\tool\mkkeywordhash.c	/^struct Keyword {$/;"	s	file:
Keyword	.\tool\mkkeywordhash.c	/^typedef struct Keyword Keyword;$/;"	t	typeref:struct:Keyword	file:
LARGEST_INT64	.\ext\fts3\fts3.c	3123;"	d	file:
LARGEST_INT64	.\ext\fts5\fts5Int.h	44;"	d
LARGEST_INT64	.\ext\misc\json1.c	37;"	d	file:
LARGEST_INT64	.\ext\misc\totype.c	60;"	d	file:
LARGEST_INT64	.\src\sqliteInt.h	714;"	d
LCS_ITERATOR_FINISHED	.\ext\fts3\fts3_snippet.c	1070;"	d	file:
LEAF_MAX	.\ext\fts2\fts2.c	4464;"	d	file:
LEAF_SELECT	.\ext\fts2\fts2.c	1862;"	d	file:
LEFT	.\tool\lemon.c	/^    LEFT,$/;"	e	enum:e_assoc	file:
LEMON_FALSE	.\tool\lemon.c	/^typedef enum {LEMON_FALSE=0, LEMON_TRUE} Boolean;$/;"	e	enum:__anon33	file:
LEMON_TRUE	.\tool\lemon.c	/^typedef enum {LEMON_FALSE=0, LEMON_TRUE} Boolean;$/;"	e	enum:__anon33	file:
LHS_ALIAS_1	.\tool\lemon.c	/^  LHS_ALIAS_1,$/;"	e	enum:e_state	file:
LHS_ALIAS_2	.\tool\lemon.c	/^  LHS_ALIAS_2,$/;"	e	enum:e_state	file:
LHS_ALIAS_3	.\tool\lemon.c	/^  LHS_ALIAS_3,$/;"	e	enum:e_state	file:
LIKEFUNC	.\src\sqliteInt.h	1452;"	d
LINESIZE	.\tool\lemon.c	3224;"	d	file:
LINKVAR	.\src\test_config.c	654;"	d	file:
LISTSIZE	.\tool\lemon.c	1747;"	d	file:
LOCKFILE_EXCLUSIVE_LOCK	.\src\os_win.c	2887;"	d	file:
LOCKFILE_FAIL_IMMEDIATELY	.\src\os_win.c	2883;"	d	file:
LOGMAX	.\src\mem5.c	78;"	d	file:
LONGDOUBLE_TYPE	.\src\sqliteInt.h	448;"	d
LONGDOUBLE_TYPE	.\src\sqliteInt.h	603;"	d
LcsIterator	.\ext\fts3\fts3_snippet.c	/^struct LcsIterator {$/;"	s	file:
LcsIterator	.\ext\fts3\fts3_snippet.c	/^typedef struct LcsIterator LcsIterator;$/;"	t	typeref:struct:LcsIterator	file:
LeafReader	.\ext\fts2\fts2.c	/^typedef struct LeafReader {$/;"	s	file:
LeafReader	.\ext\fts2\fts2.c	/^} LeafReader;$/;"	t	typeref:struct:LeafReader	file:
LeafWriter	.\ext\fts2\fts2.c	/^typedef struct LeafWriter {$/;"	s	file:
LeafWriter	.\ext\fts2\fts2.c	/^} LeafWriter;$/;"	t	typeref:struct:LeafWriter	file:
LeavesReader	.\ext\fts2\fts2.c	/^typedef struct LeavesReader {$/;"	s	file:
LeavesReader	.\ext\fts2\fts2.c	/^} LeavesReader;$/;"	t	typeref:struct:LeavesReader	file:
Literal	.\test\fuzz_common.tcl	/^proc Literal {} {$/;"	p
LoadDoclistCtx	.\ext\fts3\fts3_snippet.c	/^struct LoadDoclistCtx {$/;"	s	file:
LoadDoclistCtx	.\ext\fts3\fts3_snippet.c	/^typedef struct LoadDoclistCtx LoadDoclistCtx;$/;"	t	typeref:struct:LoadDoclistCtx	file:
LogCallback	.\src\test1.c	/^static struct LogCallback {$/;"	s	file:
LogEst	.\src\sqliteInt.h	/^typedef INT16_TYPE LogEst;$/;"	t
LogEst	.\tool\logest.c	/^typedef short int LogEst;  \/* 10 times log2() *\/$/;"	t	file:
Lookaside	.\src\sqliteInt.h	/^struct Lookaside {$/;"	s
Lookaside	.\src\sqliteInt.h	/^typedef struct Lookaside Lookaside;$/;"	t	typeref:struct:Lookaside
LookasideSlot	.\src\sqliteInt.h	/^struct LookasideSlot {$/;"	s
LookasideSlot	.\src\sqliteInt.h	/^typedef struct LookasideSlot LookasideSlot;$/;"	t	typeref:struct:LookasideSlot
M	.\src\date.c	/^  int Y, M, D;       \/* Year, month, and day *\/$/;"	m	struct:DateTime	file:
MALLOC_LOG_FRAMES	.\src\test_malloc.c	738;"	d	file:
MALLOC_LOG_KEYINTS	.\src\test_malloc.c	739;"	d	file:
MASKBIT	.\src\sqliteInt.h	2273;"	d
MASKBIT32	.\src\sqliteInt.h	2274;"	d
MASTER_NAME	.\src\sqliteInt.h	834;"	d
MASTER_ROOT	.\src\sqliteInt.h	840;"	d
MAX	.\ext\async\sqlite3async.c	29;"	d	file:
MAX	.\ext\fts3\fts3Int.h	83;"	d
MAX	.\ext\fts5\fts5Int.h	39;"	d
MAX	.\ext\rtree\rtree.c	359;"	d	file:
MAX	.\src\sqliteInt.h	543;"	d
MAX	.\src\test_onefile.c	251;"	d	file:
MAXPATHNAME	.\src\test_demovfs.c	141;"	d	file:
MAXRHS	.\tool\lemon.c	38;"	d	file:
MAXRHS	.\tool\lemon.c	40;"	d	file:
MAX_6BYTE	.\src\vdbeaux.c	2952;"	d	file:
MAX_CONNECTIONS	.\src\test_sqllog.c	99;"	d	file:
MAX_INCR_PHRASE_TOKENS	.\ext\fts3\fts3.c	4222;"	d	file:
MAX_MUTEXES	.\src\test_mutex.c	22;"	d	file:
MAX_PAGE_SIZE	.\src\test_multiplex.c	68;"	d	file:
MAX_PATH	.\src\os_win.c	95;"	d	file:
MAX_PATHNAME	.\src\os_unix.c	150;"	d	file:
MAX_PREPARED_STMTS	.\src\tclsqlite.c	74;"	d	file:
MAX_ROWID	.\src\vdbe.c	4088;"	d	file:
MAX_SECTOR_SIZE	.\src\pager.c	429;"	d	file:
MAX_STMT	.\ext\fts1\fts1.c	/^  MAX_STMT                     \/* Always at end! *\/$/;"	e	enum:fulltext_statement	file:
MAX_STMT	.\ext\fts1\fulltext.c	/^  MAX_STMT                     \/* Always at end! *\/$/;"	e	enum:fulltext_statement	file:
MAX_STMT	.\ext\fts2\fts2.c	/^  MAX_STMT                     \/* Always at end! *\/$/;"	e	enum:fulltext_statement	file:
MD5Context	.\src\tclsqlite.c	/^struct MD5Context {$/;"	s	file:
MD5Context	.\src\tclsqlite.c	/^typedef struct MD5Context MD5Context;$/;"	t	typeref:struct:MD5Context	file:
MD5Context	.\test\threadtest3.c	/^struct MD5Context {$/;"	s	file:
MD5Context	.\test\threadtest3.c	/^typedef struct MD5Context MD5Context;$/;"	t	typeref:struct:MD5Context	file:
MD5DigestToBase10x8	.\src\tclsqlite.c	/^static void MD5DigestToBase10x8(unsigned char digest[16], char zDigest[50]){$/;"	f	file:
MD5DigestToBase16	.\src\tclsqlite.c	/^static void MD5DigestToBase16(unsigned char *digest, char *zBuf){$/;"	f	file:
MD5DigestToBase16	.\test\threadtest3.c	/^static void MD5DigestToBase16(unsigned char *digest, char *zBuf){$/;"	f	file:
MD5Final	.\src\tclsqlite.c	/^static void MD5Final(unsigned char digest[16], MD5Context *ctx){$/;"	f	file:
MD5Final	.\test\threadtest3.c	/^static void MD5Final(unsigned char digest[16], MD5Context *ctx){$/;"	f	file:
MD5Init	.\src\tclsqlite.c	/^static void MD5Init(MD5Context *ctx){$/;"	f	file:
MD5Init	.\test\threadtest3.c	/^static void MD5Init(MD5Context *ctx){$/;"	f	file:
MD5STEP	.\src\tclsqlite.c	3225;"	d	file:
MD5STEP	.\test\threadtest3.c	152;"	d	file:
MD5Transform	.\src\tclsqlite.c	/^static void MD5Transform(uint32 buf[4], const uint32 in[16]){$/;"	f	file:
MD5Transform	.\test\threadtest3.c	/^static void MD5Transform(uint32 buf[4], const uint32 in[16]){$/;"	f	file:
MD5Update	.\src\tclsqlite.c	/^void MD5Update(MD5Context *ctx, const unsigned char *buf, unsigned int len){$/;"	f	file:
MD5Update	.\test\threadtest3.c	/^void MD5Update(MD5Context *ctx, const unsigned char *buf, unsigned int len){$/;"	f	file:
MEM5LINK	.\src\mem5.c	141;"	d	file:
MEMCELLSIZE	.\src\vdbeInt.h	197;"	d
MEMDB	.\src\pager.c	779;"	d	file:
MEMDB	.\src\pager.c	781;"	d	file:
MEMTYPE_HEAP	.\src\sqliteInt.h	3960;"	d
MEMTYPE_LOOKASIDE	.\src\sqliteInt.h	3961;"	d
MEMTYPE_PCACHE	.\src\sqliteInt.h	3963;"	d
MEMTYPE_SCRATCH	.\src\sqliteInt.h	3962;"	d
MEM_AffMask	.\src\vdbeInt.h	216;"	d
MEM_Agg	.\src\vdbeInt.h	233;"	d
MEM_Blob	.\src\vdbeInt.h	215;"	d
MEM_Cleared	.\src\vdbeInt.h	220;"	d
MEM_Dyn	.\src\vdbeInt.h	230;"	d
MEM_Ephem	.\src\vdbeInt.h	232;"	d
MEM_Frame	.\src\vdbeInt.h	218;"	d
MEM_Int	.\src\vdbeInt.h	213;"	d
MEM_Null	.\src\vdbeInt.h	211;"	d
MEM_Real	.\src\vdbeInt.h	214;"	d
MEM_RowSet	.\src\vdbeInt.h	217;"	d
MEM_Static	.\src\vdbeInt.h	231;"	d
MEM_Str	.\src\vdbeInt.h	212;"	d
MEM_Term	.\src\vdbeInt.h	229;"	d
MEM_TypeMask	.\src\vdbeInt.h	221;"	d
MEM_Undefined	.\src\vdbeInt.h	219;"	d
MEM_Zero	.\src\vdbeInt.h	234;"	d
MEM_Zero	.\src\vdbeInt.h	236;"	d
MEM_Zero	.\src\vdbeInt.h	237;"	d
MERGE_COUNT	.\ext\fts2\fts2.c	383;"	d	file:
MIN	.\ext\async\sqlite3async.c	28;"	d	file:
MIN	.\ext\fts3\fts3Int.h	80;"	d
MIN	.\ext\fts5\fts5Int.h	38;"	d
MIN	.\ext\rtree\rtree.c	362;"	d	file:
MIN	.\src\sqliteInt.h	542;"	d
MIN	.\src\test_onefile.c	250;"	d	file:
MODE_Ascii	.\src\shell.c	576;"	d	file:
MODE_Column	.\src\shell.c	568;"	d	file:
MODE_Csv	.\src\shell.c	574;"	d	file:
MODE_DELETE	.\test\wordcount.c	193;"	d	file:
MODE_Explain	.\src\shell.c	575;"	d	file:
MODE_Html	.\src\shell.c	571;"	d	file:
MODE_INSERT	.\test\wordcount.c	189;"	d	file:
MODE_Insert	.\src\shell.c	572;"	d	file:
MODE_Line	.\src\shell.c	567;"	d	file:
MODE_List	.\src\shell.c	569;"	d	file:
MODE_QUERY	.\test\wordcount.c	194;"	d	file:
MODE_REPLACE	.\test\wordcount.c	190;"	d	file:
MODE_SELECT	.\test\wordcount.c	191;"	d	file:
MODE_Semi	.\src\shell.c	570;"	d	file:
MODE_Tcl	.\src\shell.c	573;"	d	file:
MODE_UPDATE	.\test\wordcount.c	192;"	d	file:
MPTEST1	.\main.mk	/^MPTEST1=.\/mptester$(EXE) mptest.db $(TOP)\/mptest\/crash01.test --repeat 20$/;"	m
MPTEST2	.\main.mk	/^MPTEST2=.\/mptester$(EXE) mptest.db $(TOP)\/mptest\/multiwrite01.test --repeat 20$/;"	m
MSG_Close	.\src\test_server.c	244;"	d	file:
MSG_Done	.\src\test_server.c	245;"	d	file:
MSG_Finalize	.\src\test_server.c	243;"	d	file:
MSG_Open	.\src\test_server.c	239;"	d	file:
MSG_Prepare	.\src\test_server.c	240;"	d	file:
MSG_Reset	.\src\test_server.c	242;"	d	file:
MSG_Step	.\src\test_server.c	241;"	d	file:
MULTIPLEX_CTRL_ENABLE	.\src\test_multiplex.h	45;"	d
MULTIPLEX_CTRL_SET_CHUNK_SIZE	.\src\test_multiplex.h	46;"	d
MULTIPLEX_CTRL_SET_MAX_CHUNKS	.\src\test_multiplex.h	47;"	d
MULTITERMINAL	.\tool\lemon.c	/^  MULTITERMINAL$/;"	e	enum:symbol_type	file:
MUTEX_LOGIC	.\src\mutex.h	67;"	d
MUTEX_LOGIC	.\src\mutex.h	69;"	d
MX_ARG	.\mptest\mptest.c	863;"	d	file:
MX_CELL	.\src\btreeInt.h	229;"	d
MX_CELL_SIZE	.\src\btreeInt.h	222;"	d
MX_CHUNK_NUMBER	.\src\test_multiplex.c	85;"	d	file:
MX_CLOSE_ATTEMPT	.\src\os_win.c	2454;"	d	file:
MX_FILE	.\test\fuzzcheck.c	110;"	d	file:
MX_FILE_SZ	.\test\fuzzcheck.c	115;"	d	file:
MX_LCK	.\tool\showlocks.c	18;"	d	file:
MX_SMALL	.\src\mem3.c	40;"	d	file:
MallocLog	.\src\test_malloc.c	/^struct MallocLog {$/;"	s	file:
MallocLog	.\src\test_malloc.c	/^typedef struct MallocLog MallocLog;$/;"	t	typeref:struct:MallocLog	file:
MatchInfo	.\ext\fts3\fts3_snippet.c	/^struct MatchInfo {$/;"	s	file:
MatchInfo	.\ext\fts3\fts3_snippet.c	/^typedef struct MatchInfo MatchInfo;$/;"	t	typeref:struct:MatchInfo	file:
MatchQuery	.\ext\misc\spellfix.c	/^typedef struct MatchQuery {$/;"	s	file:
MatchQuery	.\ext\misc\spellfix.c	/^} MatchQuery;$/;"	t	typeref:struct:MatchQuery	file:
MatchinfoBuffer	.\ext\fts3\fts3Int.h	/^typedef struct MatchinfoBuffer MatchinfoBuffer;$/;"	t	typeref:struct:MatchinfoBuffer
MatchinfoBuffer	.\ext\fts3\fts3_snippet.c	/^struct MatchinfoBuffer {$/;"	s	file:
Md5_Init	.\src\tclsqlite.c	/^int Md5_Init(Tcl_Interp *interp){$/;"	f
Md5_Register	.\src\tclsqlite.c	/^int Md5_Register(sqlite3 *db){$/;"	f
Mem	.\src\vdbe.h	/^typedef struct Mem Mem;$/;"	t	typeref:struct:Mem
Mem	.\src\vdbeInt.h	/^struct Mem {$/;"	s
Mem0Global	.\src\malloc.c	/^static SQLITE_WSD struct Mem0Global {$/;"	s	file:
Mem3Block	.\src\mem3.c	/^struct Mem3Block {$/;"	s	file:
Mem3Block	.\src\mem3.c	/^typedef struct Mem3Block Mem3Block;$/;"	t	typeref:struct:Mem3Block	file:
Mem3Global	.\src\mem3.c	/^static SQLITE_WSD struct Mem3Global {$/;"	s	file:
Mem5Global	.\src\mem5.c	/^static SQLITE_WSD struct Mem5Global {$/;"	s	file:
Mem5Link	.\src\mem5.c	/^struct Mem5Link {$/;"	s	file:
Mem5Link	.\src\mem5.c	/^typedef struct Mem5Link Mem5Link;$/;"	t	typeref:struct:Mem5Link	file:
MemBlockHdr	.\src\mem2.c	/^struct MemBlockHdr {$/;"	s	file:
MemFault	.\src\test_malloc.c	/^static struct MemFault {$/;"	s	file:
MemJournal	.\src\memjournal.c	/^struct MemJournal {$/;"	s	file:
MemJournal	.\src\memjournal.c	/^typedef struct MemJournal MemJournal;$/;"	t	typeref:struct:MemJournal	file:
MemJournalMethods	.\src\memjournal.c	/^static const struct sqlite3_io_methods MemJournalMethods = {$/;"	v	typeref:struct:sqlite3_io_methods	file:
MemPage	.\src\btreeInt.h	/^struct MemPage {$/;"	s
MemPage	.\src\btreeInt.h	/^typedef struct MemPage MemPage;$/;"	t	typeref:struct:MemPage
MemSetTypeFlag	.\src\vdbeInt.h	243;"	d
MemValue	.\src\vdbeInt.h	/^  union MemValue {$/;"	u	struct:Mem
MemoryCheck	.\tool\lemon.c	400;"	d	file:
MergeEngine	.\src\vdbesort.c	/^struct MergeEngine {$/;"	s	file:
MergeEngine	.\src\vdbesort.c	/^typedef struct MergeEngine MergeEngine;     \/* Merge PMAs together *\/$/;"	t	typeref:struct:MergeEngine	file:
Module	.\src\sqliteInt.h	/^struct Module {$/;"	s
Module	.\src\sqliteInt.h	/^typedef struct Module Module;$/;"	t	typeref:struct:Module
NAMEWIDTH	.\test\speedtest1.c	266;"	d	file:
NB	.\src\btree.c	6689;"	d	file:
NCELL	.\ext\rtree\rtree.c	304;"	d	file:
NCSIZE	.\src\mem2.c	74;"	d	file:
NC_AllowAgg	.\src\sqliteInt.h	2410;"	d
NC_HasAgg	.\src\sqliteInt.h	2411;"	d
NC_IdxExpr	.\src\sqliteInt.h	2415;"	d
NC_InAggFunc	.\src\sqliteInt.h	2413;"	d
NC_IsCheck	.\src\sqliteInt.h	2412;"	d
NC_MinMaxAgg	.\src\sqliteInt.h	2416;"	d
NC_PartIdx	.\src\sqliteInt.h	2414;"	d
NDEBUG	.\ext\fts3\fts3Int.h	165;"	d
NDEBUG	.\ext\fts3\fts3Int.h	18;"	d
NDEBUG	.\ext\misc\fuzzer.c	149;"	d	file:
NDEBUG	.\src\sqliteInt.h	305;"	d
NDEBUG	.\src\sqliteInt.h	308;"	d
NDELAY	.\src\main.c	1395;"	d	file:
NEVER	.\ext\fts3\fts3Int.h	136;"	d
NEVER	.\ext\fts5\fts5Int.h	36;"	d
NEVER	.\ext\misc\spellfix.c	26;"	d	file:
NEVER	.\src\sqliteInt.h	381;"	d
NEVER	.\src\sqliteInt.h	384;"	d
NEVER	.\src\sqliteInt.h	387;"	d
NEXT	.\tool\lemon.c	1679;"	d	file:
NHASH	.\tool\sqldiff.c	771;"	d	file:
NM_MAX_TOKEN	.\ext\fts3\fts3_test.c	31;"	d	file:
NN	.\src\btree.c	6688;"	d	file:
NONE	.\tool\lemon.c	/^    NONE,$/;"	e	enum:e_assoc	file:
NONTERMINAL	.\tool\lemon.c	/^  NONTERMINAL,$/;"	e	enum:symbol_type	file:
NOT	.\ext\fts5\test\fts5_common.tcl	/^proc NOT {a b} {$/;"	p
NOT_USED	.\tool\lemon.c	/^  NOT_USED,                \/* Deleted by compression *\/$/;"	e	enum:e_action	file:
NOT_WITHIN	.\ext\rtree\sqlite3rtree.h	108;"	d
NO_LOCK	.\src\os.h	85;"	d
NO_OFFSET	.\tool\lemon.c	348;"	d	file:
NO_SHLWAPI_GDI	.\autoconf\tea\win\nmakehlp.c	17;"	d	file:
NO_SHLWAPI_REG	.\autoconf\tea\win\nmakehlp.c	19;"	d	file:
NO_SHLWAPI_STREAM	.\autoconf\tea\win\nmakehlp.c	18;"	d	file:
NTDDI_WIN8	.\src\os_win.c	72;"	d	file:
NTDDI_WINBLUE	.\src\os_win.c	76;"	d	file:
NUM_PREPARED_STMTS	.\src\tclsqlite.c	73;"	d	file:
N_HASH	.\src\mem3.c	46;"	d	file:
N_OR_COST	.\src\whereInt.h	158;"	d
N_SORT_BUCKET	.\src\pcache.c	557;"	d	file:
N_STATEMENT	.\ext\rtree\rtree.c	3028;"	d	file:
N_THREAD	.\src\test4.c	56;"	d	file:
N_THREAD	.\src\test7.c	85;"	d	file:
NameContext	.\src\sqliteInt.h	/^struct NameContext {$/;"	s
NameContext	.\src\sqliteInt.h	/^typedef struct NameContext NameContext;$/;"	t	typeref:struct:NameContext
NearDocument	.\ext\fts3\fts3_test.c	/^struct NearDocument {$/;"	s	file:
NearDocument	.\ext\fts3\fts3_test.c	/^typedef struct NearDocument NearDocument;$/;"	t	typeref:struct:NearDocument	file:
NearPhrase	.\ext\fts3\fts3_test.c	/^struct NearPhrase {$/;"	s	file:
NearPhrase	.\ext\fts3\fts3_test.c	/^typedef struct NearPhrase NearPhrase;$/;"	t	typeref:struct:NearPhrase	file:
NearToken	.\ext\fts3\fts3_test.c	/^struct NearToken {$/;"	s	file:
NearToken	.\ext\fts3\fts3_test.c	/^typedef struct NearToken NearToken;$/;"	t	typeref:struct:NearToken	file:
NodeReader	.\ext\fts3\fts3_write.c	/^struct NodeReader {$/;"	s	file:
NodeReader	.\ext\fts3\fts3_write.c	/^typedef struct NodeReader NodeReader;$/;"	t	typeref:struct:NodeReader	file:
NodeWriter	.\ext\fts3\fts3_write.c	/^struct NodeWriter {$/;"	s	file:
NodeWriter	.\ext\fts3\fts3_write.c	/^typedef struct NodeWriter NodeWriter;$/;"	t	typeref:struct:NodeWriter	file:
OE_Abort	.\src\sqliteInt.h	1781;"	d
OE_Cascade	.\src\sqliteInt.h	1789;"	d
OE_Default	.\src\sqliteInt.h	1791;"	d
OE_Fail	.\src\sqliteInt.h	1782;"	d
OE_Ignore	.\src\sqliteInt.h	1783;"	d
OE_None	.\src\sqliteInt.h	1779;"	d
OE_Replace	.\src\sqliteInt.h	1784;"	d
OE_Restrict	.\src\sqliteInt.h	1786;"	d
OE_Rollback	.\src\sqliteInt.h	1780;"	d
OE_SetDflt	.\src\sqliteInt.h	1788;"	d
OE_SetNull	.\src\sqliteInt.h	1787;"	d
OMIT_TEMPDB	.\src\sqliteInt.h	467;"	d
OMIT_TEMPDB	.\src\sqliteInt.h	469;"	d
ONEPASS_MULTI	.\src\sqliteInt.h	3393;"	d
ONEPASS_OFF	.\src\sqliteInt.h	3391;"	d
ONEPASS_SINGLE	.\src\sqliteInt.h	3392;"	d
ONE_BYTE_INT	.\src\vdbeaux.c	3104;"	d	file:
OOM_MAX	.\tool\fuzzershell.c	90;"	d	file:
OPFLAG_APPEND	.\src\sqliteInt.h	2791;"	d
OPFLAG_BULKCSR	.\src\sqliteInt.h	2795;"	d
OPFLAG_EPHEM	.\src\sqliteInt.h	2788;"	d
OPFLAG_ISUPDATE	.\src\sqliteInt.h	2790;"	d
OPFLAG_LASTROWID	.\src\sqliteInt.h	2789;"	d
OPFLAG_LENGTHARG	.\src\sqliteInt.h	2793;"	d
OPFLAG_NCHANGE	.\src\sqliteInt.h	2787;"	d
OPFLAG_P2ISREG	.\src\sqliteInt.h	2797;"	d
OPFLAG_PERMUTE	.\src\sqliteInt.h	2798;"	d
OPFLAG_SEEKEQ	.\src\sqliteInt.h	2796;"	d
OPFLAG_TYPEOFARG	.\src\sqliteInt.h	2794;"	d
OPFLAG_USESEEKRESULT	.\src\sqliteInt.h	2792;"	d
OPT_DBL	.\tool\lemon.c	/^enum option_type { OPT_FLAG=1,  OPT_INT,  OPT_DBL,  OPT_STR,$/;"	e	enum:option_type	file:
OPT_FDBL	.\tool\lemon.c	/^         OPT_FFLAG, OPT_FINT, OPT_FDBL, OPT_FSTR};$/;"	e	enum:option_type	file:
OPT_FFLAG	.\tool\lemon.c	/^         OPT_FFLAG, OPT_FINT, OPT_FDBL, OPT_FSTR};$/;"	e	enum:option_type	file:
OPT_FINT	.\tool\lemon.c	/^         OPT_FFLAG, OPT_FINT, OPT_FDBL, OPT_FSTR};$/;"	e	enum:option_type	file:
OPT_FLAG	.\tool\lemon.c	/^enum option_type { OPT_FLAG=1,  OPT_INT,  OPT_DBL,  OPT_STR,$/;"	e	enum:option_type	file:
OPT_FSTR	.\tool\lemon.c	/^         OPT_FFLAG, OPT_FINT, OPT_FDBL, OPT_FSTR};$/;"	e	enum:option_type	file:
OPT_INT	.\tool\lemon.c	/^enum option_type { OPT_FLAG=1,  OPT_INT,  OPT_DBL,  OPT_STR,$/;"	e	enum:option_type	file:
OPT_STR	.\tool\lemon.c	/^enum option_type { OPT_FLAG=1,  OPT_INT,  OPT_DBL,  OPT_STR,$/;"	e	enum:option_type	file:
OR	.\ext\fts5\test\fts5_common.tcl	/^proc OR {args} {$/;"	p
OSTRACE	.\src\sqliteInt.h	396;"	d
OSTRACE	.\src\sqliteInt.h	399;"	d
OS_ACCESS	.\src\test_osinst.c	88;"	d	file:
OS_ANNOTATE	.\src\test_osinst.c	111;"	d	file:
OS_CHECKRESERVEDLOCK	.\src\test_osinst.c	89;"	d	file:
OS_CLOSE	.\src\test_osinst.c	90;"	d	file:
OS_CURRENTTIME	.\src\test_osinst.c	91;"	d	file:
OS_DELETE	.\src\test_osinst.c	92;"	d	file:
OS_DEVCHAR	.\src\test_osinst.c	93;"	d	file:
OS_FILECONTROL	.\src\test_osinst.c	94;"	d	file:
OS_FILESIZE	.\src\test_osinst.c	95;"	d	file:
OS_FULLPATHNAME	.\src\test_osinst.c	96;"	d	file:
OS_LOCK	.\src\test_osinst.c	97;"	d	file:
OS_NUMEVENTS	.\src\test_osinst.c	113;"	d	file:
OS_OPEN	.\src\test_osinst.c	98;"	d	file:
OS_RANDOMNESS	.\src\test_osinst.c	99;"	d	file:
OS_READ	.\src\test_osinst.c	100;"	d	file:
OS_SECTORSIZE	.\src\test_osinst.c	101;"	d	file:
OS_SHMBARRIER	.\src\test_osinst.c	110;"	d	file:
OS_SHMLOCK	.\src\test_osinst.c	109;"	d	file:
OS_SHMMAP	.\src\test_osinst.c	108;"	d	file:
OS_SHMUNMAP	.\src\test_osinst.c	107;"	d	file:
OS_SLEEP	.\src\test_osinst.c	102;"	d	file:
OS_SYNC	.\src\test_osinst.c	103;"	d	file:
OS_TRUNCATE	.\src\test_osinst.c	104;"	d	file:
OS_UNLOCK	.\src\test_osinst.c	105;"	d	file:
OS_VXWORKS	.\src\vxworks.h	20;"	d
OS_VXWORKS	.\src\vxworks.h	28;"	d
OS_WRITE	.\src\test_osinst.c	106;"	d	file:
O_BINARY	.\src\os_unix.c	283;"	d	file:
O_LARGEFILE	.\src\os_unix.c	273;"	d	file:
O_LARGEFILE	.\src\os_unix.c	276;"	d	file:
O_LARGEFILE	.\src\os_unix.c	277;"	d	file:
O_NOFOLLOW	.\src\os_unix.c	280;"	d	file:
Op	.\src\vdbeInt.h	/^typedef struct VdbeOp Op;$/;"	t	typeref:struct:VdbeOp
OpenCounter	.\src\os_common.h	100;"	d
OpenCounter	.\src\os_common.h	102;"	d
OptArg	.\tool\lemon.c	/^char *OptArg(int n)$/;"	f
OptErr	.\tool\lemon.c	/^void OptErr(int n)$/;"	f
OptInit	.\tool\lemon.c	/^int OptInit(char **a, struct s_options *o, FILE *err)$/;"	f
OptLeavesReader	.\ext\fts2\fts2.c	/^typedef struct OptLeavesReader {$/;"	s	file:
OptLeavesReader	.\ext\fts2\fts2.c	/^} OptLeavesReader;$/;"	t	typeref:struct:OptLeavesReader	file:
OptNArgs	.\tool\lemon.c	/^int OptNArgs(){$/;"	f
OptPrint	.\tool\lemon.c	/^void OptPrint(){$/;"	f
OptimizationDisabled	.\src\sqliteInt.h	1319;"	d
OptimizationDisabled	.\src\sqliteInt.h	1322;"	d
OptimizationEnabled	.\src\sqliteInt.h	1320;"	d
OptimizationEnabled	.\src\sqliteInt.h	1323;"	d
OrderedDLReader	.\ext\fts2\fts2.c	/^typedef struct OrderedDLReader {$/;"	s	file:
OrderedDLReader	.\ext\fts2\fts2.c	/^} OrderedDLReader;$/;"	t	typeref:struct:OrderedDLReader	file:
Out	.\autoconf\tea\win\nmakehlp.c	/^pipeinfo Out = {INVALID_HANDLE_VALUE, '\\0'};$/;"	v
P4_ADVANCE	.\src\vdbe.h	122;"	d
P4_COLLSEQ	.\src\vdbe.h	110;"	d
P4_DYNAMIC	.\src\vdbe.h	108;"	d
P4_FUNCCTX	.\src\vdbe.h	123;"	d
P4_FUNCDEF	.\src\vdbe.h	111;"	d
P4_INT32	.\src\vdbe.h	119;"	d
P4_INT64	.\src\vdbe.h	118;"	d
P4_INTARRAY	.\src\vdbe.h	120;"	d
P4_KEYINFO	.\src\vdbe.h	112;"	d
P4_MEM	.\src\vdbe.h	113;"	d
P4_MPRINTF	.\src\vdbe.h	116;"	d
P4_NOTUSED	.\src\vdbe.h	107;"	d
P4_REAL	.\src\vdbe.h	117;"	d
P4_STATIC	.\src\vdbe.h	109;"	d
P4_SUBPROGRAM	.\src\vdbe.h	121;"	d
P4_TRANSIENT	.\src\vdbe.h	114;"	d
P4_VTAB	.\src\vdbe.h	115;"	d
P5_ConstraintCheck	.\src\vdbe.h	128;"	d
P5_ConstraintFK	.\src\vdbe.h	129;"	d
P5_ConstraintNotNull	.\src\vdbe.h	126;"	d
P5_ConstraintUnique	.\src\vdbe.h	127;"	d
PACKAGE_VERSION	.\src\tclsqlite.c	3113;"	d	file:
PAGERID	.\src\pager.c	131;"	d	file:
PAGERTRACE	.\src\pager.c	120;"	d	file:
PAGER_CACHESPILL	.\src\pager.h	96;"	d
PAGER_CKPT_FULLFSYNC	.\src\pager.h	95;"	d
PAGER_ERROR	.\src\pager.c	357;"	d	file:
PAGER_FLAGS_MASK	.\src\pager.h	97;"	d
PAGER_FULLFSYNC	.\src\pager.h	94;"	d
PAGER_GET_NOCONTENT	.\src\pager.h	84;"	d
PAGER_GET_READONLY	.\src\pager.h	85;"	d
PAGER_INCR	.\src\pager.c	726;"	d	file:
PAGER_INCR	.\src\pager.c	728;"	d	file:
PAGER_JOURNALMODE_DELETE	.\src\pager.h	74;"	d
PAGER_JOURNALMODE_MEMORY	.\src\pager.h	78;"	d
PAGER_JOURNALMODE_OFF	.\src\pager.h	76;"	d
PAGER_JOURNALMODE_PERSIST	.\src\pager.h	75;"	d
PAGER_JOURNALMODE_QUERY	.\src\pager.h	73;"	d
PAGER_JOURNALMODE_TRUNCATE	.\src\pager.h	77;"	d
PAGER_JOURNALMODE_WAL	.\src\pager.h	79;"	d
PAGER_LOCKINGMODE_EXCLUSIVE	.\src\pager.h	68;"	d
PAGER_LOCKINGMODE_NORMAL	.\src\pager.h	67;"	d
PAGER_LOCKINGMODE_QUERY	.\src\pager.h	66;"	d
PAGER_MAX_PGNO	.\src\pager.c	797;"	d	file:
PAGER_MEMORY	.\src\pager.h	61;"	d
PAGER_MJ_PGNO	.\src\pager.h	53;"	d
PAGER_OMIT_JOURNAL	.\src\pager.h	60;"	d
PAGER_OPEN	.\src\pager.c	351;"	d	file:
PAGER_READER	.\src\pager.c	352;"	d	file:
PAGER_STAT_HIT	.\src\pager.c	713;"	d	file:
PAGER_STAT_MISS	.\src\pager.c	714;"	d	file:
PAGER_STAT_WRITE	.\src\pager.c	715;"	d	file:
PAGER_SYNCHRONOUS_FULL	.\src\pager.h	92;"	d
PAGER_SYNCHRONOUS_MASK	.\src\pager.h	93;"	d
PAGER_SYNCHRONOUS_NORMAL	.\src\pager.h	91;"	d
PAGER_SYNCHRONOUS_OFF	.\src\pager.h	90;"	d
PAGER_WRITER_CACHEMOD	.\src\pager.c	354;"	d	file:
PAGER_WRITER_DBMOD	.\src\pager.c	355;"	d	file:
PAGER_WRITER_FINISHED	.\src\pager.c	356;"	d	file:
PAGER_WRITER_LOCKED	.\src\pager.c	353;"	d	file:
PARENTVFS	.\src\test_vfs.c	152;"	d	file:
PARTLY_WITHIN	.\ext\rtree\sqlite3rtree.h	109;"	d
PCACHE1_MIGHT_USE_GROUP_MUTEX	.\src\pcache1.c	224;"	d	file:
PCACHE1_MIGHT_USE_GROUP_MUTEX	.\src\pcache1.c	228;"	d	file:
PCACHE_DIRTYLIST_ADD	.\src\pcache.c	37;"	d	file:
PCACHE_DIRTYLIST_FRONT	.\src\pcache.c	38;"	d	file:
PCACHE_DIRTYLIST_REMOVE	.\src\pcache.c	36;"	d	file:
PCache	.\src\pcache.c	/^struct PCache {$/;"	s	file:
PCache	.\src\pcache.h	/^typedef struct PCache PCache;$/;"	t	typeref:struct:PCache
PCache1	.\src\pcache1.c	/^struct PCache1 {$/;"	s	file:
PCache1	.\src\pcache1.c	/^typedef struct PCache1 PCache1;$/;"	t	typeref:struct:PCache1	file:
PCacheGlobal	.\src\pcache1.c	/^static SQLITE_WSD struct PCacheGlobal {$/;"	s	file:
PENDING_BYTE	.\src\os.h	147;"	d
PENDING_BYTE	.\src\os.h	149;"	d
PENDING_BYTE	.\tool\getlock.c	53;"	d	file:
PENDING_BYTE_PAGE	.\src\btreeInt.h	583;"	d
PENDING_LOCK	.\src\os.h	88;"	d
PGHDR_CLEAN	.\src\pcache.h	49;"	d
PGHDR_DIRTY	.\src\pcache.h	50;"	d
PGHDR_DONT_WRITE	.\src\pcache.h	55;"	d
PGHDR_MMAP	.\src\pcache.h	56;"	d
PGHDR_NEED_READ	.\src\pcache.h	54;"	d
PGHDR_NEED_SYNC	.\src\pcache.h	52;"	d
PGHDR_WRITEABLE	.\src\pcache.h	51;"	d
PGroup	.\src\pcache1.c	/^struct PGroup {$/;"	s	file:
PGroup	.\src\pcache1.c	/^typedef struct PGroup PGroup;$/;"	t	typeref:struct:PGroup	file:
PLReader	.\ext\fts2\fts2.c	/^typedef struct PLReader {$/;"	s	file:
PLReader	.\ext\fts2\fts2.c	/^} PLReader;$/;"	t	typeref:struct:PLReader	file:
PLS_HASHSIZE	.\src\test_wsd.c	22;"	d	file:
PLWriter	.\ext\fts2\fts2.c	/^typedef struct PLWriter {$/;"	s	file:
PLWriter	.\ext\fts2\fts2.c	/^} PLWriter;$/;"	t	typeref:struct:PLWriter	file:
POSITION_LIST_END	.\ext\fts3\fts3.c	2040;"	d	file:
POS_BASE	.\ext\fts1\fts1.c	/^  POS_BASE$/;"	e	enum:__anon2	file:
POS_BASE	.\ext\fts2\fts2.c	/^  POS_BASE$/;"	e	enum:__anon3	file:
POS_COLUMN	.\ext\fts1\fts1.c	/^  POS_COLUMN,         \/* followed by new column number *\/$/;"	e	enum:__anon2	file:
POS_COLUMN	.\ext\fts2\fts2.c	/^  POS_COLUMN,         \/* followed by new column number *\/$/;"	e	enum:__anon3	file:
POS_COLUMN	.\ext\fts3\fts3Int.h	121;"	d
POS_END	.\ext\fts1\fts1.c	/^  POS_END = 0,        \/* end of this position list *\/$/;"	e	enum:__anon2	file:
POS_END	.\ext\fts2\fts2.c	/^  POS_END = 0,        \/* end of this position list *\/$/;"	e	enum:__anon3	file:
POS_END	.\ext\fts3\fts3Int.h	122;"	d
PRAGMA	.\tool\mkkeywordhash.c	101;"	d	file:
PRAGMA	.\tool\mkkeywordhash.c	103;"	d	file:
PRECEDENCE_MARK_1	.\tool\lemon.c	/^  PRECEDENCE_MARK_1,$/;"	e	enum:e_state	file:
PRECEDENCE_MARK_2	.\tool\lemon.c	/^  PRECEDENCE_MARK_2,$/;"	e	enum:e_state	file:
PRIVATE	.\tool\lemon.c	35;"	d	file:
PROXY_CONCHVERSION	.\src\os_unix.c	6653;"	d	file:
PROXY_HEADERLEN	.\src\os_unix.c	6654;"	d	file:
PROXY_HOSTIDLEN	.\src\os_unix.c	6614;"	d	file:
PROXY_MAXCONCHLEN	.\src\os_unix.c	6656;"	d	file:
PROXY_PATHINDEX	.\src\os_unix.c	6655;"	d	file:
PTF_INTKEY	.\src\btreeInt.h	256;"	d
PTF_LEAF	.\src\btreeInt.h	259;"	d
PTF_LEAFDATA	.\src\btreeInt.h	258;"	d
PTF_ZERODATA	.\src\btreeInt.h	257;"	d
PTR2INT	.\test\threadtest3.c	70;"	d	file:
PTRMAP_BTREE	.\src\btreeInt.h	639;"	d
PTRMAP_FREEPAGE	.\src\btreeInt.h	636;"	d
PTRMAP_ISPAGE	.\src\btreeInt.h	602;"	d
PTRMAP_OVERFLOW1	.\src\btreeInt.h	637;"	d
PTRMAP_OVERFLOW2	.\src\btreeInt.h	638;"	d
PTRMAP_PAGENO	.\src\btreeInt.h	600;"	d
PTRMAP_PTROFFSET	.\src\btreeInt.h	601;"	d
PTRMAP_ROOTPAGE	.\src\btreeInt.h	635;"	d
PUTS	.\test\releasetest.tcl	/^proc PUTS {args} {$/;"	p
Pager	.\src\pager.c	/^struct Pager {$/;"	s	file:
Pager	.\src\pager.h	/^typedef struct Pager Pager;$/;"	t	typeref:struct:Pager
PagerSavepoint	.\src\pager.c	/^struct PagerSavepoint {$/;"	s	file:
PagerSavepoint	.\src\pager.c	/^typedef struct PagerSavepoint PagerSavepoint;$/;"	t	typeref:struct:PagerSavepoint	file:
Parse	.\src\lempar.c	/^void Parse($/;"	f
Parse	.\src\sqliteInt.h	/^struct Parse {$/;"	s
Parse	.\src\sqliteInt.h	/^typedef struct Parse Parse;$/;"	t	typeref:struct:Parse
Parse	.\tool\lemon.c	/^void Parse(struct lemon *gp)$/;"	f
Parse	.\tool\lempar.c	/^void Parse($/;"	f
ParseAlloc	.\src\lempar.c	/^void *ParseAlloc(void *(*mallocProc)(u64)){$/;"	f
ParseAlloc	.\tool\lempar.c	/^void *ParseAlloc(void *(*mallocProc)(size_t)){$/;"	f
ParseContext	.\ext\fts3\fts3_expr.c	/^struct ParseContext {$/;"	s	file:
ParseContext	.\ext\fts3\fts3_expr.c	/^typedef struct ParseContext ParseContext;$/;"	t	typeref:struct:ParseContext	file:
ParseFree	.\src\lempar.c	/^void ParseFree($/;"	f
ParseFree	.\tool\lempar.c	/^void ParseFree($/;"	f
ParseStackPeak	.\src\lempar.c	/^int ParseStackPeak(void *p){$/;"	f
ParseStackPeak	.\tool\lempar.c	/^int ParseStackPeak(void *p){$/;"	f
ParseTrace	.\src\lempar.c	/^void ParseTrace(FILE *TraceFILE, char *zTracePrompt){$/;"	f
ParseTrace	.\tool\lempar.c	/^void ParseTrace(FILE *TraceFILE, char *zTracePrompt){$/;"	f
PendingList	.\ext\fts3\fts3_write.c	/^struct PendingList {$/;"	s	file:
PendingList	.\ext\fts3\fts3_write.c	/^typedef struct PendingList PendingList;$/;"	t	typeref:struct:PendingList	file:
Percentile	.\ext\misc\percentile.c	/^struct Percentile {$/;"	s	file:
Percentile	.\ext\misc\percentile.c	/^typedef struct Percentile Percentile;$/;"	t	typeref:struct:Percentile	file:
PgFreeslot	.\src\pcache1.c	/^struct PgFreeslot {$/;"	s	file:
PgFreeslot	.\src\pcache1.c	/^typedef struct PgFreeslot PgFreeslot;$/;"	t	typeref:struct:PgFreeslot	file:
PgHdr	.\src\pcache.h	/^struct PgHdr {$/;"	s
PgHdr	.\src\pcache.h	/^typedef struct PgHdr PgHdr;$/;"	t	typeref:struct:PgHdr
PgHdr1	.\src\pcache1.c	/^struct PgHdr1 {$/;"	s	file:
PgHdr1	.\src\pcache1.c	/^typedef struct PgHdr1 PgHdr1;$/;"	t	typeref:struct:PgHdr1	file:
Pgno	.\src\pager.h	/^typedef u32 Pgno;$/;"	t
Plink_add	.\tool\lemon.c	/^void Plink_add(struct plink **plpp, struct config *cfp)$/;"	f
Plink_copy	.\tool\lemon.c	/^void Plink_copy(struct plink **to, struct plink *from)$/;"	f
Plink_delete	.\tool\lemon.c	/^void Plink_delete(struct plink *plp)$/;"	f
Plink_new	.\tool\lemon.c	/^struct plink *Plink_new(){$/;"	f
PmaReader	.\src\vdbesort.c	/^struct PmaReader {$/;"	s	file:
PmaReader	.\src\vdbesort.c	/^typedef struct PmaReader PmaReader;         \/* Incrementally read one PMA *\/$/;"	t	typeref:struct:PmaReader	file:
PmaWriter	.\src\vdbesort.c	/^struct PmaWriter {$/;"	s	file:
PmaWriter	.\src\vdbesort.c	/^typedef struct PmaWriter PmaWriter;         \/* Incrementally write one PMA *\/$/;"	t	typeref:struct:PmaWriter	file:
PorterContext	.\ext\fts5\fts5_tokenize.c	/^struct PorterContext {$/;"	s	file:
PorterContext	.\ext\fts5\fts5_tokenize.c	/^typedef struct PorterContext PorterContext;$/;"	t	typeref:struct:PorterContext	file:
PorterRule	.\ext\fts5\fts5_tokenize.c	/^struct PorterRule {$/;"	s	file:
PorterRule	.\ext\fts5\fts5_tokenize.c	/^typedef struct PorterRule PorterRule;$/;"	t	typeref:struct:PorterRule	file:
PorterTokenizer	.\ext\fts5\fts5_tokenize.c	/^struct PorterTokenizer {$/;"	s	file:
PorterTokenizer	.\ext\fts5\fts5_tokenize.c	/^typedef struct PorterTokenizer PorterTokenizer;$/;"	t	typeref:struct:PorterTokenizer	file:
PoslistCallbackCtx	.\ext\fts5\fts5_index.c	/^struct PoslistCallbackCtx {$/;"	s	file:
PoslistCallbackCtx	.\ext\fts5\fts5_index.c	/^typedef struct PoslistCallbackCtx PoslistCallbackCtx;$/;"	t	typeref:struct:PoslistCallbackCtx	file:
PragFlag_NeedSchema	.\src\pragma.h	48;"	d
PragFlag_ReadOnly	.\src\pragma.h	49;"	d
PragTyp_ACTIVATE_EXTENSIONS	.\src\pragma.h	42;"	d
PragTyp_AUTO_VACUUM	.\src\pragma.h	7;"	d
PragTyp_BUSY_TIMEOUT	.\src\pragma.h	9;"	d
PragTyp_CACHE_SIZE	.\src\pragma.h	10;"	d
PragTyp_CASE_SENSITIVE_LIKE	.\src\pragma.h	11;"	d
PragTyp_COLLATION_LIST	.\src\pragma.h	12;"	d
PragTyp_COMPILE_OPTIONS	.\src\pragma.h	13;"	d
PragTyp_DATABASE_LIST	.\src\pragma.h	15;"	d
PragTyp_DATA_STORE_DIRECTORY	.\src\pragma.h	14;"	d
PragTyp_DEFAULT_CACHE_SIZE	.\src\pragma.h	16;"	d
PragTyp_ENCODING	.\src\pragma.h	17;"	d
PragTyp_FLAG	.\src\pragma.h	8;"	d
PragTyp_FOREIGN_KEY_CHECK	.\src\pragma.h	18;"	d
PragTyp_FOREIGN_KEY_LIST	.\src\pragma.h	19;"	d
PragTyp_HEADER_VALUE	.\src\pragma.h	6;"	d
PragTyp_HEXKEY	.\src\pragma.h	43;"	d
PragTyp_INCREMENTAL_VACUUM	.\src\pragma.h	20;"	d
PragTyp_INDEX_INFO	.\src\pragma.h	21;"	d
PragTyp_INDEX_LIST	.\src\pragma.h	22;"	d
PragTyp_INTEGRITY_CHECK	.\src\pragma.h	23;"	d
PragTyp_JOURNAL_MODE	.\src\pragma.h	24;"	d
PragTyp_JOURNAL_SIZE_LIMIT	.\src\pragma.h	25;"	d
PragTyp_KEY	.\src\pragma.h	44;"	d
PragTyp_LOCKING_MODE	.\src\pragma.h	27;"	d
PragTyp_LOCK_PROXY_FILE	.\src\pragma.h	26;"	d
PragTyp_LOCK_STATUS	.\src\pragma.h	46;"	d
PragTyp_MMAP_SIZE	.\src\pragma.h	29;"	d
PragTyp_PAGE_COUNT	.\src\pragma.h	28;"	d
PragTyp_PAGE_SIZE	.\src\pragma.h	30;"	d
PragTyp_PARSER_TRACE	.\src\pragma.h	47;"	d
PragTyp_REKEY	.\src\pragma.h	45;"	d
PragTyp_SECURE_DELETE	.\src\pragma.h	31;"	d
PragTyp_SHRINK_MEMORY	.\src\pragma.h	32;"	d
PragTyp_SOFT_HEAP_LIMIT	.\src\pragma.h	33;"	d
PragTyp_STATS	.\src\pragma.h	34;"	d
PragTyp_SYNCHRONOUS	.\src\pragma.h	35;"	d
PragTyp_TABLE_INFO	.\src\pragma.h	36;"	d
PragTyp_TEMP_STORE	.\src\pragma.h	37;"	d
PragTyp_TEMP_STORE_DIRECTORY	.\src\pragma.h	38;"	d
PragTyp_THREADS	.\src\pragma.h	39;"	d
PragTyp_WAL_AUTOCHECKPOINT	.\src\pragma.h	40;"	d
PragTyp_WAL_CHECKPOINT	.\src\pragma.h	41;"	d
PrintAction	.\tool\lemon.c	/^int PrintAction($/;"	f
PrintfArguments	.\src\sqliteInt.h	/^struct PrintfArguments {$/;"	s
PrintfArguments	.\src\sqliteInt.h	/^typedef struct PrintfArguments PrintfArguments;$/;"	t	typeref:struct:PrintfArguments
ProcessLocalStorage	.\src\test_wsd.c	/^struct ProcessLocalStorage {$/;"	s	file:
ProcessLocalStorage	.\src\test_wsd.c	/^typedef struct ProcessLocalStorage ProcessLocalStorage;$/;"	t	typeref:struct:ProcessLocalStorage	file:
ProcessLocalVar	.\src\test_wsd.c	/^struct ProcessLocalVar {$/;"	s	file:
ProcessLocalVar	.\src\test_wsd.c	/^typedef struct ProcessLocalVar ProcessLocalVar;$/;"	t	typeref:struct:ProcessLocalVar	file:
QUERY_FULLTEXT	.\ext\fts1\fts1.c	/^  QUERY_FULLTEXT   \/* QUERY_FULLTEXT + [i] is a full-text search for column i*\/$/;"	e	enum:QueryType	file:
QUERY_FULLTEXT	.\ext\fts1\fulltext.c	523;"	d	file:
QUERY_FULLTEXT	.\ext\fts2\fts2.c	/^  QUERY_FULLTEXT   \/* QUERY_FULLTEXT + [i] is a full-text search for column i*\/$/;"	e	enum:QueryType	file:
QUERY_GENERIC	.\ext\fts1\fts1.c	/^  QUERY_GENERIC,   \/* table scan *\/$/;"	e	enum:QueryType	file:
QUERY_GENERIC	.\ext\fts1\fulltext.c	522;"	d	file:
QUERY_GENERIC	.\ext\fts2\fts2.c	/^  QUERY_GENERIC,   \/* table scan *\/$/;"	e	enum:QueryType	file:
QUERY_ROWID	.\ext\fts1\fts1.c	/^  QUERY_ROWID,     \/* lookup by rowid *\/$/;"	e	enum:QueryType	file:
QUERY_ROWID	.\ext\fts2\fts2.c	/^  QUERY_ROWID,     \/* lookup by rowid *\/$/;"	e	enum:QueryType	file:
QualifyPath	.\autoconf\tea\win\nmakehlp.c	/^QualifyPath($/;"	f	file:
Query	.\ext\fts1\fts1.c	/^typedef struct Query {$/;"	s	file:
Query	.\ext\fts1\fts1.c	/^} Query;$/;"	t	typeref:struct:Query	file:
Query	.\ext\fts1\fulltext.c	/^typedef struct Query {$/;"	s	file:
Query	.\ext\fts1\fulltext.c	/^} Query;$/;"	t	typeref:struct:Query	file:
Query	.\ext\fts2\fts2.c	/^typedef struct Query {$/;"	s	file:
Query	.\ext\fts2\fts2.c	/^} Query;$/;"	t	typeref:struct:Query	file:
QueryResult	.\test\threadtest1.c	/^struct QueryResult {$/;"	s	file:
QueryTerm	.\ext\fts1\fts1.c	/^typedef struct QueryTerm {$/;"	s	file:
QueryTerm	.\ext\fts1\fts1.c	/^} QueryTerm;$/;"	t	typeref:struct:QueryTerm	file:
QueryTerm	.\ext\fts1\fulltext.c	/^typedef struct QueryTerm {$/;"	s	file:
QueryTerm	.\ext\fts1\fulltext.c	/^} QueryTerm;$/;"	t	typeref:struct:QueryTerm	file:
QueryTerm	.\ext\fts2\fts2.c	/^typedef struct QueryTerm {$/;"	s	file:
QueryTerm	.\ext\fts2\fts2.c	/^} QueryTerm;$/;"	t	typeref:struct:QueryTerm	file:
QueryType	.\ext\fts1\fts1.c	/^typedef enum QueryType {$/;"	g	file:
QueryType	.\ext\fts1\fts1.c	/^} QueryType;$/;"	t	typeref:enum:QueryType	file:
QueryType	.\ext\fts2\fts2.c	/^typedef enum QueryType {$/;"	g	file:
QueryType	.\ext\fts2\fts2.c	/^} QueryType;$/;"	t	typeref:enum:QueryType	file:
RBU_CREATE_STATE	.\ext\rbu\sqlite3rbu.c	166;"	d	file:
RBU_DELETE	.\ext\rbu\sqlite3rbu.c	282;"	d	file:
RBU_IDX_DELETE	.\ext\rbu\sqlite3rbu.c	283;"	d	file:
RBU_IDX_INSERT	.\ext\rbu\sqlite3rbu.c	284;"	d	file:
RBU_INSERT	.\ext\rbu\sqlite3rbu.c	281;"	d	file:
RBU_PK_EXTERNAL	.\ext\rbu\sqlite3rbu.c	272;"	d	file:
RBU_PK_IPK	.\ext\rbu\sqlite3rbu.c	271;"	d	file:
RBU_PK_NONE	.\ext\rbu\sqlite3rbu.c	270;"	d	file:
RBU_PK_NOTABLE	.\ext\rbu\sqlite3rbu.c	269;"	d	file:
RBU_PK_VTAB	.\ext\rbu\sqlite3rbu.c	274;"	d	file:
RBU_PK_WITHOUT_ROWID	.\ext\rbu\sqlite3rbu.c	273;"	d	file:
RBU_STAGE_CAPTURE	.\ext\rbu\sqlite3rbu.c	161;"	d	file:
RBU_STAGE_CKPT	.\ext\rbu\sqlite3rbu.c	162;"	d	file:
RBU_STAGE_DONE	.\ext\rbu\sqlite3rbu.c	163;"	d	file:
RBU_STAGE_MOVE	.\ext\rbu\sqlite3rbu.c	160;"	d	file:
RBU_STAGE_OAL	.\ext\rbu\sqlite3rbu.c	159;"	d	file:
RBU_STATE_CKPT	.\ext\rbu\sqlite3rbu.c	155;"	d	file:
RBU_STATE_COOKIE	.\ext\rbu\sqlite3rbu.c	156;"	d	file:
RBU_STATE_IDX	.\ext\rbu\sqlite3rbu.c	152;"	d	file:
RBU_STATE_OALSZ	.\ext\rbu\sqlite3rbu.c	157;"	d	file:
RBU_STATE_PROGRESS	.\ext\rbu\sqlite3rbu.c	154;"	d	file:
RBU_STATE_ROW	.\ext\rbu\sqlite3rbu.c	153;"	d	file:
RBU_STATE_STAGE	.\ext\rbu\sqlite3rbu.c	150;"	d	file:
RBU_STATE_TBL	.\ext\rbu\sqlite3rbu.c	151;"	d	file:
RBU_UPDATE	.\ext\rbu\sqlite3rbu.c	285;"	d	file:
RD_RESOLVED	.\tool\lemon.c	/^  RD_RESOLVED,             \/* Was reduce.  Precedence resolved conflict *\/$/;"	e	enum:e_action	file:
READMARK_NOT_USED	.\src\wal.c	368;"	d	file:
READ_LOCK	.\src\btreeInt.h	327;"	d
READ_UTF16BE	.\src\utf.c	118;"	d	file:
READ_UTF16LE	.\src\utf.c	108;"	d	file:
READ_UTF8	.\ext\fts3\fts3_unicode.c	46;"	d	file:
READ_UTF8	.\ext\fts5\fts5_tokenize.c	194;"	d	file:
READ_UTF8	.\src\utf.c	155;"	d	file:
REALVFS	.\ext\misc\vfslog.c	93;"	d	file:
REALVFS	.\src\test_osinst.c	137;"	d	file:
REARGUARD	.\src\mem2.c	69;"	d	file:
REDUCE	.\tool\lemon.c	/^  REDUCE,$/;"	e	enum:e_action	file:
REGISTER_TRACE	.\src\vdbe.c	482;"	d	file:
REGISTER_TRACE	.\src\vdbe.c	484;"	d	file:
REINDEX	.\tool\mkkeywordhash.c	106;"	d	file:
REINDEX	.\tool\mkkeywordhash.c	108;"	d	file:
RESERVED_BYTE	.\src\os.h	151;"	d
RESERVED_BYTE	.\tool\getlock.c	54;"	d	file:
RESERVED_LOCK	.\src\os.h	87;"	d
RESYNC_AFTER_DECL_ERROR	.\tool\lemon.c	/^  RESYNC_AFTER_DECL_ERROR,$/;"	e	enum:e_state	file:
RESYNC_AFTER_RULE_ERROR	.\tool\lemon.c	/^  RESYNC_AFTER_RULE_ERROR,$/;"	e	enum:e_state	file:
RE_EOF	.\ext\misc\regexp.c	74;"	d	file:
RE_OP_ACCEPT	.\ext\misc\regexp.c	84;"	d	file:
RE_OP_ANY	.\ext\misc\regexp.c	80;"	d	file:
RE_OP_ANYSTAR	.\ext\misc\regexp.c	81;"	d	file:
RE_OP_BOUNDARY	.\ext\misc\regexp.c	95;"	d	file:
RE_OP_CC_EXC	.\ext\misc\regexp.c	86;"	d	file:
RE_OP_CC_INC	.\ext\misc\regexp.c	85;"	d	file:
RE_OP_CC_RANGE	.\ext\misc\regexp.c	88;"	d	file:
RE_OP_CC_VALUE	.\ext\misc\regexp.c	87;"	d	file:
RE_OP_DIGIT	.\ext\misc\regexp.c	91;"	d	file:
RE_OP_FORK	.\ext\misc\regexp.c	82;"	d	file:
RE_OP_GOTO	.\ext\misc\regexp.c	83;"	d	file:
RE_OP_MATCH	.\ext\misc\regexp.c	79;"	d	file:
RE_OP_NOTDIGIT	.\ext\misc\regexp.c	92;"	d	file:
RE_OP_NOTSPACE	.\ext\misc\regexp.c	94;"	d	file:
RE_OP_NOTWORD	.\ext\misc\regexp.c	90;"	d	file:
RE_OP_SPACE	.\ext\misc\regexp.c	93;"	d	file:
RE_OP_WORD	.\ext\misc\regexp.c	89;"	d	file:
RHS_ALIAS_1	.\tool\lemon.c	/^  RHS_ALIAS_1,$/;"	e	enum:e_state	file:
RHS_ALIAS_2	.\tool\lemon.c	/^  RHS_ALIAS_2,$/;"	e	enum:e_state	file:
RIGHT	.\tool\lemon.c	/^    RIGHT,$/;"	e	enum:e_assoc	file:
RNDAWAY	.\ext\rtree\rtree.c	2778;"	d	file:
RNDTOWARDS	.\ext\rtree\rtree.c	2777;"	d	file:
ROOT_MAX	.\ext\fts2\fts2.c	4063;"	d	file:
ROUND8	.\src\sqliteInt.h	721;"	d
ROUNDDOWN8	.\src\sqliteInt.h	726;"	d
ROWSET_ALLOCATION_SIZE	.\src\rowset.c	69;"	d	file:
ROWSET_ENTRY_PER_CHUNK	.\src\rowset.c	74;"	d	file:
ROWSET_NEXT	.\src\rowset.c	123;"	d	file:
ROWSET_SORTED	.\src\rowset.c	122;"	d	file:
RRCONFLICT	.\tool\lemon.c	/^  RRCONFLICT,              \/* Was a reduce, but part of a conflict *\/$/;"	e	enum:e_action	file:
RTREE_CACHE_SZ	.\ext\rtree\rtree.c	217;"	d	file:
RTREE_COORD_INT32	.\ext\rtree\rtree.c	155;"	d	file:
RTREE_COORD_REAL32	.\ext\rtree\rtree.c	154;"	d	file:
RTREE_DECODE_COORD	.\ext\rtree\rtree.c	923;"	d	file:
RTREE_DECODE_COORD	.\ext\rtree\rtree.c	931;"	d	file:
RTREE_DECODE_COORD	.\ext\rtree\rtree.c	937;"	d	file:
RTREE_DEFAULT_ROWEST	.\ext\rtree\rtree.c	108;"	d	file:
RTREE_EQ	.\ext\rtree\rtree.c	282;"	d	file:
RTREE_GE	.\ext\rtree\rtree.c	285;"	d	file:
RTREE_GEOMETRY_MAGIC	.\ext\rtree\rtree.c	342;"	d	file:
RTREE_GT	.\ext\rtree\rtree.c	286;"	d	file:
RTREE_LE	.\ext\rtree\rtree.c	283;"	d	file:
RTREE_LT	.\ext\rtree\rtree.c	284;"	d	file:
RTREE_MATCH	.\ext\rtree\rtree.c	287;"	d	file:
RTREE_MAXCELLS	.\ext\rtree\rtree.c	200;"	d	file:
RTREE_MAX_DEPTH	.\ext\rtree\rtree.c	209;"	d	file:
RTREE_MAX_DIMENSIONS	.\ext\rtree\rtree.c	93;"	d	file:
RTREE_MINCELLS	.\ext\rtree\rtree.c	198;"	d	file:
RTREE_MIN_ROWEST	.\ext\rtree\rtree.c	109;"	d	file:
RTREE_OF_CURSOR	.\ext\rtree\rtree.c	239;"	d	file:
RTREE_QUERY	.\ext\rtree\rtree.c	288;"	d	file:
RTREE_QUEUE_TRACE	.\ext\rtree\rtree.c	1263;"	d	file:
RTREE_REINSERT	.\ext\rtree\rtree.c	199;"	d	file:
RTREE_ZERO	.\ext\rtree\rtree.c	165;"	d	file:
RTREE_ZERO	.\ext\rtree\rtree.c	169;"	d	file:
R_OK	.\src\test_demovfs.c	486;"	d	file:
RbuFrame	.\ext\rbu\sqlite3rbu.c	/^struct RbuFrame {$/;"	s	file:
RbuFrame	.\ext\rbu\sqlite3rbu.c	/^typedef struct RbuFrame RbuFrame;$/;"	t	typeref:struct:RbuFrame	file:
RbuObjIter	.\ext\rbu\sqlite3rbu.c	/^struct RbuObjIter {$/;"	s	file:
RbuObjIter	.\ext\rbu\sqlite3rbu.c	/^typedef struct RbuObjIter RbuObjIter;$/;"	t	typeref:struct:RbuObjIter	file:
RbuState	.\ext\rbu\sqlite3rbu.c	/^struct RbuState {$/;"	s	file:
RbuState	.\ext\rbu\sqlite3rbu.c	/^typedef struct RbuState RbuState;$/;"	t	typeref:struct:RbuState	file:
RbuUpdateStmt	.\ext\rbu\sqlite3rbu.c	/^struct RbuUpdateStmt {$/;"	s	file:
RbuUpdateStmt	.\ext\rbu\sqlite3rbu.c	/^typedef struct RbuUpdateStmt RbuUpdateStmt;$/;"	t	typeref:struct:RbuUpdateStmt	file:
ReCompiled	.\ext\misc\regexp.c	/^struct ReCompiled {$/;"	s	file:
ReCompiled	.\ext\misc\regexp.c	/^typedef struct ReCompiled ReCompiled;$/;"	t	typeref:struct:ReCompiled	file:
ReInput	.\ext\misc\regexp.c	/^struct ReInput {$/;"	s	file:
ReInput	.\ext\misc\regexp.c	/^typedef struct ReInput ReInput;$/;"	t	typeref:struct:ReInput	file:
ReStateNumber	.\ext\misc\regexp.c	/^typedef unsigned short ReStateNumber;$/;"	t	file:
ReStateSet	.\ext\misc\regexp.c	/^typedef struct ReStateSet {$/;"	s	file:
ReStateSet	.\ext\misc\regexp.c	/^} ReStateSet;$/;"	t	typeref:struct:ReStateSet	file:
ReadFromPipe	.\autoconf\tea\win\nmakehlp.c	/^ReadFromPipe($/;"	f	file:
RecordCompare	.\src\vdbe.h	/^typedef int (*RecordCompare)(int,const void*,UnpackedRecord*);$/;"	t
Reinsert	.\ext\rtree\rtree.c	/^static int Reinsert($/;"	f	file:
ReportHeader	.\tool\lemon.c	/^void ReportHeader(struct lemon *lemp)$/;"	f
ReportOutput	.\tool\lemon.c	/^void ReportOutput(struct lemon *lemp)$/;"	f
ReportTable	.\tool\lemon.c	/^void ReportTable($/;"	f
Reprint	.\tool\lemon.c	/^void Reprint(struct lemon *lemp)$/;"	f
ResortStates	.\tool\lemon.c	/^void ResortStates(struct lemon *lemp)$/;"	f
ResultSet	.\test\fuzz_common.tcl	/^proc ResultSet {{nRes 0} {c ""}} {$/;"	p
RowSet	.\src\rowset.c	/^struct RowSet {$/;"	s	file:
RowSet	.\src\sqliteInt.h	/^typedef struct RowSet RowSet;$/;"	t	typeref:struct:RowSet
RowSetChunk	.\src\rowset.c	/^struct RowSetChunk {$/;"	s	file:
RowSetEntry	.\src\rowset.c	/^struct RowSetEntry {            $/;"	s	file:
Rtree	.\ext\rtree\rtree.c	/^struct Rtree {$/;"	s	file:
Rtree	.\ext\rtree\rtree.c	/^typedef struct Rtree Rtree;$/;"	t	typeref:struct:Rtree	file:
RtreeCell	.\ext\rtree\rtree.c	/^struct RtreeCell {$/;"	s	file:
RtreeCell	.\ext\rtree\rtree.c	/^typedef struct RtreeCell RtreeCell;$/;"	t	typeref:struct:RtreeCell	file:
RtreeConstraint	.\ext\rtree\rtree.c	/^struct RtreeConstraint {$/;"	s	file:
RtreeConstraint	.\ext\rtree\rtree.c	/^typedef struct RtreeConstraint RtreeConstraint;$/;"	t	typeref:struct:RtreeConstraint	file:
RtreeCoord	.\ext\rtree\rtree.c	/^typedef union RtreeCoord RtreeCoord;$/;"	t	typeref:union:RtreeCoord	file:
RtreeCoord	.\ext\rtree\rtree.c	/^union RtreeCoord {$/;"	u	file:
RtreeCursor	.\ext\rtree\rtree.c	/^struct RtreeCursor {$/;"	s	file:
RtreeCursor	.\ext\rtree\rtree.c	/^typedef struct RtreeCursor RtreeCursor;$/;"	t	typeref:struct:RtreeCursor	file:
RtreeDValue	.\ext\rtree\rtree.c	/^  typedef double RtreeDValue;              \/* High accuracy coordinate *\/$/;"	t	file:
RtreeDValue	.\ext\rtree\rtree.c	/^  typedef sqlite3_int64 RtreeDValue;       \/* High accuracy coordinate *\/$/;"	t	file:
RtreeGeomCallback	.\ext\rtree\rtree.c	/^struct RtreeGeomCallback {$/;"	s	file:
RtreeGeomCallback	.\ext\rtree\rtree.c	/^typedef struct RtreeGeomCallback RtreeGeomCallback;$/;"	t	typeref:struct:RtreeGeomCallback	file:
RtreeMatchArg	.\ext\rtree\rtree.c	/^struct RtreeMatchArg {$/;"	s	file:
RtreeMatchArg	.\ext\rtree\rtree.c	/^typedef struct RtreeMatchArg RtreeMatchArg;$/;"	t	typeref:struct:RtreeMatchArg	file:
RtreeNode	.\ext\rtree\rtree.c	/^struct RtreeNode {$/;"	s	file:
RtreeNode	.\ext\rtree\rtree.c	/^typedef struct RtreeNode RtreeNode;$/;"	t	typeref:struct:RtreeNode	file:
RtreeSearchPoint	.\ext\rtree\rtree.c	/^struct RtreeSearchPoint {$/;"	s	file:
RtreeSearchPoint	.\ext\rtree\rtree.c	/^typedef struct RtreeSearchPoint RtreeSearchPoint;$/;"	t	typeref:struct:RtreeSearchPoint	file:
RtreeValue	.\ext\rtree\rtree.c	/^  typedef float RtreeValue;                \/* Low accuracy coordinate *\/$/;"	t	file:
RtreeValue	.\ext\rtree\rtree.c	/^  typedef int RtreeValue;                  \/* Low accuracy coordinate *\/$/;"	t	file:
RulePrint	.\tool\lemon.c	/^void RulePrint(FILE *fp, struct rule *rp, int iCursor){$/;"	f
SAVEPOINT_BEGIN	.\src\sqliteInt.h	1479;"	d
SAVEPOINT_RELEASE	.\src\sqliteInt.h	1480;"	d
SAVEPOINT_ROLLBACK	.\src\sqliteInt.h	1481;"	d
SAVE_SZ	.\src\build.c	268;"	d	file:
SCHEMA	.\src\test_schema.c	21;"	d	file:
SCHEMA_ENC	.\src\sqliteInt.h	1256;"	d
SCHEMA_TABLE	.\src\sqliteInt.h	845;"	d
SCRAMBLE	.\ext\fts2\fts2.c	398;"	d	file:
SCRAMBLE	.\ext\fts2\fts2.c	400;"	d	file:
SCRIPT_CYRILLIC	.\ext\misc\spellfix.c	1718;"	d	file:
SCRIPT_GREEK	.\ext\misc\spellfix.c	1719;"	d	file:
SCRIPT_LATIN	.\ext\misc\spellfix.c	1717;"	d	file:
SEGDIR_COUNT_STMT	.\ext\fts2\fts2.c	/^  SEGDIR_COUNT_STMT,$/;"	e	enum:fulltext_statement	file:
SEGDIR_DELETE_ALL_STMT	.\ext\fts2\fts2.c	/^  SEGDIR_DELETE_ALL_STMT,$/;"	e	enum:fulltext_statement	file:
SEGDIR_DELETE_STMT	.\ext\fts2\fts2.c	/^  SEGDIR_DELETE_STMT,$/;"	e	enum:fulltext_statement	file:
SEGDIR_MAX_INDEX_STMT	.\ext\fts2\fts2.c	/^  SEGDIR_MAX_INDEX_STMT,$/;"	e	enum:fulltext_statement	file:
SEGDIR_SELECT_ALL_STMT	.\ext\fts2\fts2.c	/^  SEGDIR_SELECT_ALL_STMT,$/;"	e	enum:fulltext_statement	file:
SEGDIR_SELECT_LEVEL_STMT	.\ext\fts2\fts2.c	/^  SEGDIR_SELECT_LEVEL_STMT,$/;"	e	enum:fulltext_statement	file:
SEGDIR_SELECT_SEGMENT_STMT	.\ext\fts2\fts2.c	/^  SEGDIR_SELECT_SEGMENT_STMT,$/;"	e	enum:fulltext_statement	file:
SEGDIR_SET_STMT	.\ext\fts2\fts2.c	/^  SEGDIR_SET_STMT,$/;"	e	enum:fulltext_statement	file:
SEGDIR_SPAN_STMT	.\ext\fts2\fts2.c	/^  SEGDIR_SPAN_STMT,$/;"	e	enum:fulltext_statement	file:
SEL	.\test\threadtest3.c	38;"	d	file:
SELECTTRACE	.\src\select.c	22;"	d	file:
SELECTTRACE	.\src\select.c	28;"	d	file:
SELECTTRACE_ENABLED	.\src\sqliteInt.h	808;"	d
SELECTTRACE_ENABLED	.\src\sqliteInt.h	810;"	d
SEP_Column	.\src\shell.c	595;"	d	file:
SEP_Comma	.\src\shell.c	599;"	d	file:
SEP_CrLf	.\src\shell.c	600;"	d	file:
SEP_Record	.\src\shell.c	602;"	d	file:
SEP_Row	.\src\shell.c	596;"	d	file:
SEP_Space	.\src\shell.c	598;"	d	file:
SEP_Tab	.\src\shell.c	597;"	d	file:
SEP_Unit	.\src\shell.c	601;"	d	file:
SERIES_COLUMN_START	.\ext\misc\series.c	119;"	d	file:
SERIES_COLUMN_STEP	.\ext\misc\series.c	121;"	d	file:
SERIES_COLUMN_STOP	.\ext\misc\series.c	120;"	d	file:
SERIES_COLUMN_VALUE	.\ext\misc\series.c	118;"	d	file:
SETBIT	.\src\bitvec.c	302;"	d	file:
SET_FULLSYNC	.\src\os.h	33;"	d
SF_Aggregate	.\src\sqliteInt.h	2467;"	d
SF_All	.\src\sqliteInt.h	2465;"	d
SF_Compound	.\src\sqliteInt.h	2471;"	d
SF_Converted	.\src\sqliteInt.h	2478;"	d
SF_Distinct	.\src\sqliteInt.h	2464;"	d
SF_Expanded	.\src\sqliteInt.h	2469;"	d
SF_HasTypeInfo	.\src\sqliteInt.h	2470;"	d
SF_MaybeConvert	.\src\sqliteInt.h	2475;"	d
SF_MinMaxAgg	.\src\sqliteInt.h	2476;"	d
SF_MultiValue	.\src\sqliteInt.h	2473;"	d
SF_NestedFrom	.\src\sqliteInt.h	2474;"	d
SF_Recursive	.\src\sqliteInt.h	2477;"	d
SF_Resolved	.\src\sqliteInt.h	2466;"	d
SF_UsesEphemeral	.\src\sqliteInt.h	2468;"	d
SF_Values	.\src\sqliteInt.h	2472;"	d
SHARED_FIRST	.\src\os.h	152;"	d
SHARED_FIRST	.\tool\getlock.c	55;"	d	file:
SHARED_LOCK	.\src\os.h	86;"	d
SHARED_SIZE	.\src\os.h	153;"	d
SHARED_SIZE	.\tool\getlock.c	56;"	d	file:
SHELL_OPT	.\main.mk	/^SHELL_OPT = -DSQLITE_ENABLE_JSON1 -DSQLITE_ENABLE_FTS4 -DSQLITE_ENABLE_FTS5$/;"	m
SHELL_USE_LOCAL_GETLINE	.\src\shell.c	97;"	d	file:
SHFLG_Lookaside	.\src\shell.c	562;"	d	file:
SHFLG_Pagecache	.\src\shell.c	561;"	d	file:
SHFLG_Scratch	.\src\shell.c	560;"	d	file:
SHIFT	.\tool\lemon.c	/^  SHIFT,$/;"	e	enum:e_action	file:
SHIFTREDUCE	.\tool\lemon.c	/^  SHIFTREDUCE              \/* Shift first, then reduce *\/$/;"	e	enum:e_action	file:
SHM_BASE	.\tool\getlock.c	61;"	d	file:
SHM_CHECKPOINT	.\tool\getlock.c	63;"	d	file:
SHM_READ_FIRST	.\tool\getlock.c	65;"	d	file:
SHM_READ_SIZE	.\tool\getlock.c	66;"	d	file:
SHM_RECOVER	.\tool\getlock.c	64;"	d	file:
SHM_WRITE	.\tool\getlock.c	62;"	d	file:
SH_RESOLVED	.\tool\lemon.c	/^  SH_RESOLVED,             \/* Was a shift.  Precedence resolved conflict *\/$/;"	e	enum:e_action	file:
SLConn	.\src\test_sqllog.c	/^struct SLConn {$/;"	s	file:
SLGlobal	.\src\test_sqllog.c	/^static struct SLGlobal {$/;"	s	file:
SLOT_2_0	.\ext\fts5\fts5_varint.c	95;"	d	file:
SLOT_2_0	.\src\util.c	766;"	d	file:
SLOT_4_2_0	.\ext\fts5\fts5_varint.c	96;"	d	file:
SLOT_4_2_0	.\src\util.c	767;"	d	file:
SMALLEST_INT64	.\ext\fts3\fts3.c	3124;"	d	file:
SMALLEST_INT64	.\ext\fts5\fts5Int.h	45;"	d
SMALLEST_INT64	.\ext\misc\json1.c	38;"	d	file:
SMALLEST_INT64	.\ext\misc\totype.c	64;"	d	file:
SMALLEST_INT64	.\src\sqliteInt.h	715;"	d
SNIPPET_DESIRED	.\ext\fts1\fts1.c	2404;"	d	file:
SNIPPET_DESIRED	.\ext\fts2\fts2.c	3253;"	d	file:
SNIPPET_IGNORE	.\ext\fts1\fts1.c	2403;"	d	file:
SNIPPET_IGNORE	.\ext\fts2\fts2.c	3252;"	d	file:
SORTER_MAX_MERGE_COUNT	.\src\vdbesort.c	460;"	d	file:
SORTER_TYPE_INTEGER	.\src\vdbesort.c	338;"	d	file:
SORTER_TYPE_TEXT	.\src\vdbesort.c	339;"	d	file:
SORTFLAG_UseSorter	.\src\select.c	59;"	d	file:
SPELLFIX_COL_COMMAND	.\ext\misc\spellfix.c	1934;"	d	file:
SPELLFIX_COL_DISTANCE	.\ext\misc\spellfix.c	1925;"	d	file:
SPELLFIX_COL_LANGID	.\ext\misc\spellfix.c	1926;"	d	file:
SPELLFIX_COL_MATCHLEN	.\ext\misc\spellfix.c	1928;"	d	file:
SPELLFIX_COL_PHONEHASH	.\ext\misc\spellfix.c	1929;"	d	file:
SPELLFIX_COL_RANK	.\ext\misc\spellfix.c	1924;"	d	file:
SPELLFIX_COL_SCOPE	.\ext\misc\spellfix.c	1931;"	d	file:
SPELLFIX_COL_SCORE	.\ext\misc\spellfix.c	1927;"	d	file:
SPELLFIX_COL_SOUNDSLIKE	.\ext\misc\spellfix.c	1933;"	d	file:
SPELLFIX_COL_SRCHCNT	.\ext\misc\spellfix.c	1932;"	d	file:
SPELLFIX_COL_TOP	.\ext\misc\spellfix.c	1930;"	d	file:
SPELLFIX_COL_WORD	.\ext\misc\spellfix.c	1923;"	d	file:
SPELLFIX_IDXNUM_DIST	.\ext\misc\spellfix.c	2051;"	d	file:
SPELLFIX_IDXNUM_DISTLE	.\ext\misc\spellfix.c	2049;"	d	file:
SPELLFIX_IDXNUM_DISTLT	.\ext\misc\spellfix.c	2048;"	d	file:
SPELLFIX_IDXNUM_LANGID	.\ext\misc\spellfix.c	2045;"	d	file:
SPELLFIX_IDXNUM_MATCH	.\ext\misc\spellfix.c	2044;"	d	file:
SPELLFIX_IDXNUM_ROWID	.\ext\misc\spellfix.c	2050;"	d	file:
SPELLFIX_IDXNUM_SCOPE	.\ext\misc\spellfix.c	2047;"	d	file:
SPELLFIX_IDXNUM_TOP	.\ext\misc\spellfix.c	2046;"	d	file:
SPELLFIX_MX_HASH	.\ext\misc\spellfix.c	1750;"	d	file:
SPELLFIX_MX_RUN	.\ext\misc\spellfix.c	1753;"	d	file:
SPILLFLAG_NOSYNC	.\src\pager.c	461;"	d	file:
SPILLFLAG_OFF	.\src\pager.c	459;"	d	file:
SPILLFLAG_ROLLBACK	.\src\pager.c	460;"	d	file:
SQLITE3_MUTEX_INITIALIZER	.\src\mutex_unix.c	53;"	d	file:
SQLITE3_MUTEX_INITIALIZER	.\src\mutex_unix.c	55;"	d	file:
SQLITE3_MUTEX_INITIALIZER	.\src\mutex_w32.c	55;"	d	file:
SQLITE3_MUTEX_INITIALIZER	.\src\mutex_w32.c	58;"	d	file:
SQLITEASYNC_DELAY	.\ext\async\sqlite3async.h	206;"	d
SQLITEASYNC_GET_DELAY	.\ext\async\sqlite3async.h	207;"	d
SQLITEASYNC_GET_HALT	.\ext\async\sqlite3async.h	205;"	d
SQLITEASYNC_GET_LOCKFILES	.\ext\async\sqlite3async.h	209;"	d
SQLITEASYNC_HALT	.\ext\async\sqlite3async.h	204;"	d
SQLITEASYNC_HALT_IDLE	.\ext\async\sqlite3async.h	217;"	d
SQLITEASYNC_HALT_NEVER	.\ext\async\sqlite3async.h	215;"	d
SQLITEASYNC_HALT_NOW	.\ext\async\sqlite3async.h	216;"	d
SQLITEASYNC_LOCKFILES	.\ext\async\sqlite3async.h	208;"	d
SQLITEASYNC_VFSNAME	.\ext\async\sqlite3async.h	12;"	d
SQLITE_AFF_BLOB	.\src\sqliteInt.h	1556;"	d
SQLITE_AFF_INTEGER	.\src\sqliteInt.h	1559;"	d
SQLITE_AFF_MASK	.\src\sqliteInt.h	1568;"	d
SQLITE_AFF_NUMERIC	.\src\sqliteInt.h	1558;"	d
SQLITE_AFF_REAL	.\src\sqliteInt.h	1560;"	d
SQLITE_AFF_TEXT	.\src\sqliteInt.h	1557;"	d
SQLITE_ALLOW_COVERING_INDEX_SCAN	.\src\global.c	152;"	d	file:
SQLITE_ASCII	.\src\sqliteInt.h	557;"	d
SQLITE_ASYNC_TWO_FILEHANDLES	.\ext\async\sqlite3async.c	376;"	d	file:
SQLITE_AllOpts	.\src\sqliteInt.h	1313;"	d
SQLITE_AutoIndex	.\src\sqliteInt.h	1285;"	d
SQLITE_BIGENDIAN	.\src\sqliteInt.h	691;"	d
SQLITE_BIGENDIAN	.\src\sqliteInt.h	698;"	d
SQLITE_BIGENDIAN	.\src\sqliteInt.h	704;"	d
SQLITE_BIG_DBL	.\src\sqliteInt.h	450;"	d
SQLITE_BIG_DBL	.\src\sqliteInt.h	458;"	d
SQLITE_BYTEORDER	.\src\sqliteInt.h	690;"	d
SQLITE_BYTEORDER	.\src\sqliteInt.h	697;"	d
SQLITE_BYTEORDER	.\src\sqliteInt.h	703;"	d
SQLITE_CANTOPEN_BKPT	.\src\sqliteInt.h	3092;"	d
SQLITE_CORE	.\ext\fts1\fts1.c	40;"	d	file:
SQLITE_CORE	.\ext\fts2\fts2.c	302;"	d	file:
SQLITE_CORE	.\ext\fts3\fts3.c	295;"	d	file:
SQLITE_CORE	.\src\loadext.c	17;"	d	file:
SQLITE_CORE	.\src\test_multiplex.c	57;"	d	file:
SQLITE_CORRUPT_BKPT	.\src\sqliteInt.h	3090;"	d
SQLITE_CacheSpill	.\src\sqliteInt.h	1266;"	d
SQLITE_CellSizeCk	.\src\sqliteInt.h	1293;"	d
SQLITE_CkptFullFSync	.\src\sqliteInt.h	1265;"	d
SQLITE_ColumnCache	.\src\sqliteInt.h	1302;"	d
SQLITE_CountRows	.\src\sqliteInt.h	1269;"	d
SQLITE_CoverIdxScan	.\src\sqliteInt.h	1307;"	d
SQLITE_DEBUG_OS_TRACE	.\src\main.c	71;"	d	file:
SQLITE_DEFAULT_AUTOVACUUM	.\src\btree.h	29;"	d
SQLITE_DEFAULT_CACHE_SIZE	.\src\sqliteLimit.h	110;"	d
SQLITE_DEFAULT_FILE_FORMAT	.\src\sqliteInt.h	480;"	d
SQLITE_DEFAULT_FILE_PERMISSIONS	.\src\os_unix.c	137;"	d	file:
SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT	.\src\pager.h	26;"	d
SQLITE_DEFAULT_MEMSTATUS	.\src\sqliteInt.h	239;"	d
SQLITE_DEFAULT_MMAP_SIZE	.\src\sqliteInt.h	781;"	d
SQLITE_DEFAULT_MMAP_SIZE	.\src\sqliteInt.h	785;"	d
SQLITE_DEFAULT_MMAP_SIZE	.\src\sqliteInt.h	786;"	d
SQLITE_DEFAULT_MMAP_SIZE_xc	.\src\sqliteInt.h	782;"	d
SQLITE_DEFAULT_PAGE_SIZE	.\src\sqliteLimit.h	159;"	d
SQLITE_DEFAULT_PAGE_SIZE	.\src\sqliteLimit.h	162;"	d
SQLITE_DEFAULT_PAGE_SIZE	.\src\sqliteLimit.h	163;"	d
SQLITE_DEFAULT_PCACHE_INITSZ	.\src\sqliteInt.h	527;"	d
SQLITE_DEFAULT_PROXYDIR_PERMISSIONS	.\src\os_unix.c	144;"	d	file:
SQLITE_DEFAULT_RECURSIVE_TRIGGERS	.\src\sqliteInt.h	488;"	d
SQLITE_DEFAULT_SECTOR_SIZE	.\src\os.h	40;"	d
SQLITE_DEFAULT_WAL_AUTOCHECKPOINT	.\src\sqliteLimit.h	118;"	d
SQLITE_DEFAULT_WORKER_THREADS	.\src\sqliteInt.h	513;"	d
SQLITE_DEMOVFS_BUFFERSZ	.\src\test_demovfs.c	135;"	d	file:
SQLITE_DYNAMIC	.\src\sqliteInt.h	866;"	d
SQLITE_DeferFKs	.\src\sqliteInt.h	1289;"	d
SQLITE_DistinctOpt	.\src\sqliteInt.h	1306;"	d
SQLITE_EBCDIC	.\src\sqliteInt.h	555;"	d
SQLITE_ECEL_DUP	.\src\sqliteInt.h	3411;"	d
SQLITE_ECEL_FACTOR	.\src\sqliteInt.h	3412;"	d
SQLITE_ECEL_REF	.\src\sqliteInt.h	3413;"	d
SQLITE_ENABLE_EXPLAIN_COMMENTS	.\src\sqliteInt.h	315;"	d
SQLITE_ENABLE_FTS3	.\ext\fts3\fts3Int.h	27;"	d
SQLITE_ENABLE_FTS3	.\src\sqliteInt.h	3101;"	d
SQLITE_ENABLE_LOCKING_STYLE	.\src\os_unix.c	68;"	d	file:
SQLITE_ENABLE_LOCKING_STYLE	.\src\os_unix.c	70;"	d	file:
SQLITE_ENABLE_LOCKING_STYLE	.\src\pragma.c	18;"	d	file:
SQLITE_ENABLE_LOCKING_STYLE	.\src\pragma.c	20;"	d	file:
SQLITE_ENABLE_LOCKING_STYLE	.\src\test1.c	5196;"	d	file:
SQLITE_ENABLE_LOCKING_STYLE	.\src\test_config.c	519;"	d	file:
SQLITE_ENABLE_LOCKING_STYLE	.\src\vxworks.h	24;"	d
SQLITE_ENABLE_STAT3	.\src\sqliteInt.h	795;"	d
SQLITE_ENABLE_STAT3_OR_STAT4	.\src\sqliteInt.h	796;"	d
SQLITE_ENABLE_STAT3_OR_STAT4	.\src\sqliteInt.h	798;"	d
SQLITE_ENABLE_STAT3_OR_STAT4	.\src\sqliteInt.h	800;"	d
SQLITE_EXTENSION_INIT1	.\src\sqlite3ext.h	522;"	d
SQLITE_EXTENSION_INIT1	.\src\sqlite3ext.h	529;"	d
SQLITE_EXTENSION_INIT2	.\src\sqlite3ext.h	523;"	d
SQLITE_EXTENSION_INIT2	.\src\sqlite3ext.h	530;"	d
SQLITE_EXTENSION_INIT3	.\src\sqlite3ext.h	524;"	d
SQLITE_EXTENSION_INIT3	.\src\sqlite3ext.h	531;"	d
SQLITE_EnableTrigger	.\src\sqliteInt.h	1288;"	d
SQLITE_FAULTINJECTOR_COUNT	.\src\sqliteInt.h	3838;"	d
SQLITE_FAULTINJECTOR_MALLOC	.\src\sqliteInt.h	3837;"	d
SQLITE_FCNTL_DB_UNCHANGED	.\src\os.h	174;"	d
SQLITE_FILE_HEADER	.\src\btreeInt.h	249;"	d
SQLITE_FREE	.\src\mem1.c	63;"	d	file:
SQLITE_FREE	.\src\mem1.c	75;"	d	file:
SQLITE_FSFLAGS_IS_MSDOS	.\src\os_unix.c	122;"	d	file:
SQLITE_FTS3_DEFAULT_NEAR_PARAM	.\ext\fts3\fts3_expr.c	79;"	d	file:
SQLITE_FTS3_MAX_EXPR_DEPTH	.\ext\fts3\fts3Int.h	50;"	d
SQLITE_FUNC_CASE	.\src\sqliteInt.h	1390;"	d
SQLITE_FUNC_COALESCE	.\src\sqliteInt.h	1396;"	d
SQLITE_FUNC_CONSTANT	.\src\sqliteInt.h	1398;"	d
SQLITE_FUNC_COUNT	.\src\sqliteInt.h	1395;"	d
SQLITE_FUNC_ENCMASK	.\src\sqliteInt.h	1388;"	d
SQLITE_FUNC_EPHEM	.\src\sqliteInt.h	1391;"	d
SQLITE_FUNC_LENGTH	.\src\sqliteInt.h	1393;"	d
SQLITE_FUNC_LIKE	.\src\sqliteInt.h	1389;"	d
SQLITE_FUNC_MINMAX	.\src\sqliteInt.h	1399;"	d
SQLITE_FUNC_NEEDCOLL	.\src\sqliteInt.h	1392;"	d
SQLITE_FUNC_SLOCHNG	.\src\sqliteInt.h	1400;"	d
SQLITE_FUNC_TYPEOF	.\src\sqliteInt.h	1394;"	d
SQLITE_FUNC_UNLIKELY	.\src\sqliteInt.h	1397;"	d
SQLITE_FactorOutConst	.\src\sqliteInt.h	1304;"	d
SQLITE_ForeignKeys	.\src\sqliteInt.h	1284;"	d
SQLITE_FullColNames	.\src\sqliteInt.h	1267;"	d
SQLITE_FullFSync	.\src\sqliteInt.h	1264;"	d
SQLITE_GroupByOrder	.\src\sqliteInt.h	1303;"	d
SQLITE_HAVE_ISNAN	.\src\sqliteInt.h	455;"	d
SQLITE_HAVE_OS_TRACE	.\src\sqliteInt.h	397;"	d
SQLITE_HAVE_OS_TRACE	.\src\sqliteInt.h	400;"	d
SQLITE_HOMEGROWN_RECURSIVE_MUTEX	.\src\vxworks.h	22;"	d
SQLITE_IDXTYPE_APPDEF	.\src\sqliteInt.h	1911;"	d
SQLITE_IDXTYPE_PRIMARYKEY	.\src\sqliteInt.h	1913;"	d
SQLITE_IDXTYPE_UNIQUE	.\src\sqliteInt.h	1912;"	d
SQLITE_INTEGRITY_CHECK_ERROR_MAX	.\src\pragma.c	1347;"	d	file:
SQLITE_INT_TO_PTR	.\src\sqliteInt.h	163;"	d
SQLITE_INT_TO_PTR	.\src\sqliteInt.h	166;"	d
SQLITE_INT_TO_PTR	.\src\sqliteInt.h	169;"	d
SQLITE_INT_TO_PTR	.\src\sqliteInt.h	172;"	d
SQLITE_IgnoreChecks	.\src\sqliteInt.h	1278;"	d
SQLITE_InternChanges	.\src\sqliteInt.h	1263;"	d
SQLITE_JUMPIFNULL	.\src\sqliteInt.h	1579;"	d
SQLITE_LITTLEENDIAN	.\src\sqliteInt.h	692;"	d
SQLITE_LITTLEENDIAN	.\src\sqliteInt.h	699;"	d
SQLITE_LITTLEENDIAN	.\src\sqliteInt.h	705;"	d
SQLITE_LOCKFILEEX_FLAGS	.\src\os_win.c	2907;"	d	file:
SQLITE_LOCKFILE_FLAGS	.\src\os_win.c	2898;"	d	file:
SQLITE_LegacyFileFmt	.\src\sqliteInt.h	1280;"	d
SQLITE_LoadExtension	.\src\sqliteInt.h	1287;"	d
SQLITE_MAGIC_BUSY	.\src\sqliteInt.h	1340;"	d
SQLITE_MAGIC_CLOSED	.\src\sqliteInt.h	1338;"	d
SQLITE_MAGIC_ERROR	.\src\sqliteInt.h	1341;"	d
SQLITE_MAGIC_OPEN	.\src\sqliteInt.h	1337;"	d
SQLITE_MAGIC_SICK	.\src\sqliteInt.h	1339;"	d
SQLITE_MAGIC_ZOMBIE	.\src\sqliteInt.h	1342;"	d
SQLITE_MALLOC	.\src\mem1.c	62;"	d	file:
SQLITE_MALLOC	.\src\mem1.c	74;"	d	file:
SQLITE_MALLOCSIZE	.\src\mem1.c	107;"	d	file:
SQLITE_MALLOCSIZE	.\src\mem1.c	111;"	d	file:
SQLITE_MALLOCSIZE	.\src\mem1.c	65;"	d	file:
SQLITE_MALLOC_SOFT_LIMIT	.\src\sqliteInt.h	280;"	d
SQLITE_MAX_ATTACHED	.\src\sqliteLimit.h	127;"	d
SQLITE_MAX_COLUMN	.\src\sqliteLimit.h	45;"	d
SQLITE_MAX_COMPOUND_SELECT	.\src\sqliteLimit.h	82;"	d
SQLITE_MAX_DEFAULT_PAGE_SIZE	.\src\sqliteLimit.h	174;"	d
SQLITE_MAX_DEFAULT_PAGE_SIZE	.\src\sqliteLimit.h	177;"	d
SQLITE_MAX_DEFAULT_PAGE_SIZE	.\src\sqliteLimit.h	178;"	d
SQLITE_MAX_EXPR_DEPTH	.\src\sqliteLimit.h	70;"	d
SQLITE_MAX_FILE_FORMAT	.\src\sqliteInt.h	478;"	d
SQLITE_MAX_FUNCTION_ARG	.\src\sqliteLimit.h	97;"	d
SQLITE_MAX_LENGTH	.\src\sqliteLimit.h	24;"	d
SQLITE_MAX_LIKE_PATTERN_LENGTH	.\ext\icu\icu.c	53;"	d	file:
SQLITE_MAX_LIKE_PATTERN_LENGTH	.\src\sqliteLimit.h	198;"	d
SQLITE_MAX_MMAP_SIZE	.\src\sqliteInt.h	747;"	d
SQLITE_MAX_MMAP_SIZE	.\src\sqliteInt.h	748;"	d
SQLITE_MAX_MMAP_SIZE	.\src\sqliteInt.h	757;"	d
SQLITE_MAX_MMAP_SIZE	.\src\sqliteInt.h	758;"	d
SQLITE_MAX_MMAP_SIZE	.\src\sqliteInt.h	768;"	d
SQLITE_MAX_MMAP_SIZE	.\src\sqliteInt.h	770;"	d
SQLITE_MAX_MMAP_SIZE_xc	.\src\sqliteInt.h	772;"	d
SQLITE_MAX_PAGE_COUNT	.\src\sqliteLimit.h	190;"	d
SQLITE_MAX_PAGE_SIZE	.\src\sqliteLimit.h	150;"	d
SQLITE_MAX_PAGE_SIZE	.\src\sqliteLimit.h	152;"	d
SQLITE_MAX_PMASZ	.\src\vdbesort.c	155;"	d	file:
SQLITE_MAX_SCHEMA_RETRY	.\src\vdbeInt.h	26;"	d
SQLITE_MAX_SQL_LENGTH	.\src\sqliteLimit.h	56;"	d
SQLITE_MAX_TRIGGER_DEPTH	.\src\sqliteLimit.h	209;"	d
SQLITE_MAX_U32	.\src\sqliteInt.h	619;"	d
SQLITE_MAX_VARIABLE_NUMBER	.\src\sqliteLimit.h	135;"	d
SQLITE_MAX_VDBE_OP	.\src\sqliteLimit.h	90;"	d
SQLITE_MAX_WORKER_THREADS	.\src\sqliteInt.h	506;"	d
SQLITE_MAX_WORKER_THREADS	.\src\sqliteInt.h	507;"	d
SQLITE_MAX_WORKER_THREADS	.\src\sqliteInt.h	510;"	d
SQLITE_MAX_WORKER_THREADS	.\src\sqliteInt.h	516;"	d
SQLITE_MAX_WORKER_THREADS	.\src\sqliteInt.h	517;"	d
SQLITE_MINIMUM_FILE_DESCRIPTOR	.\src\os_unix.c	560;"	d	file:
SQLITE_MISUSE_BKPT	.\src\sqliteInt.h	3091;"	d
SQLITE_MIXED_ENDIAN_64BIT_FLOAT	.\src\sqliteInt.h	454;"	d
SQLITE_MULTIPLEX_CHUNK_SIZE	.\src\test_multiplex.c	103;"	d	file:
SQLITE_MULTIPLEX_JOURNAL_8_3_OFFSET	.\src\test_multiplex.c	88;"	d	file:
SQLITE_MULTIPLEX_MAX_CHUNKS	.\src\test_multiplex.c	113;"	d	file:
SQLITE_MULTIPLEX_VFS_NAME	.\src\test_multiplex.c	95;"	d	file:
SQLITE_MULTIPLEX_WAL_8_3_OFFSET	.\src\test_multiplex.c	89;"	d	file:
SQLITE_MUTEX_NOOP	.\src\mutex.h	49;"	d
SQLITE_MUTEX_NREF	.\src\mutex_unix.c	33;"	d	file:
SQLITE_MUTEX_NREF	.\src\mutex_unix.c	35;"	d	file:
SQLITE_MUTEX_OMIT	.\src\mutex.h	41;"	d
SQLITE_MUTEX_PTHREADS	.\src\mutex.h	45;"	d
SQLITE_MUTEX_W32	.\src\mutex.h	47;"	d
SQLITE_NEED_ERR_NAME	.\src\sqliteInt.h	411;"	d
SQLITE_NEED_ERR_NAME	.\src\sqliteInt.h	413;"	d
SQLITE_NOINLINE	.\src\sqliteInt.h	181;"	d
SQLITE_NOINLINE	.\src\sqliteInt.h	183;"	d
SQLITE_NOINLINE	.\src\sqliteInt.h	185;"	d
SQLITE_NOTNULL	.\src\sqliteInt.h	1582;"	d
SQLITE_NULLEQ	.\src\sqliteInt.h	1581;"	d
SQLITE_N_BTREE_META	.\src\btree.h	22;"	d
SQLITE_N_COLCACHE	.\src\sqliteInt.h	2597;"	d
SQLITE_N_LIMIT	.\src\sqliteInt.h	1049;"	d
SQLITE_NullCallback	.\src\sqliteInt.h	1272;"	d
SQLITE_OMIT_DATETIME_FUNCS	.\src\sqliteInt.h	452;"	d
SQLITE_OMIT_LOAD_EXTENSION	.\src\shell.c	31;"	d	file:
SQLITE_OMIT_LOAD_EXTENSION	.\src\vxworks.h	23;"	d
SQLITE_OMIT_POPEN	.\src\shell.c	122;"	d	file:
SQLITE_OMIT_TRACE	.\src\sqliteInt.h	453;"	d
SQLITE_OS_OTHER	.\src\os_setup.h	34;"	d
SQLITE_OS_OTHER	.\src\os_setup.h	38;"	d
SQLITE_OS_OTHER	.\src\vxworks.h	21;"	d
SQLITE_OS_UNIX	.\src\os_setup.h	29;"	d
SQLITE_OS_UNIX	.\src\os_setup.h	30;"	d
SQLITE_OS_UNIX	.\src\os_setup.h	43;"	d
SQLITE_OS_UNIX	.\src\os_setup.h	46;"	d
SQLITE_OS_UNIX	.\src\os_setup.h	49;"	d
SQLITE_OS_WIN	.\src\os_setup.h	31;"	d
SQLITE_OS_WIN	.\src\os_setup.h	32;"	d
SQLITE_OS_WIN	.\src\os_setup.h	42;"	d
SQLITE_OS_WIN	.\src\os_setup.h	45;"	d
SQLITE_OS_WIN	.\src\os_setup.h	53;"	d
SQLITE_OS_WINCE	.\src\os_win.h	54;"	d
SQLITE_OS_WINCE	.\src\os_win.h	56;"	d
SQLITE_OS_WINNT	.\src\os_win.h	46;"	d
SQLITE_OS_WINRT	.\src\os_win.h	64;"	d
SQLITE_OS_WIN_THREADS	.\src\os_win.h	83;"	d
SQLITE_OS_WIN_THREADS	.\src\os_win.h	85;"	d
SQLITE_OmitNoopJoin	.\src\sqliteInt.h	1311;"	d
SQLITE_OrderByIdxJoin	.\src\sqliteInt.h	1308;"	d
SQLITE_POWERSAFE_OVERWRITE	.\src\sqliteInt.h	230;"	d
SQLITE_PRINTF_INTERNAL	.\src\sqliteInt.h	3234;"	d
SQLITE_PRINTF_SQLFUNC	.\src\sqliteInt.h	3235;"	d
SQLITE_PRINT_BUF_SIZE	.\src\printf.c	165;"	d	file:
SQLITE_PTRSIZE	.\src\sqliteInt.h	663;"	d
SQLITE_PTRSIZE	.\src\sqliteInt.h	666;"	d
SQLITE_PTRSIZE	.\src\sqliteInt.h	668;"	d
SQLITE_PTR_TO_INT	.\src\sqliteInt.h	164;"	d
SQLITE_PTR_TO_INT	.\src\sqliteInt.h	167;"	d
SQLITE_PTR_TO_INT	.\src\sqliteInt.h	170;"	d
SQLITE_PTR_TO_INT	.\src\sqliteInt.h	173;"	d
SQLITE_PreferBuiltin	.\src\sqliteInt.h	1286;"	d
SQLITE_QueryFlattener	.\src\sqliteInt.h	1301;"	d
SQLITE_QueryOnly	.\src\sqliteInt.h	1290;"	d
SQLITE_RBU_UPDATE_CACHESIZE	.\ext\rbu\sqlite3rbu.c	97;"	d	file:
SQLITE_REALLOC	.\src\mem1.c	64;"	d	file:
SQLITE_REALLOC	.\src\mem1.c	76;"	d	file:
SQLITE_ReadUncommitted	.\src\sqliteInt.h	1279;"	d
SQLITE_RecTriggers	.\src\sqliteInt.h	1283;"	d
SQLITE_RecoveryMode	.\src\sqliteInt.h	1281;"	d
SQLITE_ReverseOrder	.\src\sqliteInt.h	1282;"	d
SQLITE_SKIP_UTF8	.\src\sqliteInt.h	3074;"	d
SQLITE_SORTER_PMASZ	.\src\global.c	159;"	d	file:
SQLITE_SO_ASC	.\src\sqliteInt.h	1538;"	d
SQLITE_SO_DESC	.\src\sqliteInt.h	1539;"	d
SQLITE_SO_UNDEFINED	.\src\sqliteInt.h	1540;"	d
SQLITE_STAT4_SAMPLES	.\src\analyze.c	154;"	d	file:
SQLITE_STAT4_SAMPLES	.\src\analyze.c	155;"	d	file:
SQLITE_STAT4_SAMPLES	.\src\analyze.c	257;"	d	file:
SQLITE_STOREP2	.\src\sqliteInt.h	1580;"	d
SQLITE_SYNC_MASK	.\src\wal.h	26;"	d
SQLITE_SYSTEM_MALLOC	.\src\sqliteInt.h	272;"	d
SQLITE_ShortColNames	.\src\sqliteInt.h	1268;"	d
SQLITE_SqlTrace	.\src\sqliteInt.h	1274;"	d
SQLITE_Stat34	.\src\sqliteInt.h	1312;"	d
SQLITE_SubqCoroutine	.\src\sqliteInt.h	1309;"	d
SQLITE_TCL_NRE	.\src\tclsqlite.c	1531;"	d	file:
SQLITE_TCL_NRE	.\src\tclsqlite.c	1547;"	d	file:
SQLITE_TEMP_FILE_PREFIX	.\src\os.h	65;"	d
SQLITE_TEMP_STORE	.\src\sqliteInt.h	496;"	d
SQLITE_TEMP_STORE_xc	.\src\sqliteInt.h	497;"	d
SQLITE_THREADSAFE	.\src\sqliteInt.h	219;"	d
SQLITE_THREADSAFE	.\src\sqliteInt.h	221;"	d
SQLITE_THREADS_IMPLEMENTED	.\src\threads.c	110;"	d	file:
SQLITE_THREADS_IMPLEMENTED	.\src\threads.c	38;"	d	file:
SQLITE_Transitive	.\src\sqliteInt.h	1310;"	d
SQLITE_UNIX_THREADS	.\src\os_unix.c	130;"	d	file:
SQLITE_USE_MALLOC_H	.\src\mem1.c	83;"	d	file:
SQLITE_USE_MALLOC_H	.\src\mem1.c	92;"	d	file:
SQLITE_USE_MALLOC_USABLE_SIZE	.\src\mem1.c	84;"	d	file:
SQLITE_USE_MSIZE	.\src\mem1.c	93;"	d	file:
SQLITE_USE_URI	.\src\global.c	144;"	d	file:
SQLITE_UTF16NATIVE	.\src\sqliteInt.h	693;"	d
SQLITE_UTF16NATIVE	.\src\sqliteInt.h	700;"	d
SQLITE_UTF16NATIVE	.\src\sqliteInt.h	706;"	d
SQLITE_Vacuum	.\src\sqliteInt.h	1292;"	d
SQLITE_VdbeAddopTrace	.\src\sqliteInt.h	1277;"	d
SQLITE_VdbeEQP	.\src\sqliteInt.h	1291;"	d
SQLITE_VdbeListing	.\src\sqliteInt.h	1275;"	d
SQLITE_VdbeTrace	.\src\sqliteInt.h	1262;"	d
SQLITE_W32_MUTEX_INITIALIZER	.\src\mutex_w32.c	52;"	d	file:
SQLITE_WIN32_DATA_DIRECTORY_TYPE	.\src\os_win.c	295;"	d	file:
SQLITE_WIN32_DBG_BUF_SIZE	.\src\os_win.c	287;"	d	file:
SQLITE_WIN32_GETVERSIONEX	.\src\os_win.c	85;"	d	file:
SQLITE_WIN32_GETVERSIONEX	.\src\os_win.c	87;"	d	file:
SQLITE_WIN32_HAS_ANSI	.\src\os_win.c	47;"	d	file:
SQLITE_WIN32_HAS_WIDE	.\src\os_win.c	56;"	d	file:
SQLITE_WIN32_HEAP_CREATE	.\src\os_win.c	327;"	d	file:
SQLITE_WIN32_HEAP_FLAGS	.\src\os_win.c	350;"	d	file:
SQLITE_WIN32_HEAP_INIT_SIZE	.\src\os_win.c	334;"	d	file:
SQLITE_WIN32_HEAP_MAX_SIZE	.\src\os_win.c	342;"	d	file:
SQLITE_WIN32_IOERR_RETRY	.\src\os_win.c	1912;"	d	file:
SQLITE_WIN32_IOERR_RETRY_DELAY	.\src\os_win.c	1915;"	d	file:
SQLITE_WIN32_MAX_ERRMSG_CHARS	.\src\os_win.c	143;"	d	file:
SQLITE_WIN32_MAX_PATH_BYTES	.\src\os_win.c	127;"	d	file:
SQLITE_WIN32_MAX_PATH_CHARS	.\src\os_win.c	103;"	d	file:
SQLITE_WIN32_TEMP_DIRECTORY_TYPE	.\src\os_win.c	303;"	d	file:
SQLITE_WIN32_VOLATILE	.\src\os_win.h	72;"	d
SQLITE_WIN32_VOLATILE	.\src\os_win.h	74;"	d
SQLITE_WINNT_MAX_PATH_BYTES	.\src\os_win.c	135;"	d	file:
SQLITE_WINNT_MAX_PATH_CHARS	.\src\os_win.c	118;"	d	file:
SQLITE_WSD	.\src\sqliteInt.h	883;"	d
SQLITE_WSD	.\src\sqliteInt.h	889;"	d
SQLITE_WriteSchema	.\src\sqliteInt.h	1276;"	d
SQLLOG_NAMESZ	.\src\test_sqllog.c	93;"	d	file:
SQL_CHOMP_SEGDIR	.\ext\fts3\fts3_write.c	267;"	d	file:
SQL_CONTENT_INSERT	.\ext\fts3\fts3_write.c	251;"	d	file:
SQL_DELETE_ALL_CONTENT	.\ext\fts3\fts3_write.c	235;"	d	file:
SQL_DELETE_ALL_DOCSIZE	.\ext\fts3\fts3_write.c	238;"	d	file:
SQL_DELETE_ALL_SEGDIR	.\ext\fts3\fts3_write.c	237;"	d	file:
SQL_DELETE_ALL_SEGMENTS	.\ext\fts3\fts3_write.c	236;"	d	file:
SQL_DELETE_ALL_STAT	.\ext\fts3\fts3_write.c	239;"	d	file:
SQL_DELETE_ALL_TERMS_SEGDIR	.\ext\fts3\fts3_write.c	259;"	d	file:
SQL_DELETE_CONTENT	.\ext\fts3\fts3_write.c	233;"	d	file:
SQL_DELETE_DOCSIZE	.\ext\fts3\fts3_write.c	252;"	d	file:
SQL_DELETE_SEGDIR_ENTRY	.\ext\fts3\fts3_write.c	264;"	d	file:
SQL_DELETE_SEGDIR_LEVEL	.\ext\fts3\fts3_write.c	249;"	d	file:
SQL_DELETE_SEGDIR_RANGE	.\ext\fts3\fts3_write.c	260;"	d	file:
SQL_DELETE_SEGMENTS_RANGE	.\ext\fts3\fts3_write.c	250;"	d	file:
SQL_FIND_MERGE_LEVEL	.\ext\fts3\fts3_write.c	262;"	d	file:
SQL_INSERT_SEGDIR	.\ext\fts3\fts3_write.c	244;"	d	file:
SQL_INSERT_SEGMENTS	.\ext\fts3\fts3_write.c	242;"	d	file:
SQL_IS_EMPTY	.\ext\fts3\fts3_write.c	234;"	d	file:
SQL_MAX_LEAF_NODE_ESTIMATE	.\ext\fts3\fts3_write.c	263;"	d	file:
SQL_NEXT_SEGMENTS_ID	.\ext\fts3\fts3_write.c	243;"	d	file:
SQL_NEXT_SEGMENT_INDEX	.\ext\fts3\fts3_write.c	241;"	d	file:
SQL_OUTPUT	.\test\fuzzcheck.c	618;"	d	file:
SQL_REPLACE_DOCSIZE	.\ext\fts3\fts3_write.c	253;"	d	file:
SQL_REPLACE_STAT	.\ext\fts3\fts3_write.c	256;"	d	file:
SQL_SEGMENT_IS_APPENDABLE	.\ext\fts3\fts3_write.c	268;"	d	file:
SQL_SELECT_ALL_LANGID	.\ext\fts3\fts3_write.c	261;"	d	file:
SQL_SELECT_ALL_PREFIX_LEVEL	.\ext\fts3\fts3_write.c	258;"	d	file:
SQL_SELECT_CONTENT_BY_ROWID	.\ext\fts3\fts3_write.c	240;"	d	file:
SQL_SELECT_DOCSIZE	.\ext\fts3\fts3_write.c	254;"	d	file:
SQL_SELECT_INDEXES	.\ext\fts3\fts3_write.c	269;"	d	file:
SQL_SELECT_LEVEL	.\ext\fts3\fts3_write.c	245;"	d	file:
SQL_SELECT_LEVEL_COUNT	.\ext\fts3\fts3_write.c	247;"	d	file:
SQL_SELECT_LEVEL_RANGE	.\ext\fts3\fts3_write.c	246;"	d	file:
SQL_SELECT_LEVEL_RANGE2	.\ext\fts3\fts3_write.c	272;"	d	file:
SQL_SELECT_MXLEVEL	.\ext\fts3\fts3_write.c	270;"	d	file:
SQL_SELECT_SEGDIR	.\ext\fts3\fts3_write.c	266;"	d	file:
SQL_SELECT_SEGDIR_MAX_LEVEL	.\ext\fts3\fts3_write.c	248;"	d	file:
SQL_SELECT_STAT	.\ext\fts3\fts3_write.c	255;"	d	file:
SQL_SHIFT_SEGDIR_ENTRY	.\ext\fts3\fts3_write.c	265;"	d	file:
SQL_TRACE	.\test\fuzzcheck.c	617;"	d	file:
SQL_UPDATE_LEVEL	.\ext\fts3\fts3_write.c	274;"	d	file:
SQL_UPDATE_LEVEL_IDX	.\ext\fts3\fts3_write.c	273;"	d	file:
SQLiteThread	.\src\sqliteInt.h	/^typedef struct SQLiteThread SQLiteThread;$/;"	t	typeref:struct:SQLiteThread
SQLiteThread	.\src\threads.c	/^struct SQLiteThread {$/;"	s	file:
SRC	.\main.mk	/^SRC = \\$/;"	m
SRCONFLICT	.\tool\lemon.c	/^  SRCONFLICT,              \/* Was a reduce, but part of a conflict *\/$/;"	e	enum:e_action	file:
SRT_Coroutine	.\src\sqliteInt.h	2561;"	d
SRT_Discard	.\src\sqliteInt.h	2548;"	d
SRT_DistFifo	.\src\sqliteInt.h	2550;"	d
SRT_DistQueue	.\src\sqliteInt.h	2552;"	d
SRT_EphemTab	.\src\sqliteInt.h	2560;"	d
SRT_Except	.\src\sqliteInt.h	2546;"	d
SRT_Exists	.\src\sqliteInt.h	2547;"	d
SRT_Fifo	.\src\sqliteInt.h	2549;"	d
SRT_Mem	.\src\sqliteInt.h	2558;"	d
SRT_Output	.\src\sqliteInt.h	2557;"	d
SRT_Queue	.\src\sqliteInt.h	2551;"	d
SRT_Set	.\src\sqliteInt.h	2559;"	d
SRT_Table	.\src\sqliteInt.h	2562;"	d
SRT_Union	.\src\sqliteInt.h	2545;"	d
SRVAL	.\src\vdbesort.c	456;"	d	file:
SSCONFLICT	.\tool\lemon.c	/^  SSCONFLICT,              \/* A shift\/shift conflict *\/$/;"	e	enum:e_action	file:
STANDALONE_MIN	.\ext\fts2\fts2.c	4461;"	d	file:
STATICBUFFERSIZE	.\autoconf\tea\win\nmakehlp.c	56;"	d	file:
STATIC_MUTEXES	.\src\test_mutex.c	23;"	d	file:
STAT_GET_NDLT	.\src\analyze.c	794;"	d	file:
STAT_GET_NEQ	.\src\analyze.c	792;"	d	file:
STAT_GET_NLT	.\src\analyze.c	793;"	d	file:
STAT_GET_ROWID	.\src\analyze.c	791;"	d	file:
STAT_GET_STAT1	.\src\analyze.c	790;"	d	file:
STRACCUM_NOMEM	.\src\sqliteInt.h	2918;"	d
STRACCUM_TOOBIG	.\src\sqliteInt.h	2919;"	d
STRESS2_COUNT2	.\test\tt3_stress.c	188;"	d	file:
STRESS2_COUNT3	.\test\tt3_stress.c	189;"	d	file:
STRESS2_TABCNT	.\test\tt3_stress.c	186;"	d	file:
STRICMP	.\src\build.c	1060;"	d	file:
STRINGVALUE	.\src\test_config.c	36;"	d	file:
STRINGVALUE2	.\src\test_config.c	35;"	d	file:
STR_FUNCTION	.\src\sqliteInt.h	1449;"	d
SUBQUERY	.\tool\mkkeywordhash.c	111;"	d	file:
SUBQUERY	.\tool\mkkeywordhash.c	113;"	d	file:
SWAP	.\ext\rbu\sqlite3rbu.c	103;"	d	file:
SWAP	.\src\sqliteInt.h	548;"	d
SWAPVAL	.\ext\fts5\fts5_index.c	1838;"	d	file:
SYSCALL	.\src\os_win.c	427;"	d	file:
SavedModeInfo	.\src\shell.c	/^struct SavedModeInfo {$/;"	s	file:
SavedModeInfo	.\src\shell.c	/^typedef struct SavedModeInfo SavedModeInfo;$/;"	t	typeref:struct:SavedModeInfo	file:
Savepoint	.\src\sqliteInt.h	/^struct Savepoint {$/;"	s
Savepoint	.\src\sqliteInt.h	/^typedef struct Savepoint Savepoint;$/;"	t	typeref:struct:Savepoint
ScanStatus	.\src\vdbeInt.h	/^struct ScanStatus {$/;"	s
ScanStatus	.\src\vdbeInt.h	/^typedef struct ScanStatus ScanStatus;$/;"	t	typeref:struct:ScanStatus
Schema	.\src\sqliteInt.h	/^struct Schema {$/;"	s
Schema	.\src\sqliteInt.h	/^typedef struct Schema Schema;$/;"	t	typeref:struct:Schema
ScratchFreeslot	.\src\malloc.c	/^typedef struct ScratchFreeslot {$/;"	s	file:
ScratchFreeslot	.\src\malloc.c	/^} ScratchFreeslot;$/;"	t	typeref:struct:ScratchFreeslot	file:
SegmentNode	.\ext\fts3\fts3_write.c	/^struct SegmentNode {$/;"	s	file:
SegmentNode	.\ext\fts3\fts3_write.c	/^typedef struct SegmentNode SegmentNode;$/;"	t	typeref:struct:SegmentNode	file:
SegmentWriter	.\ext\fts3\fts3_write.c	/^struct SegmentWriter {$/;"	s	file:
SegmentWriter	.\ext\fts3\fts3_write.c	/^typedef struct SegmentWriter SegmentWriter;$/;"	t	typeref:struct:SegmentWriter	file:
Select	.\src\sqliteInt.h	/^struct Select {$/;"	s
Select	.\src\sqliteInt.h	/^typedef struct Select Select;$/;"	t	typeref:struct:Select
Select	.\test\fuzz_common.tcl	/^proc Select {{nMulti 0}} {$/;"	p
SelectDest	.\src\sqliteInt.h	/^struct SelectDest {$/;"	s
SelectDest	.\src\sqliteInt.h	/^typedef struct SelectDest SelectDest;$/;"	t	typeref:struct:SelectDest
SelectKw	.\test\fuzz_common.tcl	/^proc SelectKw {} {$/;"	p
ServerState	.\src\test_server.c	/^static struct ServerState {$/;"	s	file:
SetAdd	.\tool\lemon.c	/^int SetAdd(char *s, int e)$/;"	f
SetFind	.\tool\lemon.c	223;"	d	file:
SetFree	.\tool\lemon.c	/^void SetFree(char *s)$/;"	f
SetNew	.\tool\lemon.c	/^char *SetNew(){$/;"	f
SetSize	.\tool\lemon.c	/^void SetSize(int n)$/;"	f
SetUnion	.\tool\lemon.c	/^int SetUnion(char *s1, char *s2)$/;"	f
ShellState	.\src\shell.c	/^struct ShellState {$/;"	s	file:
ShellState	.\src\shell.c	/^typedef struct ShellState ShellState;$/;"	t	typeref:struct:ShellState	file:
ShmRegion	.\src\os_win.c	/^  struct ShmRegion {$/;"	s	struct:winShmNode	file:
SimpleSelect	.\test\fuzz_common.tcl	/^proc SimpleSelect {{nRes 0}} {$/;"	p
SimulateDiskfullError	.\src\os_common.h	78;"	d
SimulateDiskfullError	.\src\os_common.h	92;"	d
SimulateIOError	.\src\os_common.h	69;"	d
SimulateIOError	.\src\os_common.h	91;"	d
SimulateIOErrorBenign	.\src\os_common.h	68;"	d
SimulateIOErrorBenign	.\src\os_common.h	90;"	d
SizeofArray	.\ext\fts3\fts3Int.h	76;"	d
Snippet	.\ext\fts1\fts1.c	/^typedef struct Snippet {$/;"	s	file:
Snippet	.\ext\fts1\fts1.c	/^} Snippet;$/;"	t	typeref:struct:Snippet	file:
Snippet	.\ext\fts2\fts2.c	/^typedef struct Snippet {$/;"	s	file:
Snippet	.\ext\fts2\fts2.c	/^} Snippet;$/;"	t	typeref:struct:Snippet	file:
SnippetFragment	.\ext\fts3\fts3_snippet.c	/^struct SnippetFragment {$/;"	s	file:
SnippetFragment	.\ext\fts3\fts3_snippet.c	/^typedef struct SnippetFragment SnippetFragment;$/;"	t	typeref:struct:SnippetFragment	file:
SnippetIter	.\ext\fts3\fts3_snippet.c	/^struct SnippetIter {$/;"	s	file:
SnippetIter	.\ext\fts3\fts3_snippet.c	/^typedef struct SnippetIter SnippetIter;$/;"	t	typeref:struct:SnippetIter	file:
SnippetPhrase	.\ext\fts3\fts3_snippet.c	/^struct SnippetPhrase {$/;"	s	file:
SnippetPhrase	.\ext\fts3\fts3_snippet.c	/^typedef struct SnippetPhrase SnippetPhrase;$/;"	t	typeref:struct:SnippetPhrase	file:
SortByDimension	.\ext\rtree\rtree.c	/^static void SortByDimension($/;"	f	file:
SortByDistance	.\ext\rtree\rtree.c	/^static void SortByDistance($/;"	f	file:
SortCtx	.\src\select.c	/^struct SortCtx {$/;"	s	file:
SortCtx	.\src\select.c	/^typedef struct SortCtx SortCtx;$/;"	t	typeref:struct:SortCtx	file:
SortSubtask	.\src\vdbesort.c	/^struct SortSubtask {$/;"	s	file:
SortSubtask	.\src\vdbesort.c	/^typedef struct SortSubtask SortSubtask;     \/* A sub-task in the sort process *\/$/;"	t	typeref:struct:SortSubtask	file:
SorterCompare	.\src\vdbesort.c	/^typedef int (*SorterCompare)(SortSubtask*,int*,const void*,int,const void*,int);$/;"	t	file:
SorterFile	.\src\vdbesort.c	/^struct SorterFile {$/;"	s	file:
SorterFile	.\src\vdbesort.c	/^typedef struct SorterFile SorterFile;       \/* Temporary file object wrapper *\/$/;"	t	typeref:struct:SorterFile	file:
SorterList	.\src\vdbesort.c	/^struct SorterList {$/;"	s	file:
SorterList	.\src\vdbesort.c	/^typedef struct SorterList SorterList;       \/* In-memory list of records *\/$/;"	t	typeref:struct:SorterList	file:
SorterRecord	.\src\vdbesort.c	/^struct SorterRecord {$/;"	s	file:
SorterRecord	.\src\vdbesort.c	/^typedef struct SorterRecord SorterRecord;   \/* A record being sorted *\/$/;"	t	typeref:struct:SorterRecord	file:
SplitNode	.\ext\rtree\rtree.c	/^static int SplitNode($/;"	f	file:
SqlCollate	.\src\tclsqlite.c	/^struct SqlCollate {$/;"	s	file:
SqlCollate	.\src\tclsqlite.c	/^typedef struct SqlCollate SqlCollate;$/;"	t	typeref:struct:SqlCollate	file:
SqlFunc	.\src\tclsqlite.c	/^struct SqlFunc {$/;"	s	file:
SqlFunc	.\src\tclsqlite.c	/^typedef struct SqlFunc SqlFunc;$/;"	t	typeref:struct:SqlFunc	file:
SqlMessage	.\src\test_server.c	/^struct SqlMessage {$/;"	s	file:
SqlMessage	.\src\test_server.c	/^typedef struct SqlMessage SqlMessage;$/;"	t	typeref:struct:SqlMessage	file:
SqlPreparedStmt	.\src\tclsqlite.c	/^struct SqlPreparedStmt {$/;"	s	file:
SqlPreparedStmt	.\src\tclsqlite.c	/^typedef struct SqlPreparedStmt SqlPreparedStmt;$/;"	t	typeref:struct:SqlPreparedStmt	file:
SqlThread	.\src\test_thread.c	/^struct SqlThread {$/;"	s	file:
SqlThread	.\src\test_thread.c	/^typedef struct SqlThread SqlThread;$/;"	t	typeref:struct:SqlThread	file:
Sqlite	.\test\threadtest3.c	/^struct Sqlite {$/;"	s	file:
Sqlite	.\test\threadtest3.c	/^typedef struct Sqlite Sqlite;$/;"	t	typeref:struct:Sqlite	file:
Sqlite3Config	.\src\sqliteInt.h	/^struct Sqlite3Config {$/;"	s
Sqlite3_Init	.\src\tclsqlite.c	/^EXTERN int Sqlite3_Init(Tcl_Interp *interp){$/;"	f
Sqlite3_Unload	.\src\tclsqlite.c	/^EXTERN int Sqlite3_Unload(Tcl_Interp *interp, int flags){ return TCL_OK; }$/;"	f
SqliteDb	.\ext\fts5\fts5_tcl.c	/^struct SqliteDb {$/;"	s	file:
SqliteDb	.\src\tclsqlite.c	/^struct SqliteDb {$/;"	s	file:
SqliteDb	.\src\tclsqlite.c	/^typedef struct SqliteDb SqliteDb;$/;"	t	typeref:struct:SqliteDb	file:
SqliteDb	.\src\test1.c	/^struct SqliteDb {$/;"	s	file:
SqliteRbu_Init	.\ext\rbu\test_rbu.c	/^int SqliteRbu_Init(Tcl_Interp *interp){ $/;"	f
SqliteRbu_Init	.\ext\rbu\test_rbu.c	/^int SqliteRbu_Init(Tcl_Interp *interp){ return TCL_OK; }$/;"	f
SqliteSuperlock_Init	.\src\test_superlock.c	/^int SqliteSuperlock_Init(Tcl_Interp *interp){$/;"	f
Sqlite_Init	.\src\tclsqlite.c	/^int Sqlite_Init(Tcl_Interp *interp){ return Sqlite3_Init(interp); }$/;"	f
Sqlite_Unload	.\src\tclsqlite.c	/^int Sqlite_Unload(Tcl_Interp *interp, int flags){ return TCL_OK; }$/;"	f
Sqliteconfig_Init	.\src\test_config.c	/^int Sqliteconfig_Init(Tcl_Interp *interp){$/;"	f
Sqlitemultiplex_Init	.\src\test_multiplex.c	/^int Sqlitemultiplex_Init(Tcl_Interp *interp){$/;"	f
Sqlitequota_Init	.\src\test_quota.c	/^int Sqlitequota_Init(Tcl_Interp *interp){$/;"	f
Sqlitetest1_Init	.\src\test1.c	/^int Sqlitetest1_Init(Tcl_Interp *interp){$/;"	f
Sqlitetest2_Init	.\src\test2.c	/^int Sqlitetest2_Init(Tcl_Interp *interp){$/;"	f
Sqlitetest3_Init	.\src\test3.c	/^int Sqlitetest3_Init(Tcl_Interp *interp){$/;"	f
Sqlitetest4_Init	.\src\test4.c	/^int Sqlitetest4_Init(Tcl_Interp *interp){ return TCL_OK; }$/;"	f
Sqlitetest4_Init	.\src\test4.c	/^int Sqlitetest4_Init(Tcl_Interp *interp){$/;"	f
Sqlitetest5_Init	.\src\test5.c	/^int Sqlitetest5_Init(Tcl_Interp *interp){$/;"	f
Sqlitetest6_Init	.\src\test6.c	/^int Sqlitetest6_Init(Tcl_Interp *interp){$/;"	f
Sqlitetest7_Init	.\src\test7.c	/^int Sqlitetest7_Init(Tcl_Interp *interp){ return TCL_OK; }$/;"	f
Sqlitetest7_Init	.\src\test7.c	/^int Sqlitetest7_Init(Tcl_Interp *interp){$/;"	f
Sqlitetest8_Init	.\src\test8.c	/^int Sqlitetest8_Init(Tcl_Interp *interp){$/;"	f
Sqlitetest9_Init	.\src\test9.c	/^int Sqlitetest9_Init(Tcl_Interp *interp){$/;"	f
SqlitetestOnefile_Init	.\src\test_onefile.c	/^  int SqlitetestOnefile_Init() {return fs_register();}$/;"	f
SqlitetestOsinst_Init	.\src\test_osinst.c	/^int SqlitetestOsinst_Init(Tcl_Interp *interp){$/;"	f
SqlitetestSyscall_Init	.\src\test_syscall.c	/^int SqlitetestSyscall_Init(Tcl_Interp *interp){$/;"	f
SqlitetestThread_Init	.\src\test_thread.c	/^int SqlitetestThread_Init(Tcl_Interp *interp){$/;"	f
Sqlitetest_autoext_Init	.\src\test_autoext.c	/^int Sqlitetest_autoext_Init(Tcl_Interp *interp){$/;"	f
Sqlitetest_blob_Init	.\src\test_blob.c	/^int Sqlitetest_blob_Init(Tcl_Interp *interp){$/;"	f
Sqlitetest_demovfs_Init	.\src\test_demovfs.c	/^int Sqlitetest_demovfs_Init(Tcl_Interp *interp){ return TCL_OK; }$/;"	f
Sqlitetest_demovfs_Init	.\src\test_demovfs.c	/^int Sqlitetest_demovfs_Init(Tcl_Interp *interp){$/;"	f
Sqlitetest_func_Init	.\src\test_func.c	/^int Sqlitetest_func_Init(Tcl_Interp *interp){$/;"	f
Sqlitetest_hexio_Init	.\src\test_hexio.c	/^int Sqlitetest_hexio_Init(Tcl_Interp *interp){$/;"	f
Sqlitetest_init_Init	.\src\test_init.c	/^int Sqlitetest_init_Init(Tcl_Interp *interp){$/;"	f
Sqlitetest_malloc_Init	.\src\test_malloc.c	/^int Sqlitetest_malloc_Init(Tcl_Interp *interp){$/;"	f
Sqlitetest_mutex_Init	.\src\test_mutex.c	/^int Sqlitetest_mutex_Init(Tcl_Interp *interp){$/;"	f
Sqlitetestasync_Init	.\src\test_async.c	/^int Sqlitetestasync_Init(Tcl_Interp *interp){$/;"	f
Sqlitetestbackup_Init	.\src\test_backup.c	/^int Sqlitetestbackup_Init(Tcl_Interp *interp){$/;"	f
Sqlitetestfs_Init	.\src\test_fs.c	/^int Sqlitetestfs_Init(Tcl_Interp *interp){$/;"	f
Sqlitetestfts3_Init	.\ext\fts3\fts3_test.c	/^int Sqlitetestfts3_Init(Tcl_Interp *interp){$/;"	f
Sqlitetestintarray_Init	.\src\test_intarray.c	/^int Sqlitetestintarray_Init(Tcl_Interp *interp){$/;"	f
Sqlitetestrtree_Init	.\src\test_rtree.c	/^int Sqlitetestrtree_Init(Tcl_Interp *interp){$/;"	f
Sqlitetestschema_Init	.\src\test_schema.c	/^int Sqlitetestschema_Init(Tcl_Interp *interp){$/;"	f
Sqlitetesttclvar_Init	.\src\test_tclvar.c	/^int Sqlitetesttclvar_Init(Tcl_Interp *interp){$/;"	f
Sqlitetestvfs_Init	.\src\test_vfs.c	/^int Sqlitetestvfs_Init(Tcl_Interp *interp){$/;"	f
SrcCount	.\src\expr.c	/^struct SrcCount {$/;"	s	file:
SrcList	.\src\sqliteInt.h	/^struct SrcList {$/;"	s
SrcList	.\src\sqliteInt.h	/^typedef struct SrcList SrcList;$/;"	t	typeref:struct:SrcList
SrcList_item	.\src\sqliteInt.h	/^  struct SrcList_item {$/;"	s	struct:SrcList
Stat4Accum	.\src\analyze.c	/^struct Stat4Accum {$/;"	s	file:
Stat4Accum	.\src\analyze.c	/^typedef struct Stat4Accum Stat4Accum;$/;"	t	typeref:struct:Stat4Accum	file:
Stat4Sample	.\src\analyze.c	/^struct Stat4Sample {$/;"	s	file:
Stat4Sample	.\src\analyze.c	/^typedef struct Stat4Sample Stat4Sample;$/;"	t	typeref:struct:Stat4Sample	file:
StatCell	.\src\dbstat.c	/^struct StatCell {$/;"	s	file:
StatCell	.\src\dbstat.c	/^typedef struct StatCell StatCell;$/;"	t	typeref:struct:StatCell	file:
StatCursor	.\src\dbstat.c	/^struct StatCursor {$/;"	s	file:
StatCursor	.\src\dbstat.c	/^typedef struct StatCursor StatCursor;$/;"	t	typeref:struct:StatCursor	file:
StatPage	.\src\dbstat.c	/^struct StatPage {$/;"	s	file:
StatPage	.\src\dbstat.c	/^typedef struct StatPage StatPage;$/;"	t	typeref:struct:StatPage	file:
StatTable	.\src\dbstat.c	/^struct StatTable {$/;"	s	file:
StatTable	.\src\dbstat.c	/^typedef struct StatTable StatTable;$/;"	t	typeref:struct:StatTable	file:
State_arrayof	.\tool\lemon.c	/^struct state **State_arrayof()$/;"	f
State_find	.\tool\lemon.c	/^struct state *State_find(struct config *key)$/;"	f
State_init	.\tool\lemon.c	/^void State_init(){$/;"	f
State_insert	.\tool\lemon.c	/^int State_insert(struct state *data, struct config *key)$/;"	f
State_new	.\tool\lemon.c	/^struct state *State_new()$/;"	f
Statement	.\test\fuzz_common.tcl	/^proc Statement {} {$/;"	p
Statement	.\test\threadtest3.c	/^struct Statement {$/;"	s	file:
Statement	.\test\threadtest3.c	/^typedef struct Statement Statement;$/;"	t	typeref:struct:Statement	file:
StmtToDb	.\src\test1.c	134;"	d	file:
Str	.\tool\sqldiff.c	/^struct Str {$/;"	s	file:
Str	.\tool\sqldiff.c	/^typedef struct Str Str;$/;"	t	typeref:struct:Str	file:
StrAccum	.\src\sqliteInt.h	/^struct StrAccum {$/;"	s
StrAccum	.\src\sqliteInt.h	/^typedef struct StrAccum StrAccum;$/;"	t	typeref:struct:StrAccum
StrBuffer	.\ext\fts3\fts3_snippet.c	/^struct StrBuffer {$/;"	s	file:
StrBuffer	.\ext\fts3\fts3_snippet.c	/^typedef struct StrBuffer StrBuffer;$/;"	t	typeref:struct:StrBuffer	file:
Stress2Ctx	.\test\tt3_stress.c	/^struct Stress2Ctx {$/;"	s	file:
Stress2Ctx	.\test\tt3_stress.c	/^typedef struct Stress2Ctx Stress2Ctx;$/;"	t	typeref:struct:Stress2Ctx	file:
String	.\mptest\mptest.c	/^struct String {$/;"	s	file:
String	.\mptest\mptest.c	/^typedef struct String String;$/;"	t	typeref:struct:String	file:
StringBuffer	.\ext\fts1\fts1.c	/^typedef struct StringBuffer {$/;"	s	file:
StringBuffer	.\ext\fts1\fts1.c	/^} StringBuffer;$/;"	t	typeref:struct:StringBuffer	file:
StringBuffer	.\ext\fts2\fts2.c	/^typedef struct StringBuffer {$/;"	s	file:
StringBuffer	.\ext\fts2\fts2.c	/^} StringBuffer;$/;"	t	typeref:struct:StringBuffer	file:
Stringify	.\src\vdbe.c	148;"	d	file:
Strsafe	.\tool\lemon.c	/^const char *Strsafe(const char *y)$/;"	f
Strsafe_find	.\tool\lemon.c	/^const char *Strsafe_find(const char *key)$/;"	f
Strsafe_init	.\tool\lemon.c	/^void Strsafe_init(){$/;"	f
Strsafe_insert	.\tool\lemon.c	/^int Strsafe_insert(const char *data)$/;"	f
SubProgram	.\src\vdbe.h	/^struct SubProgram {$/;"	s
SubProgram	.\src\vdbe.h	/^typedef struct SubProgram SubProgram;$/;"	t	typeref:struct:SubProgram
SubstituteFile	.\autoconf\tea\win\nmakehlp.c	/^SubstituteFile($/;"	f	file:
SumCtx	.\src\func.c	/^struct SumCtx {$/;"	s	file:
SumCtx	.\src\func.c	/^typedef struct SumCtx SumCtx;$/;"	t	typeref:struct:SumCtx	file:
Superlock	.\src\test_superlock.c	/^struct Superlock {$/;"	s	file:
Superlock	.\src\test_superlock.c	/^typedef struct Superlock Superlock;$/;"	t	typeref:struct:Superlock	file:
SuperlockBusy	.\src\test_superlock.c	/^struct SuperlockBusy {$/;"	s	file:
SuperlockBusy	.\src\test_superlock.c	/^typedef struct SuperlockBusy SuperlockBusy;$/;"	t	typeref:struct:SuperlockBusy	file:
Symbol_Nth	.\tool\lemon.c	/^struct symbol *Symbol_Nth(int n)$/;"	f
Symbol_arrayof	.\tool\lemon.c	/^struct symbol **Symbol_arrayof()$/;"	f
Symbol_count	.\tool\lemon.c	/^int Symbol_count()$/;"	f
Symbol_find	.\tool\lemon.c	/^struct symbol *Symbol_find(const char *key)$/;"	f
Symbol_init	.\tool\lemon.c	/^void Symbol_init(){$/;"	f
Symbol_insert	.\tool\lemon.c	/^int Symbol_insert(struct symbol *data, const char *key)$/;"	f
Symbol_new	.\tool\lemon.c	/^struct symbol *Symbol_new(const char *x)$/;"	f
Symbolcmpp	.\tool\lemon.c	/^int Symbolcmpp(const void *_a, const void *_b)$/;"	f
TCCX	.\main.mk	/^TCCX =  $(TCC) $(OPTS) -I. -I$(TOP)\/src -I$(TOP) $/;"	m
TCLSH_MAIN	.\src\tclsqlite.c	/^int TCLSH_MAIN(int argc, char **argv){$/;"	f
TCLSH_MAIN	.\src\tclsqlite.c	3836;"	d	file:
TCL_STORAGE_CLASS	.\src\tclsqlite.c	69;"	d	file:
TCL_STORAGE_CLASS	.\src\tclsqlite.c	70;"	d	file:
TCL_THREADS	.\src\test_async.c	17;"	d	file:
TEMP_MASTER_NAME	.\src\sqliteInt.h	835;"	d
TERMINAL	.\tool\lemon.c	/^  TERMINAL,$/;"	e	enum:symbol_type	file:
TERM_ANDINFO	.\src\whereInt.h	269;"	d
TERM_CHUNK_SELECT_STMT	.\ext\fts1\fulltext.c	/^  TERM_CHUNK_SELECT_STMT,$/;"	e	enum:fulltext_statement	file:
TERM_CODED	.\src\whereInt.h	266;"	d
TERM_COPIED	.\src\whereInt.h	267;"	d
TERM_DELETE_STMT	.\ext\fts1\fts1.c	/^  TERM_DELETE_STMT,$/;"	e	enum:fulltext_statement	file:
TERM_DELETE_STMT	.\ext\fts1\fulltext.c	/^  TERM_DELETE_STMT,$/;"	e	enum:fulltext_statement	file:
TERM_DYNAMIC	.\src\whereInt.h	264;"	d
TERM_INSERT_STMT	.\ext\fts1\fts1.c	/^  TERM_INSERT_STMT,$/;"	e	enum:fulltext_statement	file:
TERM_INSERT_STMT	.\ext\fts1\fulltext.c	/^  TERM_INSERT_STMT,$/;"	e	enum:fulltext_statement	file:
TERM_IS	.\src\whereInt.h	279;"	d
TERM_LIKE	.\src\whereInt.h	278;"	d
TERM_LIKECOND	.\src\whereInt.h	277;"	d
TERM_LIKEOPT	.\src\whereInt.h	276;"	d
TERM_ORINFO	.\src\whereInt.h	268;"	d
TERM_OR_OK	.\src\whereInt.h	270;"	d
TERM_SELECT_ALL_STMT	.\ext\fts1\fts1.c	/^  TERM_SELECT_ALL_STMT,$/;"	e	enum:fulltext_statement	file:
TERM_SELECT_STMT	.\ext\fts1\fts1.c	/^  TERM_SELECT_STMT,$/;"	e	enum:fulltext_statement	file:
TERM_SELECT_STMT	.\ext\fts1\fulltext.c	/^  TERM_SELECT_STMT,$/;"	e	enum:fulltext_statement	file:
TERM_UPDATE_STMT	.\ext\fts1\fts1.c	/^  TERM_UPDATE_STMT,$/;"	e	enum:fulltext_statement	file:
TERM_UPDATE_STMT	.\ext\fts1\fulltext.c	/^  TERM_UPDATE_STMT,$/;"	e	enum:fulltext_statement	file:
TERM_VIRTUAL	.\src\whereInt.h	265;"	d
TERM_VNULL	.\src\whereInt.h	272;"	d
TERM_VNULL	.\src\whereInt.h	274;"	d
TESTBIT	.\src\bitvec.c	304;"	d	file:
TESTFIXTURE_FLAGS	.\main.mk	/^TESTFIXTURE_FLAGS  = -DSQLITE_TEST=1 -DSQLITE_CRASH_TEST=1$/;"	m
TESTONLY	.\ext\async\sqlite3async.c	167;"	d	file:
TESTONLY	.\ext\async\sqlite3async.c	169;"	d	file:
TESTONLY	.\ext\fts3\fts3Int.h	174;"	d
TESTONLY	.\ext\fts3\fts3Int.h	176;"	d
TESTONLY	.\src\sqliteInt.h	345;"	d
TESTONLY	.\src\sqliteInt.h	347;"	d
TESTOPTS	.\main.mk	/^TESTOPTS = --verbose=file --output=test-out.txt$/;"	m
TESTPCACHE_CLEAR	.\src\test_pcache.c	95;"	d	file:
TESTPCACHE_NPAGE	.\src\test_pcache.c	85;"	d	file:
TESTPCACHE_NPAGE	.\src\test_pcache.c	87;"	d	file:
TESTPCACHE_RESERVE	.\src\test_pcache.c	89;"	d	file:
TESTPCACHE_VALID	.\src\test_pcache.c	94;"	d	file:
TESTPROGS	.\main.mk	/^TESTPROGS = \\$/;"	m
TESTSRC	.\main.mk	/^TESTSRC = \\$/;"	m
TESTSRC2	.\main.mk	/^TESTSRC2 = \\$/;"	m
TESTVFS_ACCESS_MASK	.\src\test_vfs.c	126;"	d	file:
TESTVFS_ALL_MASK	.\src\test_vfs.c	133;"	d	file:
TESTVFS_CKLOCK_MASK	.\src\test_vfs.c	131;"	d	file:
TESTVFS_CLOSE_MASK	.\src\test_vfs.c	123;"	d	file:
TESTVFS_DELETE_MASK	.\src\test_vfs.c	122;"	d	file:
TESTVFS_FULLPATHNAME_MASK	.\src\test_vfs.c	127;"	d	file:
TESTVFS_LOCK_MASK	.\src\test_vfs.c	130;"	d	file:
TESTVFS_MAX_ARGS	.\src\test_vfs.c	154;"	d	file:
TESTVFS_MAX_PAGES	.\src\test_vfs.c	136;"	d	file:
TESTVFS_OPEN_MASK	.\src\test_vfs.c	120;"	d	file:
TESTVFS_READ_MASK	.\src\test_vfs.c	128;"	d	file:
TESTVFS_SHMBARRIER_MASK	.\src\test_vfs.c	117;"	d	file:
TESTVFS_SHMCLOSE_MASK	.\src\test_vfs.c	118;"	d	file:
TESTVFS_SHMLOCK_MASK	.\src\test_vfs.c	115;"	d	file:
TESTVFS_SHMMAP_MASK	.\src\test_vfs.c	116;"	d	file:
TESTVFS_SHMOPEN_MASK	.\src\test_vfs.c	114;"	d	file:
TESTVFS_SYNC_MASK	.\src\test_vfs.c	121;"	d	file:
TESTVFS_TRUNCATE_MASK	.\src\test_vfs.c	125;"	d	file:
TESTVFS_UNLOCK_MASK	.\src\test_vfs.c	129;"	d	file:
TESTVFS_WRITE_MASK	.\src\test_vfs.c	124;"	d	file:
TEST_EXTENSION	.\main.mk	/^TEST_EXTENSION = $(SHPREFIX)testloadext.$(SO)$/;"	m
TF_Autoincrement	.\src\sqliteInt.h	1685;"	d
TF_Ephemeral	.\src\sqliteInt.h	1683;"	d
TF_HasPrimaryKey	.\src\sqliteInt.h	1684;"	d
TF_NoVisibleRowid	.\src\sqliteInt.h	1688;"	d
TF_OOOHidden	.\src\sqliteInt.h	1689;"	d
TF_Readonly	.\src\sqliteInt.h	1682;"	d
TF_Virtual	.\src\sqliteInt.h	1686;"	d
TF_WithoutRowid	.\src\sqliteInt.h	1687;"	d
THREADTEST3_SRC	.\main.mk	/^THREADTEST3_SRC = $(TOP)\/test\/threadtest3.c    \\$/;"	m
THREE_BYTE_INT	.\src\vdbeaux.c	3106;"	d	file:
TIMER_ELAPSED	.\src\os_common.h	48;"	d
TIMER_ELAPSED	.\src\os_common.h	52;"	d
TIMER_END	.\src\os_common.h	47;"	d
TIMER_END	.\src\os_common.h	51;"	d
TIMER_START	.\src\os_common.h	46;"	d
TIMER_START	.\src\os_common.h	50;"	d
TOKEN	.\src\lempar.c	694;"	d	file:
TOKEN	.\tool\lempar.c	683;"	d	file:
TOKEN_EOF	.\ext\fts1\fts1.c	1531;"	d	file:
TOKEN_EOF	.\ext\fts2\fts2.c	2399;"	d	file:
TOKEN_ID	.\ext\fts1\fts1.c	1533;"	d	file:
TOKEN_ID	.\ext\fts2\fts2.c	2401;"	d	file:
TOKEN_PUNCT	.\ext\fts1\fts1.c	1535;"	d	file:
TOKEN_PUNCT	.\ext\fts2\fts2.c	2403;"	d	file:
TOKEN_SPACE	.\ext\fts1\fts1.c	1532;"	d	file:
TOKEN_SPACE	.\ext\fts2\fts2.c	2400;"	d	file:
TOKEN_STRING	.\ext\fts1\fts1.c	1534;"	d	file:
TOKEN_STRING	.\ext\fts2\fts2.c	2402;"	d	file:
TOP	.\main.mk	/^	TOP=$(TOP) sh $(TOP)\/tool\/mkautoconfamal.sh$/;"	m
TOTYPE_BIGENDIAN	.\ext\misc\totype.c	46;"	d	file:
TOTYPE_LITTLEENDIAN	.\ext\misc\totype.c	47;"	d	file:
TRACE	.\ext\fts1\fts1.c	60;"	d	file:
TRACE	.\ext\fts2\fts2.c	333;"	d	file:
TRACE	.\src\btree.c	32;"	d	file:
TRACE_IDX_INPUTS	.\src\where.c	/^static void TRACE_IDX_INPUTS(sqlite3_index_info *p){$/;"	f	file:
TRACE_IDX_INPUTS	.\src\where.c	568;"	d	file:
TRACE_IDX_OUTPUTS	.\src\where.c	/^static void TRACE_IDX_OUTPUTS(sqlite3_index_info *p){$/;"	f	file:
TRACE_IDX_OUTPUTS	.\src\where.c	569;"	d	file:
TRANS_NONE	.\src\btreeInt.h	375;"	d
TRANS_READ	.\src\btreeInt.h	376;"	d
TRANS_WRITE	.\src\btreeInt.h	377;"	d
TRIGGER	.\tool\mkkeywordhash.c	116;"	d	file:
TRIGGER	.\tool\mkkeywordhash.c	118;"	d	file:
TRIGGER_AFTER	.\src\sqliteInt.h	2837;"	d
TRIGGER_BEFORE	.\src\sqliteInt.h	2836;"	d
TT4_SERIALIZED	.\test\threadtest4.c	61;"	d	file:
TT4_TRACE	.\test\threadtest4.c	63;"	d	file:
TT4_WAL	.\test\threadtest4.c	62;"	d	file:
TWOPOWER31	.\src\util.c	1246;"	d	file:
TWOPOWER32	.\src\util.c	1245;"	d	file:
TWO_BYTE_INT	.\src\vdbeaux.c	3105;"	d	file:
TabResult	.\src\table.c	/^typedef struct TabResult {$/;"	s	file:
TabResult	.\src\table.c	/^} TabResult;$/;"	t	typeref:struct:TabResult	file:
Table	.\src\sqliteInt.h	/^struct Table {$/;"	s
Table	.\src\sqliteInt.h	/^typedef struct Table Table;$/;"	t	typeref:struct:Table
Table	.\test\fuzz_common.tcl	/^proc Table {} {$/;"	p
TableLock	.\src\build.c	/^struct TableLock {$/;"	s	file:
TableLock	.\src\sqliteInt.h	/^typedef struct TableLock TableLock;$/;"	t	typeref:struct:TableLock
TableSpec	.\ext\fts1\fts1.c	/^typedef struct TableSpec {$/;"	s	file:
TableSpec	.\ext\fts1\fts1.c	/^} TableSpec;$/;"	t	typeref:struct:TableSpec	file:
TableSpec	.\ext\fts2\fts2.c	/^typedef struct TableSpec {$/;"	s	file:
TableSpec	.\ext\fts2\fts2.c	/^} TableSpec;$/;"	t	typeref:struct:TableSpec	file:
TclQuotaCallback	.\src\test_quota.c	/^struct TclQuotaCallback {$/;"	s	file:
TclQuotaCallback	.\src\test_quota.c	/^typedef struct TclQuotaCallback TclQuotaCallback;$/;"	t	typeref:struct:TclQuotaCallback	file:
Tcl_InitStubs	.\src\tclsqlite.c	3103;"	d	file:
Tcl_InitStubs	.\src\tclsqlite.c	3104;"	d	file:
Tcl_NRAddCallback	.\src\tclsqlite.c	1549;"	d	file:
Tcl_NRCreateCommand	.\src\tclsqlite.c	1551;"	d	file:
Tcl_NREvalObj	.\src\tclsqlite.c	1550;"	d	file:
Tclsqlite3_Init	.\src\tclsqlite.c	/^EXTERN int Tclsqlite3_Init(Tcl_Interp *interp){ return Sqlite3_Init(interp); }$/;"	f
Tclsqlite3_Unload	.\src\tclsqlite.c	/^EXTERN int Tclsqlite3_Unload(Tcl_Interp *interp, int flags){ return TCL_OK; }$/;"	f
Tclsqlite_Init	.\src\tclsqlite.c	/^int Tclsqlite_Init(Tcl_Interp *interp){ return Sqlite3_Init(interp); }$/;"	f
Tclsqlite_Unload	.\src\tclsqlite.c	/^int Tclsqlite_Unload(Tcl_Interp *interp, int flags){ return TCL_OK; }$/;"	f
TermData	.\ext\fts2\fts2.c	/^typedef struct TermData {$/;"	s	file:
TermData	.\ext\fts2\fts2.c	/^} TermData;$/;"	t	typeref:struct:TermData	file:
TermOffset	.\ext\fts3\fts3_snippet.c	/^struct TermOffset {$/;"	s	file:
TermOffset	.\ext\fts3\fts3_snippet.c	/^typedef struct TermOffset TermOffset;$/;"	t	typeref:struct:TermOffset	file:
TermOffsetCtx	.\ext\fts3\fts3_snippet.c	/^struct TermOffsetCtx {$/;"	s	file:
TermOffsetCtx	.\ext\fts3\fts3_snippet.c	/^typedef struct TermOffsetCtx TermOffsetCtx;$/;"	t	typeref:struct:TermOffsetCtx	file:
TermSelect	.\ext\fts3\fts3.c	/^struct TermSelect {$/;"	s	file:
TermSelect	.\ext\fts3\fts3.c	/^typedef struct TermSelect TermSelect;$/;"	t	typeref:struct:TermSelect	file:
TestAsyncGlobal	.\src\test_async.c	/^struct TestAsyncGlobal {$/;"	s	file:
TestAsyncStaticData	.\ext\async\sqlite3async.c	/^static struct TestAsyncStaticData {$/;"	s	file:
TestCollationX	.\src\test1.c	/^struct TestCollationX {$/;"	s	file:
TestCollationX	.\src\test1.c	/^typedef struct TestCollationX TestCollationX;$/;"	t	typeref:struct:TestCollationX	file:
TestFaultInject	.\src\test_vfs.c	/^struct TestFaultInject {$/;"	s	file:
TestFaultInject	.\src\test_vfs.c	/^typedef struct TestFaultInject TestFaultInject;$/;"	t	typeref:struct:TestFaultInject	file:
TestSyscallArray	.\src\test_syscall.c	/^struct TestSyscallArray {$/;"	s	file:
TestSyscallGlobal	.\src\test_syscall.c	/^static struct TestSyscallGlobal {$/;"	s	file:
Testvfs	.\src\test_vfs.c	/^struct Testvfs {$/;"	s	file:
Testvfs	.\src\test_vfs.c	/^typedef struct Testvfs Testvfs;$/;"	t	typeref:struct:Testvfs	file:
TestvfsBuffer	.\src\test_vfs.c	/^struct TestvfsBuffer {$/;"	s	file:
TestvfsBuffer	.\src\test_vfs.c	/^typedef struct TestvfsBuffer TestvfsBuffer;$/;"	t	typeref:struct:TestvfsBuffer	file:
TestvfsFd	.\src\test_vfs.c	/^struct TestvfsFd {$/;"	s	file:
TestvfsFd	.\src\test_vfs.c	/^typedef struct TestvfsFd TestvfsFd;$/;"	t	typeref:struct:TestvfsFd	file:
TestvfsFile	.\src\test_vfs.c	/^struct TestvfsFile {$/;"	s	file:
TestvfsFile	.\src\test_vfs.c	/^typedef struct TestvfsFile TestvfsFile;$/;"	t	typeref:struct:TestvfsFile	file:
TestvfsShm	.\src\test_vfs.c	/^typedef struct TestvfsShm TestvfsShm;$/;"	t	typeref:struct:TestvfsShm	file:
Thread	.\src\test4.c	/^struct Thread {$/;"	s	file:
Thread	.\src\test4.c	/^typedef struct Thread Thread;$/;"	t	typeref:struct:Thread	file:
Thread	.\src\test7.c	/^struct Thread {$/;"	s	file:
Thread	.\src\test7.c	/^typedef struct Thread Thread;$/;"	t	typeref:struct:Thread	file:
Thread	.\test\threadtest3.c	/^struct Thread {$/;"	s	file:
Thread	.\test\threadtest3.c	/^typedef struct Thread Thread;$/;"	t	typeref:struct:Thread	file:
Threadset	.\test\threadtest3.c	/^struct Threadset {$/;"	s	file:
Threadset	.\test\threadtest3.c	/^typedef struct Threadset Threadset;$/;"	t	typeref:struct:Threadset	file:
ToLower	.\src\shell.c	137;"	d	file:
Token	.\ext\fts1\fts1.c	/^typedef struct Token {$/;"	s	file:
Token	.\ext\fts1\fts1.c	/^} Token;$/;"	t	typeref:struct:Token	file:
Token	.\ext\fts2\fts2.c	/^typedef struct Token {$/;"	s	file:
Token	.\ext\fts2\fts2.c	/^} Token;$/;"	t	typeref:struct:Token	file:
Token	.\src\sqliteInt.h	/^struct Token {$/;"	s
Token	.\src\sqliteInt.h	/^typedef struct Token Token;$/;"	t	typeref:struct:Token
TokenCtx	.\ext\fts5\fts5_expr.c	/^struct TokenCtx {$/;"	s	file:
TokenCtx	.\ext\fts5\fts5_expr.c	/^typedef struct TokenCtx TokenCtx;$/;"	t	typeref:struct:TokenCtx	file:
TokenDoclist	.\ext\fts3\fts3.c	/^struct TokenDoclist {$/;"	s	file:
TokenDoclist	.\ext\fts3\fts3.c	/^typedef struct TokenDoclist TokenDoclist;$/;"	t	typeref:struct:TokenDoclist	file:
TreeView	.\src\sqliteInt.h	/^struct TreeView {$/;"	s
TreeView	.\src\sqliteInt.h	/^typedef struct TreeView TreeView;$/;"	t	typeref:struct:TreeView
Trigger	.\src\sqliteInt.h	/^struct Trigger {$/;"	s
Trigger	.\src\sqliteInt.h	/^typedef struct Trigger Trigger;$/;"	t	typeref:struct:Trigger
TriggerPrg	.\src\sqliteInt.h	/^struct TriggerPrg {$/;"	s
TriggerPrg	.\src\sqliteInt.h	/^typedef struct TriggerPrg TriggerPrg;$/;"	t	typeref:struct:TriggerPrg
TriggerStep	.\src\sqliteInt.h	/^struct TriggerStep {$/;"	s
TriggerStep	.\src\sqliteInt.h	/^typedef struct TriggerStep TriggerStep;$/;"	t	typeref:struct:TriggerStep
UAUTH_Admin	.\src\sqliteInt.h	1113;"	d
UAUTH_Fail	.\src\sqliteInt.h	1111;"	d
UAUTH_Unknown	.\src\sqliteInt.h	1110;"	d
UAUTH_User	.\src\sqliteInt.h	1112;"	d
UINT16_TYPE	.\src\sqliteInt.h	576;"	d
UINT16_TYPE	.\src\sqliteInt.h	578;"	d
UINT32_TYPE	.\src\sqliteInt.h	569;"	d
UINT32_TYPE	.\src\sqliteInt.h	571;"	d
UINT8_TYPE	.\src\sqliteInt.h	590;"	d
UINT8_TYPE	.\src\sqliteInt.h	592;"	d
UNICODE_STRING_MAX_CHARS	.\src\os_win.c	110;"	d	file:
UNIXFILE_BLOCK	.\src\os_unix.c	262;"	d	file:
UNIXFILE_DELETE	.\src\os_unix.c	258;"	d	file:
UNIXFILE_DIRSYNC	.\src\os_unix.c	253;"	d	file:
UNIXFILE_DIRSYNC	.\src\os_unix.c	255;"	d	file:
UNIXFILE_EXCL	.\src\os_unix.c	249;"	d	file:
UNIXFILE_NOLOCK	.\src\os_unix.c	260;"	d	file:
UNIXFILE_PERSIST_WAL	.\src\os_unix.c	251;"	d	file:
UNIXFILE_PSOW	.\src\os_unix.c	257;"	d	file:
UNIXFILE_RDONLY	.\src\os_unix.c	250;"	d	file:
UNIXFILE_URI	.\src\os_unix.c	259;"	d	file:
UNIXFILE_WARNED	.\src\os_unix.c	261;"	d	file:
UNIXVFS	.\src\os_unix.c	7483;"	d	file:
UNIX_SHM_BASE	.\src\os_unix.c	4098;"	d	file:
UNIX_SHM_DMS	.\src\os_unix.c	4099;"	d	file:
UNK	.\tool\lemon.c	/^    UNK$/;"	e	enum:e_assoc	file:
UNKNOWN_LOCK	.\src\pager.c	407;"	d	file:
UNUSED_PARAM	.\ext\misc\json1.c	34;"	d	file:
UNUSED_PARAMETER	.\ext\async\sqlite3async.c	33;"	d	file:
UNUSED_PARAMETER	.\ext\fts3\fts3Int.h	159;"	d
UNUSED_PARAMETER	.\ext\rtree\rtree.c	79;"	d	file:
UNUSED_PARAMETER	.\mptest\mptest.c	64;"	d	file:
UNUSED_PARAMETER	.\src\shell.c	318;"	d	file:
UNUSED_PARAMETER	.\src\sqliteInt.h	910;"	d
UNUSED_PARAMETER	.\src\test_multiplex.c	67;"	d	file:
UNUSED_PARAMETER2	.\src\sqliteInt.h	911;"	d
UNUSED_VARIABLE_VALUE	.\src\os_win.c	159;"	d	file:
UPDATE_MAX_BLOBSIZE	.\src\vdbe.c	105;"	d	file:
UPDATE_MAX_BLOBSIZE	.\src\vdbe.c	107;"	d	file:
USEFETCH	.\src\pager.c	789;"	d	file:
USEFETCH	.\src\pager.c	791;"	d	file:
UnaryOp	.\test\fuzz_common.tcl	/^proc UnaryOp {} {$/;"	p
Unicode61Tokenizer	.\ext\fts5\fts5_tokenize.c	/^struct Unicode61Tokenizer {$/;"	s	file:
Unicode61Tokenizer	.\ext\fts5\fts5_tokenize.c	/^typedef struct Unicode61Tokenizer Unicode61Tokenizer;$/;"	t	typeref:struct:Unicode61Tokenizer	file:
UnixUnusedFd	.\src\os_unix.c	/^struct UnixUnusedFd {$/;"	s	file:
UnixUnusedFd	.\src\os_unix.c	/^typedef struct UnixUnusedFd UnixUnusedFd;     \/* An unused file descriptor *\/$/;"	t	typeref:struct:UnixUnusedFd	file:
UnlockNotification	.\src\test_thread.c	/^struct UnlockNotification {$/;"	s	file:
UnlockNotification	.\src\test_thread.c	/^typedef struct UnlockNotification UnlockNotification;$/;"	t	typeref:struct:UnlockNotification	file:
UnpackedRecord	.\src\sqliteInt.h	/^struct UnpackedRecord {$/;"	s
UnpackedRecord	.\src\sqliteInt.h	/^typedef struct UnpackedRecord UnpackedRecord;$/;"	t	typeref:struct:UnpackedRecord
Update	.\test\fuzz_common.tcl	/^proc Update {} {$/;"	p
UpperToLower	.\src\util.c	238;"	d	file:
UpperToLower	.\tool\mkkeywordhash.c	300;"	d	file:
Utf8Read	.\src\func.c	584;"	d	file:
Utf8Read	.\src\func.c	586;"	d	file:
VACUUM	.\tool\mkkeywordhash.c	122;"	d	file:
VACUUM	.\tool\mkkeywordhash.c	124;"	d	file:
VARINT_MAX	.\ext\fts1\fts1.c	109;"	d	file:
VARINT_MAX	.\ext\fts1\fulltext.c	39;"	d	file:
VARINT_MAX	.\ext\fts2\fts2.c	404;"	d	file:
VDBE_MAGIC_DEAD	.\src\vdbeInt.h	401;"	d
VDBE_MAGIC_HALT	.\src\vdbeInt.h	400;"	d
VDBE_MAGIC_INIT	.\src\vdbeInt.h	398;"	d
VDBE_MAGIC_RUN	.\src\vdbeInt.h	399;"	d
VDBE_OFFSET_LINENO	.\src\vdbe.h	284;"	d
VDBE_OFFSET_LINENO	.\src\vdbe.h	290;"	d
VFSLOG_BUFFERSIZE	.\src\test_osinst.c	115;"	d	file:
VFUNCTION	.\src\sqliteInt.h	1440;"	d
VFile	.\test\fuzzcheck.c	/^struct VFile {$/;"	s	file:
VFile	.\test\fuzzcheck.c	/^typedef struct VFile VFile;$/;"	t	typeref:struct:VFile	file:
VHandle	.\test\fuzzcheck.c	/^struct VHandle {$/;"	s	file:
VHandle	.\test\fuzzcheck.c	/^typedef struct VHandle VHandle;$/;"	t	typeref:struct:VHandle	file:
VHandleMethods	.\test\fuzzcheck.c	/^static sqlite3_io_methods VHandleMethods = {$/;"	v	file:
VIEW	.\tool\mkkeywordhash.c	127;"	d	file:
VIEW	.\tool\mkkeywordhash.c	129;"	d	file:
VLogFile	.\ext\misc\vfslog.c	/^struct VLogFile {$/;"	s	file:
VLogFile	.\ext\misc\vfslog.c	/^typedef struct VLogFile VLogFile;$/;"	t	typeref:struct:VLogFile	file:
VLogLog	.\ext\misc\vfslog.c	/^struct VLogLog {$/;"	s	file:
VLogLog	.\ext\misc\vfslog.c	/^typedef struct VLogLog VLogLog;$/;"	t	typeref:struct:VLogLog	file:
VLogVfs	.\ext\misc\vfslog.c	/^struct VLogVfs {$/;"	s	file:
VLogVfs	.\ext\misc\vfslog.c	/^typedef struct VLogVfs VLogVfs;$/;"	t	typeref:struct:VLogVfs	file:
VTAB	.\tool\mkkeywordhash.c	132;"	d	file:
VTAB	.\tool\mkkeywordhash.c	134;"	d	file:
VTAB_SCHEMA	.\src\dbstat.c	59;"	d	file:
VTSHIM_COPY_ERRMSG	.\ext\misc\vtshim.c	62;"	d	file:
VTable	.\src\sqliteInt.h	/^struct VTable {$/;"	s
VTable	.\src\sqliteInt.h	/^typedef struct VTable VTable;$/;"	t	typeref:struct:VTable
VVA_ONLY	.\src\sqliteInt.h	359;"	d
VVA_ONLY	.\src\sqliteInt.h	361;"	d
ValueNewStat4Ctx	.\src\vdbemem.c	/^struct ValueNewStat4Ctx {$/;"	s	file:
Vdbe	.\src\vdbe.h	/^typedef struct Vdbe Vdbe;$/;"	t	typeref:struct:Vdbe
Vdbe	.\src\vdbeInt.h	/^struct Vdbe {$/;"	s
VdbeBranchTaken	.\src\vdbe.c	127;"	d	file:
VdbeBranchTaken	.\src\vdbe.c	129;"	d	file:
VdbeComment	.\src\vdbe.h	242;"	d
VdbeComment	.\src\vdbe.h	251;"	d
VdbeCoverage	.\src\vdbe.h	280;"	d
VdbeCoverage	.\src\vdbe.h	286;"	d
VdbeCoverageAlwaysTaken	.\src\vdbe.h	282;"	d
VdbeCoverageAlwaysTaken	.\src\vdbe.h	288;"	d
VdbeCoverageIf	.\src\vdbe.h	281;"	d
VdbeCoverageIf	.\src\vdbe.h	287;"	d
VdbeCoverageNeverTaken	.\src\vdbe.h	283;"	d
VdbeCoverageNeverTaken	.\src\vdbe.h	289;"	d
VdbeCursor	.\src\vdbeInt.h	/^struct VdbeCursor {$/;"	s
VdbeCursor	.\src\vdbeInt.h	/^typedef struct VdbeCursor VdbeCursor;$/;"	t	typeref:struct:VdbeCursor
VdbeFrame	.\src\vdbeInt.h	/^struct VdbeFrame {$/;"	s
VdbeFrame	.\src\vdbeInt.h	/^typedef struct VdbeFrame VdbeFrame;$/;"	t	typeref:struct:VdbeFrame
VdbeFrameMem	.\src\vdbeInt.h	155;"	d
VdbeMemDynamic	.\src\vdbeInt.h	454;"	d
VdbeModuleComment	.\src\vdbe.h	246;"	d
VdbeModuleComment	.\src\vdbe.h	248;"	d
VdbeModuleComment	.\src\vdbe.h	253;"	d
VdbeNoopComment	.\src\vdbe.h	244;"	d
VdbeNoopComment	.\src\vdbe.h	252;"	d
VdbeOp	.\src\vdbe.h	/^struct VdbeOp {$/;"	s
VdbeOp	.\src\vdbe.h	/^typedef struct VdbeOp VdbeOp;$/;"	t	typeref:struct:VdbeOp
VdbeOpIter	.\src\vdbeaux.c	/^struct VdbeOpIter {$/;"	s	file:
VdbeOpIter	.\src\vdbeaux.c	/^typedef struct VdbeOpIter VdbeOpIter;$/;"	t	typeref:struct:VdbeOpIter	file:
VdbeOpList	.\src\vdbe.h	/^struct VdbeOpList {$/;"	s
VdbeOpList	.\src\vdbe.h	/^typedef struct VdbeOpList VdbeOpList;$/;"	t	typeref:struct:VdbeOpList
VdbeSorter	.\src\vdbeInt.h	/^typedef struct VdbeSorter VdbeSorter;$/;"	t	typeref:struct:VdbeSorter
VdbeSorter	.\src\vdbesort.c	/^struct VdbeSorter {$/;"	s	file:
VfslogCsr	.\src\test_osinst.c	/^struct VfslogCsr {$/;"	s	file:
VfslogCsr	.\src\test_osinst.c	/^typedef struct VfslogCsr VfslogCsr;$/;"	t	typeref:struct:VfslogCsr	file:
VfslogFile	.\src\test_osinst.c	/^struct VfslogFile {$/;"	s	file:
VfslogFile	.\src\test_osinst.c	/^typedef struct VfslogFile VfslogFile;$/;"	t	typeref:struct:VfslogFile	file:
VfslogVfs	.\src\test_osinst.c	/^struct VfslogVfs {$/;"	s	file:
VfslogVfs	.\src\test_osinst.c	/^typedef struct VfslogVfs VfslogVfs;$/;"	t	typeref:struct:VfslogVfs	file:
VfslogVtab	.\src\test_osinst.c	/^struct VfslogVtab {$/;"	s	file:
VfslogVtab	.\src\test_osinst.c	/^typedef struct VfslogVtab VfslogVtab;$/;"	t	typeref:struct:VfslogVtab	file:
VisibleRowid	.\src\sqliteInt.h	1707;"	d
VisitContext	.\tool\loadfts.c	/^struct VisitContext {$/;"	s	file:
VisitContext	.\tool\loadfts.c	/^typedef struct VisitContext VisitContext;$/;"	t	typeref:struct:VisitContext	file:
VtabCtx	.\src\sqliteInt.h	/^typedef struct VtabCtx VtabCtx;$/;"	t	typeref:struct:VtabCtx
VtabCtx	.\src\vtab.c	/^struct VtabCtx {$/;"	s	file:
WAITING_FOR_ARROW	.\tool\lemon.c	/^  WAITING_FOR_ARROW,$/;"	e	enum:e_state	file:
WAITING_FOR_CLASS_ID	.\tool\lemon.c	/^  WAITING_FOR_CLASS_ID,$/;"	e	enum:e_state	file:
WAITING_FOR_CLASS_TOKEN	.\tool\lemon.c	/^  WAITING_FOR_CLASS_TOKEN$/;"	e	enum:e_state	file:
WAITING_FOR_DATATYPE_SYMBOL	.\tool\lemon.c	/^  WAITING_FOR_DATATYPE_SYMBOL,$/;"	e	enum:e_state	file:
WAITING_FOR_DECL_ARG	.\tool\lemon.c	/^  WAITING_FOR_DECL_ARG,$/;"	e	enum:e_state	file:
WAITING_FOR_DECL_KEYWORD	.\tool\lemon.c	/^  WAITING_FOR_DECL_KEYWORD,$/;"	e	enum:e_state	file:
WAITING_FOR_DECL_OR_RULE	.\tool\lemon.c	/^  WAITING_FOR_DECL_OR_RULE,$/;"	e	enum:e_state	file:
WAITING_FOR_DESTRUCTOR_SYMBOL	.\tool\lemon.c	/^  WAITING_FOR_DESTRUCTOR_SYMBOL,$/;"	e	enum:e_state	file:
WAITING_FOR_FALLBACK_ID	.\tool\lemon.c	/^  WAITING_FOR_FALLBACK_ID,$/;"	e	enum:e_state	file:
WAITING_FOR_PRECEDENCE_SYMBOL	.\tool\lemon.c	/^  WAITING_FOR_PRECEDENCE_SYMBOL,$/;"	e	enum:e_state	file:
WAITING_FOR_WILDCARD_ID	.\tool\lemon.c	/^  WAITING_FOR_WILDCARD_ID,$/;"	e	enum:e_state	file:
WALINDEX_HDR_SIZE	.\src\wal.c	378;"	d	file:
WALINDEX_LOCK_OFFSET	.\src\wal.c	376;"	d	file:
WALINDEX_LOCK_RESERVED	.\src\wal.c	377;"	d	file:
WALINDEX_MAX_VERSION	.\src\wal.c	271;"	d	file:
WALINDEX_PGSZ	.\src\wal.c	506;"	d	file:
WALTHREAD1_NTHREAD	.\test\threadtest3.c	914;"	d	file:
WALTHREAD3_NTHREAD	.\test\threadtest3.c	915;"	d	file:
WALTRACE	.\src\wal.c	252;"	d	file:
WALTRACE	.\src\wal.c	254;"	d	file:
WAL_ALL_BUT_WRITE	.\src\wal.c	278;"	d	file:
WAL_CKPT_LOCK	.\src\wal.c	279;"	d	file:
WAL_EXCLUSIVE_MODE	.\src\wal.c	443;"	d	file:
WAL_FRAME_HDRSIZE	.\src\wal.c	381;"	d	file:
WAL_HDRSIZE	.\src\wal.c	385;"	d	file:
WAL_HEAPMEMORY_MODE	.\src\wal.c	444;"	d	file:
WAL_LOCK_CKPT	.\ext\rbu\sqlite3rbu.c	188;"	d	file:
WAL_LOCK_READ0	.\ext\rbu\sqlite3rbu.c	189;"	d	file:
WAL_LOCK_WRITE	.\ext\rbu\sqlite3rbu.c	187;"	d	file:
WAL_MAGIC	.\src\wal.c	396;"	d	file:
WAL_MAX_VERSION	.\src\wal.c	270;"	d	file:
WAL_NORMAL_MODE	.\src\wal.c	442;"	d	file:
WAL_NREADER	.\src\wal.c	282;"	d	file:
WAL_RDONLY	.\src\wal.c	450;"	d	file:
WAL_RDWR	.\src\wal.c	449;"	d	file:
WAL_READ_LOCK	.\src\wal.c	281;"	d	file:
WAL_RECOVER_LOCK	.\src\wal.c	280;"	d	file:
WAL_RETRY	.\src\wal.c	2093;"	d	file:
WAL_SAVEPOINT_NDATA	.\src\wal.h	49;"	d
WAL_SHM_RDONLY	.\src\wal.c	451;"	d	file:
WAL_SYNC_TRANSACTIONS	.\src\wal.h	25;"	d
WAL_WRITE_LOCK	.\src\wal.c	277;"	d	file:
WHERETRACE	.\src\whereInt.h	26;"	d
WHERETRACE	.\src\whereInt.h	29;"	d
WHERETRACE_ENABLED	.\src\whereInt.h	27;"	d
WHERE_AUTO_INDEX	.\src\whereInt.h	529;"	d
WHERE_BOTH_LIMIT	.\src\whereInt.h	521;"	d
WHERE_BTM_LIMIT	.\src\whereInt.h	520;"	d
WHERE_COLUMN_EQ	.\src\whereInt.h	514;"	d
WHERE_COLUMN_IN	.\src\whereInt.h	516;"	d
WHERE_COLUMN_NULL	.\src\whereInt.h	517;"	d
WHERE_COLUMN_RANGE	.\src\whereInt.h	515;"	d
WHERE_CONSTRAINT	.\src\whereInt.h	518;"	d
WHERE_DISTINCTBY	.\src\sqliteInt.h	2358;"	d
WHERE_DISTINCT_NOOP	.\src\sqliteInt.h	2366;"	d
WHERE_DISTINCT_ORDERED	.\src\sqliteInt.h	2368;"	d
WHERE_DISTINCT_UNIQUE	.\src\sqliteInt.h	2367;"	d
WHERE_DISTINCT_UNORDERED	.\src\sqliteInt.h	2369;"	d
WHERE_DUPLICATES_OK	.\src\sqliteInt.h	2352;"	d
WHERE_FORCE_TABLE	.\src\sqliteInt.h	2354;"	d
WHERE_GROUPBY	.\src\sqliteInt.h	2357;"	d
WHERE_IDX_ONLY	.\src\whereInt.h	522;"	d
WHERE_INDEXED	.\src\whereInt.h	524;"	d
WHERE_IN_ABLE	.\src\whereInt.h	526;"	d
WHERE_IPK	.\src\whereInt.h	523;"	d
WHERE_LOOP_XFER_SZ	.\src\whereInt.h	137;"	d
WHERE_MULTI_OR	.\src\whereInt.h	528;"	d
WHERE_NO_AUTOINDEX	.\src\sqliteInt.h	2356;"	d
WHERE_OMIT_OPEN_CLOSE	.\src\sqliteInt.h	2353;"	d
WHERE_ONEPASS_DESIRED	.\src\sqliteInt.h	2351;"	d
WHERE_ONEPASS_MULTIROW	.\src\sqliteInt.h	2362;"	d
WHERE_ONEROW	.\src\whereInt.h	527;"	d
WHERE_ONETABLE_ONLY	.\src\sqliteInt.h	2355;"	d
WHERE_ORDERBY_MAX	.\src\sqliteInt.h	2350;"	d
WHERE_ORDERBY_MIN	.\src\sqliteInt.h	2349;"	d
WHERE_ORDERBY_NORMAL	.\src\sqliteInt.h	2348;"	d
WHERE_PARTIALIDX	.\src\whereInt.h	532;"	d
WHERE_REOPEN_IDX	.\src\sqliteInt.h	2361;"	d
WHERE_SKIPSCAN	.\src\whereInt.h	530;"	d
WHERE_SORTBYGROUP	.\src\sqliteInt.h	2360;"	d
WHERE_TOP_LIMIT	.\src\whereInt.h	519;"	d
WHERE_UNQ_WANTED	.\src\whereInt.h	531;"	d
WHERE_VIRTUALTABLE	.\src\whereInt.h	525;"	d
WHERE_WANT_DISTINCT	.\src\sqliteInt.h	2359;"	d
WIN32_LEAN_AND_MEAN	.\mptest\mptest.c	39;"	d	file:
WIN32_LEAN_AND_MEAN	.\src\tclsqlite.c	58;"	d	file:
WINCE_DELETION_ATTEMPTS	.\src\os_win.c	2476;"	d	file:
WINFILE_PERSIST_WAL	.\src\os_win.c	280;"	d	file:
WINFILE_PSOW	.\src\os_win.c	281;"	d	file:
WINFILE_RDONLY	.\src\os_win.c	279;"	d	file:
WINMEM_MAGIC1	.\src\os_win.c	371;"	d	file:
WINMEM_MAGIC2	.\src\os_win.c	372;"	d	file:
WIN_SHM_BASE	.\src\os_win.c	3482;"	d	file:
WIN_SHM_DMS	.\src\os_win.c	3483;"	d	file:
WO_ALL	.\src\whereInt.h	506;"	d
WO_AND	.\src\whereInt.h	502;"	d
WO_EQ	.\src\whereInt.h	493;"	d
WO_EQUIV	.\src\whereInt.h	503;"	d
WO_GE	.\src\whereInt.h	497;"	d
WO_GT	.\src\whereInt.h	496;"	d
WO_IN	.\src\whereInt.h	492;"	d
WO_IS	.\src\whereInt.h	499;"	d
WO_ISNULL	.\src\whereInt.h	500;"	d
WO_LE	.\src\whereInt.h	495;"	d
WO_LT	.\src\whereInt.h	494;"	d
WO_MATCH	.\src\whereInt.h	498;"	d
WO_NOOP	.\src\whereInt.h	504;"	d
WO_OR	.\src\whereInt.h	501;"	d
WO_SINGLE	.\src\whereInt.h	507;"	d
WRC_Abort	.\src\sqliteInt.h	3042;"	d
WRC_Continue	.\src\sqliteInt.h	3040;"	d
WRC_Prune	.\src\sqliteInt.h	3041;"	d
WRITE_LOCK	.\src\btreeInt.h	328;"	d
WRITE_UTF16BE	.\src\utf.c	96;"	d	file:
WRITE_UTF16LE	.\src\utf.c	84;"	d	file:
WRITE_UTF8	.\ext\fts3\fts3_unicode.c	58;"	d	file:
WRITE_UTF8	.\ext\fts5\fts5_tokenize.c	207;"	d	file:
WRITE_UTF8	.\src\utf.c	64;"	d	file:
WSEOL_OK	.\tool\checkSpacing.c	15;"	d	file:
W_OK	.\src\test_demovfs.c	489;"	d	file:
Wal	.\src\wal.c	/^struct Wal {$/;"	s	file:
Wal	.\src\wal.h	/^typedef struct Wal Wal;$/;"	t	typeref:struct:Wal
WalCkptInfo	.\src\wal.c	/^struct WalCkptInfo {$/;"	s	file:
WalCkptInfo	.\src\wal.c	/^typedef struct WalCkptInfo WalCkptInfo;$/;"	t	typeref:struct:WalCkptInfo	file:
WalIndexHdr	.\src\wal.c	/^struct WalIndexHdr {$/;"	s	file:
WalIndexHdr	.\src\wal.c	/^typedef struct WalIndexHdr WalIndexHdr;$/;"	t	typeref:struct:WalIndexHdr	file:
WalIterator	.\src\wal.c	/^struct WalIterator {$/;"	s	file:
WalIterator	.\src\wal.c	/^typedef struct WalIterator WalIterator;$/;"	t	typeref:struct:WalIterator	file:
WalSegment	.\src\wal.c	/^  struct WalSegment {$/;"	s	struct:WalIterator	file:
WalWriter	.\src\wal.c	/^typedef struct WalWriter {$/;"	s	file:
WalWriter	.\src\wal.c	/^} WalWriter;$/;"	t	typeref:struct:WalWriter	file:
Walker	.\src\sqliteInt.h	/^struct Walker {$/;"	s
Walker	.\src\sqliteInt.h	/^typedef struct Walker Walker;$/;"	t	typeref:struct:Walker
WhereAndInfo	.\src\whereInt.h	/^struct WhereAndInfo {$/;"	s
WhereAndInfo	.\src\whereInt.h	/^typedef struct WhereAndInfo WhereAndInfo;$/;"	t	typeref:struct:WhereAndInfo
WhereClause	.\src\whereInt.h	/^struct WhereClause {$/;"	s
WhereClause	.\src\whereInt.h	/^typedef struct WhereClause WhereClause;$/;"	t	typeref:struct:WhereClause
WhereInfo	.\src\sqliteInt.h	/^typedef struct WhereInfo WhereInfo;$/;"	t	typeref:struct:WhereInfo
WhereInfo	.\src\whereInt.h	/^struct WhereInfo {$/;"	s
WhereLevel	.\src\whereInt.h	/^struct WhereLevel {$/;"	s
WhereLevel	.\src\whereInt.h	/^typedef struct WhereLevel WhereLevel;$/;"	t	typeref:struct:WhereLevel
WhereLoop	.\src\whereInt.h	/^struct WhereLoop {$/;"	s
WhereLoop	.\src\whereInt.h	/^typedef struct WhereLoop WhereLoop;$/;"	t	typeref:struct:WhereLoop
WhereLoopBuilder	.\src\whereInt.h	/^struct WhereLoopBuilder {$/;"	s
WhereLoopBuilder	.\src\whereInt.h	/^typedef struct WhereLoopBuilder WhereLoopBuilder;$/;"	t	typeref:struct:WhereLoopBuilder
WhereMaskSet	.\src\whereInt.h	/^struct WhereMaskSet {$/;"	s
WhereMaskSet	.\src\whereInt.h	/^typedef struct WhereMaskSet WhereMaskSet;$/;"	t	typeref:struct:WhereMaskSet
WhereOrCost	.\src\whereInt.h	/^struct WhereOrCost {$/;"	s
WhereOrCost	.\src\whereInt.h	/^typedef struct WhereOrCost WhereOrCost;$/;"	t	typeref:struct:WhereOrCost
WhereOrInfo	.\src\whereInt.h	/^struct WhereOrInfo {$/;"	s
WhereOrInfo	.\src\whereInt.h	/^typedef struct WhereOrInfo WhereOrInfo;$/;"	t	typeref:struct:WhereOrInfo
WhereOrSet	.\src\whereInt.h	/^struct WhereOrSet {$/;"	s
WhereOrSet	.\src\whereInt.h	/^typedef struct WhereOrSet WhereOrSet;$/;"	t	typeref:struct:WhereOrSet
WherePath	.\src\whereInt.h	/^struct WherePath {$/;"	s
WherePath	.\src\whereInt.h	/^typedef struct WherePath WherePath;$/;"	t	typeref:struct:WherePath
WhereScan	.\src\whereInt.h	/^struct WhereScan {$/;"	s
WhereScan	.\src\whereInt.h	/^typedef struct WhereScan WhereScan;$/;"	t	typeref:struct:WhereScan
WhereTerm	.\src\whereInt.h	/^struct WhereTerm {$/;"	s
WhereTerm	.\src\whereInt.h	/^typedef struct WhereTerm WhereTerm;$/;"	t	typeref:struct:WhereTerm
With	.\src\sqliteInt.h	/^struct With {$/;"	s
With	.\src\sqliteInt.h	/^typedef struct With With;$/;"	t	typeref:struct:With
WorkerInfo	.\test\threadtest4.c	/^struct WorkerInfo {$/;"	s	file:
WorkerInfo	.\test\threadtest4.c	/^typedef struct WorkerInfo WorkerInfo;$/;"	t	typeref:struct:WorkerInfo	file:
Wrapped	.\src\test_init.c	/^static struct Wrapped {$/;"	s	file:
WriteBuffer	.\src\test6.c	/^struct WriteBuffer {$/;"	s	file:
WriteBuffer	.\src\test6.c	/^typedef struct WriteBuffer WriteBuffer;$/;"	t	typeref:struct:WriteBuffer	file:
XN_EXPR	.\src\sqliteInt.h	1925;"	d
XN_ROWID	.\src\sqliteInt.h	1924;"	d
Y	.\src\date.c	/^  int Y, M, D;       \/* Year, month, and day *\/$/;"	m	struct:DateTime	file:
_BSD_SOURCE	.\src\sqliteInt.h	76;"	d
_BTREE_H_	.\src\btree.h	17;"	d
_CRT_SECURE_NO_DEPRECATE	.\autoconf\tea\win\nmakehlp.c	15;"	d	file:
_CRT_SECURE_NO_WARNINGS	.\src\shell.c	17;"	d	file:
_FILE_OFFSET_BITS	.\src\shell.c	40;"	d	file:
_FILE_OFFSET_BITS	.\src\sqliteInt.h	58;"	d
_FTS1_HASH_H_	.\ext\fts1\fts1_hash.h	18;"	d
_FTS1_TOKENIZER_H_	.\ext\fts1\fts1_tokenizer.h	21;"	d
_FTS2_HASH_H_	.\ext\fts2\fts2_hash.h	18;"	d
_FTS2_TOKENIZER_H_	.\ext\fts2\fts2_tokenizer.h	21;"	d
_FTS3_HASH_H_	.\ext\fts3\fts3_hash.h	18;"	d
_FTS3_TOKENIZER_H_	.\ext\fts3\fts3_tokenizer.h	21;"	d
_FTS5INT_H	.\ext\fts5\fts5Int.h	15;"	d
_FTS5_H	.\ext\fts5\fts5.h	22;"	d
_FTSINT_H	.\ext\fts3\fts3Int.h	15;"	d
_GNU_SOURCE	.\src\sqliteInt.h	72;"	d
_HASH_H_	.\ext\fts1\ft_hash.h	18;"	d
_HWTIME_H_	.\src\hwtime.h	17;"	d
_INTARRAY_H_	.\src\test_intarray.h	79;"	d
_LARGEFILE_SOURCE	.\src\shell.c	42;"	d	file:
_LARGEFILE_SOURCE	.\src\sqliteInt.h	60;"	d
_LARGE_FILE	.\src\shell.c	38;"	d	file:
_LARGE_FILE	.\src\sqliteInt.h	56;"	d
_MSVC_H_	.\src\msvc.h	16;"	d
_OS_COMMON_H_	.\src\os_common.h	21;"	d
_OS_SETUP_H_	.\src\os_setup.h	17;"	d
_OS_WIN_H_	.\src\os_win.h	16;"	d
_PAGER_H_	.\src\pager.h	18;"	d
_SHM_RDLCK	.\src\os_win.c	3489;"	d	file:
_SHM_UNLCK	.\src\os_win.c	3488;"	d	file:
_SHM_WRLCK	.\src\os_win.c	3490;"	d	file:
_SQLITE3EXT_H_	.\src\sqlite3ext.h	19;"	d
_SQLITE3RBU_H	.\ext\rbu\sqlite3rbu.h	268;"	d
_SQLITE3RTREE_H_	.\ext\rtree\sqlite3rtree.h	15;"	d
_SQLITEINT_H_	.\src\sqliteInt.h	16;"	d
_SQLITE_HASH_H_	.\src\hash.h	16;"	d
_SQLITE_OS_C_	.\src\os.c	16;"	d	file:
_SQLITE_OS_C_	.\src\os.c	18;"	d	file:
_SQLITE_OS_H_	.\src\os.h	21;"	d
_SQLITE_VDBE_H_	.\src\vdbe.h	19;"	d
_TEST_MULTIPLEX_H	.\src\test_multiplex.h	24;"	d
_TOKENIZER_H_	.\ext\fts1\tokenizer.h	21;"	d
_USE_32BIT_TIME_T	.\src\sqliteInt.h	108;"	d
_VDBEINT_H_	.\src\vdbeInt.h	19;"	d
_WAL_H_	.\src\wal.h	18;"	d
_XOPEN_SOURCE	.\src\sqliteInt.h	290;"	d
__SQLITEASYNC_H_	.\ext\async\sqlite3async.h	3;"	d
__WIN32__	.\tool\lemon.c	18;"	d	file:
__declspec	.\ext\fts1\fts1.c	/^__declspec(dllexport)$/;"	f
__declspec	.\ext\fts1\fulltext.c	/^__declspec(dllexport)$/;"	f
__declspec	.\ext\fts2\fts2.c	/^__declspec(dllexport)$/;"	f
__declspec	.\ext\fts3\fts3.c	/^__declspec(dllexport)$/;"	f
__declspec	.\ext\fts5\fts5_main.c	/^__declspec(dllexport)$/;"	f
__declspec	.\ext\icu\icu.c	/^__declspec(dllexport)$/;"	f
__declspec	.\ext\misc\amatch.c	/^__declspec(dllexport)$/;"	f
__declspec	.\ext\misc\closure.c	/^__declspec(dllexport)$/;"	f
__declspec	.\ext\misc\compress.c	/^__declspec(dllexport)$/;"	f
__declspec	.\ext\misc\eval.c	/^__declspec(dllexport)$/;"	f
__declspec	.\ext\misc\fileio.c	/^__declspec(dllexport)$/;"	f
__declspec	.\ext\misc\fuzzer.c	/^__declspec(dllexport)$/;"	f
__declspec	.\ext\misc\ieee754.c	/^__declspec(dllexport)$/;"	f
__declspec	.\ext\misc\json1.c	/^__declspec(dllexport)$/;"	f
__declspec	.\ext\misc\nextchar.c	/^__declspec(dllexport)$/;"	f
__declspec	.\ext\misc\percentile.c	/^__declspec(dllexport)$/;"	f
__declspec	.\ext\misc\regexp.c	/^__declspec(dllexport)$/;"	f
__declspec	.\ext\misc\rot13.c	/^__declspec(dllexport)$/;"	f
__declspec	.\ext\misc\series.c	/^__declspec(dllexport)$/;"	f
__declspec	.\ext\misc\showauth.c	/^__declspec(dllexport)$/;"	f
__declspec	.\ext\misc\spellfix.c	/^__declspec(dllexport)$/;"	f
__declspec	.\ext\misc\totype.c	/^__declspec(dllexport)$/;"	f
__declspec	.\ext\misc\vtshim.c	/^__declspec(dllexport)$/;"	f
__declspec	.\ext\misc\wholenumber.c	/^__declspec(dllexport)$/;"	f
__declspec	.\ext\rtree\rtree.c	/^__declspec(dllexport)$/;"	f
__declspec	.\src\test_loadext.c	/^__declspec(dllexport)$/;"	f
__declspec	.\src\test_schema.c	/^__declspec(dllexport)$/;"	f
_all_whitespace	.\src\shell.c	/^static int _all_whitespace(const char *z){$/;"	f	file:
_fts1ht	.\ext\fts1\fts1_hash.h	/^  struct _fts1ht {        \/* the hash table *\/$/;"	s	struct:fts1Hash
_fts2ht	.\ext\fts2\fts2_hash.h	/^  struct _fts2ht {        \/* the hash table *\/$/;"	s	struct:fts2Hash
_fts3ht	.\ext\fts3\fts3_hash.h	/^  struct _fts3ht {        \/* the hash table *\/$/;"	s	struct:Fts3Hash
_ht	.\ext\fts1\ft_hash.h	/^  struct _ht {            \/* the hash table *\/$/;"	s	struct:Hash
_ht	.\src\hash.h	/^  struct _ht {              \/* the hash table *\/$/;"	s	struct:Hash
_sqliteZone_	.\src\mem1.c	/^static malloc_zone_t* _sqliteZone_;$/;"	v	file:
a	.\ext\fts3\fts3_write.c	/^  char *a;                        \/* Pointer to allocation *\/$/;"	m	struct:Blob	file:
a	.\ext\fts5\fts5.h	/^  const unsigned char *a;$/;"	m	struct:Fts5PhraseIter
a	.\ext\fts5\fts5Int.h	/^  const u8 *a;                    \/* Position list to iterate through *\/$/;"	m	struct:Fts5PoslistReader
a	.\ext\fts5\fts5_expr.c	/^  const u8 *a;                    \/* Buffer containing position list *\/$/;"	m	struct:Fts5LookaheadReader	file:
a	.\ext\misc\percentile.c	/^  double *a;           \/* Array of Y values *\/$/;"	m	struct:Percentile	file:
a	.\ext\misc\spellfix.c	/^  EditDist3From *a;        \/* Extra info about each char of the FROM string *\/$/;"	m	struct:EditDist3FromString	file:
a	.\ext\misc\spellfix.c	/^  EditDist3Lang *a;      \/* One for each distinct language ID *\/$/;"	m	struct:EditDist3Config	file:
a	.\ext\misc\spellfix.c	/^  EditDist3To *a;          \/* Extra info about each char of the TO string *\/$/;"	m	struct:EditDist3ToString	file:
a	.\ext\misc\spellfix.c	/^  char a[4]    ;            \/* FROM string followed by TO string *\/$/;"	m	struct:EditDist3Cost	file:
a	.\ext\misc\spellfix.c	/^  } *a; $/;"	m	struct:spellfix1_cursor	typeref:struct:spellfix1_cursor::spellfix1_row	file:
a	.\src\analyze.c	/^  Stat4Sample *a;           \/* Array of mxSample Stat4Sample objects *\/$/;"	m	struct:Stat4Accum	file:
a	.\src\sqliteInt.h	/^  FuncDef *a[23];       \/* Hash table for functions *\/$/;"	m	struct:FuncDefHash
a	.\src\sqliteInt.h	/^  } *a;                  \/* Alloc a power of two greater or equal to nExpr *\/$/;"	m	struct:ExprList	typeref:struct:ExprList::ExprList_item
a	.\src\sqliteInt.h	/^  } *a;$/;"	m	struct:IdList	typeref:struct:IdList::IdList_item
a	.\src\sqliteInt.h	/^  } a[1];             \/* One entry for each identifier on the list *\/$/;"	m	struct:SrcList	typeref:struct:SrcList::SrcList_item
a	.\src\sqliteInt.h	/^  } a[1];$/;"	m	struct:With	typeref:struct:With::Cte
a	.\src\test_intarray.c	/^  sqlite3_int64 *a;         \/* Contents of the array *\/$/;"	m	struct:sqlite3_intarray	file:
a	.\src\test_pcache.c	/^  } a[TESTPCACHE_NPAGE];    \/* All pages in the cache *\/$/;"	m	struct:testpcache	typeref:struct:testpcache::testpcachePage	file:
a	.\src\whereInt.h	/^  WhereLevel a[1];          \/* Information about each nest loop in WHERE *\/$/;"	m	struct:WhereInfo
a	.\src\whereInt.h	/^  WhereOrCost a[N_OR_COST];   \/* Set of best costs *\/$/;"	m	struct:WhereOrSet
a	.\src\whereInt.h	/^  WhereTerm *a;            \/* Each a[] describes a term of the WHERE cluase *\/$/;"	m	struct:WhereClause
a	.\test\fuzzcheck.c	/^  unsigned char *a;       \/* Content of the file.  From malloc() *\/$/;"	m	struct:VFile	file:
a	.\test\fuzzcheck.c	/^  unsigned char a[1];     \/* Blob content.  Extra space allocated as needed. *\/$/;"	m	struct:Blob	file:
a	.\tool\sqldiff.c	/^  u16 a, b;         \/* Hash values *\/$/;"	m	struct:hash	file:
aAction	.\src\sqliteInt.h	/^  u8 aAction[2];        \/* ON DELETE and ON UPDATE actions, respectively *\/$/;"	m	struct:FKey
aAction	.\tool\lemon.c	/^    *aAction,                  \/* The yy_action[] table under construction *\/$/;"	m	struct:acttab	typeref:struct:acttab::lookahead_action	file:
aAll	.\ext\fts3\fts3Int.h	/^  char *aAll;                    \/* Array containing doclist (or NULL) *\/$/;"	m	struct:Fts3Doclist
aAlloc	.\src\vdbesort.c	/^  u8 *aAlloc;                 \/* Space for aKey if aBuffer and pMap wont work *\/$/;"	m	struct:PmaReader	file:
aArg	.\ext\misc\regexp.c	/^  int *aArg;                  \/* Arguments to each operator *\/$/;"	m	struct:ReCompiled	file:
aAsciiTokenChar	.\ext\fts5\fts5_tokenize.c	/^static unsigned char aAsciiTokenChar[128] = {$/;"	v	file:
aAvgEq	.\src\sqliteInt.h	/^  tRowcnt *aAvgEq;         \/* Average nEq values for keys not in aSample *\/$/;"	m	struct:Index
aBest	.\src\analyze.c	/^  Stat4Sample *aBest;       \/* Array of nCol best samples *\/$/;"	m	struct:Stat4Accum	file:
aBitmap	.\src\bitvec.c	/^    BITVEC_TELEM aBitmap[BITVEC_NELEM];    \/* Bitmap representation *\/$/;"	m	union:Bitvec::__anon8	file:
aBox	.\src\test_rtree.c	/^  } aBox[2];$/;"	m	struct:Circle	typeref:struct:Circle::Box	file:
aBuf	.\ext\fts5\fts5_tokenize.c	/^  char *aBuf;$/;"	m	struct:PorterContext	file:
aBuf	.\ext\fts5\fts5_tokenize.c	/^  char aBuf[FTS5_PORTER_MAX_TOKEN + 64];$/;"	m	struct:PorterTokenizer	file:
aBuf	.\ext\rbu\sqlite3rbu.c	/^  u8 *aBuf;$/;"	m	struct:sqlite3rbu	file:
aBuf	.\src\test_osinst.c	/^  char aBuf[VFSLOG_BUFFERSIZE];   \/* Write buffer *\/$/;"	m	struct:VfslogVfs	file:
aBuf	.\src\test_osinst.c	/^  unsigned char aBuf[1024];       \/* Current vfs log entry (read from file) *\/$/;"	m	struct:VfslogCsr	file:
aBuffer	.\ext\fts3\fts3Int.h	/^  char *aBuffer;                  \/* Buffer to merge doclists in *\/$/;"	m	struct:Fts3MultiSegReader
aBuffer	.\ext\fts3\fts3_test.c	/^  char *aBuffer;               \/* Buffer containing current token *\/$/;"	m	struct:test_tokenizer_cursor	file:
aBuffer	.\src\test_demovfs.c	/^  char *aBuffer;                  \/* Pointer to malloc'd buffer *\/$/;"	m	struct:DemoFile	file:
aBuffer	.\src\vdbesort.c	/^  u8 *aBuffer;                    \/* Pointer to write buffer *\/$/;"	m	struct:PmaWriter	file:
aBuffer	.\src\vdbesort.c	/^  u8 *aBuffer;                \/* Current read buffer *\/$/;"	m	struct:PmaReader	file:
aCell	.\src\dbstat.c	/^  StatCell *aCell;                \/* Array of parsed cells *\/$/;"	m	struct:StatPage	file:
aCellIdx	.\src\btreeInt.h	/^  u8 *aCellIdx;        \/* The cell index area *\/$/;"	m	struct:MemPage
aChar	.\ext\fts2\fts2_icu.c	/^  UChar *aChar;               \/* Copy of input using utf-16 encoding *\/$/;"	m	struct:IcuCursor	file:
aChar	.\ext\fts3\fts3_icu.c	/^  UChar *aChar;               \/* Copy of input using utf-16 encoding *\/$/;"	m	struct:IcuCursor	file:
aCksum	.\src\test_journal.c	/^  u32 *aCksum;             \/* Checksum for first nPage pages *\/$/;"	m	struct:jt_file	file:
aCksum	.\src\wal.c	/^  u32 aCksum[2];                  \/* Checksum over all prior fields *\/$/;"	m	struct:WalIndexHdr	file:
aCnt	.\ext\fts5\fts5_vocab.c	/^  i64 *aCnt;$/;"	m	struct:Fts5VocabCursor	file:
aCol	.\src\sqliteInt.h	/^  Column *aCol;        \/* Information about each column *\/$/;"	m	struct:Table
aCol	.\src\sqliteInt.h	/^  } *aCol;$/;"	m	struct:AggInfo	typeref:struct:AggInfo::AggInfo_col
aCol	.\src\sqliteInt.h	/^  } aCol[1];            \/* One entry for each of nCol columns *\/$/;"	m	struct:FKey	typeref:struct:FKey::sColMap
aCol	.\src\test8.c	/^  char **aCol;            \/* Array of size nCol. Column names *\/$/;"	m	struct:echo_vtab	file:
aColCache	.\src\sqliteInt.h	/^  } aColCache[SQLITE_N_COLCACHE];  \/* One for each column cache entry *\/$/;"	m	struct:Parse	typeref:struct:Parse::yColCache
aColExpr	.\src\sqliteInt.h	/^  ExprList *aColExpr;      \/* Column expressions *\/$/;"	m	struct:Index
aColName	.\src\vdbeInt.h	/^  Mem *aColName;          \/* Column names to return *\/$/;"	m	struct:Vdbe
aColl	.\src\sqliteInt.h	/^  CollSeq *aColl[1];  \/* Collating sequence for each term of the key *\/$/;"	m	struct:KeyInfo
aCollSeq	.\src\sqliteInt.h	/^  Hash aCollSeq;                \/* All collating sequences *\/$/;"	m	struct:sqlite3
aColmask	.\src\sqliteInt.h	/^  u32 aColmask[2];        \/* Masks of old.*, new.* columns accessed *\/$/;"	m	struct:TriggerPrg
aColumnSize	.\ext\fts5\fts5_main.c	/^  int *aColumnSize;               \/* Values for xColumnSize() *\/$/;"	m	struct:Fts5Cursor	file:
aCond	.\ext\async\sqlite3async.c	/^  HANDLE aCond[1];$/;"	m	struct:AsyncPrimitives	file:
aCond	.\ext\async\sqlite3async.c	/^  pthread_cond_t aCond[1];$/;"	m	struct:AsyncPrimitives	file:
aConn	.\src\test_sqllog.c	/^  struct SLConn aConn[MAX_CONNECTIONS];$/;"	m	struct:SLGlobal	typeref:struct:SLGlobal::SLConn	file:
aConstraint	.\ext\rtree\rtree.c	/^  RtreeConstraint *aConstraint;     \/* Search constraints. *\/$/;"	m	struct:RtreeCursor	file:
aCoord	.\ext\rtree\rtree.c	/^  RtreeCoord aCoord[RTREE_MAX_DIMENSIONS*2];  \/* Bounding box coordinates *\/$/;"	m	struct:RtreeCell	file:
aCoord	.\ext\rtree\sqlite3rtree.h	/^  sqlite3_rtree_dbl *aCoord;        \/* Coordinates of node or entry to check *\/$/;"	m	struct:sqlite3_rtree_query_info
aCounter	.\src\test_mutex.c	/^  int aCounter[MAX_MUTEXES]; \/* Number of grabs of each type of mutex *\/$/;"	m	struct:test_mutex_globals	file:
aCounter	.\src\vdbeInt.h	/^  u32 aCounter[5];        \/* Counters used by sqlite3_stmt_status() *\/$/;"	m	struct:Vdbe
aCtrl	.\src\mem5.c	/^  u8 *aCtrl;$/;"	m	struct:Mem5Global	file:
aData	.\ext\fts3\fts3_write.c	/^  char *aData;                    \/* Node data *\/$/;"	m	struct:SegmentNode	file:
aData	.\ext\fts3\fts3_write.c	/^  char *aData;                    \/* Pointer to block from malloc() *\/$/;"	m	struct:SegmentWriter	file:
aData	.\ext\fts3\fts3_write.c	/^  char *aData;$/;"	m	struct:PendingList	file:
aData	.\src\btreeInt.h	/^  u8 *aData;           \/* Pointer to disk image of the page data *\/$/;"	m	struct:MemPage
aData	.\src\test_wsd.c	/^  ProcessLocalVar *aData[PLS_HASHSIZE];$/;"	m	struct:ProcessLocalStorage	file:
aDataEnd	.\src\btreeInt.h	/^  u8 *aDataEnd;        \/* One byte past the end of usable data *\/$/;"	m	struct:MemPage
aDataOfst	.\src\btreeInt.h	/^  u8 *aDataOfst;       \/* Same as aData for leaves.  aData+4 for interior *\/$/;"	m	struct:MemPage
aDb	.\src\sqliteInt.h	/^  Db *aDb;                      \/* All backends *\/$/;"	m	struct:sqlite3
aDbStatic	.\src\sqliteInt.h	/^  Db aDbStatic[2];              \/* Static space for the 2 default backends *\/$/;"	m	struct:sqlite3
aDigits	.\src\printf.c	/^static const char aDigits[] = "0123456789ABCDEF0123456789abcdef";$/;"	v	file:
aDlidx	.\ext\fts5\fts5_index.c	/^  Fts5DlidxWriter *aDlidx;        \/* Array of Fts5DlidxWriter objects *\/$/;"	m	struct:Fts5SegWriter	file:
aDoc	.\ext\fts5\fts5_vocab.c	/^  i64 *aDoc;$/;"	m	struct:Fts5VocabCursor	file:
aDoclist	.\ext\fts3\fts3Int.h	/^  char *aDoclist;                 \/* List of docids for full-text queries *\/$/;"	m	struct:Fts3Cursor
aDoclist	.\ext\fts3\fts3Int.h	/^  char *aDoclist;                 \/* Pointer to doclist buffer *\/$/;"	m	struct:Fts3MultiSegReader
aDoclist	.\ext\fts3\fts3_write.c	/^  char *aDoclist;                 \/* Pointer to doclist of current entry *\/$/;"	m	struct:Fts3SegReader	file:
aDoclist	.\ext\fts3\fts3_write.c	/^  const char *aDoclist;           \/* Pointer to doclist *\/$/;"	m	struct:NodeReader	file:
aEntry	.\src\rowset.c	/^  struct RowSetEntry aEntry[ROWSET_ENTRY_PER_CHUNK]; \/* Allocated entries *\/$/;"	m	struct:RowSetChunk	typeref:struct:RowSetChunk::RowSetEntry	file:
aEof	.\ext\fts5\fts5_index.c	/^  u8 *aEof;                       \/* Pointer to 1 byte past end of doclist *\/$/;"	m	struct:Fts5DoclistIter	file:
aExt	.\src\loadext.c	/^  void (**aExt)(void);   \/* Pointers to the extension init functions *\/$/;"	m	struct:sqlite3AutoExtList	file:
aExtension	.\src\sqliteInt.h	/^  void **aExtension;            \/* Array of shared library handles *\/$/;"	m	struct:sqlite3
aFile	.\src\vdbesort.c	/^  SorterFile aFile[2];            \/* aFile[0] for reading, [1] for writing *\/$/;"	m	struct:IncrMerger	file:
aFile	.\test\fuzzcheck.c	/^  VFile aFile[MX_FILE];            \/* The virtual filesystem *\/$/;"	m	struct:GlobalVars	file:
aFirst	.\ext\fts5\fts5_index.c	/^  Fts5CResult *aFirst;            \/* Current merge state (see above) *\/$/;"	m	struct:Fts5IndexIter	file:
aFold	.\ext\fts5\fts5_tokenize.c	/^  char *aFold;                    \/* Buffer to fold text into *\/$/;"	m	struct:Unicode61Tokenizer	file:
aFrame	.\ext\rbu\sqlite3rbu.c	/^  RbuFrame *aFrame;$/;"	m	struct:sqlite3rbu	file:
aFrameCksum	.\src\wal.c	/^  u32 aFrameCksum[2];             \/* Checksum of last frame in log *\/$/;"	m	struct:WalIndexHdr	file:
aFreq	.\ext\fts5\fts5_aux.c	/^  double *aFreq;                  \/* Array used to calculate phrase freq. *\/$/;"	m	struct:Fts5Bm25Data	file:
aFunc	.\src\sqliteInt.h	/^  FuncDefHash aFunc;            \/* Hash table of connection functions *\/$/;"	m	struct:sqlite3
aFunc	.\src\sqliteInt.h	/^  } *aFunc;$/;"	m	struct:AggInfo	typeref:struct:AggInfo::AggInfo_func
aHardLimit	.\src\main.c	/^static const int aHardLimit[] = {$/;"	v	file:
aHash	.\ext\rtree\rtree.c	/^  RtreeNode *aHash[HASHSIZE]; \/* Hash table of in-memory nodes. *\/ $/;"	m	struct:Rtree	file:
aHash	.\src\bitvec.c	/^    u32 aHash[BITVEC_NINT];      \/* Hash table representation *\/$/;"	m	union:Bitvec::__anon8	file:
aHolder	.\ext\async\sqlite3async.c	/^  DWORD aHolder[3];$/;"	m	struct:AsyncPrimitives	file:
aHolder	.\ext\async\sqlite3async.c	/^  pthread_t aHolder[3];$/;"	m	struct:AsyncPrimitives	file:
aIDF	.\ext\fts5\fts5_aux.c	/^  double *aIDF;                   \/* IDF for each phrase *\/$/;"	m	struct:Fts5Bm25Data	file:
aIdx	.\ext\fts5\fts5_main.c	/^  int aIdx[1];                    \/* Offsets into aPoslist for current row *\/$/;"	m	struct:Fts5Sorter	file:
aInLoop	.\src\whereInt.h	/^      } *aInLoop;           \/* Information about each nested IN operator *\/$/;"	m	struct:WhereLevel::__anon26::__anon27	typeref:struct:WhereLevel::__anon26::__anon27::InLoop
aIndent	.\src\vdbeInt.h	/^  u16 aIndent[100];  \/* Levels of indentation *\/$/;"	m	struct:Explain
aIndex	.\ext\fts3\fts3Int.h	/^  } *aIndex;$/;"	m	struct:Fts3Table	typeref:struct:Fts3Table::Fts3Index
aIndex	.\src\test8.c	/^  int *aIndex;            \/* Array of size nCol. True if column has an index *\/$/;"	m	struct:echo_vtab	file:
aIndex	.\src\wal.c	/^    ht_slot *aIndex;              \/* i0, i1, i2... such that aPgno[iN] ascend *\/$/;"	m	struct:WalIterator::WalSegment	file:
aInput	.\ext\fts3\fts3_test.c	/^  const char *aInput;          \/* Input being tokenized *\/$/;"	m	struct:test_tokenizer_cursor	file:
aInput	.\ext\fts3\fts3_unicode.c	/^  const unsigned char *aInput;    \/* Input text being tokenized *\/$/;"	m	struct:unicode_cursor	file:
aInst	.\ext\fts5\fts5_main.c	/^  int *aInst;                     \/* 3 integers per phrase instance *\/$/;"	m	struct:Fts5Cursor	file:
aInstIter	.\ext\fts5\fts5_main.c	/^  Fts5PoslistReader *aInstIter;   \/* One for each phrase *\/$/;"	m	struct:Fts5Cursor	file:
aJournalMagic	.\src\pager.c	/^static const unsigned char aJournalMagic[] = {$/;"	v	file:
aKey	.\src\vdbesort.c	/^  u8 *aKey;                   \/* Pointer to current key *\/$/;"	m	struct:PmaReader	file:
aKeywordTable	.\tool\mkkeywordhash.c	/^static Keyword aKeywordTable[] = {$/;"	v	file:
aLTerm	.\src\whereInt.h	/^  WhereTerm **aLTerm;   \/* WhereTerms used *\/$/;"	m	struct:WhereLoop
aLTermSpace	.\src\whereInt.h	/^  WhereTerm *aLTermSpace[3];  \/* Initial aLTerm[] space *\/$/;"	m	struct:WhereLoop
aLabel	.\src\sqliteInt.h	/^  int *aLabel;         \/* Space to hold the labels *\/$/;"	m	struct:Parse
aLevel	.\ext\fts5\fts5_index.c	/^  Fts5StructureLevel aLevel[1];   \/* Array of nLevel level objects *\/$/;"	m	struct:Fts5Structure	file:
aLimit	.\src\sqliteInt.h	/^  int aLimit[SQLITE_N_LIMIT];   \/* Limits *\/$/;"	m	struct:sqlite3
aLookahead	.\tool\lemon.c	/^    *aLookahead;               \/* A single new transaction set *\/$/;"	m	struct:acttab	typeref:struct:acttab::	file:
aLoop	.\src\whereInt.h	/^  WhereLoop **aLoop;    \/* Array of WhereLoop objects implementing this path *\/$/;"	m	struct:WherePath
aLvl	.\ext\fts5\fts5_index.c	/^  Fts5DlidxLvl aLvl[1];$/;"	m	struct:Fts5DlidxIter	file:
aMI	.\ext\fts3\fts3Int.h	/^  u32 *aMI;                  \/* See above *\/$/;"	m	struct:Fts3Expr
aMallocLog	.\src\test_malloc.c	/^static Tcl_HashTable aMallocLog;$/;"	v	file:
aMap	.\src\vdbesort.c	/^  u8 *aMap;                   \/* Pointer to mapping of entire file *\/$/;"	m	struct:PmaReader	file:
aMatch	.\ext\fts1\fts1.c	/^  } *aMatch;      \/* Points to space obtained from malloc *\/$/;"	m	struct:Snippet	typeref:struct:Snippet::snippetMatch	file:
aMatch	.\ext\fts2\fts2.c	/^  } *aMatch;      \/* Points to space obtained from malloc *\/$/;"	m	struct:Snippet	typeref:struct:Snippet::snippetMatch	file:
aMatchinfo	.\ext\fts3\fts3_snippet.c	/^  u32 *aMatchinfo;                \/* Pre-allocated buffer *\/$/;"	m	struct:MatchInfo	file:
aMatchinfo	.\ext\fts3\fts3_snippet.c	/^  u32 aMatchinfo[1];$/;"	m	struct:MatchinfoBuffer	file:
aMem	.\src\sqliteInt.h	/^  Mem *aMem;          \/* Values *\/$/;"	m	struct:UnpackedRecord
aMem	.\src\vdbeInt.h	/^  Mem *aMem;              \/* Array of memory cells for parent frame *\/$/;"	m	struct:VdbeFrame
aMem	.\src\vdbeInt.h	/^  Mem *aMem;              \/* The memory locations *\/$/;"	m	struct:Vdbe
aMemory	.\src\vdbesort.c	/^  u8 *aMemory;                    \/* If non-NULL, bulk memory to hold pList *\/$/;"	m	struct:SorterList	file:
aModule	.\src\sqliteInt.h	/^  Hash aModule;                 \/* populated by sqlite3_create_module() *\/$/;"	m	struct:sqlite3
aMutex	.\ext\async\sqlite3async.c	/^  CRITICAL_SECTION aMutex[3];$/;"	m	struct:AsyncPrimitives	file:
aMutex	.\ext\async\sqlite3async.c	/^  pthread_mutex_t aMutex[3];$/;"	m	struct:AsyncPrimitives	file:
aName	.\src\test_mutex.c	/^static const char *aName[MAX_MUTEXES+1] = {$/;"	v	file:
aNode	.\ext\fts3\fts3_write.c	/^  char *aNode;                    \/* Pointer to node data (or NULL) *\/$/;"	m	struct:Fts3SegReader	file:
aNode	.\ext\fts3\fts3_write.c	/^  const char *aNode;$/;"	m	struct:NodeReader	file:
aNode	.\ext\misc\json1.c	/^  JsonNode *aNode;   \/* Array of nodes containing the parse *\/$/;"	m	struct:JsonParse	file:
aNode	.\ext\rtree\rtree.c	/^  RtreeNode *aNode[RTREE_CACHE_SZ]; \/* Rtree node cache *\/$/;"	m	struct:RtreeCursor	file:
aNodeWriter	.\ext\fts3\fts3_write.c	/^  NodeWriter aNodeWriter[FTS_MAX_APPENDABLE_HEIGHT];$/;"	m	struct:IncrmergeWriter	file:
aOffset	.\ext\fts2\fts2_icu.c	/^  int *aOffset;               \/* Offsets of each character in utf-8 input *\/$/;"	m	struct:IcuCursor	file:
aOffset	.\ext\fts3\fts3_icu.c	/^  int *aOffset;               \/* Offsets of each character in utf-8 input *\/$/;"	m	struct:IcuCursor	file:
aOffset	.\src\vdbeInt.h	/^  u32 *aOffset;         \/* Pointer to aType[nField] *\/$/;"	m	struct:VdbeCursor
aOnceFlag	.\src\vdbeInt.h	/^  u8 *aOnceFlag;          \/* Array of OP_Once flags for parent frame *\/$/;"	m	struct:VdbeFrame
aOnceFlag	.\src\vdbeInt.h	/^  u8 *aOnceFlag;          \/* Flags for OP_Once *\/$/;"	m	struct:Vdbe
aOp	.\ext\misc\regexp.c	/^  char *aOp;                  \/* Operators for the virtual machine *\/$/;"	m	struct:ReCompiled	file:
aOp	.\src\vdbe.h	/^  VdbeOp *aOp;                  \/* Array of opcodes for sub-program *\/$/;"	m	struct:SubProgram
aOp	.\src\vdbeInt.h	/^  Op *aOp;                \/* Program instructions for parent frame *\/$/;"	m	struct:VdbeFrame
aOp	.\src\vdbeInt.h	/^  Op *aOp;                \/* Space to hold the virtual machine's program *\/$/;"	m	struct:Vdbe
aOverflow	.\src\btreeInt.h	/^  Pgno *aOverflow;          \/* Cache of overflow page locations *\/$/;"	m	struct:BtCursor
aOvfl	.\src\dbstat.c	/^  u32 *aOvfl;                     \/* Array of overflow page numbers *\/$/;"	m	struct:StatCell	file:
aPadding	.\src\os_unix.c	/^  char aPadding[32];$/;"	m	struct:unixFile	file:
aPage	.\src\dbstat.c	/^  StatPage aPage[32];$/;"	m	struct:StatCursor	file:
aPage	.\src\test_vfs.c	/^  u8 *aPage[TESTVFS_MAX_PAGES];   \/* Array of ckalloc'd pages *\/$/;"	m	struct:TestvfsBuffer	file:
aPage	.\tool\offsets.c	/^  u8 *aPage;            \/* Current page content *\/$/;"	m	struct:GState	file:
aParam	.\ext\rtree\rtree.c	/^  RtreeDValue aParam[1];      \/* Values for parameters to the SQL function *\/$/;"	m	struct:RtreeMatchArg	file:
aParam	.\ext\rtree\sqlite3rtree.h	/^  sqlite3_rtree_dbl *aParam;        \/* value of function parameters *\/$/;"	m	struct:sqlite3_rtree_query_info
aParam	.\ext\rtree\sqlite3rtree.h	/^  sqlite3_rtree_dbl *aParam;      \/* Parameters passed to SQL geom function *\/$/;"	m	struct:sqlite3_rtree_geometry
aPgRef	.\src\btreeInt.h	/^  u8 *aPgRef;       \/* 1 bit per page in the db (see above) *\/$/;"	m	struct:IntegrityCk
aPgno	.\src\wal.c	/^    u32 *aPgno;                   \/* Array of page numbers. *\/$/;"	m	struct:WalIterator::WalSegment	file:
aPgno	.\tool\offsets.c	/^  int aPgno[20];        \/* Page number stack *\/$/;"	m	struct:GState	file:
aPhrase	.\ext\fts3\fts3_snippet.c	/^  SnippetPhrase *aPhrase;         \/* Array of size nPhrase *\/$/;"	m	struct:SnippetIter	file:
aPoint	.\ext\rtree\rtree.c	/^  RtreeSearchPoint *aPoint;         \/* Priority queue for search points *\/$/;"	m	struct:RtreeCursor	file:
aPool	.\src\mem3.c	/^  Mem3Block *aPool;$/;"	m	struct:Mem3Global	file:
aPoslist	.\ext\fts5\fts5_index.c	/^  u8 *aPoslist;$/;"	m	struct:Fts5DoclistIter	file:
aPoslist	.\ext\fts5\fts5_main.c	/^  const u8 *aPoslist;             \/* Position lists for current row *\/$/;"	m	struct:Fts5Sorter	file:
aPragmaNames	.\src\pragma.h	/^} aPragmaNames[] = {$/;"	v	typeref:struct:sPragmaNames
aPrefix	.\ext\fts5\fts5Int.h	/^  int *aPrefix;                   \/* Sizes in bytes of nPrefix prefix indexes *\/$/;"	m	struct:Fts5Config
aPrefix	.\src\printf.c	/^static const char aPrefix[] = "-x0\\000X0";$/;"	v	file:
aQueue	.\ext\misc\fuzzer.c	/^  fuzzer_stem *aQueue[FUZZER_NQUEUE];  \/* Queue of stems with higher rCostX *\/$/;"	m	struct:fuzzer_cursor	file:
aReadMark	.\src\wal.c	/^  u32 aReadMark[WAL_NREADER];     \/* Reader marks *\/$/;"	m	struct:WalCkptInfo	file:
aReadr	.\src\vdbesort.c	/^  PmaReader *aReadr;         \/* Array of PmaReaders to merge data from *\/$/;"	m	struct:MergeEngine	file:
aReal	.\src\test_multiplex.c	/^  } *aReal;                        \/* list of all chunks *\/$/;"	m	struct:multiplexGroup	typeref:struct:multiplexGroup::multiplexReal	file:
aRef	.\ext\fts3\fts3_snippet.c	/^  u8 aRef[3];$/;"	m	struct:MatchinfoBuffer	file:
aRegion	.\src\os_win.c	/^  } *aRegion;$/;"	m	struct:winShmNode	typeref:struct:winShmNode::ShmRegion	file:
aResult	.\ext\misc\nextchar.c	/^  unsigned int *aResult;            \/* Array of next characters *\/$/;"	m	struct:nextCharContext	file:
aRet	.\ext\fts5\fts5_test_mi.c	/^  u32 *aRet;                      \/* Array of 32-bit unsigned ints to return *\/$/;"	m	struct:Fts5MatchinfoCtx	file:
aRow	.\src\vdbeInt.h	/^  const u8 *aRow;       \/* Data for the current row, if all on one page *\/$/;"	m	struct:VdbeCursor
aRowid	.\src\analyze.c	/^    u8 *aRowid;                     \/* Key for WITHOUT ROWID tables *\/$/;"	m	union:Stat4Sample::__anon7	file:
aRowidOffset	.\ext\fts5\fts5_index.c	/^  int *aRowidOffset;              \/* Array of offset to rowid fields *\/$/;"	m	struct:Fts5SegIter	file:
aSalt	.\src\wal.c	/^  u32 aSalt[2];                   \/* Two salt values copied from WAL header *\/$/;"	m	struct:WalIndexHdr	file:
aSample	.\src\sqliteInt.h	/^  IndexSample *aSample;    \/* Samples of the left-most key *\/$/;"	m	struct:Index
aSavepoint	.\src\pager.c	/^  PagerSavepoint *aSavepoint; \/* Array of active savepoints *\/$/;"	m	struct:Pager	file:
aScan	.\src\vdbeInt.h	/^  ScanStatus *aScan;      \/* Scan definitions for sqlite3_stmt_scanstatus() *\/$/;"	m	struct:Vdbe
aSeg	.\ext\fts5\fts5_index.c	/^  Fts5SegIter aSeg[1];            \/* Array of segment iterators *\/$/;"	m	struct:Fts5IndexIter	file:
aSeg	.\ext\fts5\fts5_index.c	/^  Fts5StructureSegment *aSeg;     \/* Array of segments. aSeg[0] is oldest. *\/$/;"	m	struct:Fts5StructureLevel	file:
aSegment	.\src\wal.c	/^  } aSegment[1];                  \/* One for every 32KB page in the wal-index *\/$/;"	m	struct:WalIterator	typeref:struct:WalIterator::WalSegment	file:
aSemName	.\src\os_unix.c	/^  char aSemName[MAX_PATHNAME+2];  \/* Name of that semaphore *\/$/;"	m	struct:unixInodeInfo	file:
aSlot	.\ext\fts5\fts5_hash.c	/^  Fts5HashEntry **aSlot;          \/* Array of hash slots *\/$/;"	m	struct:Fts5Hash	file:
aSortOrder	.\src\sqliteInt.h	/^  u8 *aSortOrder;          \/* for each column: True==DESC, False==ASC *\/$/;"	m	struct:Index
aSortOrder	.\src\sqliteInt.h	/^  u8 *aSortOrder;     \/* Sort order for each column. *\/$/;"	m	struct:KeyInfo
aStack	.\tool\offsets.c	/^  u8 *aStack[20];       \/* Page stack *\/$/;"	m	struct:GState	file:
aStat	.\ext\fts3\fts3_aux.c	/^  } *aStat;$/;"	m	struct:Fts3auxCursor	typeref:struct:Fts3auxCursor::Fts3auxColstats	file:
aStat	.\src\pager.c	/^  int aStat[3];               \/* Total cache hits, misses and writes *\/$/;"	m	struct:Pager	file:
aState	.\ext\misc\regexp.c	/^  ReStateNumber *aState;      \/* Current states *\/$/;"	m	struct:ReStateSet	file:
aStatic	.\src\test_mutex.c	/^  sqlite3_mutex aStatic[STATIC_MUTEXES]; \/* The static mutexes *\/$/;"	m	struct:test_mutex_globals	file:
aStatic	.\src\whereInt.h	/^  WhereTerm aStatic[1];    \/* Initial static space for a[] *\/$/;"	m	struct:WhereClause
aStatic	.\src\whereInt.h	/^  WhereTerm aStatic[8];    \/* Initial static space for a[] *\/$/;"	m	struct:WhereClause
aStmt	.\ext\fts3\fts3Int.h	/^  sqlite3_stmt *aStmt[40];$/;"	m	struct:Fts3Table
aStmt	.\ext\fts5\fts5_storage.c	/^  sqlite3_stmt *aStmt[11];$/;"	m	struct:Fts5Storage	file:
aSyscall	.\src\os_unix.c	/^} aSyscall[] = {$/;"	v	typeref:struct:unix_syscall	file:
aSyscall	.\src\os_win.c	/^} aSyscall[] = {$/;"	v	typeref:struct:win_syscall	file:
aSyscall	.\src\test_syscall.c	/^} aSyscall[] = {$/;"	v	typeref:struct:TestSyscallArray
aTableLock	.\src\sqliteInt.h	/^  TableLock *aTableLock; \/* Required table locks for shared-cache mode *\/$/;"	m	struct:Parse
aTask	.\src\vdbesort.c	/^  SortSubtask aTask[1];           \/* One or more subtasks *\/$/;"	m	struct:VdbeSorter	file:
aTempReg	.\src\sqliteInt.h	/^  int aTempReg[8];     \/* Holding area for temporary registers *\/$/;"	m	struct:Parse
aTerm	.\ext\fts3\fts3_snippet.c	/^  TermOffset *aTerm;$/;"	m	struct:TermOffsetCtx	file:
aTerm	.\ext\fts5\fts5_expr.c	/^  Fts5ExprTerm aTerm[1];          \/* Terms that make up this phrase *\/$/;"	m	struct:Fts5ExprPhrase	file:
aText	.\test\threadtest3.c	/^  char **aText;                   \/* Stored text results *\/$/;"	m	struct:Sqlite	file:
aToken	.\ext\fts3\fts3Int.h	/^  Fts3PhraseToken aToken[1]; \/* One entry for each token in the phrase *\/$/;"	m	struct:Fts3Phrase
aToken	.\ext\fts3\fts3_test.c	/^  NearToken *aToken;              \/* Token array *\/$/;"	m	struct:NearDocument	file:
aToken	.\ext\fts3\fts3_test.c	/^  NearToken aToken[NM_MAX_TOKEN]; \/* Array of tokens in this phrase *\/$/;"	m	struct:NearPhrase	file:
aTokenChar	.\ext\fts5\fts5_tokenize.c	/^  unsigned char aTokenChar[128];  \/* ASCII range token characters *\/$/;"	m	struct:Unicode61Tokenizer	file:
aTokenChar	.\ext\fts5\fts5_tokenize.c	/^  unsigned char aTokenChar[128];$/;"	m	struct:AsciiTokenizer	file:
aTotalSize	.\ext\fts5\fts5_storage.c	/^  i64 *aTotalSize;                \/* Total sizes of each column *\/ $/;"	m	struct:Fts5Storage	file:
aTree	.\src\vdbesort.c	/^  int *aTree;                \/* Current state of incremental merge *\/$/;"	m	struct:MergeEngine	file:
aType	.\src\vdbeInt.h	/^  u32 aType[1];         \/* Type values for all entries in the record *\/$/;"	m	struct:VdbeCursor
aUp	.\ext\misc\json1.c	/^  u32 *aUp;          \/* Index of parent of each node *\/$/;"	m	struct:JsonParse	file:
aVTrans	.\src\sqliteInt.h	/^  VTable **aVTrans;             \/* Virtual tables with open transactions *\/$/;"	m	struct:sqlite3
aVal	.\ext\fts5\fts5_vocab.c	/^  i64 aVal[3];                    \/* Up to three columns left of 'term' *\/$/;"	m	struct:Fts5VocabCursor	file:
aVar	.\src\vdbeInt.h	/^  Mem *aVar;              \/* Values for the OP_Variable opcode. *\/$/;"	m	struct:Vdbe
aWalData	.\src\pager.c	/^  u32 aWalData[WAL_SAVEPOINT_NDATA];        \/* WAL savepoint context *\/$/;"	m	struct:PagerSavepoint	file:
aaOutput	.\ext\fts3\fts3.c	/^  char *aaOutput[16];             \/* Malloc'd output buffers *\/$/;"	m	struct:TermSelect	file:
abIndexed	.\ext\rbu\sqlite3rbu.c	/^  u8 *abIndexed;                  \/* Array of flags, set on indexed & PK cols *\/$/;"	m	struct:RbuObjIter	file:
abNotNull	.\ext\rbu\sqlite3rbu.c	/^  u8 *abNotNull;                  \/* Array of flags, set on NOT NULL columns *\/$/;"	m	struct:RbuObjIter	file:
abNotindexed	.\ext\fts3\fts3Int.h	/^  u8 *abNotindexed;               \/* True for 'notindexed' columns *\/$/;"	m	struct:Fts3Table
abTblPk	.\ext\rbu\sqlite3rbu.c	/^  u8 *abTblPk;                    \/* Array of flags, set on target PK columns *\/$/;"	m	struct:RbuObjIter	file:
abUnindexed	.\ext\fts5\fts5Int.h	/^  u8 *abUnindexed;                \/* True for unindexed columns *\/$/;"	m	struct:Fts5Config
abendError	.\tool\fuzzershell.c	/^static void abendError(const char *zFormat, ...){$/;"	f	file:
absFunc	.\src\func.c	/^static void absFunc(sqlite3_context *context, int argc, sqlite3_value **argv){$/;"	f	file:
abuse_create_function	.\src\test_func.c	/^static int abuse_create_function($/;"	f	file:
accError	.\src\sqliteInt.h	/^  u8   accError;       \/* STRACCUM_NOMEM or STRACCUM_TOOBIG *\/$/;"	m	struct:StrAccum
accept	.\tool\lemon.c	/^  char *accept;            \/* Code to execute when the parser excepts *\/$/;"	m	struct:lemon	file:
access	.\src\shell.c	106;"	d	file:
accessPayload	.\src\btree.c	/^static int accessPayload($/;"	f	file:
action	.\tool\lemon.c	/^  int action;                \/* Action to take on the given lookahead *\/$/;"	m	struct:lookahead_action	file:
action	.\tool\lemon.c	/^struct action {$/;"	s	file:
actionName	.\src\pragma.c	/^static const char *actionName(u8 action){$/;"	f	file:
actioncmp	.\tool\lemon.c	/^static int actioncmp($/;"	f	file:
acttab	.\tool\lemon.c	/^struct acttab {$/;"	s	file:
acttab	.\tool\lemon.c	/^typedef struct acttab acttab;$/;"	t	typeref:struct:acttab	file:
acttab_action	.\tool\lemon.c	/^void acttab_action(acttab *p, int lookahead, int action){$/;"	f
acttab_alloc	.\tool\lemon.c	/^acttab *acttab_alloc(void){$/;"	f
acttab_free	.\tool\lemon.c	/^void acttab_free(acttab *p){$/;"	f
acttab_insert	.\tool\lemon.c	/^int acttab_insert(acttab *p){$/;"	f
acttab_size	.\tool\lemon.c	571;"	d	file:
acttab_yyaction	.\tool\lemon.c	574;"	d	file:
acttab_yylookahead	.\tool\lemon.c	577;"	d	file:
actualWidth	.\src\shell.c	/^  int actualWidth[100];  \/* Actual width of each column *\/$/;"	m	struct:ShellState	file:
addAggInfoColumn	.\src\expr.c	/^static int addAggInfoColumn(sqlite3 *db, AggInfo *pInfo){$/;"	f	file:
addAggInfoFunc	.\src\expr.c	/^static int addAggInfoFunc(sqlite3 *db, AggInfo *pInfo){$/;"	f	file:
addArgumentToVtab	.\src\vtab.c	/^static void addArgumentToVtab(Parse *pParse){$/;"	f	file:
addAsyncWrite	.\ext\async\sqlite3async.c	/^static void addAsyncWrite(AsyncWrite *pWrite){$/;"	f	file:
addCharToHash	.\test\wordcount.c	/^static void addCharToHash(unsigned int *a, unsigned char x){$/;"	f	file:
addColOffset	.\src\sqliteInt.h	/^  int addColOffset;    \/* Offset in CREATE TABLE stmt to add a new column *\/$/;"	m	struct:Table
addModuleArgument	.\src\vtab.c	/^static void addModuleArgument(sqlite3 *db, Table *pTable, char *zArg){$/;"	f	file:
addNewAsyncWrite	.\ext\async\sqlite3async.c	/^static int addNewAsyncWrite($/;"	f	file:
addPos	.\ext\fts1\fts1.c	/^static void addPos(DocList *d, int iColumn, int iPos){$/;"	f	file:
addToBlockedList	.\src\notify.c	/^static void addToBlockedList(sqlite3 *db){$/;"	f	file:
addToSavepointBitvecs	.\src\pager.c	/^static int addToSavepointBitvecs(Pager *pPager, Pgno pgno){$/;"	f	file:
addToVTrans	.\src\vtab.c	/^static void addToVTrans(sqlite3 *db, VTable *pVTab){$/;"	f	file:
addWhereTerm	.\src\select.c	/^static void addWhereTerm($/;"	f	file:
add_alignment_test_collations	.\src\test1.c	/^static int add_alignment_test_collations($/;"	f	file:
add_column_fullname	.\src\parse.y	/^add_column_fullname ::= fullname(X). {$/;"	l
addrBody	.\src\whereInt.h	/^  int addrBody;         \/* Beginning of the body of this loop *\/$/;"	m	struct:WhereLevel
addrBrk	.\src\whereInt.h	/^  int addrBrk;          \/* Jump here to break out of the loop *\/$/;"	m	struct:WhereLevel
addrCont	.\src\whereInt.h	/^  int addrCont;         \/* Jump here to continue with the next loop cycle *\/$/;"	m	struct:WhereLevel
addrCrTab	.\src\sqliteInt.h	/^  int addrCrTab;       \/* Address of OP_CreateTable opcode on CREATE TABLE *\/$/;"	m	struct:Parse
addrExplain	.\src\vdbeInt.h	/^  int addrExplain;                \/* OP_Explain for loop *\/$/;"	m	struct:ScanStatus
addrFillSub	.\src\sqliteInt.h	/^    int addrFillSub;  \/* Address of subroutine to manifest a subquery *\/$/;"	m	struct:SrcList::SrcList_item
addrFirst	.\src\whereInt.h	/^  int addrFirst;        \/* First instruction of interior of the loop *\/$/;"	m	struct:WhereLevel
addrInTop	.\src\whereInt.h	/^        int addrInTop;         \/* Top of the IN loop *\/$/;"	m	struct:WhereLevel::__anon26::__anon27::InLoop
addrLikeRep	.\src\whereInt.h	/^  int addrLikeRep;      \/* LIKE range processing address *\/$/;"	m	struct:WhereLevel
addrLoop	.\src\vdbeInt.h	/^  int addrLoop;                   \/* Address of "loops" counter *\/$/;"	m	struct:ScanStatus
addrNxt	.\src\whereInt.h	/^  int addrNxt;          \/* Jump here to start the next IN combination *\/$/;"	m	struct:WhereLevel
addrOpenEphm	.\src\sqliteInt.h	/^  int addrOpenEphm[2];   \/* OP_OpenEphem opcodes related to this select *\/$/;"	m	struct:Select
addrSkip	.\src\whereInt.h	/^  int addrSkip;         \/* Jump here for next iteration of skip-scan *\/$/;"	m	struct:WhereLevel
addrSortIndex	.\src\select.c	/^  int addrSortIndex;    \/* Address of the OP_SorterOpen or OP_OpenEphemeral *\/$/;"	m	struct:SortCtx	file:
addrTnct	.\src\select.c	/^  int addrTnct;   \/* Address of OP_OpenEphemeral opcode for tabTnct *\/$/;"	m	struct:DistinctCtx	file:
addrVisit	.\src\vdbeInt.h	/^  int addrVisit;                  \/* Address of "rows visited" counter *\/$/;"	m	struct:ScanStatus
addrVisit	.\src\whereInt.h	/^  int addrVisit;        \/* Address at which row is visited *\/$/;"	m	struct:WhereLevel
adjustStats	.\src\mem2.c	/^static void adjustStats(int iSize, int increment){$/;"	f	file:
affSdst	.\src\sqliteInt.h	/^  char affSdst;        \/* Affinity used when eDest==SRT_Set *\/$/;"	m	struct:SelectDest
affinity	.\src\sqliteInt.h	/^  char affinity;         \/* The affinity of the column or 0 if not a column *\/$/;"	m	struct:Expr
affinity	.\src\sqliteInt.h	/^  char affinity;   \/* One of the SQLITE_AFF_... values *\/$/;"	m	struct:Column
afpCheckReservedLock	.\src\os_unix.c	/^static int afpCheckReservedLock(sqlite3_file *id, int *pResOut){$/;"	f	file:
afpClose	.\src\os_unix.c	/^static int afpClose(sqlite3_file *id) {$/;"	f	file:
afpLock	.\src\os_unix.c	/^static int afpLock(sqlite3_file *id, int eFileLock){$/;"	f	file:
afpLockingContext	.\src\os_unix.c	/^struct afpLockingContext {$/;"	s	file:
afpLockingContext	.\src\os_unix.c	/^typedef struct afpLockingContext afpLockingContext;$/;"	t	typeref:struct:afpLockingContext	file:
afpSetLock	.\src\os_unix.c	/^static int afpSetLock($/;"	f	file:
afpUnlock	.\src\os_unix.c	/^static int afpUnlock(sqlite3_file *id, int eFileLock) {$/;"	f	file:
afpfsByteRangeLock2FSCTL	.\src\os_unix.c	2652;"	d	file:
aggregate_context	.\src\sqlite3ext.h	/^  void * (*aggregate_context)(sqlite3_context*,int nBytes);$/;"	m	struct:sqlite3_api_routines
aggregate_count	.\src\sqlite3ext.h	/^  int  (*aggregate_count)(sqlite3_context*);$/;"	m	struct:sqlite3_api_routines
ai	.\src\vdbe.h	/^    int *ai;               \/* Used when p4type is P4_INTARRAY *\/$/;"	m	union:VdbeOp::p4union
aiCol	.\ext\fts5\fts5Int.h	/^  int aiCol[1];$/;"	m	struct:Fts5Colset
aiColumn	.\src\sqliteInt.h	/^  i16 *aiColumn;           \/* Which columns are used by this index.  1st is 0 *\/$/;"	m	struct:Index
aiColumn	.\src\whereInt.h	/^  i16 aiColumn[11];          \/* Corresponding column number in the eq-class *\/$/;"	m	struct:WhereScan
aiCur	.\src\whereInt.h	/^  int aiCur[11];             \/* Cursors in the equivalence class *\/$/;"	m	struct:WhereScan
aiCurOnePass	.\src\whereInt.h	/^  int aiCurOnePass[2];      \/* OP_OpenWrite cursors for the ONEPASS opt *\/$/;"	m	struct:WhereInfo
aiException	.\ext\fts3\fts3_unicode.c	/^  int *aiException;$/;"	m	struct:unicode_tokenizer	file:
aiException	.\ext\fts5\fts5_tokenize.c	/^  int *aiException;$/;"	m	struct:Unicode61Tokenizer	file:
aiFreelist	.\src\mem5.c	/^  int aiFreelist[LOGMAX+1];$/;"	m	struct:Mem5Global	file:
aiHash	.\src\mem3.c	/^  u32 aiHash[N_HASH];        \/* For sizes MX_SMALL+1 and larger *\/$/;"	m	struct:Mem3Global	file:
aiIdx	.\src\btreeInt.h	/^  u16 aiIdx[BTCURSOR_MAX_DEPTH];        \/* Current index in apPage[i] *\/$/;"	m	struct:BtCursor
aiIndent	.\src\shell.c	/^  int *aiIndent;         \/* Array of indents used in MODE_Explain *\/$/;"	m	struct:ShellState	file:
aiOvfl	.\src\btreeInt.h	/^  u16 aiOvfl[5];       \/* Insert the i-th overflow cell before the aiOvfl-th$/;"	m	struct:MemPage
aiRowEst	.\src\sqliteInt.h	/^  tRowcnt *aiRowEst;       \/* Non-logarithmic stat1 data for this index *\/$/;"	m	struct:Index
aiRowLogEst	.\src\sqliteInt.h	/^  LogEst *aiRowLogEst;     \/* From ANALYZE: Est. rows selected by each column *\/$/;"	m	struct:Index
aiSmall	.\src\mem3.c	/^  u32 aiSmall[MX_SMALL-1];   \/* For sizes 2 through MX_SMALL, inclusive *\/$/;"	m	struct:Mem3Global	file:
aiSrcOrder	.\ext\rbu\sqlite3rbu.c	/^  int *aiSrcOrder;                \/* src table col -> target table col *\/$/;"	m	struct:RbuObjIter	file:
alarmBusy	.\src\mem3.c	/^  int alarmBusy;$/;"	m	struct:Mem3Global	file:
alarmThreshold	.\src\malloc.c	/^  sqlite3_int64 alarmThreshold; \/* The soft heap limit *\/$/;"	m	struct:Mem0Global	file:
alias	.\tool\lemon.c	/^  const char *alias[MAXRHS]; \/* Aliases for each RHS symbol (or NULL) *\/$/;"	m	struct:pstate	file:
alignmentCollFunc	.\src\test1.c	/^static int alignmentCollFunc($/;"	f	file:
allLogs	.\ext\misc\vfslog.c	/^static VLogLog *allLogs = 0;$/;"	v	file:
allSpaces	.\src\main.c	/^static int allSpaces(const char *z, int n){$/;"	f	file:
all_descendents	.\tool\stack_usage.tcl	/^proc all_descendents {root} {$/;"	p
all_stop	.\test\threadtest2.c	/^volatile int all_stop = 0;$/;"	v
allcksum	.\test\tester.tcl	/^proc allcksum {{db db}} {$/;"	p
allocSpace	.\src\vdbeaux.c	/^static void *allocSpace($/;"	f	file:
allocateBtreePage	.\src\btree.c	/^static int allocateBtreePage($/;"	f	file:
allocateCursor	.\src\vdbe.c	/^static VdbeCursor *allocateCursor($/;"	f	file:
allocateIndexInfo	.\src\where.c	/^static sqlite3_index_info *allocateIndexInfo($/;"	f	file:
allocateSpace	.\src\btree.c	/^static int allocateSpace(MemPage *pPage, int nByte, int *pIdx){$/;"	f	file:
allocateTempSpace	.\src\btree.c	/^static void allocateTempSpace(BtShared *pBt){$/;"	f	file:
alloced	.\ext\fts1\fts1.c	/^  int alloced;  \/* Space allocated for s[] *\/ $/;"	m	struct:StringBuffer	file:
allowedOp	.\src\whereexpr.c	/^static int allowedOp(int op){$/;"	f	file:
amatchAddWord	.\ext\misc\amatch.c	/^static void amatchAddWord($/;"	f	file:
amatchAvlBalance	.\ext\misc\amatch.c	/^static amatch_avl *amatchAvlBalance(amatch_avl *p){$/;"	f	file:
amatchAvlFirst	.\ext\misc\amatch.c	/^static amatch_avl *amatchAvlFirst(amatch_avl *p){$/;"	f	file:
amatchAvlFromPtr	.\ext\misc\amatch.c	/^static amatch_avl **amatchAvlFromPtr(amatch_avl *p, amatch_avl **pp){$/;"	f	file:
amatchAvlInsert	.\ext\misc\amatch.c	/^static amatch_avl *amatchAvlInsert(amatch_avl **ppHead, amatch_avl *pNew){$/;"	f	file:
amatchAvlRecomputeHeight	.\ext\misc\amatch.c	/^static void amatchAvlRecomputeHeight(amatch_avl *p){$/;"	f	file:
amatchAvlRemove	.\ext\misc\amatch.c	/^static void amatchAvlRemove(amatch_avl **ppHead, amatch_avl *pOld){$/;"	f	file:
amatchAvlRotateAfter	.\ext\misc\amatch.c	/^static amatch_avl *amatchAvlRotateAfter(amatch_avl *pP){$/;"	f	file:
amatchAvlRotateBefore	.\ext\misc\amatch.c	/^static amatch_avl *amatchAvlRotateBefore(amatch_avl *pP){$/;"	f	file:
amatchAvlSearch	.\ext\misc\amatch.c	/^static amatch_avl *amatchAvlSearch(amatch_avl *p, const char *zKey){$/;"	f	file:
amatchBestIndex	.\ext\misc\amatch.c	/^static int amatchBestIndex($/;"	f	file:
amatchClearCursor	.\ext\misc\amatch.c	/^static void amatchClearCursor(amatch_cursor *pCur){$/;"	f	file:
amatchClose	.\ext\misc\amatch.c	/^static int amatchClose(sqlite3_vtab_cursor *cur){$/;"	f	file:
amatchColumn	.\ext\misc\amatch.c	/^static int amatchColumn(sqlite3_vtab_cursor *cur, sqlite3_context *ctx, int i){$/;"	f	file:
amatchConnect	.\ext\misc\amatch.c	/^static int amatchConnect($/;"	f	file:
amatchDequote	.\ext\misc\amatch.c	/^static char *amatchDequote(const char *zIn){$/;"	f	file:
amatchDisconnect	.\ext\misc\amatch.c	/^static int amatchDisconnect(sqlite3_vtab *pVtab){$/;"	f	file:
amatchEncodeInt	.\ext\misc\amatch.c	/^static void amatchEncodeInt(int x, char *z){$/;"	f	file:
amatchEof	.\ext\misc\amatch.c	/^static int amatchEof(sqlite3_vtab_cursor *cur){$/;"	f	file:
amatchFilter	.\ext\misc\amatch.c	/^static int amatchFilter($/;"	f	file:
amatchFree	.\ext\misc\amatch.c	/^static void amatchFree(amatch_vtab *p){$/;"	f	file:
amatchFreeRules	.\ext\misc\amatch.c	/^static void amatchFreeRules(amatch_vtab *p){$/;"	f	file:
amatchLoadOneRule	.\ext\misc\amatch.c	/^static int amatchLoadOneRule($/;"	f	file:
amatchLoadRules	.\ext\misc\amatch.c	/^static int amatchLoadRules($/;"	f	file:
amatchMergeRules	.\ext\misc\amatch.c	/^static amatch_rule *amatchMergeRules(amatch_rule *pA, amatch_rule *pB){$/;"	f	file:
amatchModule	.\ext\misc\amatch.c	/^static sqlite3_module amatchModule = {$/;"	v	file:
amatchNext	.\ext\misc\amatch.c	/^static int amatchNext(sqlite3_vtab_cursor *cur){$/;"	f	file:
amatchOpen	.\ext\misc\amatch.c	/^static int amatchOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor){$/;"	f	file:
amatchRowid	.\ext\misc\amatch.c	/^static int amatchRowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid){$/;"	f	file:
amatchStrcat	.\ext\misc\amatch.c	/^static void amatchStrcat(char *dest, const char *src){$/;"	f	file:
amatchStrcat	.\ext\misc\amatch.c	1014;"	d	file:
amatchStrcpy	.\ext\misc\amatch.c	/^static void amatchStrcpy(char *dest, const char *src){$/;"	f	file:
amatchStrcpy	.\ext\misc\amatch.c	1013;"	d	file:
amatchUpdate	.\ext\misc\amatch.c	/^static int amatchUpdate($/;"	f	file:
amatchVCheckClear	.\ext\misc\amatch.c	/^static void amatchVCheckClear(amatch_vtab *p){$/;"	f	file:
amatchValueOfKey	.\ext\misc\amatch.c	/^static const char *amatchValueOfKey(const char *zKey, const char *zStr){$/;"	f	file:
amatchWriteCost	.\ext\misc\amatch.c	/^static void amatchWriteCost(amatch_word *pWord){$/;"	f	file:
amatch_avl	.\ext\misc\amatch.c	/^struct amatch_avl {$/;"	s	file:
amatch_avl	.\ext\misc\amatch.c	/^typedef struct amatch_avl amatch_avl;$/;"	t	typeref:struct:amatch_avl	file:
amatch_cost	.\ext\misc\amatch.c	/^typedef int amatch_cost;$/;"	t	file:
amatch_cursor	.\ext\misc\amatch.c	/^struct amatch_cursor {$/;"	s	file:
amatch_cursor	.\ext\misc\amatch.c	/^typedef struct amatch_cursor amatch_cursor;$/;"	t	typeref:struct:amatch_cursor	file:
amatch_langid	.\ext\misc\amatch.c	/^typedef int amatch_langid;$/;"	t	file:
amatch_len	.\ext\misc\amatch.c	/^typedef signed char amatch_len;$/;"	t	file:
amatch_rule	.\ext\misc\amatch.c	/^struct amatch_rule {$/;"	s	file:
amatch_rule	.\ext\misc\amatch.c	/^typedef struct amatch_rule amatch_rule;$/;"	t	typeref:struct:amatch_rule	file:
amatch_vtab	.\ext\misc\amatch.c	/^struct amatch_vtab {$/;"	s	file:
amatch_vtab	.\ext\misc\amatch.c	/^typedef struct amatch_vtab amatch_vtab;$/;"	t	typeref:struct:amatch_vtab	file:
amatch_word	.\ext\misc\amatch.c	/^struct amatch_word {$/;"	s	file:
amatch_word	.\ext\misc\amatch.c	/^typedef struct amatch_word amatch_word;$/;"	t	typeref:struct:amatch_word	file:
anDLt	.\src\analyze.c	/^  tRowcnt *anDLt;                 \/* sqlite_stat4.nDLt *\/$/;"	m	struct:Stat4Sample	file:
anDLt	.\src\sqliteInt.h	/^  tRowcnt *anDLt;   \/* Est. number of distinct keys less than this sample *\/$/;"	m	struct:IndexSample
anEq	.\src\analyze.c	/^  tRowcnt *anEq;                  \/* sqlite_stat4.nEq *\/$/;"	m	struct:Stat4Sample	file:
anEq	.\src\sqliteInt.h	/^  tRowcnt *anEq;    \/* Est. number of rows where the key equals this sample *\/$/;"	m	struct:IndexSample
anExec	.\src\vdbeInt.h	/^  i64 *anExec;            \/* Event counters from parent frame *\/$/;"	m	struct:VdbeFrame
anExec	.\src\vdbeInt.h	/^  i64 *anExec;            \/* Number of times each op has been executed *\/$/;"	m	struct:Vdbe
anLt	.\src\analyze.c	/^  tRowcnt *anLt;                  \/* sqlite_stat4.nLt *\/$/;"	m	struct:Stat4Sample	file:
anLt	.\src\sqliteInt.h	/^  tRowcnt *anLt;    \/* Est. number of rows where key is less than this sample *\/$/;"	m	struct:IndexSample
anOutput	.\ext\fts3\fts3.c	/^  int anOutput[16];               \/* Size each output buffer in bytes *\/$/;"	m	struct:TermSelect	file:
anQueue	.\ext\rtree\rtree.c	/^  u32 anQueue[RTREE_MAX_DEPTH+1];   \/* Number of queued entries by iLevel *\/$/;"	m	struct:RtreeCursor	file:
anQueue	.\ext\rtree\sqlite3rtree.h	/^  unsigned int *anQueue;            \/* Number of pending entries in the queue *\/$/;"	m	struct:sqlite3_rtree_query_info
anStat	.\src\sqliteInt.h	/^  int anStat[3];          \/* 0: hits.  1: size misses.  2: full misses *\/$/;"	m	struct:Lookaside
an_load_separator_ranges	.\ext\fts3\unicode\mkunicode.tcl	/^proc an_load_separator_ranges {} {$/;"	p
an_load_unicodedata_text	.\ext\fts3\unicode\parseunicode.tcl	/^proc an_load_unicodedata_text {zName} {$/;"	p
an_print_ascii_bitmap	.\ext\fts3\unicode\mkunicode.tcl	/^proc an_print_ascii_bitmap {lRange} {$/;"	p
an_print_range_array	.\ext\fts3\unicode\mkunicode.tcl	/^proc an_print_range_array {lRange} {$/;"	p
analysisInfo	.\src\analyze.c	/^struct analysisInfo {$/;"	s	file:
analysisInfo	.\src\analyze.c	/^typedef struct analysisInfo analysisInfo;$/;"	t	typeref:struct:analysisInfo	file:
analysisLoader	.\src\analyze.c	/^static int analysisLoader(void *pData, int argc, char **argv, char **NotUsed){$/;"	f	file:
analyzeAggregate	.\src\expr.c	/^static int analyzeAggregate(Walker *pWalker, Expr *pExpr){$/;"	f	file:
analyzeAggregatesInSelect	.\src\expr.c	/^static int analyzeAggregatesInSelect(Walker *pWalker, Select *pSelect){$/;"	f	file:
analyzeDatabase	.\src\analyze.c	/^static void analyzeDatabase(Parse *pParse, int iDb){$/;"	f	file:
analyzeOneTable	.\src\analyze.c	/^static void analyzeOneTable($/;"	f	file:
analyzeTable	.\src\analyze.c	/^static void analyzeTable(Parse *pParse, Table *pTab, Index *pOnlyIdx){$/;"	f	file:
anylist	.\src\parse.y	/^anylist ::= .$/;"	l
anylist	.\src\parse.y	/^anylist ::= anylist ANY.$/;"	l
anylist	.\src\parse.y	/^anylist ::= anylist LP anylist RP.$/;"	l
ap	.\tool\lemon.c	/^  struct action *ap;       \/* Array of actions for this state *\/$/;"	m	struct:state	typeref:struct:state::action	file:
apArg	.\src\sqliteInt.h	/^  sqlite3_value **apArg;   \/* The argument values *\/$/;"	m	struct:PrintfArguments
apArg	.\src\vdbeInt.h	/^  Mem **apArg;            \/* Arguments to currently executing user function *\/$/;"	m	struct:Vdbe
apCell	.\src\btree.c	/^  u8 **apCell;            \/* All cells begin balanced *\/$/;"	m	struct:CellArray	file:
apChild	.\ext\fts5\fts5_expr.c	/^  Fts5ExprNode *apChild[1];       \/* Array of child nodes *\/$/;"	m	struct:Fts5ExprNode	file:
apColName	.\src\tclsqlite.c	/^  Tcl_Obj **apColName;            \/* Array of column names *\/$/;"	m	struct:DbEvalContext	file:
apCsr	.\src\vdbeInt.h	/^  VdbeCursor **apCsr;     \/* Array of Vdbe cursors for parent frame *\/$/;"	m	struct:VdbeFrame
apCsr	.\src\vdbeInt.h	/^  VdbeCursor **apCsr;     \/* One element of this array for each open cursor *\/$/;"	m	struct:Vdbe
apDel	.\ext\misc\spellfix.c	/^  EditDist3Cost **apDel;   \/* Array of deletion cost entries *\/$/;"	m	struct:EditDist3From	file:
apExprPhrase	.\ext\fts5\fts5_expr.c	/^  Fts5ExprPhrase **apExprPhrase;  \/* Pointers to phrase objects *\/$/;"	m	struct:Fts5Expr	file:
apHash	.\ext\misc\fuzzer.c	/^  fuzzer_stem *apHash[FUZZER_HASH]; \/* Hash of previously generated terms *\/$/;"	m	struct:fuzzer_cursor	file:
apHash	.\src\pcache1.c	/^  PgHdr1 **apHash;                    \/* Hash table for fast lookup by key *\/$/;"	m	struct:PCache1	file:
apIns	.\ext\misc\spellfix.c	/^  EditDist3Cost **apIns;   \/* Array of deletion cost entries *\/$/;"	m	struct:EditDist3To	file:
apOvfl	.\src\btreeInt.h	/^  u8 *apOvfl[5];       \/* Pointers to the body of overflow cells *\/$/;"	m	struct:MemPage
apPage	.\src\btreeInt.h	/^  MemPage *apPage[BTCURSOR_MAX_DEPTH];  \/* Pages from root to current page *\/$/;"	m	struct:BtCursor
apParm	.\src\tclsqlite.c	/^  Tcl_Obj **apParm;        \/* Array of referenced object pointers *\/$/;"	m	struct:SqlPreparedStmt	file:
apPhrase	.\ext\fts5\fts5_expr.c	/^  Fts5ExprPhrase **apPhrase;      \/* Array of all phrases *\/$/;"	m	struct:Fts5Parse	file:
apPhrase	.\ext\fts5\fts5_expr.c	/^  Fts5ExprPhrase *apPhrase[1];    \/* Array of phrase pointers *\/$/;"	m	struct:Fts5ExprNearset	file:
apRankArg	.\ext\fts5\fts5_main.c	/^  sqlite3_value **apRankArg;      \/* Array of trailing arguments *\/$/;"	m	struct:Fts5Cursor	file:
apRegion	.\src\os_unix.c	/^  char **apRegion;           \/* Array of mapped shared-memory regions *\/$/;"	m	struct:unixShmNode	file:
apSegment	.\ext\fts3\fts3Int.h	/^  Fts3SegReader **apSegment;      \/* Array of Fts3SegReader objects *\/$/;"	m	struct:Fts3MultiSegReader
apShm	.\ext\rbu\sqlite3rbu.c	/^  char **apShm;                   \/* Array of mmap'd *-shm regions *\/$/;"	m	struct:rbu_file	file:
apSqlParam	.\ext\rtree\rtree.c	/^  sqlite3_value **apSqlParam; \/* Original SQL parameter values *\/$/;"	m	struct:RtreeMatchArg	file:
apSqlParam	.\ext\rtree\sqlite3rtree.h	/^  sqlite3_value **apSqlParam;       \/* Original SQL values of parameters *\/$/;"	m	struct:sqlite3_rtree_query_info
apSub	.\src\bitvec.c	/^    Bitvec *apSub[BITVEC_NPTR];  \/* Recursive representation *\/$/;"	m	union:Bitvec::__anon8	file:
apSub	.\src\vdbeaux.c	/^  SubProgram **apSub;        \/* Array of subprograms *\/$/;"	m	struct:VdbeOpIter	file:
apSubst	.\ext\misc\spellfix.c	/^  EditDist3Cost **apSubst; \/* Array of substitution costs for this element *\/$/;"	m	struct:EditDist3From	file:
apTrigger	.\src\sqliteInt.h	/^  Trigger *apTrigger[2];\/* Triggers for aAction[] actions *\/$/;"	m	struct:FKey
apVfs	.\src\test1.c	/^static sqlite3_vfs *apVfs[20];$/;"	v	file:
apVtabLock	.\src\sqliteInt.h	/^  Table **apVtabLock;       \/* Pointer to virtual tables needing locking *\/$/;"	m	struct:Parse
apWiData	.\src\wal.c	/^  volatile u32 **apWiData;   \/* Pointer to wal-index content in memory *\/$/;"	m	struct:Wal	file:
api	.\ext\fts5\fts5_main.c	/^  fts5_api api;                   \/* User visible part of object (see fts5.h) *\/$/;"	m	struct:Fts5Global	file:
apiOomError	.\src\malloc.c	/^static SQLITE_NOINLINE int apiOomError(sqlite3 *db){$/;"	f	file:
append	.\ext\fts1\fts1.c	/^static void append(StringBuffer *sb, const char *zFrom){$/;"	f	file:
append	.\ext\fts2\fts2.c	/^static void append(StringBuffer *sb, const char *zFrom){$/;"	f	file:
appendArgs	.\tool\mkvsix.tcl	/^proc appendArgs { args } {$/;"	p
appendList	.\ext\fts1\fts1.c	/^static void appendList(StringBuffer *sb, int nString, char **azString){$/;"	f	file:
appendList	.\ext\fts2\fts2.c	/^static void appendList(StringBuffer *sb, int nString, char **azString){$/;"	f	file:
appendText	.\src\shell.c	/^static char *appendText(char *zIn, char const *zAppend, char quote){$/;"	f	file:
appendToEchoModule	.\src\test8.c	/^static void appendToEchoModule(Tcl_Interp *interp, const char *zArg){$/;"	f	file:
appendVarint	.\ext\fts1\fts1.c	/^static void appendVarint(DocList *d, sqlite_int64 i){$/;"	f	file:
appendVarint	.\ext\fts1\fulltext.c	/^static void appendVarint(DocList *d, sqlite_int64 i){$/;"	f	file:
appendWhiteSpace	.\ext\fts1\fts1.c	/^static void appendWhiteSpace(StringBuffer *p){$/;"	f	file:
appendWhiteSpace	.\ext\fts2\fts2.c	/^static void appendWhiteSpace(StringBuffer *p){$/;"	f	file:
append_str	.\tool\lemon.c	/^PRIVATE char *append_str(const char *zText, int n, int p1, int p2){$/;"	f
applyAffinity	.\src\vdbe.c	/^static void applyAffinity($/;"	f	file:
applyNumericAffinity	.\src\vdbe.c	/^static void applyNumericAffinity(Mem *pRec, int bTryForInt){$/;"	f	file:
approx	.\src\func.c	/^  u8 approx;        \/* True if non-integer value was input to the sum *\/$/;"	m	struct:SumCtx	file:
arg	.\tool\lemon.c	/^  char *arg;               \/* Declaration of the 3th argument to parser *\/$/;"	m	struct:lemon	file:
arg	.\tool\lemon.c	/^  char *arg;$/;"	m	struct:s_options	file:
argc	.\src\test4.c	/^  int argc;             \/* number of columns in result *\/$/;"	m	struct:Thread	file:
argc	.\src\test7.c	/^  int argc;                \/* number of columns in result *\/$/;"	m	struct:Thread	file:
argc	.\src\vdbeInt.h	/^  u8 argc;                \/* Number of arguments *\/$/;"	m	struct:sqlite3_context
argindex	.\tool\lemon.c	/^static int argindex(int n)$/;"	f	file:
argv	.\src\test4.c	/^  const char *argv[100];    \/* result columns *\/$/;"	m	struct:Thread	file:
argv	.\src\test7.c	/^  const char *argv[100];   \/* result columns *\/$/;"	m	struct:Thread	file:
argv	.\src\vdbeInt.h	/^  sqlite3_value *argv[1]; \/* Argument set *\/$/;"	m	struct:sqlite3_context
argv	.\tool\lemon.c	/^static char **argv;$/;"	v	file:
argv0	.\mptest\mptest.c	/^  char *argv0;           \/* Name of the executable *\/$/;"	m	struct:Global	file:
argv0	.\tool\lemon.c	/^  char *argv0;             \/* Name of the program *\/$/;"	m	struct:lemon	file:
asciiFold	.\ext\fts5\fts5_tokenize.c	/^static void asciiFold(char *aOut, const char *aIn, int nByte){$/;"	f	file:
asciiToUtf16le	.\tool\speedtest16.c	/^static void *asciiToUtf16le(const char *z){$/;"	f	file:
ascii_read_one_field	.\src\shell.c	/^static char *SQLITE_CDECL ascii_read_one_field(ImportCtx *p){$/;"	f	file:
assertCellInfo	.\src\btree.c	/^  static void assertCellInfo(BtCursor *pCur){$/;"	f	file:
assertCellInfo	.\src\btree.c	4199;"	d	file:
assertColumnName	.\ext\rbu\sqlite3rbu.c	/^static void assertColumnName(sqlite3_stmt *pStmt, int iCol, const char *zName){$/;"	f	file:
assertColumnName	.\ext\rbu\sqlite3rbu.c	2555;"	d	file:
assertMutexHeld	.\src\notify.c	31;"	d	file:
assertParentIndex	.\src\btree.c	/^static void assertParentIndex(MemPage *pParent, int iIdx, Pgno iChild){$/;"	f	file:
assertParentIndex	.\src\btree.c	4751;"	d	file:
assertTruncateConstraint	.\src\pager.c	/^static void assertTruncateConstraint(Pager *pPager){$/;"	f	file:
assertTruncateConstraint	.\src\pager.c	3840;"	d	file:
assertTruncateConstraintCb	.\src\pager.c	/^static void assertTruncateConstraintCb(PgHdr *pPg){$/;"	f	file:
assert_mutex_is_held	.\ext\async\sqlite3async.c	371;"	d	file:
assert_nc	.\ext\fts5\fts5Int.h	78;"	d
assert_nc	.\ext\fts5\fts5Int.h	80;"	d
assert_pager_state	.\src\pager.c	/^static int assert_pager_state(Pager *p){$/;"	f	file:
assoc	.\tool\lemon.c	/^  enum e_assoc assoc;      \/* Associativity if precedence is defined *\/$/;"	m	struct:symbol	typeref:enum:symbol::e_assoc	file:
async	.\ext\async\sqlite3async.c	/^} async = { 0,0,0,0,0,1,0,0 };$/;"	v	typeref:struct:TestAsyncStaticData	file:
asyncAccess	.\ext\async\sqlite3async.c	/^static int asyncAccess($/;"	f	file:
asyncCheckReservedLock	.\ext\async\sqlite3async.c	/^static int asyncCheckReservedLock(sqlite3_file *pFile, int *pResOut){$/;"	f	file:
asyncClose	.\ext\async\sqlite3async.c	/^static int asyncClose(sqlite3_file *pFile){$/;"	f	file:
asyncCurrentTime	.\ext\async\sqlite3async.c	/^static int asyncCurrentTime(sqlite3_vfs *pAsyncVfs, double *pTimeOut){$/;"	f	file:
asyncDelete	.\ext\async\sqlite3async.c	/^static int asyncDelete(sqlite3_vfs *pAsyncVfs, const char *z, int syncDir){$/;"	f	file:
asyncDeviceCharacteristics	.\ext\async\sqlite3async.c	/^static int asyncDeviceCharacteristics(sqlite3_file *pFile){$/;"	f	file:
asyncDlClose	.\ext\async\sqlite3async.c	/^static void asyncDlClose(sqlite3_vfs *pAsyncVfs, void *pHandle){$/;"	f	file:
asyncDlError	.\ext\async\sqlite3async.c	/^static void asyncDlError(sqlite3_vfs *pAsyncVfs, int nByte, char *zErrMsg){$/;"	f	file:
asyncDlOpen	.\ext\async\sqlite3async.c	/^static void *asyncDlOpen(sqlite3_vfs *pAsyncVfs, const char *zPath){$/;"	f	file:
asyncDlSym	.\ext\async\sqlite3async.c	/^static void (*asyncDlSym($/;"	f	file:
asyncFileControl	.\ext\async\sqlite3async.c	/^static int asyncFileControl(sqlite3_file *id, int op, void *pArg){$/;"	f	file:
asyncFileSize	.\ext\async\sqlite3async.c	/^int asyncFileSize(sqlite3_file *pFile, sqlite3_int64 *piSize){$/;"	f
asyncFullPathname	.\ext\async\sqlite3async.c	/^static int asyncFullPathname($/;"	f	file:
asyncLock	.\ext\async\sqlite3async.c	/^static int asyncLock(sqlite3_file *pFile, int eLock){$/;"	f	file:
asyncOpen	.\ext\async\sqlite3async.c	/^static int asyncOpen($/;"	f	file:
asyncRandomness	.\ext\async\sqlite3async.c	/^static int asyncRandomness(sqlite3_vfs *pAsyncVfs, int nByte, char *zBufOut){$/;"	f	file:
asyncRead	.\ext\async\sqlite3async.c	/^static int asyncRead($/;"	f	file:
asyncSectorSize	.\ext\async\sqlite3async.c	/^static int asyncSectorSize(sqlite3_file *pFile){$/;"	f	file:
asyncSleep	.\ext\async\sqlite3async.c	/^static int asyncSleep(sqlite3_vfs *pAsyncVfs, int nMicro){$/;"	f	file:
asyncSync	.\ext\async\sqlite3async.c	/^static int asyncSync(sqlite3_file *pFile, int flags){$/;"	f	file:
asyncTrace	.\ext\async\sqlite3async.c	/^static void asyncTrace(const char *zFormat, ...){$/;"	f	file:
asyncTruncate	.\ext\async\sqlite3async.c	/^static int asyncTruncate(sqlite3_file *pFile, sqlite3_int64 nByte){$/;"	f	file:
asyncUnlock	.\ext\async\sqlite3async.c	/^static int asyncUnlock(sqlite3_file *pFile, int eLock){$/;"	f	file:
asyncWrite	.\ext\async\sqlite3async.c	/^static int asyncWrite($/;"	f	file:
asyncWriterThread	.\ext\async\sqlite3async.c	/^static void asyncWriterThread(void){$/;"	f	file:
async_cond_signal	.\ext\async\sqlite3async.c	/^static void async_cond_signal(int eCond){$/;"	f	file:
async_cond_wait	.\ext\async\sqlite3async.c	/^static void async_cond_wait(int eCond, int eMutex){$/;"	f	file:
async_mutex_enter	.\ext\async\sqlite3async.c	/^static void async_mutex_enter(int eMutex){$/;"	f	file:
async_mutex_leave	.\ext\async\sqlite3async.c	/^static void async_mutex_leave(int eMutex){$/;"	f	file:
async_os_initialize	.\ext\async\sqlite3async.c	/^static int  async_os_initialize(void) {return 0;}$/;"	f	file:
async_os_initialize	.\ext\async\sqlite3async.c	/^static int async_os_initialize(void){$/;"	f	file:
async_os_shutdown	.\ext\async\sqlite3async.c	/^static void async_os_shutdown(void) {}$/;"	f	file:
async_os_shutdown	.\ext\async\sqlite3async.c	/^static void async_os_shutdown(void){$/;"	f	file:
async_sched_yield	.\ext\async\sqlite3async.c	/^static void async_sched_yield(void){$/;"	f	file:
async_vfs	.\ext\async\sqlite3async.c	/^static sqlite3_vfs async_vfs = {$/;"	v	file:
atEOF	.\ext\rtree\rtree.c	/^  u8 atEOF;                         \/* True if at end of search *\/$/;"	m	struct:RtreeCursor	file:
atEnd	.\ext\fts1\fts1.c	/^static int atEnd(DocListReader *pReader){$/;"	f	file:
atoi64	.\ext\fts3\tool\fts3view.c	/^static sqlite3_int64 atoi64(const char *z){$/;"	f	file:
attachBackupObject	.\src\backup.c	/^static void attachBackupObject(sqlite3_backup *p){$/;"	f	file:
attachFunc	.\src\attach.c	/^static void attachFunc($/;"	f	file:
auth	.\src\sqliteInt.h	/^  sqlite3_userauth auth;        \/* User authentication information *\/$/;"	m	struct:sqlite3
authCallback	.\ext\misc\showauth.c	/^static int authCallback($/;"	f	file:
authLevel	.\src\sqliteInt.h	/^  u8 authLevel;                 \/* Current authentication level *\/$/;"	m	struct:sqlite3_userauth
auth_callback	.\src\tclsqlite.c	/^static int auth_callback($/;"	f	file:
autoCommit	.\src\sqliteInt.h	/^  u8 autoCommit;                \/* The auto-commit flag. *\/$/;"	m	struct:sqlite3
autoEQP	.\src\shell.c	/^  int autoEQP;           \/* Run EXPLAIN QUERY PLAN prior to seach SQL stmt *\/$/;"	m	struct:ShellState	file:
autoExtBrokenObjCmd	.\src\test_autoext.c	/^static int autoExtBrokenObjCmd($/;"	f	file:
autoExtCubeObjCmd	.\src\test_autoext.c	/^static int autoExtCubeObjCmd($/;"	f	file:
autoExtSqrObjCmd	.\src\test_autoext.c	/^static int autoExtSqrObjCmd($/;"	f	file:
autoIncBegin	.\src\insert.c	/^static int autoIncBegin($/;"	f	file:
autoIncBegin	.\src\insert.c	338;"	d	file:
autoIncStep	.\src\insert.c	/^static void autoIncStep(Parse *pParse, int memId, int regRowid){$/;"	f	file:
autoIncStep	.\src\insert.c	339;"	d	file:
autoReduce	.\tool\lemon.c	/^  int autoReduce;          \/* True if this is an auto-reduce state *\/$/;"	m	struct:state	file:
autoVacuum	.\src\btreeInt.h	/^  u8 autoVacuum;        \/* True if auto-vacuum is enabled *\/$/;"	m	struct:BtShared
autoVacuumCommit	.\src\btree.c	/^static int autoVacuumCommit(BtShared *pBt){$/;"	f	file:
auto_extension	.\src\sqlite3ext.h	/^  int (*auto_extension)(void(*)(void));$/;"	m	struct:sqlite3_api_routines
autoinstall_test_funcs	.\src\test_func.c	/^static int autoinstall_test_funcs($/;"	f	file:
autolockIoFinder	.\src\os_unix.c	/^  *(*const autolockIoFinder)(const char*,unixFile*) = autolockIoFinderImpl;$/;"	v	file:
autolockIoFinderImpl	.\src\os_unix.c	/^static const sqlite3_io_methods *autolockIoFinderImpl($/;"	f	file:
autovacuum_overhead	.\tool\spaceanal.tcl	/^proc autovacuum_overhead {filePages pageSize} {$/;"	p
avgFinalize	.\src\func.c	/^static void avgFinalize(sqlite3_context *context){$/;"	f	file:
avgdl	.\ext\fts5\fts5_aux.c	/^  double avgdl;                   \/* Average number of tokens in each row *\/$/;"	m	struct:Fts5Bm25Data	file:
axset	.\tool\lemon.c	/^struct axset {$/;"	s	file:
axset_compare	.\tool\lemon.c	/^static int axset_compare(const void *a, const void *b){$/;"	f	file:
azCol	.\ext\fts3\fts3_expr.c	/^  const char **azCol;                 \/* Array of column names for fts3 table *\/$/;"	m	struct:ParseContext	file:
azCol	.\ext\fts5\fts5Int.h	/^  char **azCol;                   \/* Column names *\/$/;"	m	struct:Fts5Config
azColl	.\src\sqliteInt.h	/^  char **azColl;           \/* Array of collation sequence names for index *\/$/;"	m	struct:Index
azColumn	.\ext\fts1\fts1.c	/^  char **azColumn;                 \/* column names.  malloced *\/$/;"	m	struct:fulltext_vtab	file:
azColumn	.\ext\fts1\fts1.c	/^  char **azColumn;         \/* Original names of columns to be indexed *\/$/;"	m	struct:TableSpec	file:
azColumn	.\ext\fts2\fts2.c	/^  char **azColumn;                 \/* column names.  malloced *\/$/;"	m	struct:fulltext_vtab	file:
azColumn	.\ext\fts2\fts2.c	/^  char **azColumn;         \/* Original names of columns to be indexed *\/$/;"	m	struct:TableSpec	file:
azColumn	.\ext\fts3\fts3Int.h	/^  char **azColumn;                \/* column names.  malloced *\/$/;"	m	struct:Fts3Table
azCompileOpt	.\src\ctime.c	/^static const char * const azCompileOpt[] = {$/;"	v	file:
azContentColumn	.\ext\fts1\fts1.c	/^  char **azContentColumn;          \/* column names in content table; malloced *\/$/;"	m	struct:fulltext_vtab	file:
azContentColumn	.\ext\fts1\fts1.c	/^  char **azContentColumn;  \/* Column names for %_content *\/$/;"	m	struct:TableSpec	file:
azContentColumn	.\ext\fts2\fts2.c	/^  char **azContentColumn;          \/* column names in content table; malloced *\/$/;"	m	struct:fulltext_vtab	file:
azContentColumn	.\ext\fts2\fts2.c	/^  char **azContentColumn;  \/* Column names for %_content *\/$/;"	m	struct:TableSpec	file:
azDefine	.\tool\lemon.c	/^static char **azDefine = 0;  \/* Name of the -D macros *\/$/;"	v	file:
azElem	.\test\threadtest1.c	/^  char **azElem;      \/* The result of the query *\/$/;"	m	struct:QueryResult	file:
azExtra	.\ext\fts3\tool\fts3view.c	/^char **azExtra;$/;"	v
azFile	.\src\test_osinst.c	/^  char **azFile;                  \/* File strings *\/$/;"	m	struct:VfslogCsr	file:
azFileLock	.\src\os_unix.c	/^static const char *azFileLock(int eFileLock){$/;"	f	file:
azModuleArg	.\src\sqliteInt.h	/^  char **azModuleArg;  \/* 0: module 1: schema 2: vtab name 3...: args *\/$/;"	m	struct:Table
azOpcodeName	.\ext\async\sqlite3async.c	/^static const char *azOpcodeName[] = {$/;"	v	file:
azPrior	.\ext\misc\spellfix.c	/^  char azPrior[SPELLFIX_MX_RUN][SPELLFIX_MX_HASH];  \/* Prior hashes *\/$/;"	m	struct:MatchQuery	file:
azResult	.\src\table.c	/^  char **azResult;   \/* Accumulated output *\/$/;"	m	struct:TabResult	file:
azTblCol	.\ext\rbu\sqlite3rbu.c	/^  char **azTblCol;                \/* Array of unquoted target column names *\/$/;"	m	struct:RbuObjIter	file:
azTblType	.\ext\rbu\sqlite3rbu.c	/^  char **azTblType;               \/* Array of target column types *\/$/;"	m	struct:RbuObjIter	file:
azTokenizer	.\ext\fts1\fts1.c	/^  char **azTokenizer;      \/* Name of tokenizer and its arguments *\/$/;"	m	struct:TableSpec	file:
azTokenizer	.\ext\fts2\fts2.c	/^  char **azTokenizer;      \/* Name of tokenizer and its arguments *\/$/;"	m	struct:TableSpec	file:
azVar	.\src\sqliteInt.h	/^  char **azVar;             \/* Pointers to names of parameters *\/$/;"	m	struct:Parse
azVar	.\src\vdbeInt.h	/^  char **azVar;           \/* Name of variables *\/$/;"	m	struct:Vdbe
b	.\ext\fts2\fts2.c	/^  DataBuffer *b;$/;"	m	struct:DLWriter	file:
b	.\ext\fts2\fts2.c	/^  DataBuffer b;            \/* Includes null terminator. *\/$/;"	m	struct:StringBuffer	file:
b	.\ext\fts2\fts2.c	/^  DataBuffer b;$/;"	m	struct:DLCollector	file:
b	.\ext\fts5\fts5.h	/^  const unsigned char *b;$/;"	m	struct:Fts5PhraseIter
b	.\tool\sqldiff.c	/^  u16 a, b;         \/* Hash values *\/$/;"	m	struct:hash	file:
bBusy	.\src\btreeInt.h	/^  u8 bBusy;            \/* Prevent endless loops on corrupt database files *\/$/;"	m	struct:MemPage
bCleanup	.\ext\rbu\sqlite3rbu.c	/^  int bCleanup;                   \/* True in "cleanup" state *\/$/;"	m	struct:RbuObjIter	file:
bColumnsize	.\ext\fts5\fts5Int.h	/^  int bColumnsize;                \/* "columnsize=" option value (dflt==1) *\/$/;"	m	struct:Fts5Config
bConstraint	.\src\sqliteInt.h	/^  u8 bConstraint;           \/* True if constraints are supported *\/$/;"	m	struct:VTable
bCoreMutex	.\src\sqliteInt.h	/^  int bCoreMutex;                   \/* True to enable core mutexing *\/$/;"	m	struct:Sqlite3Config
bDeclared	.\src\vtab.c	/^  int bDeclared;      \/* True after sqlite3_declare_vtab() is called *\/$/;"	m	struct:VtabCtx	file:
bDeferred	.\ext\fts3\fts3Int.h	/^  u8 bDeferred;              \/* True if this expression is entirely deferred *\/$/;"	m	struct:Fts3Expr
bDel	.\ext\fts5\fts5_hash.c	/^  u8 bDel;                        \/* Set delete-flag @ iSzPoslist *\/$/;"	m	struct:Fts5HashEntry	file:
bDel	.\ext\fts5\fts5_index.c	/^  int bDel;                       \/* True if the delete flag is set *\/$/;"	m	struct:Fts5SegIter	file:
bDelete	.\ext\fts5\fts5_index.c	/^  int bDelete;                    \/* Current write is a delete *\/$/;"	m	struct:Fts5Index	file:
bDesc	.\ext\fts3\fts3Int.h	/^  u8 bDesc;                       \/* True to sort in descending order *\/$/;"	m	struct:Fts3Cursor
bDesc	.\ext\fts5\fts5_expr.c	/^  int bDesc;                      \/* Iterate in descending rowid order *\/$/;"	m	struct:Fts5Expr	file:
bDesc	.\ext\fts5\fts5_main.c	/^  int bDesc;                      \/* True for "ORDER BY rowid DESC" queries *\/$/;"	m	struct:Fts5Cursor	file:
bDescIdx	.\ext\fts3\fts3Int.h	/^  u8 bDescIdx;                    \/* True if doclists are in reverse order *\/$/;"	m	struct:Fts3Table
bDestLocked	.\src\backup.c	/^  int bDestLocked;         \/* True once a write-transaction is open on pDest *\/$/;"	m	struct:sqlite3_backup	file:
bDisposed	.\ext\misc\vtshim.c	/^  int bDisposed;                \/* True if disposed *\/$/;"	m	struct:vtshim_aux	file:
bDoTruncate	.\src\btreeInt.h	/^  u8 bDoTruncate;       \/* True to truncate db on commit *\/$/;"	m	struct:BtShared
bDone	.\src\vdbesort.c	/^  int bDone;                      \/* Set if thread is finished but not joined *\/$/;"	m	struct:SortSubtask	file:
bEnabled	.\src\sqliteInt.h	/^  u8 bEnabled;            \/* False to disable new lookaside allocations *\/$/;"	m	struct:Lookaside
bEnabled	.\src\test_multiplex.c	/^  unsigned char bEnabled;          \/* TRUE to use Multiplex VFS for this file *\/$/;"	m	struct:multiplexGroup	file:
bEof	.\ext\fts3\fts3Int.h	/^  u8 bEof;                   \/* True this expression is at EOF already *\/$/;"	m	struct:Fts3Expr
bEof	.\ext\fts5\fts5Int.h	/^  u8 bEof;                        \/* Set to true at EOF *\/$/;"	m	struct:Fts5PoslistReader
bEof	.\ext\fts5\fts5_expr.c	/^  int bEof;                       \/* True at EOF *\/$/;"	m	struct:Fts5ExprNode	file:
bEof	.\ext\fts5\fts5_index.c	/^  int bEof;                     \/* At EOF already *\/$/;"	m	struct:Fts5DlidxLvl	file:
bEof	.\ext\fts5\fts5_index.c	/^  u8 bEof;                        \/* True at EOF *\/$/;"	m	struct:Fts5IndexIter	file:
bEof	.\ext\fts5\fts5_vocab.c	/^  int bEof;                       \/* True if this cursor is at EOF *\/$/;"	m	struct:Fts5VocabCursor	file:
bEof	.\src\vdbesort.c	/^  int bEof;                       \/* Set to true when merge is finished *\/$/;"	m	struct:IncrMerger	file:
bErr	.\ext\misc\json1.c	/^  u8 bErr;                 \/* True if an error has been encountered *\/$/;"	m	struct:JsonString	file:
bExclusive	.\src\os_win.c	/^  BOOL bExclusive;    \/* Indicates an exclusive lock has been obtained *\/$/;"	m	struct:winceLock	file:
bExplain	.\test\speedtest1.c	/^  int bExplain;              \/* Print SQL with EXPLAIN prefix *\/$/;"	m	struct:Global	file:
bFiltered	.\ext\fts5\fts5_index.c	/^  u8 bFiltered;                   \/* True if column-filter already applied *\/$/;"	m	struct:Fts5IndexIter	file:
bFirst	.\ext\fts3\fts3Int.h	/^  int bFirst;                     \/* True if token must appear at position 0 *\/$/;"	m	struct:Fts3PhraseToken
bFirstRowidInDoclist	.\ext\fts5\fts5_index.c	/^  u8 bFirstRowidInDoclist;        \/* True if next rowid is first in doclist *\/$/;"	m	struct:Fts5SegWriter	file:
bFirstRowidInPage	.\ext\fts5\fts5_index.c	/^  u8 bFirstRowidInPage;           \/* True if next rowid is first in page *\/$/;"	m	struct:Fts5SegWriter	file:
bFirstTermInPage	.\ext\fts5\fts5_index.c	/^  u8 bFirstTermInPage;            \/* True if next term will be first in leaf *\/$/;"	m	struct:Fts5SegWriter	file:
bFlag	.\ext\fts5\fts5Int.h	/^  u8 bFlag;                       \/* For client use (any custom purpose) *\/$/;"	m	struct:Fts5PoslistReader
bFreeList	.\ext\fts3\fts3Int.h	/^  int bFreeList;                 \/* True if pList should be sqlite3_free()d *\/$/;"	m	struct:Fts3Doclist
bFreeWith	.\src\sqliteInt.h	/^  u8 bFreeWith;             \/* True if pWith should be freed with parser *\/$/;"	m	struct:Parse
bFts4	.\ext\fts3\fts3Int.h	/^  u8 bFts4;                       \/* True for FTS4, false for FTS3 *\/$/;"	m	struct:Fts3Table
bFts4	.\ext\fts3\fts3_expr.c	/^  int bFts4;                          \/* True to allow FTS4-only syntax *\/$/;"	m	struct:ParseContext	file:
bFullMutex	.\src\sqliteInt.h	/^  int bFullMutex;                   \/* True to enable full mutexing *\/$/;"	m	struct:Sqlite3Config
bGlobal	.\ext\fts3\fts3_snippet.c	/^  int bGlobal;                    \/* Set if global data is loaded *\/$/;"	m	struct:MatchinfoBuffer	file:
bHasDocsize	.\ext\fts3\fts3Int.h	/^  u8 bHasDocsize;                 \/* True if %_docsize table exists *\/$/;"	m	struct:Fts3Table
bHasStat	.\ext\fts3\fts3Int.h	/^  u8 bHasStat;                    \/* True if %_stat table exists (2==unknown) *\/$/;"	m	struct:Fts3Table
bIgnore	.\ext\fts3\fts3.c	/^  int bIgnore;$/;"	m	struct:TokenDoclist	file:
bIgnoreSavepoint	.\ext\fts3\fts3Int.h	/^  u8 bIgnoreSavepoint;            \/* True to ignore xSavepoint invocations *\/$/;"	m	struct:Fts3Table
bIgnoreSqlErrors	.\mptest\mptest.c	/^  int bIgnoreSqlErrors;  \/* Ignore errors in SQL statements *\/$/;"	m	struct:Global	file:
bIncr	.\ext\fts3\fts3Int.h	/^  int bIncr;                 \/* True if doclist is loaded incrementally *\/$/;"	m	struct:Fts3Phrase
bIsReader	.\src\vdbeInt.h	/^  bft bIsReader:1;        \/* True for statements that read *\/$/;"	m	struct:Vdbe
bLegacyPrepare	.\src\tclsqlite.c	/^  int bLegacyPrepare;        \/* True to use sqlite3_prepare() *\/$/;"	m	struct:SqliteDb	file:
bLine	.\src\sqliteInt.h	/^  u8  bLine[100];         \/* Draw vertical in column i if bLine[i] is true *\/$/;"	m	struct:TreeView
bLocaltimeFault	.\src\sqliteInt.h	/^  int bLocaltimeFault;              \/* True to fail localtime() calls *\/$/;"	m	struct:Sqlite3Config
bLockFiles	.\ext\async\sqlite3async.c	/^  volatile int bLockFiles;     \/* Current value of "lockfiles" parameter *\/$/;"	m	struct:TestAsyncStaticData	file:
bLookup	.\ext\fts3\fts3Int.h	/^  int bLookup;                    \/* True if a lookup of a single entry. *\/$/;"	m	struct:Fts3MultiSegReader
bLookup	.\ext\fts3\fts3_write.c	/^  u8 bLookup;                     \/* True for a lookup only *\/$/;"	m	struct:Fts3SegReader	file:
bMalloced	.\src\sqliteInt.h	/^  u8 bMalloced;           \/* True if pStart obtained from sqlite3_malloc() *\/$/;"	m	struct:Lookaside
bMemShrink	.\test\speedtest1.c	/^  int bMemShrink;            \/* Call sqlite3_db_release_memory() often *\/$/;"	m	struct:Global	file:
bMemstat	.\src\sqliteInt.h	/^  int bMemstat;                     \/* True to enable memory status *\/$/;"	m	struct:Sqlite3Config
bNoIncrDoclist	.\ext\fts3\fts3Int.h	/^  int bNoIncrDoclist;$/;"	m	struct:Fts3Table
bNoLeafData	.\ext\fts3\fts3_write.c	/^  u8 bNoLeafData;                 \/* If true, store 0 for segment size *\/$/;"	m	struct:IncrmergeWriter	file:
bNomatch	.\ext\fts5\fts5_expr.c	/^  int bNomatch;                   \/* True if entry is not a match *\/$/;"	m	struct:Fts5ExprNode	file:
bOomEnable	.\tool\fuzzershell.c	/^  int bOomEnable;                  \/* True to enable OOM simulation *\/$/;"	m	struct:GlobalVars	file:
bOomOnce	.\tool\fuzzershell.c	/^  int bOomOnce;                    \/* Fail just once if true *\/$/;"	m	struct:GlobalVars	file:
bOpenUri	.\src\sqliteInt.h	/^  int bOpenUri;                     \/* True to interpret filenames as URIs *\/$/;"	m	struct:Sqlite3Config
bOwned	.\src\os_win.c	/^  BOOL bOwned;  \/* Do we own the heap (i.e. destroy it on shutdown)? *\/$/;"	m	struct:winMemData	file:
bPending	.\src\os_win.c	/^  BOOL bPending;      \/* Indicates a pending lock has been obtained *\/$/;"	m	struct:winceLock	file:
bPersist	.\src\test_syscall.c	/^  int bPersist;                   \/* 1 for persistent errors, 0 for transient *\/$/;"	m	struct:TestSyscallGlobal	file:
bPoint	.\ext\rtree\rtree.c	/^  u8 bPoint;                        \/* True if sPoint is valid *\/$/;"	m	struct:RtreeCursor	file:
bPrefix	.\ext\fts5\fts5_expr.c	/^  int bPrefix;                    \/* True for a prefix term *\/$/;"	m	struct:Fts5ExprTerm	file:
bPrefixIndex	.\ext\fts5\fts5Int.h	/^  int bPrefixIndex;               \/* True to use prefix-indexes *\/$/;"	m	struct:Fts5Config
bPrevDelete	.\ext\fts3\fts3Int.h	/^  int bPrevDelete;                \/* True if last operation was a delete *\/$/;"	m	struct:Fts3Table
bPrevValid	.\ext\fts5\fts5_index.c	/^  int bPrevValid;                 \/* True if iPrev is valid *\/$/;"	m	struct:Fts5DlidxWriter	file:
bProcessLock	.\src\os_unix.c	/^  unsigned char bProcessLock;     \/* An exclusive process lock is held *\/$/;"	m	struct:unixInodeInfo	file:
bPurgeable	.\src\pcache.c	/^  u8 bPurgeable;                      \/* True if pages are on backing store *\/$/;"	m	struct:PCache	file:
bPurgeable	.\src\pcache1.c	/^  int bPurgeable;                     \/* True if cache is purgeable *\/$/;"	m	struct:PCache1	file:
bPurgeable	.\src\test_pcache.c	/^  int bPurgeable;           \/* True if the page cache is purgeable *\/$/;"	m	struct:testpcache	file:
bRaw	.\tool\showdb.c	/^  int bRaw;                       \/* True to access db file via OS APIs *\/$/;"	m	struct:GlobalData	file:
bRec	.\src\test_sqllog.c	/^  int bRec;                       \/* True if testSqllog() is called rec. *\/$/;"	m	struct:SLGlobal	file:
bRecursive	.\ext\misc\json1.c	/^  u8 bRecursive;             \/* True for json_tree().  False for json_each() *\/$/;"	m	struct:JsonEachCursor	file:
bRemoveDiacritic	.\ext\fts3\fts3_unicode.c	/^  int bRemoveDiacritic;$/;"	m	struct:unicode_tokenizer	file:
bRemoveDiacritic	.\ext\fts5\fts5_tokenize.c	/^  int bRemoveDiacritic;           \/* True if remove_diacritics=1 is set *\/$/;"	m	struct:Unicode61Tokenizer	file:
bReprepare	.\test\speedtest1.c	/^  int bReprepare;            \/* True to reprepare the SQL on each rerun *\/$/;"	m	struct:Global	file:
bReserved	.\src\os_win.c	/^  BOOL bReserved;     \/* Indicates a reserved lock has been obtained *\/$/;"	m	struct:winceLock	file:
bRestart	.\ext\fts3\fts3Int.h	/^  int bRestart;$/;"	m	struct:Fts3MultiSegReader
bReuse	.\src\test_sqllog.c	/^  int bReuse;                     \/* True to avoid extra copies of db files *\/$/;"	m	struct:SLGlobal	file:
bRev	.\ext\fts5\fts5_index.c	/^  int bRev;                       \/* True to iterate in reverse order *\/$/;"	m	struct:Fts5IndexIter	file:
bSchemaOnly	.\tool\sqldiff.c	/^  int bSchemaOnly;          \/* Only show schema differences *\/$/;"	m	struct:GlobalVars	file:
bSchemaPK	.\tool\sqldiff.c	/^  int bSchemaPK;            \/* Use the schema-defined PK, not the true PK *\/$/;"	m	struct:GlobalVars	file:
bSkipEmpty	.\ext\fts5\fts5_index.c	/^  u8 bSkipEmpty;                  \/* True to skip deleted entries *\/$/;"	m	struct:Fts5IndexIter	file:
bSpanIsTab	.\src\sqliteInt.h	/^    unsigned bSpanIsTab :1; \/* zSpan holds DB.TABLE.COLUMN *\/$/;"	m	struct:ExprList::ExprList_item
bSqlOnly	.\test\speedtest1.c	/^  int bSqlOnly;              \/* True to print the SQL once only *\/$/;"	m	struct:Global	file:
bSqlTrace	.\mptest\mptest.c	/^  int bSqlTrace;         \/* True to trace SQL commands *\/$/;"	m	struct:Global	file:
bStart	.\ext\fts3\fts3Int.h	/^  u8 bStart;                 \/* True if iDocid is valid *\/$/;"	m	struct:Fts3Expr
bStatic	.\ext\misc\json1.c	/^  u8 bStatic;              \/* True if zBuf is static space *\/$/;"	m	struct:JsonString	file:
bSubst	.\ext\fts5\fts5_tcl.c	/^  int bSubst;$/;"	m	struct:F5tTokenizeCtx	file:
bSwap	.\tool\showwal.c	/^  int bSwap;           \/* True to do byte swapping on 32-bit words *\/$/;"	m	struct:Cksum	file:
bSync	.\mptest\mptest.c	/^  int bSync;             \/* Call fsync() *\/$/;"	m	struct:Global	file:
bTermEq	.\ext\fts5\fts5_index.c	/^  u8 bTermEq;                     \/* True if the terms are equal *\/$/;"	m	struct:Fts5CResult	file:
bTotalsValid	.\ext\fts5\fts5_storage.c	/^  int bTotalsValid;               \/* True if nTotalRow\/aTotalSize[] are valid *\/$/;"	m	struct:Fts5Storage	file:
bTrace	.\tool\offsets.c	/^  int bTrace;           \/* True for tracing output *\/$/;"	m	struct:GState	file:
bTruncate	.\src\test_multiplex.c	/^  unsigned char bTruncate;         \/* TRUE to enable truncation of databases *\/$/;"	m	struct:multiplexGroup	file:
bUnderPressure	.\src\pcache1.c	/^  int bUnderPressure;            \/* True if low on PAGECACHE memory *\/$/;"	m	struct:PCacheGlobal	file:
bUnique	.\ext\rbu\sqlite3rbu.c	/^  int bUnique;                    \/* Current index is unique *\/$/;"	m	struct:RbuObjIter	file:
bUnordered	.\src\sqliteInt.h	/^  unsigned bUnordered:1;   \/* Use this index for == or IN queries only *\/$/;"	m	struct:Index
bUseCis	.\src\sqliteInt.h	/^  int bUseCis;                      \/* Use covering indices for full-scans *\/$/;"	m	struct:Sqlite3Config
bUseFetch	.\src\pager.c	/^  u8 bUseFetch;               \/* True to use xFetch() *\/$/;"	m	struct:Pager	file:
bUsePMA	.\src\vdbesort.c	/^  u8 bUsePMA;                     \/* True if one or more PMAs created *\/$/;"	m	struct:VdbeSorter	file:
bUseThread	.\src\vdbesort.c	/^  int bUseThread;                 \/* True to use a bg thread for this object *\/$/;"	m	struct:IncrMerger	file:
bUseThreads	.\src\vdbesort.c	/^  u8 bUseThreads;                 \/* True to use background threads *\/$/;"	m	struct:VdbeSorter	file:
bVarOnly	.\src\sqliteInt.h	/^  int bVarOnly;       \/* Check for variable references only *\/$/;"	m	struct:DbFixer
bVerify	.\test\speedtest1.c	/^  int bVerify;               \/* Try to verify that results are correct *\/$/;"	m	struct:Global	file:
bWal	.\src\test_superlock.c	/^  int bWal;                       \/* True if db is a WAL database *\/$/;"	m	struct:Superlock	file:
bWithoutRowid	.\test\speedtest1.c	/^  int bWithoutRowid;         \/* True for --without-rowid *\/$/;"	m	struct:Global	file:
backslashOn	.\src\shell.c	/^  int backslashOn;       \/* Resolve C-style \\x escapes in SQL input text *\/$/;"	m	struct:ShellState	file:
backtrace	.\src\mem2.c	37;"	d	file:
backtrace_symbols_fd	.\src\mem2.c	38;"	d	file:
backupOnePage	.\src\backup.c	/^static int backupOnePage($/;"	f	file:
backupTestCmd	.\src\test_backup.c	/^static int backupTestCmd($/;"	f	file:
backupTestFinish	.\src\test_backup.c	/^static void backupTestFinish(ClientData clientData){$/;"	f	file:
backupTestInit	.\src\test_backup.c	/^static int backupTestInit($/;"	f	file:
backupTruncateFile	.\src\backup.c	/^static int backupTruncateFile(sqlite3_file *pFile, i64 iSize){$/;"	f	file:
backupUpdate	.\src\backup.c	/^static SQLITE_NOINLINE void backupUpdate($/;"	f	file:
backup_finish	.\src\sqlite3ext.h	/^  int (*backup_finish)(sqlite3_backup*);$/;"	m	struct:sqlite3_api_routines
backup_init	.\src\sqlite3ext.h	/^  sqlite3_backup *(*backup_init)(sqlite3*,const char*,sqlite3*,const char*);$/;"	m	struct:sqlite3_api_routines
backup_pagecount	.\src\sqlite3ext.h	/^  int (*backup_pagecount)(sqlite3_backup*);$/;"	m	struct:sqlite3_api_routines
backup_remaining	.\src\sqlite3ext.h	/^  int (*backup_remaining)(sqlite3_backup*);$/;"	m	struct:sqlite3_api_routines
backup_step	.\src\sqlite3ext.h	/^  int (*backup_step)(sqlite3_backup*,int);$/;"	m	struct:sqlite3_api_routines
bail_on_error	.\src\shell.c	/^static int bail_on_error = 0;$/;"	v	file:
balance	.\src\btree.c	/^static int balance(BtCursor *pCur){$/;"	f	file:
balance_deeper	.\src\btree.c	/^static int balance_deeper(MemPage *pRoot, MemPage **ppChild){$/;"	f	file:
balance_nonroot	.\src\btree.c	/^static int balance_nonroot($/;"	f	file:
balance_quick	.\src\btree.c	/^static int balance_quick(MemPage *pParent, MemPage *pPage, u8 *pSpace){$/;"	f	file:
base	.\ext\fts1\fts1.c	/^  sqlite3_vtab base;               \/* Base class used by SQLite core *\/$/;"	m	struct:fulltext_vtab	file:
base	.\ext\fts1\fts1.c	/^  sqlite3_vtab_cursor base;        \/* Base class used by SQLite core *\/$/;"	m	struct:fulltext_cursor	file:
base	.\ext\fts1\fts1_porter.c	/^  sqlite3_tokenizer base;      \/* Base class *\/$/;"	m	struct:porter_tokenizer	file:
base	.\ext\fts1\fts1_porter.c	/^  sqlite3_tokenizer_cursor base;$/;"	m	struct:porter_tokenizer_cursor	file:
base	.\ext\fts1\fts1_tokenizer1.c	/^  sqlite3_tokenizer base;$/;"	m	struct:simple_tokenizer	file:
base	.\ext\fts1\fts1_tokenizer1.c	/^  sqlite3_tokenizer_cursor base;$/;"	m	struct:simple_tokenizer_cursor	file:
base	.\ext\fts1\fulltext.c	/^  sqlite3_vtab base;$/;"	m	struct:fulltext_vtab	file:
base	.\ext\fts1\fulltext.c	/^  sqlite3_vtab_cursor base;$/;"	m	struct:fulltext_cursor	file:
base	.\ext\fts1\simple_tokenizer.c	/^  sqlite3_tokenizer base;$/;"	m	struct:simple_tokenizer	file:
base	.\ext\fts1\simple_tokenizer.c	/^  sqlite3_tokenizer_cursor base;$/;"	m	struct:simple_tokenizer_cursor	file:
base	.\ext\fts2\fts2.c	/^  sqlite3_vtab base;               \/* Base class used by SQLite core *\/$/;"	m	struct:fulltext_vtab	file:
base	.\ext\fts2\fts2.c	/^  sqlite3_vtab_cursor base;        \/* Base class used by SQLite core *\/$/;"	m	struct:fulltext_cursor	file:
base	.\ext\fts2\fts2_icu.c	/^  sqlite3_tokenizer base;$/;"	m	struct:IcuTokenizer	file:
base	.\ext\fts2\fts2_icu.c	/^  sqlite3_tokenizer_cursor base;$/;"	m	struct:IcuCursor	file:
base	.\ext\fts2\fts2_porter.c	/^  sqlite3_tokenizer base;      \/* Base class *\/$/;"	m	struct:porter_tokenizer	file:
base	.\ext\fts2\fts2_porter.c	/^  sqlite3_tokenizer_cursor base;$/;"	m	struct:porter_tokenizer_cursor	file:
base	.\ext\fts2\fts2_tokenizer1.c	/^  sqlite3_tokenizer base;$/;"	m	struct:simple_tokenizer	file:
base	.\ext\fts2\fts2_tokenizer1.c	/^  sqlite3_tokenizer_cursor base;$/;"	m	struct:simple_tokenizer_cursor	file:
base	.\ext\fts3\fts3Int.h	/^  sqlite3_vtab base;              \/* Base class used by SQLite core *\/$/;"	m	struct:Fts3Table
base	.\ext\fts3\fts3Int.h	/^  sqlite3_vtab_cursor base;       \/* Base class used by SQLite core *\/$/;"	m	struct:Fts3Cursor
base	.\ext\fts3\fts3_aux.c	/^  sqlite3_vtab base;              \/* Base class used by SQLite core *\/$/;"	m	struct:Fts3auxTable	file:
base	.\ext\fts3\fts3_aux.c	/^  sqlite3_vtab_cursor base;       \/* Base class used by SQLite core *\/$/;"	m	struct:Fts3auxCursor	file:
base	.\ext\fts3\fts3_icu.c	/^  sqlite3_tokenizer base;$/;"	m	struct:IcuTokenizer	file:
base	.\ext\fts3\fts3_icu.c	/^  sqlite3_tokenizer_cursor base;$/;"	m	struct:IcuCursor	file:
base	.\ext\fts3\fts3_porter.c	/^  sqlite3_tokenizer base;      \/* Base class *\/$/;"	m	struct:porter_tokenizer	file:
base	.\ext\fts3\fts3_porter.c	/^  sqlite3_tokenizer_cursor base;$/;"	m	struct:porter_tokenizer_cursor	file:
base	.\ext\fts3\fts3_term.c	/^  sqlite3_vtab base;              \/* Base class used by SQLite core *\/$/;"	m	struct:Fts3termTable	file:
base	.\ext\fts3\fts3_term.c	/^  sqlite3_vtab_cursor base;       \/* Base class used by SQLite core *\/$/;"	m	struct:Fts3termCursor	file:
base	.\ext\fts3\fts3_test.c	/^  sqlite3_tokenizer base;$/;"	m	struct:test_tokenizer	file:
base	.\ext\fts3\fts3_test.c	/^  sqlite3_tokenizer_cursor base;$/;"	m	struct:test_tokenizer_cursor	file:
base	.\ext\fts3\fts3_tokenize_vtab.c	/^  sqlite3_vtab base;              \/* Base class used by SQLite core *\/$/;"	m	struct:Fts3tokTable	file:
base	.\ext\fts3\fts3_tokenize_vtab.c	/^  sqlite3_vtab_cursor base;       \/* Base class used by SQLite core *\/$/;"	m	struct:Fts3tokCursor	file:
base	.\ext\fts3\fts3_tokenizer1.c	/^  sqlite3_tokenizer base;$/;"	m	struct:simple_tokenizer	file:
base	.\ext\fts3\fts3_tokenizer1.c	/^  sqlite3_tokenizer_cursor base;$/;"	m	struct:simple_tokenizer_cursor	file:
base	.\ext\fts3\fts3_unicode.c	/^  sqlite3_tokenizer base;$/;"	m	struct:unicode_tokenizer	file:
base	.\ext\fts3\fts3_unicode.c	/^  sqlite3_tokenizer_cursor base;$/;"	m	struct:unicode_cursor	file:
base	.\ext\fts5\fts5_main.c	/^  sqlite3_vtab base;              \/* Base class used by SQLite core *\/$/;"	m	struct:Fts5Table	file:
base	.\ext\fts5\fts5_main.c	/^  sqlite3_vtab_cursor base;       \/* Base class used by SQLite core *\/$/;"	m	struct:Fts5Cursor	file:
base	.\ext\fts5\fts5_vocab.c	/^  sqlite3_vtab base;$/;"	m	struct:Fts5VocabTable	file:
base	.\ext\fts5\fts5_vocab.c	/^  sqlite3_vtab_cursor base;$/;"	m	struct:Fts5VocabCursor	file:
base	.\ext\misc\amatch.c	/^  sqlite3_vtab base;         \/* Base class - must be first *\/$/;"	m	struct:amatch_vtab	file:
base	.\ext\misc\amatch.c	/^  sqlite3_vtab_cursor base;  \/* Base class - must be first *\/$/;"	m	struct:amatch_cursor	file:
base	.\ext\misc\closure.c	/^  sqlite3_vtab base;         \/* Base class - must be first *\/$/;"	m	struct:closure_vtab	file:
base	.\ext\misc\closure.c	/^  sqlite3_vtab_cursor base;  \/* Base class - must be first *\/$/;"	m	struct:closure_cursor	file:
base	.\ext\misc\fuzzer.c	/^  sqlite3_vtab base;         \/* Base class - must be first *\/$/;"	m	struct:fuzzer_vtab	file:
base	.\ext\misc\fuzzer.c	/^  sqlite3_vtab_cursor base;  \/* Base class - must be first *\/$/;"	m	struct:fuzzer_cursor	file:
base	.\ext\misc\json1.c	/^  sqlite3_vtab_cursor base;  \/* Base class - must be first *\/$/;"	m	struct:JsonEachCursor	file:
base	.\ext\misc\series.c	/^  sqlite3_vtab_cursor base;  \/* Base class - must be first *\/$/;"	m	struct:series_cursor	file:
base	.\ext\misc\spellfix.c	/^  sqlite3_vtab base;         \/* Base class - must be first *\/$/;"	m	struct:spellfix1_vtab	file:
base	.\ext\misc\spellfix.c	/^  sqlite3_vtab_cursor base;    \/* Base class - must be first *\/$/;"	m	struct:spellfix1_cursor	file:
base	.\ext\misc\vfslog.c	/^  sqlite3_file base;              \/* IO methods *\/$/;"	m	struct:VLogFile	file:
base	.\ext\misc\vfslog.c	/^  sqlite3_vfs base;               \/* VFS methods *\/$/;"	m	struct:VLogVfs	file:
base	.\ext\misc\vtshim.c	/^  sqlite3_vtab base;       \/* Base class - must be first *\/$/;"	m	struct:vtshim_vtab	file:
base	.\ext\misc\vtshim.c	/^  sqlite3_vtab_cursor base;    \/* Base class - must be first *\/$/;"	m	struct:vtshim_cursor	file:
base	.\ext\misc\wholenumber.c	/^  sqlite3_vtab_cursor base;  \/* Base class - must be first *\/$/;"	m	struct:wholenumber_cursor	file:
base	.\ext\rbu\sqlite3rbu.c	/^  sqlite3_file base;              \/* sqlite3_file methods *\/$/;"	m	struct:rbu_file	file:
base	.\ext\rbu\sqlite3rbu.c	/^  sqlite3_vfs base;               \/* rbu VFS shim methods *\/$/;"	m	struct:rbu_vfs	file:
base	.\ext\rtree\rtree.c	/^  sqlite3_vtab base;          \/* Base class.  Must be first *\/$/;"	m	struct:Rtree	file:
base	.\ext\rtree\rtree.c	/^  sqlite3_vtab_cursor base;         \/* Base class.  Must be first *\/$/;"	m	struct:RtreeCursor	file:
base	.\src\dbstat.c	/^  sqlite3_vtab base;$/;"	m	struct:StatTable	file:
base	.\src\dbstat.c	/^  sqlite3_vtab_cursor base;$/;"	m	struct:StatCursor	file:
base	.\src\printf.c	/^  etByte base;             \/* The base for radix conversion *\/$/;"	m	struct:et_info	file:
base	.\src\test8.c	/^  sqlite3_vtab base;$/;"	m	struct:echo_vtab	file:
base	.\src\test8.c	/^  sqlite3_vtab_cursor base;$/;"	m	struct:echo_cursor	file:
base	.\src\test_demovfs.c	/^  sqlite3_file base;              \/* Base class. Must be first. *\/$/;"	m	struct:DemoFile	file:
base	.\src\test_devsym.c	/^  sqlite3_file base;$/;"	m	struct:devsym_file	file:
base	.\src\test_fs.c	/^  sqlite3_vtab base;$/;"	m	struct:fs_vtab	file:
base	.\src\test_fs.c	/^  sqlite3_vtab_cursor base;$/;"	m	struct:fs_cursor	file:
base	.\src\test_intarray.c	/^  sqlite3_vtab base;            \/* Base class *\/$/;"	m	struct:intarray_vtab	file:
base	.\src\test_intarray.c	/^  sqlite3_vtab_cursor base;    \/* Base class *\/$/;"	m	struct:intarray_cursor	file:
base	.\src\test_journal.c	/^  sqlite3_file base;$/;"	m	struct:jt_file	file:
base	.\src\test_multiplex.c	/^  sqlite3_file base;              \/* Base class - must be first *\/$/;"	m	struct:multiplexConn	file:
base	.\src\test_onefile.c	/^  sqlite3_file base;$/;"	m	struct:fs_file	file:
base	.\src\test_onefile.c	/^  sqlite3_file base;$/;"	m	struct:tmp_file	file:
base	.\src\test_onefile.c	/^  sqlite3_vfs base;$/;"	m	struct:fs_vfs_t	file:
base	.\src\test_osinst.c	/^  sqlite3_file base;              \/* IO methods *\/$/;"	m	struct:VfslogFile	file:
base	.\src\test_osinst.c	/^  sqlite3_vfs base;               \/* VFS methods *\/$/;"	m	struct:VfslogVfs	file:
base	.\src\test_osinst.c	/^  sqlite3_vtab base;              \/* Base class *\/$/;"	m	struct:VfslogVtab	file:
base	.\src\test_osinst.c	/^  sqlite3_vtab_cursor base;       \/* Base class *\/$/;"	m	struct:VfslogCsr	file:
base	.\src\test_quota.c	/^  sqlite3_file base;              \/* Base class - must be first *\/$/;"	m	struct:quotaConn	file:
base	.\src\test_schema.c	/^  sqlite3_vtab base;$/;"	m	struct:schema_vtab	file:
base	.\src\test_schema.c	/^  sqlite3_vtab_cursor base;$/;"	m	struct:schema_cursor	file:
base	.\src\test_tclvar.c	/^  sqlite3_vtab base;$/;"	m	struct:tclvar_vtab	file:
base	.\src\test_tclvar.c	/^  sqlite3_vtab_cursor base;$/;"	m	struct:tclvar_cursor	file:
base	.\src\test_thread.c	/^  Tcl_Event base;          \/* Base class of type Tcl_Event *\/$/;"	m	struct:EvalEvent	file:
base	.\src\test_vfs.c	/^  sqlite3_file base;              \/* Base class.  Must be first *\/$/;"	m	struct:TestvfsFile	file:
base	.\src\test_vfstrace.c	/^  sqlite3_file base;        \/* Base class.  Must be first *\/$/;"	m	struct:vfstrace_file	file:
base	.\test\fuzzcheck.c	/^  sqlite3_file base;      \/* Base class.  Must be first *\/$/;"	m	struct:VHandle	file:
basis	.\tool\lemon.c	/^static struct config *basis = 0;         \/* Top of list of basis configs *\/$/;"	v	typeref:struct:config	file:
basisend	.\tool\lemon.c	/^static struct config **basisend = 0;     \/* End of list of basis configs *\/$/;"	v	typeref:struct:config	file:
basisflag	.\tool\lemon.c	/^  int basisflag;           \/* Print only basis configurations *\/$/;"	m	struct:lemon	file:
bc_find_binaries	.\test\bc_common.tcl	/^proc bc_find_binaries {zCaption} {$/;"	p
beginTimer	.\src\shell.c	/^static void beginTimer(void){$/;"	f	file:
betweenop	.\test\randexpr1.tcl	/^proc betweenop {lhs first second} {$/;"	p
bfs_query_func	.\src\test_rtree.c	/^static int bfs_query_func(sqlite3_rtree_query_info *p){$/;"	f	file:
bft	.\src\vdbeInt.h	/^typedef unsigned bft;  \/* Bit Field Type *\/$/;"	t
bigEndCksum	.\src\wal.c	/^  u8 bigEndCksum;                 \/* True if checksums in WAL are big-endian *\/$/;"	m	struct:WalIndexHdr	file:
bigToNative	.\ext\misc\vfslog.c	/^static int bigToNative(const unsigned char *x){$/;"	f	file:
binCollFunc	.\src\main.c	/^static int binCollFunc($/;"	f	file:
binCompare	.\ext\fts1\ft_hash.c	/^static int binCompare(const void *pKey1, int n1, const void *pKey2, int n2){$/;"	f	file:
binCompare	.\ext\fts1\fts1_hash.c	/^static int binCompare(const void *pKey1, int n1, const void *pKey2, int n2){$/;"	f	file:
binCompare	.\ext\fts2\fts2_hash.c	/^static int binCompare(const void *pKey1, int n1, const void *pKey2, int n2){$/;"	f	file:
binHash	.\ext\fts1\ft_hash.c	/^static int binHash(const void *pKey, int nKey){$/;"	f	file:
binHash	.\ext\fts1\fts1_hash.c	/^static int binHash(const void *pKey, int nKey){$/;"	f	file:
binHash	.\ext\fts2\fts2_hash.c	/^static int binHash(const void *pKey, int nKey){$/;"	f	file:
binarize	.\src\test5.c	/^static int binarize($/;"	f	file:
binaryCompareP5	.\src\expr.c	/^static u8 binaryCompareP5(Expr *pExpr1, Expr *pExpr2, int jumpIfNull){$/;"	f	file:
bindText	.\src\vdbeapi.c	/^static int bindText($/;"	f	file:
bind_blob	.\src\sqlite3ext.h	/^  int  (*bind_blob)(sqlite3_stmt*,int,const void*,int n,void(*)(void*));$/;"	m	struct:sqlite3_api_routines
bind_blob64	.\src\sqlite3ext.h	/^  int (*bind_blob64)(sqlite3_stmt*,int,const void*,sqlite3_uint64,$/;"	m	struct:sqlite3_api_routines
bind_double	.\src\sqlite3ext.h	/^  int  (*bind_double)(sqlite3_stmt*,int,double);$/;"	m	struct:sqlite3_api_routines
bind_int	.\src\sqlite3ext.h	/^  int  (*bind_int)(sqlite3_stmt*,int,int);$/;"	m	struct:sqlite3_api_routines
bind_int64	.\src\sqlite3ext.h	/^  int  (*bind_int64)(sqlite3_stmt*,int,sqlite_int64);$/;"	m	struct:sqlite3_api_routines
bind_null	.\src\sqlite3ext.h	/^  int  (*bind_null)(sqlite3_stmt*,int);$/;"	m	struct:sqlite3_api_routines
bind_parameter_count	.\src\sqlite3ext.h	/^  int  (*bind_parameter_count)(sqlite3_stmt*);$/;"	m	struct:sqlite3_api_routines
bind_parameter_index	.\src\sqlite3ext.h	/^  int  (*bind_parameter_index)(sqlite3_stmt*,const char*zName);$/;"	m	struct:sqlite3_api_routines
bind_parameter_name	.\src\sqlite3ext.h	/^  const char * (*bind_parameter_name)(sqlite3_stmt*,int);$/;"	m	struct:sqlite3_api_routines
bind_text	.\src\sqlite3ext.h	/^  int  (*bind_text)(sqlite3_stmt*,int,const char*,int n,void(*)(void*));$/;"	m	struct:sqlite3_api_routines
bind_text16	.\src\sqlite3ext.h	/^  int  (*bind_text16)(sqlite3_stmt*,int,const void*,int,void(*)(void*));$/;"	m	struct:sqlite3_api_routines
bind_text64	.\src\sqlite3ext.h	/^  int (*bind_text64)(sqlite3_stmt*,int,const char*,sqlite3_uint64,$/;"	m	struct:sqlite3_api_routines
bind_value	.\src\sqlite3ext.h	/^  int  (*bind_value)(sqlite3_stmt*,int,const sqlite3_value*);$/;"	m	struct:sqlite3_api_routines
bind_zeroblob	.\src\sqlite3ext.h	/^  int (*bind_zeroblob)(sqlite3_stmt*,int,int);$/;"	m	struct:sqlite3_api_routines
bind_zeroblob64	.\src\sqlite3ext.h	/^  int (*bind_zeroblob64)(sqlite3_stmt*, int, sqlite3_uint64);$/;"	m	struct:sqlite3_api_routines
bits	.\src\tclsqlite.c	/^  uint32 bits[2];$/;"	m	struct:MD5Context	file:
bits	.\test\threadtest3.c	/^  uint32 bits[2];$/;"	m	struct:MD5Context	file:
blobGrowBuffer	.\ext\fts3\fts3_write.c	/^static void blobGrowBuffer(Blob *pBlob, int nMin, int *pRc){$/;"	f	file:
blobHandleFromObj	.\src\test1.c	/^static int blobHandleFromObj($/;"	f	file:
blobHandleFromObj	.\src\test_blob.c	/^static int blobHandleFromObj($/;"	f	file:
blobListFree	.\test\fuzzcheck.c	/^static void blobListFree(Blob *p){$/;"	f	file:
blobListLoadFromDb	.\test\fuzzcheck.c	/^static void blobListLoadFromDb($/;"	f	file:
blobReadWrite	.\src\vdbeblob.c	/^static int blobReadWrite($/;"	f	file:
blobSeekToRow	.\src\vdbeblob.c	/^static int blobSeekToRow(Incrblob *p, sqlite3_int64 iRow, char **pzErr){$/;"	f	file:
blobStringFromObj	.\src\test_blob.c	/^static char *blobStringFromObj(Tcl_Obj *pObj){$/;"	f	file:
blob_bytes	.\src\sqlite3ext.h	/^  int (*blob_bytes)(sqlite3_blob*);$/;"	m	struct:sqlite3_api_routines
blob_close	.\src\sqlite3ext.h	/^  int (*blob_close)(sqlite3_blob*);$/;"	m	struct:sqlite3_api_routines
blob_open	.\src\sqlite3ext.h	/^  int (*blob_open)(sqlite3*,const char*,const char*,const char*,sqlite3_int64,$/;"	m	struct:sqlite3_api_routines
blob_read	.\src\sqlite3ext.h	/^  int (*blob_read)(sqlite3_blob*,void*,int,int);$/;"	m	struct:sqlite3_api_routines
blob_reopen	.\src\sqlite3ext.h	/^  int (*blob_reopen)(sqlite3_blob*,sqlite3_int64);$/;"	m	struct:sqlite3_api_routines
blob_write	.\src\sqlite3ext.h	/^  int (*blob_write)(sqlite3_blob*,const void*,int,int);$/;"	m	struct:sqlite3_api_routines
block	.\ext\fts3\fts3_write.c	/^  Blob block;                     \/* Current block image *\/$/;"	m	struct:NodeWriter	file:
block_delete	.\ext\fts2\fts2.c	/^static int block_delete(fulltext_vtab *v,$/;"	f	file:
block_insert	.\ext\fts2\fts2.c	/^static int block_insert(fulltext_vtab *v, const char *pData, int nData,$/;"	f	file:
blocking_prepare_v2_proc	.\src\test_thread.c	/^static Tcl_ObjCmdProc blocking_prepare_v2_proc;$/;"	v	file:
blocking_prepare_v2_proc	.\src\test_thread.c	/^static int blocking_prepare_v2_proc($/;"	f	file:
blocking_step_proc	.\src\test_thread.c	/^static Tcl_ObjCmdProc blocking_step_proc;$/;"	v	file:
blocking_step_proc	.\src\test_thread.c	/^static int blocking_step_proc($/;"	f	file:
booleanValue	.\mptest\mptest.c	/^static int booleanValue(char *zArg){$/;"	f	file:
booleanValue	.\src\shell.c	/^static int booleanValue(char *zArg){$/;"	f	file:
bp	.\tool\lemon.c	/^  struct config *bp;       \/* The basis configurations for this state *\/$/;"	m	struct:state	typeref:struct:state::config	file:
bp	.\tool\lemon.c	/^  struct config *bp;       \/* The next basis configuration *\/$/;"	m	struct:config	typeref:struct:config::config	file:
bplp	.\tool\lemon.c	/^  struct plink *bplp;      \/* Follow-set backwards propagation links *\/$/;"	m	struct:config	typeref:struct:config::plink	file:
broken_init	.\src\test_autoext.c	/^static int broken_init($/;"	f	file:
btree	.\src\whereInt.h	/^    } btree;$/;"	m	union:WhereLoop::__anon28	typeref:struct:WhereLoop::__anon28::__anon29
btreeClearHasContent	.\src\btree.c	/^static void btreeClearHasContent(BtShared *pBt){$/;"	f	file:
btreeCreateTable	.\src\btree.c	/^static int btreeCreateTable(Btree *p, int *piTable, int createTabFlags){$/;"	f	file:
btreeCursor	.\src\btree.c	/^static int btreeCursor($/;"	f	file:
btreeDropTable	.\src\btree.c	/^static int btreeDropTable(Btree *p, Pgno iTable, int *piMoved){$/;"	f	file:
btreeEndTransaction	.\src\btree.c	/^static void btreeEndTransaction(Btree *p){$/;"	f	file:
btreeGetHasContent	.\src\btree.c	/^static int btreeGetHasContent(BtShared *pBt, Pgno pgno){$/;"	f	file:
btreeGetPage	.\src\btree.c	/^static int btreeGetPage($/;"	f	file:
btreeGetUnusedPage	.\src\btree.c	/^static int btreeGetUnusedPage($/;"	f	file:
btreeHeapInsert	.\src\btree.c	/^static void btreeHeapInsert(u32 *aHeap, u32 x){$/;"	f	file:
btreeHeapPull	.\src\btree.c	/^static int btreeHeapPull(u32 *aHeap, u32 *pOut){$/;"	f	file:
btreeInitPage	.\src\btree.c	/^static int btreeInitPage(MemPage *pPage){$/;"	f	file:
btreeIntegrity	.\src\btreeInt.h	644;"	d
btreeInvokeBusyHandler	.\src\btree.c	/^static int btreeInvokeBusyHandler(void *pArg){$/;"	f	file:
btreeLockCarefully	.\src\btmutex.c	/^static void SQLITE_NOINLINE btreeLockCarefully(Btree *p){$/;"	f	file:
btreeMask	.\src\vdbeInt.h	/^  yDbMask btreeMask;      \/* Bitmask of db->aDb[] entries referenced *\/$/;"	m	struct:Vdbe
btreeMoveto	.\src\btree.c	/^static int btreeMoveto($/;"	f	file:
btreeNext	.\src\btree.c	/^static SQLITE_NOINLINE int btreeNext(BtCursor *pCur, int *pRes){$/;"	f	file:
btreePageFromDbPage	.\src\btree.c	/^static MemPage *btreePageFromDbPage(DbPage *pDbPage, Pgno pgno, BtShared *pBt){$/;"	f	file:
btreePageLookup	.\src\btree.c	/^static MemPage *btreePageLookup(BtShared *pBt, Pgno pgno){$/;"	f	file:
btreePagecount	.\src\btree.c	/^static Pgno btreePagecount(BtShared *pBt){$/;"	f	file:
btreeParseCell	.\src\btree.c	/^static void btreeParseCell($/;"	f	file:
btreeParseCellAdjustSizeForOverflow	.\src\btree.c	/^static SQLITE_NOINLINE void btreeParseCellAdjustSizeForOverflow($/;"	f	file:
btreeParseCellPtr	.\src\btree.c	/^static void btreeParseCellPtr($/;"	f	file:
btreeParseCellPtrIndex	.\src\btree.c	/^static void btreeParseCellPtrIndex($/;"	f	file:
btreeParseCellPtrNoPayload	.\src\btree.c	/^static void btreeParseCellPtrNoPayload($/;"	f	file:
btreePrevious	.\src\btree.c	/^static SQLITE_NOINLINE int btreePrevious(BtCursor *pCur, int *pRes){$/;"	f	file:
btreeReleaseAllCursorPages	.\src\btree.c	/^static void btreeReleaseAllCursorPages(BtCursor *pCur){$/;"	f	file:
btreeRestoreCursorPosition	.\src\btree.c	/^static int btreeRestoreCursorPosition(BtCursor *pCur){$/;"	f	file:
btreeSetHasContent	.\src\btree.c	/^static int btreeSetHasContent(BtShared *pBt, Pgno pgno){$/;"	f	file:
btree_begin_transaction	.\src\test3.c	/^static int btree_begin_transaction($/;"	f	file:
btree_close	.\src\test3.c	/^static int btree_close($/;"	f	file:
btree_close_cursor	.\src\test3.c	/^static int btree_close_cursor($/;"	f	file:
btree_cursor	.\src\test3.c	/^static int btree_cursor($/;"	f	file:
btree_eof	.\src\test3.c	/^static int btree_eof($/;"	f	file:
btree_first	.\src\test3.c	/^static int btree_first($/;"	f	file:
btree_from_db	.\src\test3.c	/^static int btree_from_db($/;"	f	file:
btree_ismemdb	.\src\test3.c	/^static int btree_ismemdb($/;"	f	file:
btree_next	.\src\test3.c	/^static int btree_next($/;"	f	file:
btree_open	.\src\test3.c	/^static int btree_open($/;"	f	file:
btree_pager_stats	.\src\test3.c	/^static int btree_pager_stats($/;"	f	file:
btree_payload_size	.\src\test3.c	/^static int btree_payload_size($/;"	f	file:
btree_set_cache_size	.\src\test3.c	/^static int btree_set_cache_size($/;"	f	file:
btree_varint_test	.\src\test3.c	/^static int btree_varint_test($/;"	f	file:
btsFlags	.\src\btreeInt.h	/^  u16 btsFlags;         \/* Boolean parameters.  See BTS_* macros below *\/$/;"	m	struct:BtShared
btterm	.\ext\fts5\fts5_index.c	/^  Fts5Buffer btterm;              \/* Next term to insert into %_idx table *\/$/;"	m	struct:Fts5SegWriter	file:
buf	.\ext\fts5\fts5_index.c	/^  Fts5Buffer buf;                 \/* Buffer containing leaf data *\/$/;"	m	struct:Fts5PageWriter	file:
buf	.\ext\fts5\fts5_index.c	/^  Fts5Buffer buf;                 \/* Buffer containing page data *\/$/;"	m	struct:Fts5DlidxWriter	file:
buf	.\src\tclsqlite.c	/^  uint32 buf[4];$/;"	m	struct:MD5Context	file:
buf	.\test\threadtest3.c	/^  uint32 buf[4];$/;"	m	struct:MD5Context	file:
buffer	.\autoconf\tea\win\nmakehlp.c	/^    char buffer[STATICBUFFERSIZE];$/;"	m	struct:__anon1	file:
buildTerms	.\ext\fts1\fts1.c	/^static int buildTerms(fulltext_vtab *v, fts1Hash *terms, sqlite_int64 iDocid,$/;"	f	file:
buildTerms	.\ext\fts2\fts2.c	/^static int buildTerms(fulltext_vtab *v, sqlite_int64 iDocid,$/;"	f	file:
build_terms	.\ext\fts1\fulltext.c	/^static int build_terms(Hash *terms, sqlite3_tokenizer *pTokenizer,$/;"	f	file:
build_vocab	.\ext\fts3\fts3speed.tcl	/^proc build_vocab {nWord} {$/;"	p
buildshifts	.\tool\lemon.c	/^PRIVATE void buildshifts(struct lemon *lemp, struct state *stp)$/;"	f
busy	.\src\sqliteInt.h	/^    u8 busy;                    \/* TRUE if currently initializing *\/$/;"	m	struct:sqlite3::sqlite3InitInfo
busy	.\src\test4.c	/^  int busy;              \/* True if this thread is in use *\/$/;"	m	struct:Thread	file:
busy	.\src\test7.c	/^  volatile int busy;       \/* True if this thread is in use *\/$/;"	m	struct:Thread	file:
busyHandler	.\mptest\mptest.c	/^static int busyHandler(void *pCD, int count){$/;"	f	file:
busyHandler	.\src\sqliteInt.h	/^  BusyHandler busyHandler;      \/* Busy callback *\/$/;"	m	struct:sqlite3
busyTimeout	.\src\sqliteInt.h	/^  int busyTimeout;              \/* Busy handler timeout, in msec *\/$/;"	m	struct:sqlite3
busy_handler	.\src\sqlite3ext.h	/^  int  (*busy_handler)(sqlite3*,int(*)(void*,int),void*);$/;"	m	struct:sqlite3_api_routines
busy_timeout	.\src\sqlite3ext.h	/^  int  (*busy_timeout)(sqlite3*,int ms);$/;"	m	struct:sqlite3_api_routines
busyhandler	.\test\threadtest3.c	/^static int busyhandler(void *pArg, int n){$/;"	f	file:
byteReverse	.\src\tclsqlite.c	/^static void byteReverse (unsigned char *buf, unsigned longs){$/;"	f	file:
byteReverse	.\test\threadtest3.c	/^static void byteReverse (unsigned char *buf, unsigned longs){$/;"	f	file:
cColSep	.\src\shell.c	/^  int cColSep;        \/* The column separator character.  (Usually ",") *\/$/;"	m	struct:ImportCtx	file:
cFrom	.\ext\misc\spellfix.c	/^ unsigned short int cFrom;$/;"	m	struct:__anon5	file:
cId	.\src\whereInt.h	/^  char cId;             \/* Symbolic ID of this loop for debugging use *\/$/;"	m	struct:WhereLoop
cRowSep	.\src\shell.c	/^  int cRowSep;        \/* The row separator character.  (Usually "\\n") *\/$/;"	m	struct:ImportCtx	file:
cTerm	.\src\shell.c	/^  int cTerm;          \/* Character that terminated the most recent field *\/$/;"	m	struct:ImportCtx	file:
cTo0	.\ext\misc\spellfix.c	/^ unsigned char cTo0, cTo1;$/;"	m	struct:__anon5	file:
cTo1	.\ext\misc\spellfix.c	/^ unsigned char cTo0, cTo1;$/;"	m	struct:__anon5	file:
cType	.\ext\fts1\fts1_porter.c	/^static const char cType[] = {$/;"	v	file:
cType	.\ext\fts2\fts2_porter.c	/^static const char cType[] = {$/;"	v	file:
cType	.\ext\fts3\fts3_porter.c	/^static const char cType[] = {$/;"	v	file:
c_collation_test	.\src\test9.c	/^static int c_collation_test($/;"	f	file:
c_misuse_test	.\src\test9.c	/^static int c_misuse_test($/;"	f	file:
c_realloc_test	.\src\test9.c	/^static int c_realloc_test($/;"	f	file:
cacheCtr	.\src\vdbeInt.h	/^  u32 cacheCtr;           \/* VdbeCursor row cache generation counter *\/$/;"	m	struct:Vdbe
cacheEntryClear	.\src\expr.c	/^static void cacheEntryClear(Parse *pParse, struct yColCache *p){$/;"	f	file:
cacheStatus	.\src\vdbeInt.h	/^  u32 cacheStatus;      \/* Cache is valid if this matches Vdbe.cacheCtr *\/$/;"	m	struct:VdbeCursor
cache_size	.\src\sqliteInt.h	/^  int cache_size;      \/* Number of pages to use in the cache *\/$/;"	m	struct:Schema
cachedCellSize	.\src\btree.c	/^static u16 cachedCellSize(CellArray *p, int N){$/;"	f	file:
calc_chksum	.\tool\restore_jrnl.tcl	/^proc calc_chksum {jrnl_pgno} {$/;"	p
calc_nonce	.\tool\restore_jrnl.tcl	/^proc calc_nonce {jrnl_pgno} {$/;"	p
callCollNeeded	.\src\callback.c	/^static void callCollNeeded(sqlite3 *db, int enc, const char *zName){$/;"	f	file:
callFinaliser	.\src\vtab.c	/^static void callFinaliser(sqlite3 *db, int offset){$/;"	f	file:
callStatGet	.\src\analyze.c	/^static void callStatGet(Vdbe *v, int regStat4, int iParam, int regOut){$/;"	f	file:
callback	.\ext\misc\eval.c	/^static int callback(void *pCtx, int argc, char **argv, char **colnames){$/;"	f	file:
callback	.\src\shell.c	/^static int callback(void *pArg, int nArg, char **azArg, char **azCol){$/;"	f	file:
callback	.\tool\fuzzershell.c	/^static int callback(void *pCtx, int argc, char **argv, char **colnames){$/;"	f	file:
canReduce	.\tool\lemon.c	/^  Boolean canReduce;       \/* True if this rule is ever reduced *\/$/;"	m	struct:rule	file:
cancelAutoExtBrokenObjCmd	.\src\test_autoext.c	/^static int cancelAutoExtBrokenObjCmd($/;"	f	file:
cancelAutoExtCubeObjCmd	.\src\test_autoext.c	/^static int cancelAutoExtCubeObjCmd($/;"	f	file:
cancelAutoExtSqrObjCmd	.\src\test_autoext.c	/^static int cancelAutoExtSqrObjCmd($/;"	f	file:
cancel_auto_extension	.\src\sqlite3ext.h	/^  int (*cancel_auto_extension)(void(*)(void));$/;"	m	struct:sqlite3_api_routines
cantopen_err	.\src\test_vfs.c	/^  TestFaultInject cantopen_err;$/;"	m	struct:Testvfs	file:
cantopen_injectinstall	.\test\malloc_common.tcl	/^proc cantopen_injectinstall {} {$/;"	p
cantopen_injectstart	.\test\malloc_common.tcl	/^proc cantopen_injectstart {persist iFail} {$/;"	p
cantopen_injectstop	.\test\malloc_common.tcl	/^proc cantopen_injectstop {} {$/;"	p
cantopen_injectuninstall	.\test\malloc_common.tcl	/^proc cantopen_injectuninstall {} {$/;"	p
capable	.\test\tester.tcl	/^proc capable {expr} {$/;"	p
carglist	.\src\parse.y	/^carglist ::= .$/;"	l
carglist	.\src\parse.y	/^carglist ::= carglist ccons.$/;"	l
catchcmd	.\test\tester.tcl	/^proc catchcmd {db {cmd ""}} {$/;"	p
catchcmdex	.\test\tester.tcl	/^proc catchcmdex {db {cmd ""}} {$/;"	p
catchsql	.\test\tester.tcl	/^proc catchsql {sql {db db}} {$/;"	p
catchsql	.\tool\restore_jrnl.tcl	/^proc catchsql {sql} {$/;"	p
cb	.\ext\rtree\rtree.c	/^  RtreeGeomCallback cb;       \/* Info about the callback functions *\/$/;"	m	struct:RtreeMatchArg	file:
ccons	.\src\parse.y	/^ccons ::= CHECK LP expr(X) RP.   {sqlite3AddCheckConstraint(pParse,X.pExpr);}$/;"	l
ccons	.\src\parse.y	/^ccons ::= COLLATE ids(C).        {sqlite3AddCollateType(pParse, &C);}$/;"	l
ccons	.\src\parse.y	/^ccons ::= CONSTRAINT nm(X).           {pParse->constraintName = X;}$/;"	l
ccons	.\src\parse.y	/^ccons ::= DEFAULT LP expr(X) RP.      {sqlite3AddDefaultValue(pParse,&X);}$/;"	l
ccons	.\src\parse.y	/^ccons ::= DEFAULT MINUS(A) term(X).      {$/;"	l
ccons	.\src\parse.y	/^ccons ::= DEFAULT PLUS term(X).       {sqlite3AddDefaultValue(pParse,&X);}$/;"	l
ccons	.\src\parse.y	/^ccons ::= DEFAULT id(X).              {$/;"	l
ccons	.\src\parse.y	/^ccons ::= DEFAULT term(X).            {sqlite3AddDefaultValue(pParse,&X);}$/;"	l
ccons	.\src\parse.y	/^ccons ::= NOT NULL onconf(R).    {sqlite3AddNotNull(pParse, R);}$/;"	l
ccons	.\src\parse.y	/^ccons ::= NULL onconf.$/;"	l
ccons	.\src\parse.y	/^ccons ::= PRIMARY KEY sortorder(Z) onconf(R) autoinc(I).$/;"	l
ccons	.\src\parse.y	/^ccons ::= REFERENCES nm(T) eidlist_opt(TA) refargs(R).$/;"	l
ccons	.\src\parse.y	/^ccons ::= UNIQUE onconf(R).      {sqlite3CreateIndex(pParse,0,0,0,0,R,0,0,0,0);}$/;"	l
ccons	.\src\parse.y	/^ccons ::= defer_subclause(D).    {sqlite3DeferForeignKey(pParse,D);}$/;"	l
cdateFunc	.\src\date.c	/^static void cdateFunc($/;"	f	file:
cellArea	.\ext\rtree\rtree.c	/^static RtreeDValue cellArea(Rtree *pRtree, RtreeCell *p){$/;"	f	file:
cellContains	.\ext\rtree\rtree.c	/^static int cellContains(Rtree *pRtree, RtreeCell *p1, RtreeCell *p2){$/;"	f	file:
cellGrowth	.\ext\rtree\rtree.c	/^static RtreeDValue cellGrowth(Rtree *pRtree, RtreeCell *p, RtreeCell *pCell){$/;"	f	file:
cellMargin	.\ext\rtree\rtree.c	/^static RtreeDValue cellMargin(Rtree *pRtree, RtreeCell *p){$/;"	f	file:
cellOffset	.\src\btreeInt.h	/^  u16 cellOffset;      \/* Index in aData of first cell pointer *\/$/;"	m	struct:MemPage
cellOverlap	.\ext\rtree\rtree.c	/^static RtreeDValue cellOverlap($/;"	f	file:
cellSize	.\src\btree.c	/^static u16 cellSize(MemPage *pPage, int iCell){$/;"	f	file:
cellSizePtr	.\src\btree.c	/^static u16 cellSizePtr(MemPage *pPage, u8 *pCell){$/;"	f	file:
cellSizePtrNoPayload	.\src\btree.c	/^static u16 cellSizePtrNoPayload(MemPage *pPage, u8 *pCell){$/;"	f	file:
cellUnion	.\ext\rtree\rtree.c	/^static void cellUnion(Rtree *pRtree, RtreeCell *p1, RtreeCell *p2){$/;"	f	file:
cell_report	.\ext\rtree\viewrtree.tcl	/^proc cell_report {db zTab iParent iCell} {$/;"	p
centerx	.\src\test_rtree.c	/^  double centerx;$/;"	m	struct:Circle	file:
centery	.\src\test_rtree.c	/^  double centery;$/;"	m	struct:Circle	file:
cf2Destroy	.\src\test1.c	/^static void cf2Destroy(void *pUser){$/;"	f	file:
cf2Final	.\src\test1.c	/^static void cf2Final(sqlite3_context *ctx){$/;"	f	file:
cf2Func	.\src\test1.c	/^static void cf2Func(sqlite3_context *ctx, int nArg, sqlite3_value **aArg){$/;"	f	file:
cf2Step	.\src\test1.c	/^static void cf2Step(sqlite3_context *ctx, int nArg, sqlite3_value **aArg){$/;"	f	file:
cfAccess	.\src\test6.c	/^static int cfAccess($/;"	f	file:
cfCheckReservedLock	.\src\test6.c	/^static int cfCheckReservedLock(sqlite3_file *pFile, int *pResOut){$/;"	f	file:
cfClose	.\src\test6.c	/^static int cfClose(sqlite3_file *pFile){$/;"	f	file:
cfCurrentTime	.\src\test6.c	/^static int cfCurrentTime(sqlite3_vfs *pCfVfs, double *pTimeOut){$/;"	f	file:
cfDelete	.\src\test6.c	/^static int cfDelete(sqlite3_vfs *pCfVfs, const char *zPath, int dirSync){$/;"	f	file:
cfDeviceCharacteristics	.\src\test6.c	/^static int cfDeviceCharacteristics(sqlite3_file *pFile){$/;"	f	file:
cfDlClose	.\src\test6.c	/^static void cfDlClose(sqlite3_vfs *pCfVfs, void *pHandle){$/;"	f	file:
cfDlError	.\src\test6.c	/^static void cfDlError(sqlite3_vfs *pCfVfs, int nByte, char *zErrMsg){$/;"	f	file:
cfDlOpen	.\src\test6.c	/^static void *cfDlOpen(sqlite3_vfs *pCfVfs, const char *zPath){$/;"	f	file:
cfDlSym	.\src\test6.c	/^static void (*cfDlSym(sqlite3_vfs *pCfVfs, void *pH, const char *zSym))(void){$/;"	f	file:
cfFileControl	.\src\test6.c	/^static int cfFileControl(sqlite3_file *pFile, int op, void *pArg){$/;"	f	file:
cfFileSize	.\src\test6.c	/^static int cfFileSize(sqlite3_file *pFile, sqlite_int64 *pSize){$/;"	f	file:
cfFullPathname	.\src\test6.c	/^static int cfFullPathname($/;"	f	file:
cfLock	.\src\test6.c	/^static int cfLock(sqlite3_file *pFile, int eLock){$/;"	f	file:
cfOpen	.\src\test6.c	/^static int cfOpen($/;"	f	file:
cfRandomness	.\src\test6.c	/^static int cfRandomness(sqlite3_vfs *pCfVfs, int nByte, char *zBufOut){$/;"	f	file:
cfRead	.\src\test6.c	/^static int cfRead($/;"	f	file:
cfSectorSize	.\src\test6.c	/^static int cfSectorSize(sqlite3_file *pFile){$/;"	f	file:
cfShmBarrier	.\src\test6.c	/^static void cfShmBarrier(sqlite3_file *pFile){$/;"	f	file:
cfShmLock	.\src\test6.c	/^static int cfShmLock(sqlite3_file *pFile, int ofst, int n, int flags){$/;"	f	file:
cfShmMap	.\src\test6.c	/^static int cfShmMap($/;"	f	file:
cfShmUnmap	.\src\test6.c	/^static int cfShmUnmap(sqlite3_file *pFile, int delFlag){$/;"	f	file:
cfSleep	.\src\test6.c	/^static int cfSleep(sqlite3_vfs *pCfVfs, int nMicro){$/;"	f	file:
cfSync	.\src\test6.c	/^static int cfSync(sqlite3_file *pFile, int flags){$/;"	f	file:
cfTruncate	.\src\test6.c	/^static int cfTruncate(sqlite3_file *pFile, sqlite_int64 size){$/;"	f	file:
cfUnlock	.\src\test6.c	/^static int cfUnlock(sqlite3_file *pFile, int eLock){$/;"	f	file:
cfWrite	.\src\test6.c	/^static int cfWrite($/;"	f	file:
cfgstatus	.\tool\lemon.c	/^enum cfgstatus {$/;"	g	file:
cfp	.\tool\lemon.c	/^  struct config *cfp;      \/* All configurations in this set *\/$/;"	m	struct:state	typeref:struct:state::config	file:
cfp	.\tool\lemon.c	/^  struct config *cfp;      \/* The configuration to which linked *\/$/;"	m	struct:plink	typeref:struct:plink::config	file:
cgt_pager_1	.\test\threadtest3.c	/^static void cgt_pager_1(int nMs){$/;"	f	file:
cgt_pager_1_populate	.\test\threadtest3.c	/^static void cgt_pager_1_populate(Error *pErr, Sqlite *pDb){$/;"	f	file:
cgt_pager_1_read	.\test\threadtest3.c	/^static void cgt_pager_1_read(Error *pErr, Sqlite *pDb){$/;"	f	file:
cgt_pager_1_update	.\test\threadtest3.c	/^static void cgt_pager_1_update(Error *pErr, Sqlite *pDb){$/;"	f	file:
chain	.\ext\fts1\ft_hash.h	/^    HashElem *chain;         \/* Pointer to first entry with this hash *\/$/;"	m	struct:Hash::_ht
chain	.\ext\fts1\fts1_hash.h	/^    fts1HashElem *chain;     \/* Pointer to first entry with this hash *\/$/;"	m	struct:fts1Hash::_fts1ht
chain	.\ext\fts2\fts2_hash.h	/^    fts2HashElem *chain;     \/* Pointer to first entry with this hash *\/$/;"	m	struct:fts2Hash::_fts2ht
chain	.\ext\fts3\fts3_hash.h	/^    Fts3HashElem *chain;     \/* Pointer to first entry with this hash *\/$/;"	m	struct:Fts3Hash::_fts3ht
chain	.\src\hash.h	/^    HashElem *chain;           \/* Pointer to first entry with this hash *\/$/;"	m	struct:Hash::_ht
changeCntOn	.\src\vdbeInt.h	/^  bft changeCntOn:1;      \/* True to update the change-counter *\/$/;"	m	struct:Vdbe
changeCountDone	.\src\pager.c	/^  u8 changeCountDone;         \/* Set after incrementing the change-counter *\/$/;"	m	struct:Pager	file:
changeTempStorage	.\src\pragma.c	/^static int changeTempStorage(Parse *pParse, const char *zStorageType){$/;"	f	file:
changes	.\src\func.c	/^static void changes($/;"	f	file:
changes	.\src\sqlite3ext.h	/^  int  (*changes)(sqlite3*);$/;"	m	struct:sqlite3_api_routines
changeset_one_table	.\tool\sqldiff.c	/^static void changeset_one_table(const char *zTab, FILE *out){$/;"	f	file:
channel	.\src\tclsqlite.c	/^  Tcl_Channel channel;      \/* Channel identifier *\/$/;"	m	struct:IncrblobChannel	file:
charFunc	.\src\func.c	/^static void charFunc($/;"	f	file:
charMap	.\src\tokenize.c	29;"	d	file:
charMap	.\src\tokenize.c	32;"	d	file:
characterClass	.\ext\misc\spellfix.c	/^static char characterClass(char cPrev, char c){$/;"	f	file:
charset	.\src\printf.c	/^  etByte charset;          \/* Offset into aDigits[] of the digits string *\/$/;"	m	struct:et_info	file:
checkActiveVdbeCnt	.\src\vdbeaux.c	/^static void checkActiveVdbeCnt(sqlite3 *db){$/;"	f	file:
checkActiveVdbeCnt	.\src\vdbeaux.c	2274;"	d	file:
checkAppendMsg	.\src\btree.c	/^static void checkAppendMsg($/;"	f	file:
checkColumnOverlap	.\src\trigger.c	/^static int checkColumnOverlap(IdList *pIdList, ExprList *pEList){$/;"	f	file:
checkColumnSpecifier	.\ext\fts1\fts1.c	/^static int checkColumnSpecifier($/;"	f	file:
checkColumnSpecifier	.\ext\fts2\fts2.c	/^static int checkColumnSpecifier($/;"	f	file:
checkForMultiColumnSelectError	.\src\select.c	/^static int checkForMultiColumnSelectError($/;"	f	file:
checkList	.\src\btree.c	/^static void checkList($/;"	f	file:
checkListProperties	.\src\notify.c	/^static void checkListProperties(sqlite3 *db){$/;"	f	file:
checkListProperties	.\src\notify.c	76;"	d	file:
checkPage	.\src\pager.c	/^static void checkPage(PgHdr *pPg){$/;"	f	file:
checkProfileCallback	.\src\vdbeapi.c	75;"	d	file:
checkProfileCallback	.\src\vdbeapi.c	78;"	d	file:
checkPtrmap	.\src\btree.c	/^static void checkPtrmap($/;"	f	file:
checkReadTransaction	.\src\backup.c	/^static int checkReadTransaction(sqlite3 *db, Btree *p){$/;"	f	file:
checkRef	.\src\btree.c	/^static int checkRef(IntegrityCk *pCheck, Pgno iPage){$/;"	f	file:
checkSavepointCount	.\src\vdbe.c	/^static int checkSavepointCount(sqlite3 *db){$/;"	f	file:
checkSchema	.\src\sqliteInt.h	/^  u8 checkSchema;      \/* Causes schema cookie check after an error *\/$/;"	m	struct:Parse
checkSchemasMatch	.\tool\sqldiff.c	/^static void checkSchemasMatch(const char *zTab){$/;"	f	file:
checkSpacing	.\tool\checkSpacing.c	/^static void checkSpacing(const char *zFile, unsigned flags){$/;"	f	file:
checkTreePage	.\src\btree.c	/^static int checkTreePage($/;"	f	file:
check_callback	.\test\threadtest2.c	/^int check_callback(void *pid, int argc, char **argv, char **notUsed2){$/;"	f
check_oom	.\test\threadtest4.c	/^static void check_oom(void *x){$/;"	f	file:
checkpoint_starvation_1	.\test\tt3_checkpoint.c	/^static void checkpoint_starvation_1(int nMs){$/;"	f	file:
checkpoint_starvation_2	.\test\tt3_checkpoint.c	/^static void checkpoint_starvation_2(int nMs){$/;"	f	file:
checkpoint_starvation_main	.\test\tt3_checkpoint.c	/^static void checkpoint_starvation_main(int nMs, CheckpointStarvationCtx *p){$/;"	f	file:
checkpoint_starvation_reader	.\test\tt3_checkpoint.c	/^static char *checkpoint_starvation_reader(int iTid, void *pArg){$/;"	f	file:
checkpoint_starvation_walhook	.\test\tt3_checkpoint.c	/^static int checkpoint_starvation_walhook($/;"	f	file:
checksum	.\tool\sqldiff.c	/^static unsigned int checksum(const char *zIn, size_t N){$/;"	f	file:
checksumFinalize	.\test\wordcount.c	/^static void checksumFinalize(sqlite3_context *context){$/;"	f	file:
checksumStep	.\test\wordcount.c	/^static void checksumStep($/;"	f	file:
childPtrSize	.\src\btreeInt.h	/^  u8 childPtrSize;     \/* 0 if leaf==1.  4 if leaf==0 *\/$/;"	m	struct:MemPage
circle_del	.\src\test_rtree.c	/^static void circle_del(void *p){$/;"	f	file:
circle_geom	.\src\test_rtree.c	/^static int circle_geom($/;"	f	file:
circle_query_func	.\src\test_rtree.c	/^static int circle_query_func(sqlite3_rtree_query_info *p){$/;"	f	file:
ckBase	.\src\sqliteInt.h	/^  int ckBase;          \/* Base register of data during check constraints *\/$/;"	m	struct:Parse
ckptLock	.\src\wal.c	/^  u8 ckptLock;               \/* True if holding a checkpoint lock *\/$/;"	m	struct:Wal	file:
ckptSyncFlags	.\src\pager.c	/^  u8 ckptSyncFlags;           \/* SYNC_NORMAL or SYNC_FULL for checkpoint *\/$/;"	m	struct:Pager	file:
cksum	.\ext\fts5\fts5_storage.c	/^  u64 cksum;$/;"	m	struct:Fts5IntegrityCtx	file:
cksum	.\test\tester.tcl	/^proc cksum {{db db}} {$/;"	p
cksumInit	.\src\pager.c	/^  u32 cksumInit;              \/* Quasi-random value added to every checksum *\/$/;"	m	struct:Pager	file:
cksumNonce	.\tool\showjournal.c	/^static unsigned cksumNonce = 0;$/;"	v	file:
clang_sanitize_address	.\src\test1.c	/^static int clang_sanitize_address($/;"	f	file:
className	.\ext\misc\spellfix.c	/^static const unsigned char className[] = ".ABCDHLRMY9 ?";$/;"	v	file:
clearAllSharedCacheTableLocks	.\src\btree.c	/^static void clearAllSharedCacheTableLocks(Btree *p){$/;"	f	file:
clearAllSharedCacheTableLocks	.\src\btree.c	109;"	d	file:
clearCell	.\src\btree.c	/^static int clearCell($/;"	f	file:
clearDatabasePage	.\src\btree.c	/^static int clearDatabasePage($/;"	f	file:
clearPendingTerms	.\ext\fts2\fts2.c	/^static int clearPendingTerms(fulltext_vtab *v){$/;"	f	file:
clearSelect	.\src\select.c	/^static void clearSelect(sqlite3 *db, Select *p, int bFree){$/;"	f	file:
clearTableSpec	.\ext\fts1\fts1.c	/^static void clearTableSpec(TableSpec *p) {$/;"	f	file:
clearTableSpec	.\ext\fts2\fts2.c	/^static void clearTableSpec(TableSpec *p) {$/;"	f	file:
clearYMD_HMS_TZ	.\src\date.c	/^static void clearYMD_HMS_TZ(DateTime *p){$/;"	f	file:
clear_bindings	.\src\sqlite3ext.h	/^  int (*clear_bindings)(sqlite3_stmt*);$/;"	m	struct:sqlite3_api_routines
clear_error	.\test\threadtest3.c	64;"	d	file:
clear_error_x	.\test\threadtest3.c	/^static void clear_error_x($/;"	f	file:
clientMutex	.\src\test_server.c	/^  pthread_mutex_t clientMutex; \/* Hold this mutex to access the message *\/$/;"	m	struct:SqlMessage	file:
clientWakeup	.\src\test_server.c	/^  pthread_cond_t clientWakeup; \/* Signal to wake up the client *\/$/;"	m	struct:SqlMessage	file:
client_main	.\src\test7.c	/^static void *client_main(void *pArg){$/;"	f	file:
client_wait	.\src\test7.c	/^static void client_wait(Thread *p){$/;"	f	file:
clipLength	.\mptest\mptest.c	/^static int clipLength(const char *z){$/;"	f	file:
clock_seconds_proc	.\src\test_thread.c	/^static Tcl_ObjCmdProc clock_seconds_proc;$/;"	v	file:
clock_seconds_proc	.\src\test_thread.c	/^static int clock_seconds_proc($/;"	f	file:
close	.\src\sqlite3ext.h	/^  int  (*close)(sqlite3*);$/;"	m	struct:sqlite3_api_routines
closeAllCursors	.\src\vdbeaux.c	/^static void closeAllCursors(Vdbe *p){$/;"	f	file:
closeCursorsInFrame	.\src\vdbeaux.c	/^static void closeCursorsInFrame(Vdbe *p){$/;"	f	file:
closeIncrblobChannels	.\src\tclsqlite.c	/^static void closeIncrblobChannels(SqliteDb *pDb){$/;"	f	file:
closeIncrblobChannels	.\src\tclsqlite.c	398;"	d	file:
closeOp	.\ext\async\sqlite3async.c	/^  AsyncWrite closeOp;        \/* Preallocated close operation *\/$/;"	m	struct:AsyncFileData	file:
closePendingFds	.\src\os_unix.c	/^static void closePendingFds(unixFile *pFile){$/;"	f	file:
closeTransaction	.\src\test_journal.c	/^static void closeTransaction(jt_file *p){$/;"	f	file:
closeUnixFile	.\src\os_unix.c	/^static int closeUnixFile(sqlite3_file *id){$/;"	f	file:
close_v2	.\src\sqlite3ext.h	/^  int (*close_v2)(sqlite3*);$/;"	m	struct:sqlite3_api_routines
closedb	.\test\threadtest3.c	42;"	d	file:
closedb_x	.\test\threadtest3.c	/^static void closedb_x($/;"	f	file:
closureAvlBalance	.\ext\misc\closure.c	/^static closure_avl *closureAvlBalance(closure_avl *p){$/;"	f	file:
closureAvlDestroy	.\ext\misc\closure.c	/^static void closureAvlDestroy(closure_avl *p, void (*xDestroy)(closure_avl*)){$/;"	f	file:
closureAvlFirst	.\ext\misc\closure.c	/^static closure_avl *closureAvlFirst(closure_avl *p){$/;"	f	file:
closureAvlFromPtr	.\ext\misc\closure.c	/^static closure_avl **closureAvlFromPtr(closure_avl *p, closure_avl **pp){$/;"	f	file:
closureAvlInsert	.\ext\misc\closure.c	/^static closure_avl *closureAvlInsert($/;"	f	file:
closureAvlNext	.\ext\misc\closure.c	/^closure_avl *closureAvlNext(closure_avl *p){$/;"	f
closureAvlRecomputeHeight	.\ext\misc\closure.c	/^static void closureAvlRecomputeHeight(closure_avl *p){$/;"	f	file:
closureAvlRotateAfter	.\ext\misc\closure.c	/^static closure_avl *closureAvlRotateAfter(closure_avl *pP){$/;"	f	file:
closureAvlRotateBefore	.\ext\misc\closure.c	/^static closure_avl *closureAvlRotateBefore(closure_avl *pP){$/;"	f	file:
closureAvlSearch	.\ext\misc\closure.c	/^static closure_avl *closureAvlSearch(closure_avl *p, sqlite3_int64 id){$/;"	f	file:
closureBestIndex	.\ext\misc\closure.c	/^static int closureBestIndex($/;"	f	file:
closureClearCursor	.\ext\misc\closure.c	/^static void closureClearCursor(closure_cursor *pCur){$/;"	f	file:
closureClose	.\ext\misc\closure.c	/^static int closureClose(sqlite3_vtab_cursor *cur){$/;"	f	file:
closureColumn	.\ext\misc\closure.c	/^static int closureColumn(sqlite3_vtab_cursor *cur, sqlite3_context *ctx, int i){$/;"	f	file:
closureConnect	.\ext\misc\closure.c	/^static int closureConnect($/;"	f	file:
closureDequote	.\ext\misc\closure.c	/^static char *closureDequote(const char *zIn){$/;"	f	file:
closureDisconnect	.\ext\misc\closure.c	/^static int closureDisconnect(sqlite3_vtab *pVtab){$/;"	f	file:
closureEof	.\ext\misc\closure.c	/^static int closureEof(sqlite3_vtab_cursor *cur){$/;"	f	file:
closureFilter	.\ext\misc\closure.c	/^static int closureFilter($/;"	f	file:
closureFree	.\ext\misc\closure.c	/^static void closureFree(closure_vtab *p){$/;"	f	file:
closureInsertNode	.\ext\misc\closure.c	/^static int closureInsertNode($/;"	f	file:
closureModule	.\ext\misc\closure.c	/^static sqlite3_module closureModule = {$/;"	v	file:
closureNext	.\ext\misc\closure.c	/^static int closureNext(sqlite3_vtab_cursor *cur){$/;"	f	file:
closureOpen	.\ext\misc\closure.c	/^static int closureOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor){$/;"	f	file:
closureRowid	.\ext\misc\closure.c	/^static int closureRowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid){$/;"	f	file:
closureValueOfKey	.\ext\misc\closure.c	/^static const char *closureValueOfKey(const char *zKey, const char *zStr){$/;"	f	file:
closure_avl	.\ext\misc\closure.c	/^struct closure_avl {$/;"	s	file:
closure_avl	.\ext\misc\closure.c	/^typedef struct closure_avl closure_avl;$/;"	t	typeref:struct:closure_avl	file:
closure_cursor	.\ext\misc\closure.c	/^struct closure_cursor {$/;"	s	file:
closure_cursor	.\ext\misc\closure.c	/^typedef struct closure_cursor closure_cursor;$/;"	t	typeref:struct:closure_cursor	file:
closure_queue	.\ext\misc\closure.c	/^struct closure_queue {$/;"	s	file:
closure_queue	.\ext\misc\closure.c	/^typedef struct closure_queue closure_queue;$/;"	t	typeref:struct:closure_queue	file:
closure_vtab	.\ext\misc\closure.c	/^struct closure_vtab {$/;"	s	file:
closure_vtab	.\ext\misc\closure.c	/^typedef struct closure_vtab closure_vtab;$/;"	t	typeref:struct:closure_vtab	file:
cmd	.\src\parse.y	/^cmd ::= ALTER TABLE add_column_fullname ADD kwcolumn_opt column(Y). {$/;"	l
cmd	.\src\parse.y	/^cmd ::= ALTER TABLE fullname(X) RENAME TO nm(Z). {$/;"	l
cmd	.\src\parse.y	/^cmd ::= ANALYZE nm(X) dbnm(Y).  {sqlite3Analyze(pParse, &X, &Y);}$/;"	l
cmd	.\src\parse.y	/^cmd ::= ANALYZE.                {sqlite3Analyze(pParse, 0, 0);}$/;"	l
cmd	.\src\parse.y	/^cmd ::= ATTACH database_kw_opt expr(F) AS expr(D) key_opt(K). {$/;"	l
cmd	.\src\parse.y	/^cmd ::= BEGIN transtype(Y) trans_opt.  {sqlite3BeginTransaction(pParse, Y);}$/;"	l
cmd	.\src\parse.y	/^cmd ::= COMMIT trans_opt.      {sqlite3CommitTransaction(pParse);}$/;"	l
cmd	.\src\parse.y	/^cmd ::= DETACH database_kw_opt expr(D). {$/;"	l
cmd	.\src\parse.y	/^cmd ::= DROP INDEX ifexists(E) fullname(X).   {sqlite3DropIndex(pParse, X, E);}$/;"	l
cmd	.\src\parse.y	/^cmd ::= DROP TABLE ifexists(E) fullname(X). {$/;"	l
cmd	.\src\parse.y	/^cmd ::= DROP TRIGGER ifexists(NOERR) fullname(X). {$/;"	l
cmd	.\src\parse.y	/^cmd ::= DROP VIEW ifexists(E) fullname(X). {$/;"	l
cmd	.\src\parse.y	/^cmd ::= END trans_opt.         {sqlite3CommitTransaction(pParse);}$/;"	l
cmd	.\src\parse.y	/^cmd ::= PRAGMA nm(X) dbnm(Z) EQ minus_num(Y). $/;"	l
cmd	.\src\parse.y	/^cmd ::= PRAGMA nm(X) dbnm(Z) EQ nmnum(Y).    {sqlite3Pragma(pParse,&X,&Z,&Y,0);}$/;"	l
cmd	.\src\parse.y	/^cmd ::= PRAGMA nm(X) dbnm(Z) LP minus_num(Y) RP.$/;"	l
cmd	.\src\parse.y	/^cmd ::= PRAGMA nm(X) dbnm(Z) LP nmnum(Y) RP. {sqlite3Pragma(pParse,&X,&Z,&Y,0);}$/;"	l
cmd	.\src\parse.y	/^cmd ::= PRAGMA nm(X) dbnm(Z).                {sqlite3Pragma(pParse,&X,&Z,0,0);}$/;"	l
cmd	.\src\parse.y	/^cmd ::= REINDEX nm(X) dbnm(Y).  {sqlite3Reindex(pParse, &X, &Y);}$/;"	l
cmd	.\src\parse.y	/^cmd ::= REINDEX.                {sqlite3Reindex(pParse, 0, 0);}$/;"	l
cmd	.\src\parse.y	/^cmd ::= RELEASE savepoint_opt nm(X). {$/;"	l
cmd	.\src\parse.y	/^cmd ::= ROLLBACK trans_opt TO savepoint_opt nm(X). {$/;"	l
cmd	.\src\parse.y	/^cmd ::= ROLLBACK trans_opt.    {sqlite3RollbackTransaction(pParse);}$/;"	l
cmd	.\src\parse.y	/^cmd ::= SAVEPOINT nm(X). {$/;"	l
cmd	.\src\parse.y	/^cmd ::= VACUUM nm.             {sqlite3Vacuum(pParse);}$/;"	l
cmd	.\src\parse.y	/^cmd ::= VACUUM.                {sqlite3Vacuum(pParse);}$/;"	l
cmd	.\src\parse.y	/^cmd ::= create_table create_table_args.$/;"	l
cmd	.\src\parse.y	/^cmd ::= create_vtab LP vtabarglist RP(X).  {sqlite3VtabFinishParse(pParse,&X);}$/;"	l
cmd	.\src\parse.y	/^cmd ::= create_vtab.                       {sqlite3VtabFinishParse(pParse,0);}$/;"	l
cmd	.\src\parse.y	/^cmd ::= createkw trigger_decl(A) BEGIN trigger_cmd_list(S) END(Z). {$/;"	l
cmd	.\src\parse.y	/^cmd ::= createkw(S) uniqueflag(U) INDEX ifnotexists(NE) nm(X) dbnm(D)$/;"	l
cmd	.\src\parse.y	/^cmd ::= createkw(X) temp(T) VIEW ifnotexists(E) nm(Y) dbnm(Z) eidlist_opt(C)$/;"	l
cmd	.\src\parse.y	/^cmd ::= select(X).  {$/;"	l
cmd	.\src\parse.y	/^cmd ::= with(C) DELETE FROM fullname(X) indexed_opt(I) where_opt(W) $/;"	l
cmd	.\src\parse.y	/^cmd ::= with(C) DELETE FROM fullname(X) indexed_opt(I) where_opt(W). {$/;"	l
cmd	.\src\parse.y	/^cmd ::= with(C) UPDATE orconf(R) fullname(X) indexed_opt(I) SET setlist(Y)$/;"	l
cmd	.\src\parse.y	/^cmd ::= with(W) insert_cmd(R) INTO fullname(X) idlist_opt(F) DEFAULT VALUES.$/;"	l
cmd	.\src\parse.y	/^cmd ::= with(W) insert_cmd(R) INTO fullname(X) idlist_opt(F) select(S). {$/;"	l
cmdlineError	.\tool\sqldiff.c	/^static void cmdlineError(const char *zFormat, ...){$/;"	f	file:
cmdline_option_value	.\src\shell.c	/^static char *cmdline_option_value(int argc, char **argv, int i){$/;"	f	file:
cmdlist	.\src\parse.y	/^cmdlist ::= cmdlist ecmd.$/;"	l
cmdlist	.\src\parse.y	/^cmdlist ::= ecmd.$/;"	l
cmdx	.\src\parse.y	/^cmdx ::= cmd.           { sqlite3FinishCoding(pParse); }$/;"	l
cnt	.\src\func.c	/^  i64 cnt;          \/* Number of elements summed *\/$/;"	m	struct:SumCtx	file:
cnt	.\src\mutex_noop.c	/^  int cnt;    \/* Number of entries without a matching leave *\/$/;"	m	struct:sqlite3_debug_mutex	file:
cnt	.\src\shell.c	/^  int cnt;               \/* Number of records displayed so far *\/$/;"	m	struct:ShellState	file:
cnt	.\src\vdbe.h	/^  u32 cnt;                 \/* Number of times this instruction was executed *\/$/;"	m	struct:VdbeOp
coalesce_subquery	.\test\randexpr1.tcl	/^proc coalesce_subquery {a b e} {$/;"	p
code	.\tool\lemon.c	/^  const char *code;        \/* The code executed when this rule is reduced *\/$/;"	m	struct:rule	file:
code1	.\test\bc_common.tcl	/^  proc code1 {tcl} { uplevel #0 $tcl }$/;"	p
code1	.\test\lock_common.tcl	/^    proc code1 {tcl} { uplevel #0 $tcl }$/;"	p
code2	.\test\bc_common.tcl	/^  proc code2 {tcl} { testfixture $::bc_chan $tcl }$/;"	p
code2	.\test\lock_common.tcl	/^    proc code2 {tcl} { testfixture $::code2_chan $tcl }$/;"	p
code2	.\test\lock_common.tcl	/^    proc code2 {tcl} { uplevel #0 $tcl }$/;"	p
code3	.\test\lock_common.tcl	/^    proc code3 {tcl} { testfixture $::code3_chan $tcl }$/;"	p
code3	.\test\lock_common.tcl	/^    proc code3 {tcl} { uplevel #0 $tcl }$/;"	p
codeAllEqualityTerms	.\src\wherecode.c	/^static int codeAllEqualityTerms($/;"	f	file:
codeApplyAffinity	.\src\wherecode.c	/^static void codeApplyAffinity(Parse *pParse, int base, int n, char *zAff){$/;"	f	file:
codeAttach	.\src\attach.c	/^static void codeAttach($/;"	f	file:
codeCompare	.\src\expr.c	/^static int codeCompare($/;"	f	file:
codeDistinct	.\src\select.c	/^static void codeDistinct($/;"	f	file:
codeEqualityTerm	.\src\wherecode.c	/^static int codeEqualityTerm($/;"	f	file:
codeInteger	.\src\expr.c	/^static void codeInteger(Parse *pParse, Expr *pExpr, int negFlag, int iMem){$/;"	f	file:
codeOffset	.\src\select.c	/^static void codeOffset($/;"	f	file:
codeReal	.\src\expr.c	/^static void codeReal(Vdbe *v, const char *z, int negateFlag, int iMem){$/;"	f	file:
codeRowTrigger	.\src\trigger.c	/^static TriggerPrg *codeRowTrigger($/;"	f	file:
codeTableLocks	.\src\build.c	/^static void codeTableLocks(Parse *pParse){$/;"	f	file:
codeTableLocks	.\src\build.c	113;"	d	file:
codeTriggerProgram	.\src\trigger.c	/^static int codeTriggerProgram($/;"	f	file:
colFlags	.\src\sqliteInt.h	/^  u8 colFlags;     \/* Boolean properties.  See COLFLAG_ defines below *\/$/;"	m	struct:Column
colNamesSet	.\src\sqliteInt.h	/^  u8 colNamesSet;      \/* TRUE after OP_ColumnName has been issued to pVdbe *\/$/;"	m	struct:Parse
colSeparator	.\src\shell.c	/^  char colSeparator[20]; \/* Column separator character for several modes *\/$/;"	m	struct:ShellState	file:
colUsed	.\src\sqliteInt.h	/^    Bitmask colUsed;  \/* Bit N (1<<N) set if column N of pTab is used *\/$/;"	m	struct:SrcList::SrcList_item
colWidth	.\src\shell.c	/^  int colWidth[100];     \/* Requested width of each column when in column mode*\/$/;"	m	struct:ShellState	file:
colWidth	.\src\shell.c	/^  int colWidth[100];  \/* Column widths prior to ".explain on" *\/$/;"	m	struct:SavedModeInfo	file:
collationMatch	.\src\build.c	/^static int collationMatch(const char *zColl, Index *pIndex){$/;"	f	file:
collation_needed	.\src\sqlite3ext.h	/^  int  (*collation_needed)(sqlite3*,void*,void(*)(void*,sqlite3*,$/;"	m	struct:sqlite3_api_routines
collation_needed16	.\src\sqlite3ext.h	/^  int  (*collation_needed16)(sqlite3*,void*,void(*)(void*,sqlite3*,$/;"	m	struct:sqlite3_api_routines
collectSegmentTerms	.\ext\fts2\fts2.c	/^static int collectSegmentTerms(fulltext_vtab *v, sqlite3_stmt *s,$/;"	f	file:
collide	.\tool\lemon.c	/^  struct action *collide;  \/* Next action with the same hash *\/$/;"	m	struct:action	typeref:struct:action::action	file:
columnIndex	.\src\select.c	/^static int columnIndex(Table *pTab, const char *zCol){$/;"	f	file:
columnMallocFailure	.\src\vdbeapi.c	/^static void columnMallocFailure(sqlite3_stmt *pStmt)$/;"	f	file:
columnMem	.\src\vdbeapi.c	/^static Mem *columnMem(sqlite3_stmt *pStmt, int i){$/;"	f	file:
columnName	.\src\vdbeapi.c	/^static const void *columnName($/;"	f	file:
columnNames	.\tool\sqldiff.c	/^static char **columnNames($/;"	f	file:
columnNullValue	.\src\vdbeapi.c	/^static const Mem *columnNullValue(void){$/;"	f	file:
columnType	.\src\select.c	1320;"	d	file:
columnType	.\src\select.c	1322;"	d	file:
columnTypeImpl	.\src\select.c	/^static const char *columnTypeImpl($/;"	f	file:
column_blob	.\src\sqlite3ext.h	/^  const void * (*column_blob)(sqlite3_stmt*,int iCol);$/;"	m	struct:sqlite3_api_routines
column_bytes	.\src\sqlite3ext.h	/^  int  (*column_bytes)(sqlite3_stmt*,int iCol);$/;"	m	struct:sqlite3_api_routines
column_bytes16	.\src\sqlite3ext.h	/^  int  (*column_bytes16)(sqlite3_stmt*,int iCol);$/;"	m	struct:sqlite3_api_routines
column_count	.\src\sqlite3ext.h	/^  int  (*column_count)(sqlite3_stmt*pStmt);$/;"	m	struct:sqlite3_api_routines
column_database_name	.\src\sqlite3ext.h	/^  const char * (*column_database_name)(sqlite3_stmt*,int);$/;"	m	struct:sqlite3_api_routines
column_database_name16	.\src\sqlite3ext.h	/^  const void * (*column_database_name16)(sqlite3_stmt*,int);$/;"	m	struct:sqlite3_api_routines
column_decltype	.\src\sqlite3ext.h	/^  const char * (*column_decltype)(sqlite3_stmt*,int i);$/;"	m	struct:sqlite3_api_routines
column_decltype16	.\src\sqlite3ext.h	/^  const void * (*column_decltype16)(sqlite3_stmt*,int);$/;"	m	struct:sqlite3_api_routines
column_double	.\src\sqlite3ext.h	/^  double  (*column_double)(sqlite3_stmt*,int iCol);$/;"	m	struct:sqlite3_api_routines
column_int	.\src\sqlite3ext.h	/^  int  (*column_int)(sqlite3_stmt*,int iCol);$/;"	m	struct:sqlite3_api_routines
column_int64	.\src\sqlite3ext.h	/^  sqlite_int64  (*column_int64)(sqlite3_stmt*,int iCol);$/;"	m	struct:sqlite3_api_routines
column_name	.\src\sqlite3ext.h	/^  const char * (*column_name)(sqlite3_stmt*,int);$/;"	m	struct:sqlite3_api_routines
column_name16	.\src\sqlite3ext.h	/^  const void * (*column_name16)(sqlite3_stmt*,int);$/;"	m	struct:sqlite3_api_routines
column_origin_name	.\src\sqlite3ext.h	/^  const char * (*column_origin_name)(sqlite3_stmt*,int);$/;"	m	struct:sqlite3_api_routines
column_origin_name16	.\src\sqlite3ext.h	/^  const void * (*column_origin_name16)(sqlite3_stmt*,int);$/;"	m	struct:sqlite3_api_routines
column_table_name	.\src\sqlite3ext.h	/^  const char * (*column_table_name)(sqlite3_stmt*,int);$/;"	m	struct:sqlite3_api_routines
column_table_name16	.\src\sqlite3ext.h	/^  const void * (*column_table_name16)(sqlite3_stmt*,int);$/;"	m	struct:sqlite3_api_routines
column_text	.\src\sqlite3ext.h	/^  const unsigned char * (*column_text)(sqlite3_stmt*,int iCol);$/;"	m	struct:sqlite3_api_routines
column_text16	.\src\sqlite3ext.h	/^  const void * (*column_text16)(sqlite3_stmt*,int iCol);$/;"	m	struct:sqlite3_api_routines
column_type	.\src\sqlite3ext.h	/^  int  (*column_type)(sqlite3_stmt*,int iCol);$/;"	m	struct:sqlite3_api_routines
column_value	.\src\sqlite3ext.h	/^  sqlite3_value* (*column_value)(sqlite3_stmt*,int iCol);$/;"	m	struct:sqlite3_api_routines
columnlist	.\src\parse.y	/^columnlist ::= column.$/;"	l
columnlist	.\src\parse.y	/^columnlist ::= columnlist COMMA column.$/;"	l
columnsInIndex	.\src\where.c	/^static Bitmask columnsInIndex(Index *pIdx){$/;"	f	file:
colv	.\src\test4.c	/^  const char *colv[100];    \/* result column names *\/$/;"	m	struct:Thread	file:
colv	.\src\test7.c	/^  const char *colv[100];   \/* result column names *\/$/;"	m	struct:Thread	file:
commit_hook	.\src\sqlite3ext.h	/^  void * (*commit_hook)(sqlite3*,int(*)(void*),void*);$/;"	m	struct:sqlite3_api_routines
compare2pow63	.\src\util.c	/^static int compare2pow63(const char *zNum, int incr){$/;"	f	file:
compareFunction	.\ext\fts1\ft_hash.c	/^static int (*compareFunction(int keyClass))(const void*,int,const void*,int){$/;"	f	file:
compareFunction	.\ext\fts1\fts1_hash.c	/^static int (*compareFunction(int keyClass))(const void*,int,const void*,int){$/;"	f	file:
compareFunction	.\ext\fts2\fts2_hash.c	/^static int (*compareFunction(int keyClass))(const void*,int,const void*,int){$/;"	f	file:
compareInfo	.\src\func.c	/^struct compareInfo {$/;"	s	file:
comparisonAffinity	.\src\expr.c	/^static char comparisonAffinity(Expr *pExpr){$/;"	f	file:
compileoption_get	.\src\sqlite3ext.h	/^  const char *(*compileoption_get)(int);$/;"	m	struct:sqlite3_api_routines
compileoption_used	.\src\sqlite3ext.h	/^  int (*compileoption_used)(const char*);$/;"	m	struct:sqlite3_api_routines
compileoptiongetFunc	.\src\func.c	/^static void compileoptiongetFunc($/;"	f	file:
compileoptionusedFunc	.\src\func.c	/^static void compileoptionusedFunc($/;"	f	file:
complete	.\src\sqlite3ext.h	/^  int  (*complete)(const char*sql);$/;"	m	struct:sqlite3_api_routines
complete16	.\src\sqlite3ext.h	/^  int  (*complete16)(const void*sql);$/;"	m	struct:sqlite3_api_routines
completed	.\src\test4.c	/^  int completed;        \/* Number of operations completed *\/$/;"	m	struct:Thread	file:
completed	.\src\test7.c	/^  volatile int completed;  \/* Number of operations completed *\/$/;"	m	struct:Thread	file:
compressFunc	.\ext\misc\compress.c	/^static void compressFunc($/;"	f	file:
computeCellSize	.\src\btree.c	/^static SQLITE_NOINLINE u16 computeCellSize(CellArray *p, int N){$/;"	f	file:
computeHMS	.\src\date.c	/^static void computeHMS(DateTime *p){$/;"	f	file:
computeJD	.\src\date.c	/^static void computeJD(DateTime *p){$/;"	f	file:
computeLimitRegisters	.\src\select.c	/^static void computeLimitRegisters(Parse *pParse, Select *p, int iBreak){$/;"	f	file:
computeNumericType	.\src\vdbe.c	/^static u16 SQLITE_NOINLINE computeNumericType(Mem *pMem){$/;"	f	file:
computeSigs	.\tool\pagesig.c	/^static void computeSigs(const char *zFilename){$/;"	f	file:
computeYMD	.\src\date.c	/^static void computeYMD(DateTime *p){$/;"	f	file:
computeYMD_HMS	.\src\date.c	/^static void computeYMD_HMS(DateTime *p){$/;"	f	file:
compute_action	.\tool\lemon.c	/^PRIVATE int compute_action(struct lemon *lemp, struct action *ap)$/;"	f
conchFile	.\src\os_unix.c	/^  unixFile *conchFile;         \/* Open conch file *\/$/;"	m	struct:proxyLockingContext	file:
conchFilePath	.\src\os_unix.c	/^  char *conchFilePath;         \/* Name of the conch file *\/$/;"	m	struct:proxyLockingContext	file:
conchHeld	.\src\os_unix.c	/^  int conchHeld;               \/* 1 if the conch is held, -1 if lockless *\/$/;"	m	struct:proxyLockingContext	file:
cond	.\src\test_thread.c	/^  pthread_cond_t cond;               \/* Condition variable to wait on *\/$/;"	m	struct:UnlockNotification	file:
config	.\tool\lemon.c	/^struct config {$/;"	s	file:
confighash	.\tool\lemon.c	/^PRIVATE unsigned confighash(struct config *a)$/;"	f
configureCommand	.\test\releasetest.tcl	/^proc configureCommand {opts} {$/;"	p
connectionIsBusy	.\src\main.c	/^static int connectionIsBusy(sqlite3 *db){$/;"	f	file:
conslist	.\src\parse.y	/^conslist ::= conslist tconscomma tcons.$/;"	l
conslist	.\src\parse.y	/^conslist ::= tcons.$/;"	l
constraintName	.\src\sqliteInt.h	/^  Token constraintName;\/* Name of the constraint currently being parsed *\/$/;"	m	struct:Parse
constructAutomaticIndex	.\src\where.c	/^static void constructAutomaticIndex($/;"	f	file:
constructVtab	.\ext\fts1\fts1.c	/^static int constructVtab($/;"	f	file:
constructVtab	.\ext\fts2\fts2.c	/^static int constructVtab($/;"	f	file:
contentInsertStatement	.\ext\fts1\fts1.c	/^static const char *contentInsertStatement(fulltext_vtab *v){$/;"	f	file:
contentInsertStatement	.\ext\fts2\fts2.c	/^static const char *contentInsertStatement(fulltext_vtab *v){$/;"	f	file:
contentUpdateStatement	.\ext\fts1\fts1.c	/^static const char *contentUpdateStatement(fulltext_vtab *v){$/;"	f	file:
contentUpdateStatement	.\ext\fts2\fts2.c	/^static const char *contentUpdateStatement(fulltext_vtab *v){$/;"	f	file:
content_delete	.\ext\fts1\fts1.c	/^static int content_delete(fulltext_vtab *v, sqlite_int64 iRow){$/;"	f	file:
content_delete	.\ext\fts1\fulltext.c	/^static int content_delete(fulltext_vtab *v, sqlite_int64 iRow){$/;"	f	file:
content_delete	.\ext\fts2\fts2.c	/^static int content_delete(fulltext_vtab *v, sqlite_int64 iRow){$/;"	f	file:
content_exists	.\ext\fts2\fts2.c	/^static int content_exists(fulltext_vtab *v){$/;"	f	file:
content_insert	.\ext\fts1\fts1.c	/^static int content_insert(fulltext_vtab *v, sqlite3_value *rowid,$/;"	f	file:
content_insert	.\ext\fts1\fulltext.c	/^static int content_insert(fulltext_vtab *v, sqlite3_value *rowid,$/;"	f	file:
content_insert	.\ext\fts2\fts2.c	/^static int content_insert(fulltext_vtab *v, sqlite3_value *rowid,$/;"	f	file:
content_select	.\ext\fts1\fts1.c	/^static int content_select(fulltext_vtab *v, sqlite_int64 iRow,$/;"	f	file:
content_select	.\ext\fts1\fulltext.c	/^static int content_select(fulltext_vtab *v, sqlite_int64 iRow,$/;"	f	file:
content_select	.\ext\fts2\fts2.c	/^static int content_select(fulltext_vtab *v, sqlite_int64 iRow,$/;"	f	file:
content_update	.\ext\fts1\fts1.c	/^static int content_update(fulltext_vtab *v, sqlite3_value **pValues,$/;"	f	file:
content_update	.\ext\fts2\fts2.c	/^static int content_update(fulltext_vtab *v, sqlite3_value **pValues,$/;"	f	file:
contextMalloc	.\src\func.c	/^static void *contextMalloc(sqlite3_context *context, i64 nByte){$/;"	f	file:
context_db_handle	.\src\sqlite3ext.h	/^  sqlite3 *(*context_db_handle)(sqlite3_context*);$/;"	m	struct:sqlite3_api_routines
continuePrompt	.\src\shell.c	/^static char continuePrompt[20]; \/* Continuation prompt. default: "   ...> " *\/$/;"	v	file:
convertCompoundSelectToSubquery	.\src\select.c	/^static int convertCompoundSelectToSubquery(Walker *pWalker, Select *p){$/;"	f	file:
convertToWithoutRowidTable	.\src\build.c	/^static void convertToWithoutRowidTable(Parse *pParse, Table *pTab){$/;"	f	file:
cookieMask	.\src\sqliteInt.h	/^  yDbMask cookieMask;  \/* Bitmask of schema verified databases *\/$/;"	m	struct:Parse
cookieValue	.\src\sqliteInt.h	/^  int cookieValue[SQLITE_MAX_ATTACHED+2];  \/* Values of cookies to verify *\/$/;"	m	struct:Parse
copyKey	.\ext\fts1\ft_hash.h	/^  char copyKey;           \/* True if copy of key made on insert *\/$/;"	m	struct:Hash
copyKey	.\ext\fts1\fts1_hash.h	/^  char copyKey;           \/* True if copy of key made on insert *\/$/;"	m	struct:fts1Hash
copyKey	.\ext\fts2\fts2_hash.h	/^  char copyKey;           \/* True if copy of key made on insert *\/$/;"	m	struct:fts2Hash
copyKey	.\ext\fts3\fts3_hash.h	/^  char copyKey;           \/* True if copy of key made on insert *\/$/;"	m	struct:Fts3Hash
copyNodeContent	.\src\btree.c	/^static void copyNodeContent(MemPage *pFrom, MemPage *pTo, int *pRC){$/;"	f	file:
copyPayload	.\src\btree.c	/^static int copyPayload($/;"	f	file:
copy_file	.\ext\fts2\mkfts2amal.tcl	/^proc copy_file {filename} {$/;"	p
copy_file	.\ext\fts3\mkfts3amal.tcl	/^proc copy_file {filename} {$/;"	p
copy_file	.\test\tester.tcl	/^proc copy_file {from to} {$/;"	p
copy_file	.\tool\mksqlite3c-noext.tcl	/^proc copy_file {filename} {$/;"	p
copy_file	.\tool\mksqlite3c.tcl	/^proc copy_file {filename} {$/;"	p
copy_file	.\tool\mksqlite3internalh.tcl	/^proc copy_file {filename} {$/;"	p
copy_file	.\tool\restore_jrnl.tcl	/^proc copy_file {from to} {$/;"	p
copy_stemmer	.\ext\fts1\fts1_porter.c	/^static void copy_stemmer(const char *zIn, int nIn, char *zOut, int *pnOut){$/;"	f	file:
copy_stemmer	.\ext\fts2\fts2_porter.c	/^static void copy_stemmer(const char *zIn, int nIn, char *zOut, int *pnOut){$/;"	f	file:
copy_stemmer	.\ext\fts3\fts3_porter.c	/^static void copy_stemmer(const char *zIn, int nIn, char *zOut, int *pnOut){$/;"	f	file:
corruptSchema	.\src\prepare.c	/^static void corruptSchema($/;"	f	file:
costMult	.\src\sqliteInt.h	/^  LogEst costMult;     \/* Cost multiplier for using this table *\/$/;"	m	struct:Table
count	.\ext\fts1\ft_hash.h	/^    int count;               \/* Number of entries with this hash *\/$/;"	m	struct:Hash::_ht
count	.\ext\fts1\ft_hash.h	/^  int count;              \/* Number of entries in this table *\/$/;"	m	struct:Hash
count	.\ext\fts1\fts1_hash.h	/^    int count;               \/* Number of entries with this hash *\/$/;"	m	struct:fts1Hash::_fts1ht
count	.\ext\fts1\fts1_hash.h	/^  int count;              \/* Number of entries in this table *\/$/;"	m	struct:fts1Hash
count	.\ext\fts2\fts2_hash.h	/^    int count;               \/* Number of entries with this hash *\/$/;"	m	struct:fts2Hash::_fts2ht
count	.\ext\fts2\fts2_hash.h	/^  int count;              \/* Number of entries in this table *\/$/;"	m	struct:fts2Hash
count	.\ext\fts3\fts3_hash.h	/^    int count;               \/* Number of entries with this hash *\/$/;"	m	struct:Fts3Hash::_fts3ht
count	.\ext\fts3\fts3_hash.h	/^  int count;              \/* Number of entries in this table *\/$/;"	m	struct:Fts3Hash
count	.\src\hash.h	/^    int count;                 \/* Number of entries with this hash *\/$/;"	m	struct:Hash::_ht
count	.\src\hash.h	/^  unsigned int count;       \/* Number of entries in this table *\/$/;"	m	struct:Hash
count	.\tool\lemon.c	/^  int count;              \/* Number of currently slots filled *\/$/;"	m	struct:s_x1	file:
count	.\tool\lemon.c	/^  int count;              \/* Number of currently slots filled *\/$/;"	m	struct:s_x2	file:
count	.\tool\lemon.c	/^  int count;              \/* Number of currently slots filled *\/$/;"	m	struct:s_x3	file:
count	.\tool\lemon.c	/^  int count;              \/* Number of currently slots filled *\/$/;"	m	struct:s_x4	file:
countFinalize	.\src\func.c	/^static void countFinalize(sqlite3_context *context){$/;"	f	file:
countStep	.\src\func.c	/^static void countStep(sqlite3_context *context, int argc, sqlite3_value **argv){$/;"	f	file:
countValidCursors	.\src\btree.c	/^static int countValidCursors(BtShared *pBt, int wrOnly){$/;"	f	file:
count_terms	.\ext\fts5\tool\showfts5.tcl	/^proc count_terms {tbl arrayname} {$/;"	p
count_tests_and_errors	.\test\releasetest.tcl	/^proc count_tests_and_errors {logfile rcVar errmsgVar} {$/;"	p
counterFunc	.\src\test_func.c	/^static void counterFunc($/;"	f	file:
counterMutexAlloc	.\src\test_mutex.c	/^static sqlite3_mutex *counterMutexAlloc(int eType){$/;"	f	file:
counterMutexEnd	.\src\test_mutex.c	/^static int counterMutexEnd(void){ $/;"	f	file:
counterMutexEnter	.\src\test_mutex.c	/^static void counterMutexEnter(sqlite3_mutex *p){$/;"	f	file:
counterMutexFree	.\src\test_mutex.c	/^static void counterMutexFree(sqlite3_mutex *p){$/;"	f	file:
counterMutexHeld	.\src\test_mutex.c	/^static int counterMutexHeld(sqlite3_mutex *p){$/;"	f	file:
counterMutexInit	.\src\test_mutex.c	/^static int counterMutexInit(void){ $/;"	f	file:
counterMutexLeave	.\src\test_mutex.c	/^static void counterMutexLeave(sqlite3_mutex *p){$/;"	f	file:
counterMutexNotheld	.\src\test_mutex.c	/^static int counterMutexNotheld(sqlite3_mutex *p){$/;"	f	file:
counterMutexTry	.\src\test_mutex.c	/^static int counterMutexTry(sqlite3_mutex *p){$/;"	f	file:
covered	.\ext\fts3\fts3_snippet.c	/^  u64 covered;                    \/* Mask of query phrases covered *\/$/;"	m	struct:SnippetFragment	file:
crashAppData	.\src\test6.c	/^struct crashAppData {$/;"	s	file:
crashEnableCmd	.\src\test6.c	/^static int crashEnableCmd($/;"	f	file:
crashParamsObjCmd	.\src\test6.c	/^static int crashParamsObjCmd($/;"	f	file:
crash_free	.\src\test6.c	/^static void crash_free(void *p){$/;"	f	file:
crash_malloc	.\src\test6.c	/^static void *crash_malloc(int nByte){$/;"	f	file:
crash_realloc	.\src\test6.c	/^static void *crash_realloc(void *p, int n){$/;"	f	file:
crashsql	.\test\tester.tcl	/^proc crashsql {args} {$/;"	p
createAggContext	.\src\vdbeapi.c	/^static SQLITE_NOINLINE void *createAggContext(sqlite3_context *p, int nByte){$/;"	f	file:
createCollation	.\src\main.c	/^static int createCollation($/;"	f	file:
createDoclistResult	.\ext\fts2\fts2.c	/^static void createDoclistResult(sqlite3_context *pContext,$/;"	f	file:
createFile	.\src\journal.c	/^static int createFile(JournalFile *p){$/;"	f	file:
createIncrblobChannel	.\src\tclsqlite.c	/^static int createIncrblobChannel($/;"	f	file:
createMask	.\src\where.c	/^static void createMask(WhereMaskSet *pMaskSet, int iCursor){$/;"	f	file:
createModule	.\src\vtab.c	/^static int createModule($/;"	f	file:
createTableStmt	.\src\build.c	/^static char *createTableStmt(sqlite3 *db, Table *p){$/;"	f	file:
createVFile	.\test\fuzzcheck.c	/^static VFile *createVFile(const char *zName, int sz, unsigned char *pData){$/;"	f	file:
create_collation	.\src\sqlite3ext.h	/^  int  (*create_collation)(sqlite3*,const char*,int,void*,$/;"	m	struct:sqlite3_api_routines
create_collation16	.\src\sqlite3ext.h	/^  int  (*create_collation16)(sqlite3*,const void*,int,void*,$/;"	m	struct:sqlite3_api_routines
create_collation_v2	.\src\sqlite3ext.h	/^  int (*create_collation_v2)(sqlite3*,const char*,int,void*,$/;"	m	struct:sqlite3_api_routines
create_drop_index_1	.\test\tt3_index.c	/^static void create_drop_index_1(int nMs){$/;"	f	file:
create_drop_index_thread	.\test\tt3_index.c	/^static char *create_drop_index_thread(int iTid, void *pArg){$/;"	f	file:
create_function	.\src\sqlite3ext.h	/^  int  (*create_function)(sqlite3*,const char*,int,int,void*,$/;"	m	struct:sqlite3_api_routines
create_function16	.\src\sqlite3ext.h	/^  int  (*create_function16)(sqlite3*,const void*,int,int,void*,$/;"	m	struct:sqlite3_api_routines
create_function_v2	.\src\sqlite3ext.h	/^  int (*create_function_v2)(sqlite3*,const char*,int,int,void*,$/;"	m	struct:sqlite3_api_routines
create_module	.\src\sqlite3ext.h	/^  int (*create_module)(sqlite3*,const char*,const sqlite3_module*,void*);$/;"	m	struct:sqlite3_api_routines
create_module_v2	.\src\sqlite3ext.h	/^  int (*create_module_v2)(sqlite3*,const char*,const sqlite3_module*,void*,$/;"	m	struct:sqlite3_api_routines
create_step_function	.\ext\fts5\mkportersteps.tcl	/^proc create_step_function {name data} {$/;"	p
create_table	.\ext\fts5\tool\fts5txt2db.tcl	/^proc create_table {} {$/;"	p
create_table	.\src\parse.y	/^create_table ::= createkw temp(T) TABLE ifnotexists(E) nm(Y) dbnm(Z). {$/;"	l
create_table_args	.\src\parse.y	/^create_table_args ::= AS select(S). {$/;"	l
create_table_args	.\src\parse.y	/^create_table_args ::= LP columnlist conslist_opt(X) RP(E) table_options(F). {$/;"	l
create_vtab	.\src\parse.y	/^create_vtab ::= createkw VIRTUAL TABLE ifnotexists(E)$/;"	l
csql1	.\test\lock_common.tcl	/^    proc csql1 {sql} { list [catch { sql1 $sql } msg] $msg }$/;"	p
csql2	.\test\lock_common.tcl	/^    proc csql2 {sql} { list [catch { sql2 $sql } msg] $msg }$/;"	p
csql3	.\test\lock_common.tcl	/^    proc csql3 {sql} { list [catch { sql3 $sql } msg] $msg }$/;"	p
csr	.\ext\fts3\fts3_aux.c	/^  Fts3MultiSegReader csr;        \/* Must be right after "base" *\/$/;"	m	struct:Fts3auxCursor	file:
csr	.\ext\fts3\fts3_term.c	/^  Fts3MultiSegReader csr;        \/* Must be right after "base" *\/$/;"	m	struct:Fts3termCursor	file:
csrflags	.\ext\fts5\fts5_main.c	/^  int csrflags;                   \/* Mask of cursor flags (see below) *\/$/;"	m	struct:Fts5Cursor	file:
csv_read_one_field	.\src\shell.c	/^static char *SQLITE_CDECL csv_read_one_field(ImportCtx *p){$/;"	f	file:
ctimeFunc	.\src\date.c	/^static void ctimeFunc($/;"	f	file:
ctimestampFunc	.\src\date.c	/^static void ctimestampFunc($/;"	f	file:
ctrlFlags	.\src\os_unix.c	/^  unsigned short int ctrlFlags;       \/* Behavioral bits.  UNIXFILE_* flags *\/$/;"	m	struct:unixFile	file:
ctrlFlags	.\src\os_win.c	/^  u8 ctrlFlags;           \/* Flags.  See WINFILE_* below *\/$/;"	m	struct:winFile	file:
cubeFunc	.\src\test_autoext.c	/^static void cubeFunc($/;"	f	file:
cube_context_free	.\src\test_rtree.c	/^static void cube_context_free(void *p){$/;"	f	file:
cube_geom	.\src\test_rtree.c	/^static int cube_geom($/;"	f	file:
cube_init	.\src\test_autoext.c	/^static int cube_init($/;"	f	file:
curFlags	.\src\btreeInt.h	/^  u8 curFlags;              \/* zero or more BTCF_* flags defined below *\/$/;"	m	struct:BtCursor
curIntKey	.\src\btreeInt.h	/^  u8 curIntKey;             \/* Value of apPage[0]->intKey *\/$/;"	m	struct:BtCursor
curPagerFlags	.\src\btreeInt.h	/^  u8 curPagerFlags;         \/* Flags to send to sqlite3PagerAcquire() *\/$/;"	m	struct:BtCursor
current	.\src\analyze.c	/^  Stat4Sample current;      \/* Current row as a Stat4Sample *\/$/;"	m	struct:Stat4Accum	file:
current	.\tool\lemon.c	/^static struct config *current = 0;       \/* Top of list of configurations *\/$/;"	v	typeref:struct:config	file:
currentCount	.\src\mem5.c	/^  u32 currentCount;   \/* Current number of distinct checkouts *\/$/;"	m	struct:Mem5Global	file:
currentOut	.\src\mem5.c	/^  u32 currentOut;     \/* Current checkout, including internal fragmentation *\/$/;"	m	struct:Mem5Global	file:
currentTimeFunc	.\src\date.c	/^static void currentTimeFunc($/;"	f	file:
currentend	.\tool\lemon.c	/^static struct config **currentend = 0;   \/* Last on list of configs *\/$/;"	v	typeref:struct:config	file:
cursorHoldsMutex	.\src\btree.c	/^static int cursorHoldsMutex(BtCursor *p){$/;"	f	file:
cursor_info	.\tool\fragck.tcl	/^proc cursor_info {arrayvar csr {up 0}} {$/;"	p
cursor_vtab	.\ext\fts1\fts1.c	/^static struct fulltext_vtab *cursor_vtab(fulltext_cursor *c){$/;"	f	file:
cursor_vtab	.\ext\fts1\fulltext.c	/^static struct fulltext_vtab *cursor_vtab(fulltext_cursor *c){$/;"	f	file:
cursor_vtab	.\ext\fts2\fts2.c	/^static struct fulltext_vtab *cursor_vtab(fulltext_cursor *c){$/;"	f	file:
custom_errno	.\src\test_syscall.c	/^  int custom_errno;               \/* Current value for errno if error *\/$/;"	m	struct:TestSyscallArray	file:
cycles	.\src\vdbe.h	/^  u64 cycles;              \/* Total time spent executing this instruction *\/$/;"	m	struct:VdbeOp
data	.\ext\fts1\ft_hash.h	/^  void *data;              \/* Data associated with this element *\/$/;"	m	struct:HashElem
data	.\ext\fts1\fts1_hash.h	/^  void *data;                \/* Data associated with this element *\/$/;"	m	struct:fts1HashElem
data	.\ext\fts2\fts2.c	/^  DataBuffer data;                \/* encoding buffer *\/$/;"	m	struct:LeafWriter	file:
data	.\ext\fts2\fts2.c	/^  DataBuffer data;           \/* Accumulated data for the block. *\/$/;"	m	struct:InteriorBlock	file:
data	.\ext\fts2\fts2_hash.h	/^  void *data;                \/* Data associated with this element *\/$/;"	m	struct:fts2HashElem
data	.\ext\fts3\fts3_hash.h	/^  void *data;                \/* Data associated with this element *\/$/;"	m	struct:Fts3HashElem
data	.\src\hash.h	/^  void *data;                  \/* Data associated with this element *\/$/;"	m	struct:HashElem
data	.\tool\lemon.c	/^  const char *data;        \/* The data *\/$/;"	m	struct:s_x1node	file:
data	.\tool\lemon.c	/^  struct config *data;                  \/* The data *\/$/;"	m	struct:s_x4node	typeref:struct:s_x4node::config	file:
data	.\tool\lemon.c	/^  struct state *data;                  \/* The data *\/$/;"	m	struct:s_x3node	typeref:struct:s_x3node::state	file:
data	.\tool\lemon.c	/^  struct symbol *data;     \/* The data *\/$/;"	m	struct:s_x2node	typeref:struct:s_x2node::symbol	file:
dataBufferAppend	.\ext\fts2\fts2.c	/^static void dataBufferAppend(DataBuffer *pBuffer,$/;"	f	file:
dataBufferAppend2	.\ext\fts2\fts2.c	/^static void dataBufferAppend2(DataBuffer *pBuffer,$/;"	f	file:
dataBufferDestroy	.\ext\fts2\fts2.c	/^static void dataBufferDestroy(DataBuffer *pBuffer){$/;"	f	file:
dataBufferExpand	.\ext\fts2\fts2.c	/^static void dataBufferExpand(DataBuffer *pBuffer, int nAddCapacity){$/;"	f	file:
dataBufferInit	.\ext\fts2\fts2.c	/^static void dataBufferInit(DataBuffer *pBuffer, int nCapacity){$/;"	f	file:
dataBufferReplace	.\ext\fts2\fts2.c	/^static void dataBufferReplace(DataBuffer *pBuffer,$/;"	f	file:
dataBufferReset	.\ext\fts2\fts2.c	/^static void dataBufferReset(DataBuffer *pBuffer){$/;"	f	file:
dataBufferSwap	.\ext\fts2\fts2.c	/^static void dataBufferSwap(DataBuffer *pBuffer1, DataBuffer *pBuffer2){$/;"	f	file:
data_count	.\src\sqlite3ext.h	/^  int  (*data_count)(sqlite3_stmt*pStmt);$/;"	m	struct:sqlite3_api_routines
databaseIsUnmoved	.\src\pager.c	/^static int databaseIsUnmoved(Pager *pPager){$/;"	f	file:
database_kw_opt	.\src\parse.y	/^database_kw_opt ::= .$/;"	l
database_kw_opt	.\src\parse.y	/^database_kw_opt ::= DATABASE.$/;"	l
database_may_be_corrupt	.\src\test1.c	/^static int database_may_be_corrupt($/;"	f	file:
database_never_corrupt	.\src\test1.c	/^static int database_never_corrupt($/;"	f	file:
datatype	.\tool\lemon.c	/^  char *datatype;          \/* The data type of information held by this$/;"	m	struct:symbol	file:
dateFunc	.\src\date.c	/^static void dateFunc($/;"	f	file:
datetimeFunc	.\src\date.c	/^static void datetimeFunc($/;"	f	file:
db	.\ext\fts1\fts1.c	/^  sqlite3 *db;                     \/* The database connection *\/$/;"	m	struct:fulltext_vtab	file:
db	.\ext\fts1\fulltext.c	/^  sqlite3 *db;$/;"	m	struct:fulltext_vtab	file:
db	.\ext\fts2\fts2.c	/^  sqlite3 *db;                     \/* The database connection *\/$/;"	m	struct:fulltext_vtab	file:
db	.\ext\fts3\fts3Int.h	/^  sqlite3 *db;                    \/* The database connection *\/$/;"	m	struct:Fts3Table
db	.\ext\fts5\fts5Int.h	/^  sqlite3 *db;                    \/* Database handle *\/$/;"	m	struct:Fts5Config
db	.\ext\fts5\fts5_main.c	/^  sqlite3 *db;                    \/* Associated database connection *\/ $/;"	m	struct:Fts5Global	file:
db	.\ext\fts5\fts5_tcl.c	/^  sqlite3 *db;$/;"	m	struct:SqliteDb	file:
db	.\ext\fts5\fts5_vocab.c	/^  sqlite3 *db;                    \/* Database handle *\/$/;"	m	struct:Fts5VocabTable	file:
db	.\ext\misc\amatch.c	/^  sqlite3 *db;               \/* The database connection *\/$/;"	m	struct:amatch_vtab	file:
db	.\ext\misc\closure.c	/^  sqlite3 *db;               \/* The database connection *\/$/;"	m	struct:closure_vtab	file:
db	.\ext\misc\nextchar.c	/^  sqlite3 *db;                      \/* Database connection *\/$/;"	m	struct:nextCharContext	file:
db	.\ext\misc\spellfix.c	/^  sqlite3 *db;               \/* Database connection *\/$/;"	m	struct:spellfix1_vtab	file:
db	.\ext\misc\vtshim.c	/^  sqlite3 *db;                  \/* The database to which we are attached *\/$/;"	m	struct:vtshim_aux	file:
db	.\ext\rtree\rtree.c	/^  sqlite3 *db;                \/* Host database connection *\/$/;"	m	struct:Rtree	file:
db	.\mptest\mptest.c	/^  sqlite3 *db;           \/* Open connection to database *\/$/;"	m	struct:Global	file:
db	.\src\analyze.c	/^  sqlite3 *db;              \/* Database connection, for malloc() *\/$/;"	m	struct:Stat4Accum	file:
db	.\src\analyze.c	/^  sqlite3 *db;$/;"	m	struct:analysisInfo	file:
db	.\src\btreeInt.h	/^  sqlite3 *db;          \/* Database connection currently using this Btree *\/$/;"	m	struct:BtShared
db	.\src\btreeInt.h	/^  sqlite3 *db;       \/* The database connection holding this btree *\/$/;"	m	struct:Btree
db	.\src\dbstat.c	/^  sqlite3 *db;$/;"	m	struct:StatTable	file:
db	.\src\rowset.c	/^  sqlite3 *db;                   \/* The database connection *\/$/;"	m	struct:RowSet	file:
db	.\src\shell.c	/^  sqlite3 *db;           \/* The database *\/$/;"	m	struct:ShellState	file:
db	.\src\sqliteInt.h	/^  sqlite3 *db;              \/* Database connection associated with this table *\/$/;"	m	struct:VTable
db	.\src\sqliteInt.h	/^  sqlite3 *db;         \/* Optional database for lookaside.  Can be NULL *\/$/;"	m	struct:StrAccum
db	.\src\sqliteInt.h	/^  sqlite3 *db;         \/* The main database structure *\/$/;"	m	struct:Parse
db	.\src\sqliteInt.h	/^  sqlite3 *db;        \/* The database being initialized *\/$/;"	m	struct:__anon21
db	.\src\sqliteInt.h	/^  sqlite3 *db;        \/* The database connection *\/$/;"	m	struct:KeyInfo
db	.\src\tclsqlite.c	/^  sqlite3 *db;               \/* The "real" database structure. MUST BE FIRST *\/$/;"	m	struct:SqliteDb	file:
db	.\src\test1.c	/^  sqlite3 *db;$/;"	m	struct:SqliteDb	file:
db	.\src\test4.c	/^  sqlite3 *db;           \/* Open database *\/$/;"	m	struct:Thread	file:
db	.\src\test7.c	/^  sqlite3 *db;             \/* Open database *\/$/;"	m	struct:Thread	file:
db	.\src\test8.c	/^  sqlite3 *db;            \/* Database connection *\/$/;"	m	struct:echo_vtab	file:
db	.\src\test_fs.c	/^  sqlite3 *db;$/;"	m	struct:fs_vtab	file:
db	.\src\test_schema.c	/^  sqlite3 *db;$/;"	m	struct:schema_vtab	file:
db	.\src\test_sqllog.c	/^  sqlite3 *db;                    \/* Connection handle *\/$/;"	m	struct:SLConn	file:
db	.\src\test_superlock.c	/^  sqlite3 *db;                    \/* Database handle used to lock db *\/$/;"	m	struct:Superlock	file:
db	.\src\vdbeInt.h	/^  sqlite3 *db;            \/* The database connection that owns this statement *\/$/;"	m	struct:Vdbe
db	.\src\vdbeInt.h	/^  sqlite3 *db;        \/* The associated database connection *\/$/;"	m	struct:Mem
db	.\src\vdbeblob.c	/^  sqlite3 *db;            \/* The associated database *\/$/;"	m	struct:Incrblob	file:
db	.\src\vdbesort.c	/^  sqlite3 *db;                    \/* Database connection *\/$/;"	m	struct:VdbeSorter	file:
db	.\test\speedtest1.c	/^  sqlite3 *db;               \/* The open database connection *\/$/;"	m	struct:Global	file:
db	.\test\threadtest3.c	/^  sqlite3 *db;                    \/* Database handle *\/$/;"	m	struct:Sqlite	file:
db	.\test\threadtest4.c	/^  sqlite3 *db;                \/* Database connection of this thread *\/$/;"	m	struct:WorkerInfo	file:
db	.\tool\loadfts.c	/^  sqlite3 *db;                    \/* Database handle *\/$/;"	m	struct:VisitContext	file:
db	.\tool\showjournal.c	/^static FILE *db = 0;$/;"	v	file:
db	.\tool\sqldiff.c	/^  sqlite3 *db;              \/* The database connection *\/$/;"	m	struct:GlobalVars	file:
dbEvalColumnValue	.\src\tclsqlite.c	/^static Tcl_Obj *dbEvalColumnValue(DbEvalContext *p, int iCol){$/;"	f	file:
dbEvalFinalize	.\src\tclsqlite.c	/^static void dbEvalFinalize(DbEvalContext *p){$/;"	f	file:
dbEvalInit	.\src\tclsqlite.c	/^static void dbEvalInit($/;"	f	file:
dbEvalRowInfo	.\src\tclsqlite.c	/^static void dbEvalRowInfo($/;"	f	file:
dbEvalStep	.\src\tclsqlite.c	/^static int dbEvalStep(DbEvalContext *p){$/;"	f	file:
dbFileSize	.\src\pager.c	/^  Pgno dbFileSize;            \/* Number of pages in the database file *\/$/;"	m	struct:Pager	file:
dbFileVers	.\src\pager.c	/^  char dbFileVers[16];        \/* Changes whenever database file changes *\/$/;"	m	struct:Pager	file:
dbFreeStmt	.\src\tclsqlite.c	/^static void dbFreeStmt(SqlPreparedStmt *pStmt){$/;"	f	file:
dbHintSize	.\src\pager.c	/^  Pgno dbHintSize;            \/* Value passed to FCNTL_SIZE_HINT call *\/$/;"	m	struct:Pager	file:
dbMain	.\ext\rbu\sqlite3rbu.c	/^  sqlite3 *dbMain;                \/* target database handle *\/$/;"	m	struct:sqlite3rbu	file:
dbOptFlags	.\src\sqliteInt.h	/^  u16 dbOptFlags;               \/* Flags to enable\/disable optimizations *\/$/;"	m	struct:sqlite3
dbOrigSize	.\src\pager.c	/^  Pgno dbOrigSize;            \/* dbSize before the current transaction *\/$/;"	m	struct:Pager	file:
dbPath	.\src\os_unix.c	/^  char *dbPath;                \/* Name of the open file *\/$/;"	m	struct:proxyLockingContext	file:
dbPath	.\src\os_unix.c	/^  const char *dbPath;             \/* Name of the open file *\/$/;"	m	struct:afpLockingContext	file:
dbPrepare	.\src\tclsqlite.c	/^static int dbPrepare($/;"	f	file:
dbPrepareAndBind	.\src\tclsqlite.c	/^static int dbPrepareAndBind($/;"	f	file:
dbRbu	.\ext\rbu\sqlite3rbu.c	/^  sqlite3 *dbRbu;                 \/* rbu database handle *\/$/;"	m	struct:sqlite3rbu	file:
dbReleaseColumnNames	.\src\tclsqlite.c	/^static void dbReleaseColumnNames(DbEvalContext *p){$/;"	f	file:
dbReleaseStmt	.\src\tclsqlite.c	/^static void dbReleaseStmt($/;"	f	file:
dbSize	.\src\pager.c	/^  Pgno dbSize;                \/* Number of pages in the database *\/$/;"	m	struct:Pager	file:
dbUpdate	.\src\os_unix.c	/^  unsigned char dbUpdate;        \/* True if any part of database file changed *\/$/;"	m	struct:unixFile	file:
db_check	.\test\threadtest1.c	/^void db_check(const char *zFile, const char *zMsg, char **az, ...){$/;"	f
db_config	.\src\sqlite3ext.h	/^  int (*db_config)(sqlite3*,int,...);$/;"	m	struct:sqlite3_api_routines
db_delete_and_reopen	.\test\tester.tcl	/^proc db_delete_and_reopen {{file test.db}} {$/;"	p
db_enter	.\src\test1.c	/^static int db_enter($/;"	f	file:
db_execute	.\test\threadtest1.c	/^void db_execute(sqlite *db, const char *zFile, const char *zFormat, ...){$/;"	f
db_filename	.\src\sqlite3ext.h	/^  const char *(*db_filename)(sqlite3*,const char*);$/;"	m	struct:sqlite3_api_routines
db_handle	.\src\sqlite3ext.h	/^  sqlite3 * (*db_handle)(sqlite3_stmt*);$/;"	m	struct:sqlite3_api_routines
db_int	.\src\shell.c	/^static int db_int(ShellState *p, const char *zSql){$/;"	f	file:
db_is_locked	.\test\threadtest1.c	/^static int db_is_locked(void *NotUsed, int iCount){$/;"	f	file:
db_last_stmt_ptr	.\src\tclsqlite.c	/^static int db_last_stmt_ptr($/;"	f	file:
db_leave	.\src\test1.c	/^static int db_leave($/;"	f	file:
db_mutex	.\src\sqlite3ext.h	/^  sqlite3_mutex *(*db_mutex)(sqlite3*);$/;"	m	struct:sqlite3_api_routines
db_prepare	.\tool\sqldiff.c	/^static sqlite3_stmt *db_prepare(const char *zFormat, ...){$/;"	f	file:
db_query	.\test\threadtest1.c	/^char **db_query(sqlite *db, const char *zFile, const char *zFormat, ...){$/;"	f
db_query_callback	.\test\threadtest1.c	/^static int db_query_callback($/;"	f	file:
db_query_free	.\test\threadtest1.c	/^void db_query_free(char **az){$/;"	f
db_readonly	.\src\sqlite3ext.h	/^  int (*db_readonly)(sqlite3*,const char*);$/;"	m	struct:sqlite3_api_routines
db_release_memory	.\src\sqlite3ext.h	/^  int (*db_release_memory)(sqlite3*);$/;"	m	struct:sqlite3_api_routines
db_restore	.\test\tester.tcl	/^proc db_restore {} {$/;"	p
db_restore_and_reopen	.\test\tester.tcl	/^proc db_restore_and_reopen {{dbfile test.db}} {$/;"	p
db_save	.\test\tester.tcl	/^proc db_save {} {$/;"	p
db_save_and_close	.\test\tester.tcl	/^proc db_save_and_close {} {$/;"	p
db_status	.\src\sqlite3ext.h	/^  int (*db_status)(sqlite3*,int,int*,int*,int);$/;"	m	struct:sqlite3_api_routines
db_use_legacy_prepare_cmd	.\src\tclsqlite.c	/^static int db_use_legacy_prepare_cmd($/;"	f	file:
db_vprepare	.\tool\sqldiff.c	/^static sqlite3_stmt *db_vprepare(const char *zFormat, va_list ap){$/;"	f	file:
dbcksum	.\test\tester.tcl	/^proc dbcksum {db dbname} {$/;"	p
dbfd	.\tool\showdb.c	/^  int dbfd;                       \/* File descriptor for reading the DB *\/$/;"	m	struct:GlobalData	file:
debugMutexAlloc	.\src\mutex_noop.c	/^static sqlite3_mutex *debugMutexAlloc(int id){$/;"	f	file:
debugMutexEnd	.\src\mutex_noop.c	/^static int debugMutexEnd(void){ return SQLITE_OK; }$/;"	f	file:
debugMutexEnter	.\src\mutex_noop.c	/^static void debugMutexEnter(sqlite3_mutex *pX){$/;"	f	file:
debugMutexFree	.\src\mutex_noop.c	/^static void debugMutexFree(sqlite3_mutex *pX){$/;"	f	file:
debugMutexHeld	.\src\mutex_noop.c	/^static int debugMutexHeld(sqlite3_mutex *pX){$/;"	f	file:
debugMutexInit	.\src\mutex_noop.c	/^static int debugMutexInit(void){ return SQLITE_OK; }$/;"	f	file:
debugMutexLeave	.\src\mutex_noop.c	/^static void debugMutexLeave(sqlite3_mutex *pX){$/;"	f	file:
debugMutexNotheld	.\src\mutex_noop.c	/^static int debugMutexNotheld(sqlite3_mutex *pX){$/;"	f	file:
debugMutexTry	.\src\mutex_noop.c	/^static int debugMutexTry(sqlite3_mutex *pX){$/;"	f	file:
declareVtab	.\src\sqliteInt.h	/^  u8 declareVtab;           \/* True if inside sqlite3_declare_vtab() *\/$/;"	m	struct:Parse
declare_vtab	.\src\sqlite3ext.h	/^  int (*declare_vtab)(sqlite3*,const char*);$/;"	m	struct:sqlite3_api_routines
declare_vtab	.\src\test8.c	/^static int declare_vtab($/;"	f	file:
declargslot	.\tool\lemon.c	/^  char **declargslot;        \/* Where the declaration argument should be put *\/$/;"	m	struct:pstate	file:
declassoc	.\tool\lemon.c	/^  enum e_assoc declassoc;    \/* Assign this association to decl arguments *\/$/;"	m	struct:pstate	typeref:enum:pstate::e_assoc	file:
declkeyword	.\tool\lemon.c	/^  const char *declkeyword;   \/* Keyword of a declaration *\/$/;"	m	struct:pstate	file:
decllinenoslot	.\tool\lemon.c	/^  int *decllinenoslot;       \/* Where to write declaration line number *\/$/;"	m	struct:pstate	file:
decodeCell	.\tool\showdb.c	/^static void decodeCell($/;"	f	file:
decodeDoclist	.\ext\fts3\tool\fts3view.c	/^static void decodeDoclist($/;"	f	file:
decodeFlags	.\src\btree.c	/^static int decodeFlags(MemPage *pPage, int flagByte){$/;"	f	file:
decodeInt32	.\tool\showdb.c	/^static unsigned int decodeInt32(const unsigned char *z){$/;"	f	file:
decodeIntArray	.\src\analyze.c	/^static void decodeIntArray($/;"	f	file:
decodeJournalHdr	.\src\test_journal.c	/^static int decodeJournalHdr($/;"	f	file:
decodeSegment	.\ext\fts3\tool\fts3view.c	/^static void decodeSegment($/;"	f	file:
decodeUint32	.\src\test_journal.c	/^static u32 decodeUint32(const unsigned char *z){$/;"	f	file:
decodeVarint	.\tool\showdb.c	/^static int decodeVarint(const unsigned char *z, i64 *pVal){$/;"	f	file:
decodeVarint	.\tool\showstat4.c	/^static int decodeVarint(const unsigned char *z, i64 *pVal){$/;"	f	file:
decodeVarint	.\tool\showwal.c	/^static int decodeVarint(const unsigned char *z, i64 *pVal){$/;"	f	file:
decode_btree_page	.\tool\showdb.c	/^static void decode_btree_page($/;"	f	file:
decode_btree_page	.\tool\showwal.c	/^static void decode_btree_page($/;"	f	file:
decode_journal_header	.\tool\showjournal.c	/^static unsigned decode_journal_header(int iOfst){$/;"	f	file:
decode_trunk_page	.\tool\showdb.c	/^static void decode_trunk_page($/;"	f	file:
default_errno	.\src\test_syscall.c	/^  int default_errno;              \/* Default value for errno following errors *\/$/;"	m	struct:TestSyscallArray	file:
default_rc	.\src\sqliteInt.h	/^  i8 default_rc;      \/* Comparison result if keys are equal *\/$/;"	m	struct:UnpackedRecord
deferredMoveto	.\src\vdbeInt.h	/^  u8 deferredMoveto;    \/* A call to sqlite3BtreeMoveto() is needed *\/$/;"	m	struct:VdbeCursor
defragmentPage	.\src\btree.c	/^static int defragmentPage(MemPage *pPage){$/;"	f	file:
delay1	.\src\test1.c	/^  int delay1;         \/* Delay before locking *\/$/;"	m	struct:win32FileLocker	file:
delay2	.\src\test1.c	/^  int delay2;         \/* Delay before unlocking *\/$/;"	m	struct:win32FileLocker	file:
deleteCell	.\ext\rtree\rtree.c	/^static int deleteCell(Rtree *pRtree, RtreeNode *pNode, int iCell, int iHeight){$/;"	f	file:
deleteOnClose	.\src\test_quota.c	/^  int deleteOnClose;              \/* True to delete this file when it closes *\/$/;"	m	struct:quotaFile	file:
deleteTerms	.\ext\fts1\fts1.c	/^static int deleteTerms(fulltext_vtab *v, fts1Hash *pTerms, sqlite_int64 iRowid){$/;"	f	file:
deleteTerms	.\ext\fts2\fts2.c	/^static int deleteTerms(fulltext_vtab *v, sqlite_int64 iRowid){$/;"	f	file:
delete_all_data	.\test\tester.tcl	/^proc delete_all_data {} {$/;"	p
delete_collation	.\src\test1.c	/^static int delete_collation($/;"	f	file:
delete_file	.\test\tester.tcl	/^proc delete_file {args} {$/;"	p
delete_function	.\src\test1.c	/^static int delete_function($/;"	f	file:
deleteconfig	.\tool\lemon.c	/^PRIVATE void deleteconfig(struct config *old)$/;"	f
delim	.\ext\fts1\fts1_tokenizer1.c	/^  char delim[128];             \/* flag ASCII delimiters *\/$/;"	m	struct:simple_tokenizer	file:
delim	.\ext\fts2\fts2_tokenizer1.c	/^  char delim[128];             \/* flag ASCII delimiters *\/$/;"	m	struct:simple_tokenizer	file:
delim	.\ext\fts3\fts3_tokenizer1.c	/^  char delim[128];             \/* flag ASCII delimiters *\/$/;"	m	struct:simple_tokenizer	file:
demoAccess	.\src\test_demovfs.c	/^static int demoAccess($/;"	f	file:
demoCheckReservedLock	.\src\test_demovfs.c	/^static int demoCheckReservedLock(sqlite3_file *pFile, int *pResOut){$/;"	f	file:
demoClose	.\src\test_demovfs.c	/^static int demoClose(sqlite3_file *pFile){$/;"	f	file:
demoCurrentTime	.\src\test_demovfs.c	/^static int demoCurrentTime(sqlite3_vfs *pVfs, double *pTime){$/;"	f	file:
demoDelete	.\src\test_demovfs.c	/^static int demoDelete(sqlite3_vfs *pVfs, const char *zPath, int dirSync){$/;"	f	file:
demoDeviceCharacteristics	.\src\test_demovfs.c	/^static int demoDeviceCharacteristics(sqlite3_file *pFile){$/;"	f	file:
demoDirectWrite	.\src\test_demovfs.c	/^static int demoDirectWrite($/;"	f	file:
demoDlClose	.\src\test_demovfs.c	/^static void demoDlClose(sqlite3_vfs *pVfs, void *pHandle){$/;"	f	file:
demoDlError	.\src\test_demovfs.c	/^static void demoDlError(sqlite3_vfs *pVfs, int nByte, char *zErrMsg){$/;"	f	file:
demoDlOpen	.\src\test_demovfs.c	/^static void *demoDlOpen(sqlite3_vfs *pVfs, const char *zPath){$/;"	f	file:
demoDlSym	.\src\test_demovfs.c	/^static void (*demoDlSym(sqlite3_vfs *pVfs, void *pH, const char *z))(void){$/;"	f	file:
demoFileControl	.\src\test_demovfs.c	/^static int demoFileControl(sqlite3_file *pFile, int op, void *pArg){$/;"	f	file:
demoFileSize	.\src\test_demovfs.c	/^static int demoFileSize(sqlite3_file *pFile, sqlite_int64 *pSize){$/;"	f	file:
demoFlushBuffer	.\src\test_demovfs.c	/^static int demoFlushBuffer(DemoFile *p){$/;"	f	file:
demoFullPathname	.\src\test_demovfs.c	/^static int demoFullPathname($/;"	f	file:
demoLock	.\src\test_demovfs.c	/^static int demoLock(sqlite3_file *pFile, int eLock){$/;"	f	file:
demoOpen	.\src\test_demovfs.c	/^static int demoOpen($/;"	f	file:
demoRandomness	.\src\test_demovfs.c	/^static int demoRandomness(sqlite3_vfs *pVfs, int nByte, char *zByte){$/;"	f	file:
demoRead	.\src\test_demovfs.c	/^static int demoRead($/;"	f	file:
demoSectorSize	.\src\test_demovfs.c	/^static int demoSectorSize(sqlite3_file *pFile){$/;"	f	file:
demoSleep	.\src\test_demovfs.c	/^static int demoSleep(sqlite3_vfs *pVfs, int nMicro){$/;"	f	file:
demoSync	.\src\test_demovfs.c	/^static int demoSync(sqlite3_file *pFile, int flags){$/;"	f	file:
demoTruncate	.\src\test_demovfs.c	/^static int demoTruncate(sqlite3_file *pFile, sqlite_int64 size){$/;"	f	file:
demoUnlock	.\src\test_demovfs.c	/^static int demoUnlock(sqlite3_file *pFile, int eLock){$/;"	f	file:
demoWrite	.\src\test_demovfs.c	/^static int demoWrite($/;"	f	file:
depth	.\src\test_rtree.c	/^  double depth;$/;"	m	struct:Cube	file:
dequote	.\src\test_osinst.c	/^static void dequote(char *z){$/;"	f	file:
dequoteString	.\ext\fts1\fts1.c	/^static void dequoteString(char *z){$/;"	f	file:
dequoteString	.\ext\fts2\fts2.c	/^static void dequoteString(char *z){$/;"	f	file:
dequoteString	.\src\test8.c	/^static void dequoteString(char *z){$/;"	f	file:
describeCell	.\tool\showdb.c	/^static i64 describeCell($/;"	f	file:
describeCell	.\tool\showwal.c	/^static i64 describeCell($/;"	f	file:
describeContent	.\tool\showdb.c	/^static i64 describeContent($/;"	f	file:
describeContent	.\tool\showwal.c	/^static i64 describeContent($/;"	f	file:
deserializeGeometry	.\ext\rtree\rtree.c	/^static int deserializeGeometry(sqlite3_value *pValue, RtreeConstraint *pCons){$/;"	f	file:
destLineno	.\tool\lemon.c	/^  int destLineno;          \/* Line number for start of destructor *\/$/;"	m	struct:symbol	file:
destroyRootPage	.\src\build.c	/^static void destroyRootPage(Parse *pParse, int iTable, int iDb){$/;"	f	file:
destroyTable	.\src\build.c	/^static void destroyTable(Parse *pParse, Table *pTab){$/;"	f	file:
destructor	.\src\test_func.c	/^static void destructor(void *p){$/;"	f	file:
destructor	.\tool\lemon.c	/^  char *destructor;        \/* Code which executes whenever this symbol is$/;"	m	struct:symbol	file:
detachFunc	.\src\attach.c	/^static void detachFunc($/;"	f	file:
dev	.\src\os_unix.c	/^  dev_t dev;                  \/* Device number *\/$/;"	m	struct:unixFileId	file:
devSymObjCmd	.\src\test6.c	/^static int devSymObjCmd($/;"	f	file:
deviceCharacteristics	.\src\os_unix.c	/^  int deviceCharacteristics;          \/* Precomputed device characteristics *\/$/;"	m	struct:unixFile	file:
devsymAccess	.\src\test_devsym.c	/^static int devsymAccess($/;"	f	file:
devsymCheckReservedLock	.\src\test_devsym.c	/^static int devsymCheckReservedLock(sqlite3_file *pFile, int *pResOut){$/;"	f	file:
devsymClose	.\src\test_devsym.c	/^static int devsymClose(sqlite3_file *pFile){$/;"	f	file:
devsymCurrentTime	.\src\test_devsym.c	/^static int devsymCurrentTime(sqlite3_vfs *pVfs, double *pTimeOut){$/;"	f	file:
devsymDelete	.\src\test_devsym.c	/^static int devsymDelete(sqlite3_vfs *pVfs, const char *zPath, int dirSync){$/;"	f	file:
devsymDeviceCharacteristics	.\src\test_devsym.c	/^static int devsymDeviceCharacteristics(sqlite3_file *pFile){$/;"	f	file:
devsymDlClose	.\src\test_devsym.c	/^static void devsymDlClose(sqlite3_vfs *pVfs, void *pHandle){$/;"	f	file:
devsymDlError	.\src\test_devsym.c	/^static void devsymDlError(sqlite3_vfs *pVfs, int nByte, char *zErrMsg){$/;"	f	file:
devsymDlOpen	.\src\test_devsym.c	/^static void *devsymDlOpen(sqlite3_vfs *pVfs, const char *zPath){$/;"	f	file:
devsymDlSym	.\src\test_devsym.c	/^static void (*devsymDlSym(sqlite3_vfs *pVfs, void *p, const char *zSym))(void){$/;"	f	file:
devsymFileControl	.\src\test_devsym.c	/^static int devsymFileControl(sqlite3_file *pFile, int op, void *pArg){$/;"	f	file:
devsymFileSize	.\src\test_devsym.c	/^static int devsymFileSize(sqlite3_file *pFile, sqlite_int64 *pSize){$/;"	f	file:
devsymFullPathname	.\src\test_devsym.c	/^static int devsymFullPathname($/;"	f	file:
devsymLock	.\src\test_devsym.c	/^static int devsymLock(sqlite3_file *pFile, int eLock){$/;"	f	file:
devsymOpen	.\src\test_devsym.c	/^static int devsymOpen($/;"	f	file:
devsymRandomness	.\src\test_devsym.c	/^static int devsymRandomness(sqlite3_vfs *pVfs, int nByte, char *zBufOut){$/;"	f	file:
devsymRead	.\src\test_devsym.c	/^static int devsymRead($/;"	f	file:
devsymSectorSize	.\src\test_devsym.c	/^static int devsymSectorSize(sqlite3_file *pFile){$/;"	f	file:
devsymShmBarrier	.\src\test_devsym.c	/^static void devsymShmBarrier(sqlite3_file *pFile){$/;"	f	file:
devsymShmLock	.\src\test_devsym.c	/^static int devsymShmLock(sqlite3_file *pFile, int ofst, int n, int flags){$/;"	f	file:
devsymShmMap	.\src\test_devsym.c	/^static int devsymShmMap($/;"	f	file:
devsymShmUnmap	.\src\test_devsym.c	/^static int devsymShmUnmap(sqlite3_file *pFile, int delFlag){$/;"	f	file:
devsymSleep	.\src\test_devsym.c	/^static int devsymSleep(sqlite3_vfs *pVfs, int nMicro){$/;"	f	file:
devsymSync	.\src\test_devsym.c	/^static int devsymSync(sqlite3_file *pFile, int flags){$/;"	f	file:
devsymTruncate	.\src\test_devsym.c	/^static int devsymTruncate(sqlite3_file *pFile, sqlite_int64 size){$/;"	f	file:
devsymUnlock	.\src\test_devsym.c	/^static int devsymUnlock(sqlite3_file *pFile, int eLock){$/;"	f	file:
devsymWrite	.\src\test_devsym.c	/^static int devsymWrite($/;"	f	file:
devsym_file	.\src\test_devsym.c	/^struct devsym_file {$/;"	s	file:
devsym_file	.\src\test_devsym.c	/^typedef struct devsym_file devsym_file;$/;"	t	typeref:struct:devsym_file	file:
devsym_io_methods	.\src\test_devsym.c	/^static sqlite3_io_methods devsym_io_methods = {$/;"	v	file:
devsym_register	.\src\test_devsym.c	/^void devsym_register(int iDeviceChar, int iSectorSize){$/;"	f
devsym_vfs	.\src\test_devsym.c	/^static sqlite3_vfs devsym_vfs = {$/;"	v	file:
dfltColumn	.\ext\fts1\fts1.c	/^  int dfltColumn;       \/* The default column *\/$/;"	m	struct:Query	file:
dfltColumn	.\ext\fts2\fts2.c	/^  int dfltColumn;       \/* The default column *\/$/;"	m	struct:Query	file:
dfltLockMode	.\src\sqliteInt.h	/^  u8 dfltLockMode;              \/* Default locking-mode for attached dbs *\/$/;"	m	struct:sqlite3
diff_one_table	.\tool\sqldiff.c	/^static void diff_one_table(const char *zTab, FILE *out){$/;"	f	file:
digit_count	.\tool\sqldiff.c	/^static int digit_count(int v){$/;"	f	file:
directMode	.\src\sqliteInt.h	/^  u8 directMode;          \/* Direct rendering mode means take data directly$/;"	m	struct:AggInfo
disableAuth	.\src\tclsqlite.c	/^  int disableAuth;           \/* Disable the authorizer if it exists *\/$/;"	m	struct:SqliteDb	file:
disableInit	.\src\test_mutex.c	/^  int disableInit;           \/* True to cause sqlite3_initalize() to fail *\/$/;"	m	struct:test_mutex_globals	file:
disableTerm	.\src\wherecode.c	/^static void disableTerm(WhereLevel *pLevel, WhereTerm *pTerm){$/;"	f	file:
disableTriggers	.\src\sqliteInt.h	/^  u8 disableTriggers;  \/* True to disable triggers *\/$/;"	m	struct:Parse
disableTry	.\src\test_mutex.c	/^  int disableTry;            \/* True to force sqlite3_mutex_try() to fail *\/$/;"	m	struct:test_mutex_globals	file:
disable_simulated_io_errors	.\src\pager.c	/^void disable_simulated_io_errors(void){$/;"	f
disable_simulated_io_errors	.\src\pager.c	3723;"	d	file:
disable_simulated_io_errors	.\src\pager.h	214;"	d
disallow	.\src\mem2.c	/^  int disallow; \/* Do not allow memory allocation *\/$/;"	m	struct:__anon10	file:
discardChance	.\src\test_pcache.c	/^  unsigned discardChance;   \/* Chance of discarding on an unpin (0-100) *\/$/;"	m	struct:testpcacheGlobalType	file:
disconnectAllVtab	.\src\main.c	/^static void disconnectAllVtab(sqlite3 *db){$/;"	f	file:
displayComment	.\src\vdbeaux.c	/^static int displayComment($/;"	f	file:
displayP4	.\src\vdbeaux.c	/^static char *displayP4(Op *pOp, char *zTemp, int nTemp){$/;"	f	file:
display_scanstats	.\src\shell.c	/^static void display_scanstats($/;"	f	file:
display_stats	.\src\shell.c	/^static int display_stats($/;"	f	file:
divide	.\tool\spaceanal.tcl	/^proc divide {num denom} {$/;"	p
dlcAddDoclist	.\ext\fts2\fts2.c	/^static void dlcAddDoclist(DLCollector *pCollector, DataBuffer *b){$/;"	f	file:
dlcAddPos	.\ext\fts2\fts2.c	/^static void dlcAddPos(DLCollector *pCollector, int iColumn, int iPos,$/;"	f	file:
dlcDelete	.\ext\fts2\fts2.c	/^static void dlcDelete(DLCollector *pCollector){$/;"	f	file:
dlcNew	.\ext\fts2\fts2.c	/^static DLCollector *dlcNew(sqlite_int64 iDocid, DocListType iType){$/;"	f	file:
dlcNext	.\ext\fts2\fts2.c	/^static void dlcNext(DLCollector *pCollector, sqlite_int64 iDocid){$/;"	f	file:
dlrAllDataBytes	.\ext\fts2\fts2.c	/^static int dlrAllDataBytes(DLReader *pReader){$/;"	f	file:
dlrAtEnd	.\ext\fts2\fts2.c	/^static int dlrAtEnd(DLReader *pReader){$/;"	f	file:
dlrDestroy	.\ext\fts2\fts2.c	/^static void dlrDestroy(DLReader *pReader){$/;"	f	file:
dlrDocData	.\ext\fts2\fts2.c	/^static const char *dlrDocData(DLReader *pReader){$/;"	f	file:
dlrDocDataBytes	.\ext\fts2\fts2.c	/^static int dlrDocDataBytes(DLReader *pReader){$/;"	f	file:
dlrDocid	.\ext\fts2\fts2.c	/^static sqlite_int64 dlrDocid(DLReader *pReader){$/;"	f	file:
dlrInit	.\ext\fts2\fts2.c	/^static void dlrInit(DLReader *pReader, DocListType iType,$/;"	f	file:
dlrPosData	.\ext\fts2\fts2.c	/^static const char *dlrPosData(DLReader *pReader){$/;"	f	file:
dlrPosDataLen	.\ext\fts2\fts2.c	/^static int dlrPosDataLen(DLReader *pReader){$/;"	f	file:
dlrStep	.\ext\fts2\fts2.c	/^static void dlrStep(DLReader *pReader){$/;"	f	file:
dlw	.\ext\fts2\fts2.c	/^  DLWriter *dlw;$/;"	m	struct:PLWriter	file:
dlw	.\ext\fts2\fts2.c	/^  DLWriter dlw;$/;"	m	struct:DLCollector	file:
dlwAdd	.\ext\fts2\fts2.c	/^static void dlwAdd(DLWriter *pWriter, sqlite_int64 iDocid){$/;"	f	file:
dlwAppend	.\ext\fts2\fts2.c	/^static void dlwAppend(DLWriter *pWriter,$/;"	f	file:
dlwCopy	.\ext\fts2\fts2.c	/^static void dlwCopy(DLWriter *pWriter, DLReader *pReader){$/;"	f	file:
dlwDestroy	.\ext\fts2\fts2.c	/^static void dlwDestroy(DLWriter *pWriter){$/;"	f	file:
dlwInit	.\ext\fts2\fts2.c	/^static void dlwInit(DLWriter *pWriter, DocListType iType, DataBuffer *b){$/;"	f	file:
doAsynchronousOpen	.\ext\async\sqlite3async.c	/^static int doAsynchronousOpen(int flags){$/;"	f	file:
doNotSpill	.\src\pager.c	/^  u8 doNotSpill;              \/* Do not spill the cache when non-zero *\/$/;"	m	struct:Pager	file:
doPassiveTest	.\test\malloc_common.tcl	/^proc doPassiveTest {isRestart name sql catchres} {$/;"	p
doWalCallbacks	.\src\vdbeapi.c	/^static int doWalCallbacks(sqlite3 *db){$/;"	f	file:
do_all_bc_test	.\test\bc_common.tcl	/^proc do_all_bc_test {script} {$/;"	p
do_bc_test	.\test\bc_common.tcl	/^proc do_bc_test {bin script} {$/;"	p
do_catchsql_test	.\test\tester.tcl	/^proc do_catchsql_test {testname sql result} {$/;"	p
do_compile	.\src\test4.c	/^static void do_compile(Thread *p){$/;"	f	file:
do_compile	.\src\test7.c	/^static void do_compile(Thread *p){$/;"	f	file:
do_copy_file	.\test\tester.tcl	/^proc do_copy_file {force from to} {$/;"	p
do_delete_file	.\test\tester.tcl	/^proc do_delete_file {force args} {$/;"	p
do_delete_win32_file	.\test\tester.tcl	/^  proc do_delete_win32_file {args} {$/;"	p
do_eqp_test	.\test\tester.tcl	/^proc do_eqp_test {name sql res} {$/;"	p
do_error_test	.\test\malloc_common.tcl	/^proc do_error_test {name sql error} {$/;"	p
do_execsql_test	.\test\tester.tcl	/^proc do_execsql_test {testname sql {result {}}} {$/;"	p
do_faultsim_test	.\test\malloc_common.tcl	/^proc do_faultsim_test {name args} {$/;"	p
do_filepath_test	.\test\tester.tcl	/^proc do_filepath_test {name cmd expected} {$/;"	p
do_finalize	.\src\test4.c	/^static void do_finalize(Thread *p){$/;"	f	file:
do_finalize	.\src\test7.c	/^static void do_finalize(Thread *p){$/;"	f	file:
do_fuzzy_test	.\test\fuzz_common.tcl	/^proc do_fuzzy_test {testname args} {$/;"	p
do_ioerr_test	.\test\tester.tcl	/^proc do_ioerr_test {testname args} {$/;"	p
do_malloc_test	.\test\malloc_common.tcl	/^proc do_malloc_test {tn args} {$/;"	p
do_meta_command	.\src\shell.c	/^static int do_meta_command(char *zLine, ShellState *p){$/;"	f	file:
do_multiclient_test	.\test\lock_common.tcl	/^proc do_multiclient_test {varname script} {$/;"	p
do_not_use_codec	.\test\tester.tcl	/^proc do_not_use_codec {} {$/;"	p
do_one_faultsim_test	.\test\malloc_common.tcl	/^proc do_one_faultsim_test {testname args} {$/;"	p
do_realnum_test	.\test\tester.tcl	/^proc do_realnum_test {name cmd expected} {$/;"	p
do_remove_win32_dir	.\test\tester.tcl	/^  proc do_remove_win32_dir {args} {$/;"	p
do_reset	.\src\test7.c	/^static void do_reset(Thread *p){$/;"	f	file:
do_restart_select_test	.\test\malloc_common.tcl	/^proc do_restart_select_test {name sql result} {$/;"	p
do_select_test	.\test\malloc_common.tcl	/^proc do_select_test {name sql result} {$/;"	p
do_select_tests	.\test\tester.tcl	/^proc do_select_tests {prefix args} {$/;"	p
do_some_sql	.\test\crashtest1.c	/^static void do_some_sql(int parent){$/;"	f	file:
do_step	.\src\test4.c	/^static void do_step(Thread *p){$/;"	f	file:
do_step	.\src\test7.c	/^static void do_step(Thread *p){$/;"	f	file:
do_test	.\test\tester.tcl	/^proc do_test {name cmd expected} {$/;"	p
do_test	.\test\thread_common.tcl	/^  proc do_test {name script result} {$/;"	p
do_test	.\tool\restore_jrnl.tcl	/^proc do_test {name cmd expected} {$/;"	p
do_timed_execsql_test	.\test\tester.tcl	/^proc do_timed_execsql_test {testname sql {result {}}} {$/;"	p
do_write_test	.\test\malloc_common.tcl	/^proc do_write_test {name tbl sql} {$/;"	p
docListAccumulate	.\ext\fts1\fts1.c	/^static void docListAccumulate(DocList *pAcc, DocList *pUpdate){$/;"	f	file:
docListAccumulateUnion	.\ext\fts2\fts2.c	/^static void docListAccumulateUnion(DataBuffer *acc,$/;"	f	file:
docListAddDocid	.\ext\fts1\fts1.c	/^static void docListAddDocid(DocList *d, sqlite_int64 iDocid){$/;"	f	file:
docListAddDocid	.\ext\fts1\fulltext.c	/^static void docListAddDocid(DocList *d, sqlite_int64 iDocid){$/;"	f	file:
docListAddEndPos	.\ext\fts1\fulltext.c	/^static void docListAddEndPos(DocList *d){$/;"	f	file:
docListAddPos	.\ext\fts1\fts1.c	/^static void docListAddPos(DocList *d, int iColumn, int iPos){$/;"	f	file:
docListAddPos	.\ext\fts1\fulltext.c	/^static void docListAddPos(DocList *d, int iPos){$/;"	f	file:
docListAddPosOffset	.\ext\fts1\fts1.c	/^static void docListAddPosOffset($/;"	f	file:
docListAddPosOffset	.\ext\fts1\fulltext.c	/^static void docListAddPosOffset(DocList *d, int iPos,$/;"	f	file:
docListAndMerge	.\ext\fts1\fts1.c	/^static void docListAndMerge($/;"	f	file:
docListAndMerge	.\ext\fts2\fts2.c	/^static void docListAndMerge($/;"	f	file:
docListDelete	.\ext\fts1\fts1.c	/^static void docListDelete(DocList *d){$/;"	f	file:
docListDelete	.\ext\fts1\fulltext.c	/^static void docListDelete(DocList *d){$/;"	f	file:
docListDestroy	.\ext\fts1\fts1.c	/^static void docListDestroy(DocList *d){$/;"	f	file:
docListDestroy	.\ext\fts1\fulltext.c	/^static void docListDestroy(DocList *d){$/;"	f	file:
docListDiscardEmpty	.\ext\fts1\fts1.c	/^static void docListDiscardEmpty(DocList *in) {$/;"	f	file:
docListEnd	.\ext\fts1\fts1.c	/^static char *docListEnd(DocList *d){$/;"	f	file:
docListEnd	.\ext\fts1\fulltext.c	/^static char *docListEnd(DocList *d){$/;"	f	file:
docListExceptMerge	.\ext\fts1\fts1.c	/^static void docListExceptMerge($/;"	f	file:
docListExceptMerge	.\ext\fts2\fts2.c	/^static void docListExceptMerge($/;"	f	file:
docListInit	.\ext\fts1\fts1.c	/^static void docListInit(DocList *d, DocListType iType,$/;"	f	file:
docListInit	.\ext\fts1\fulltext.c	/^static void docListInit(DocList *d, DocListType iType,$/;"	f	file:
docListMerge	.\ext\fts2\fts2.c	/^static void docListMerge(DataBuffer *out,$/;"	f	file:
docListNew	.\ext\fts1\fts1.c	/^static DocList *docListNew(DocListType iType){$/;"	f	file:
docListNew	.\ext\fts1\fulltext.c	/^static DocList *docListNew(DocListType iType){$/;"	f	file:
docListOfTerm	.\ext\fts1\fts1.c	/^static int docListOfTerm($/;"	f	file:
docListOfTerm	.\ext\fts2\fts2.c	/^static int docListOfTerm($/;"	f	file:
docListOrMerge	.\ext\fts1\fts1.c	/^static void docListOrMerge($/;"	f	file:
docListOrMerge	.\ext\fts2\fts2.c	/^static void docListOrMerge($/;"	f	file:
docListPhraseMerge	.\ext\fts1\fts1.c	/^static void docListPhraseMerge($/;"	f	file:
docListPhraseMerge	.\ext\fts2\fts2.c	/^static void docListPhraseMerge($/;"	f	file:
docListRestrictColumn	.\ext\fts1\fts1.c	/^static void docListRestrictColumn(DocList *in, int iRestrictColumn){$/;"	f	file:
docListSpliceElement	.\ext\fts1\fts1.c	/^static void docListSpliceElement(DocListReader *r, sqlite_int64 iDocid,$/;"	f	file:
docListSplit	.\ext\fts1\fulltext.c	/^static int docListSplit(DocList *d, DocList *d2){$/;"	f	file:
docListTrim	.\ext\fts2\fts2.c	/^static void docListTrim(DocListType iType, const char *pData, int nData,$/;"	f	file:
docListUnion	.\ext\fts2\fts2.c	/^static void docListUnion($/;"	f	file:
docListUpdate	.\ext\fts1\fts1.c	/^static void docListUpdate(DocList *d, DocList *pUpdate){$/;"	f	file:
docListUpdate	.\ext\fts1\fulltext.c	/^static int docListUpdate(DocList *d, sqlite_int64 iDocid, DocList *pUpdate){$/;"	f	file:
docListValidate	.\ext\fts2\fts2.c	/^static void docListValidate(DocListType iType, const char *pData, int nData,$/;"	f	file:
doclist	.\ext\fts3\fts3Int.h	/^  Fts3Doclist doclist;$/;"	m	struct:Fts3Phrase
doingRerun	.\src\vdbeInt.h	/^  bft doingRerun:1;       \/* True if rerunning after an auto-reprepare *\/$/;"	m	struct:Vdbe
done	.\src\sqliteInt.h	/^    unsigned done :1;       \/* A flag to indicate when processing is finished *\/$/;"	m	struct:ExprList::ExprList_item
done	.\src\threads.c	/^  int done;                      \/* Set to true when thread finishes *\/$/;"	m	struct:SQLiteThread	file:
dot	.\tool\lemon.c	/^  int dot;                 \/* The parse point *\/$/;"	m	struct:config	file:
dotlockCheckReservedLock	.\src\os_unix.c	/^static int dotlockCheckReservedLock(sqlite3_file *id, int *pResOut) {$/;"	f	file:
dotlockClose	.\src\os_unix.c	/^static int dotlockClose(sqlite3_file *id) {$/;"	f	file:
dotlockLock	.\src\os_unix.c	/^static int dotlockLock(sqlite3_file *id, int eFileLock) {$/;"	f	file:
dotlockUnlock	.\src\os_unix.c	/^static int dotlockUnlock(sqlite3_file *id, int eFileLock) {$/;"	f	file:
double	.\src\sqliteInt.h	446;"	d
doubleCmp	.\ext\misc\percentile.c	/^static int doubleCmp(const void *pA, const void *pB){$/;"	f	file:
doubleConsonant	.\ext\fts1\fts1_porter.c	/^static int doubleConsonant(const char *z){$/;"	f	file:
doubleConsonant	.\ext\fts2\fts2_porter.c	/^static int doubleConsonant(const char *z){$/;"	f	file:
doubleConsonant	.\ext\fts3\fts3_porter.c	/^static int doubleConsonant(const char *z){$/;"	f	file:
doubleToInt64	.\src\vdbemem.c	/^static i64 doubleToInt64(double r){$/;"	f	file:
downgradeAllSharedCacheTableLocks	.\src\btree.c	/^static void downgradeAllSharedCacheTableLocks(Btree *p){$/;"	f	file:
downgradeAllSharedCacheTableLocks	.\src\btree.c	110;"	d	file:
dropCell	.\src\btree.c	/^static void dropCell(MemPage *pPage, int idx, int sz, int *pRC){$/;"	f	file:
drop_all_tables	.\test\tester.tcl	/^proc drop_all_tables {{db db}} {$/;"	p
dstr	.\src\test1.c	/^struct dstr {$/;"	s	file:
dstrAppend	.\src\test1.c	/^static void dstrAppend(struct dstr *p, const char *z, int divider){$/;"	f	file:
dtnum	.\tool\lemon.c	/^  int dtnum;               \/* The data type number.  In the parser, the value$/;"	m	struct:symbol	file:
dumpDoclistFunc	.\ext\fts2\fts2.c	/^static void dumpDoclistFunc($/;"	f	file:
dumpTermsFunc	.\ext\fts2\fts2.c	/^static void dumpTermsFunc($/;"	f	file:
dump_callback	.\src\shell.c	/^static int dump_callback(void *pArg, int nArg, char **azArg, char **azCol){$/;"	f	file:
dump_jrnl_page	.\tool\restore_jrnl.tcl	/^proc dump_jrnl_page {jrnl_pgno} {$/;"	p
dump_table	.\tool\sqldiff.c	/^static void dump_table(const char *zTab, FILE *out){$/;"	f	file:
dumpbytes	.\test\tester.tcl	/^proc dumpbytes {s} {$/;"	p
dupedExprNodeSize	.\src\expr.c	/^static int dupedExprNodeSize(Expr *p, int flags){$/;"	f	file:
dupedExprSize	.\src\expr.c	/^static int dupedExprSize(Expr *p, int flags){$/;"	f	file:
dupedExprStructSize	.\src\expr.c	/^static int dupedExprStructSize(Expr *p, int flags){$/;"	f	file:
dynamic_triggers	.\test\threadtest3.c	/^static void dynamic_triggers(int nMs){$/;"	f	file:
dynamic_triggers_1	.\test\threadtest3.c	/^static char *dynamic_triggers_1(int iTid, void *pArg){$/;"	f	file:
dynamic_triggers_2	.\test\threadtest3.c	/^static char *dynamic_triggers_2(int iTid, void *pArg){$/;"	f	file:
eAsyncLock	.\ext\async\sqlite3async.c	/^  int eAsyncLock;           \/* Lock-state with write-queue unlock *\/$/;"	m	struct:AsyncFileLock	file:
eCode	.\src\sqliteInt.h	/^  u8 eCode;                                 \/* A small processing code *\/$/;"	m	struct:Walker
eContent	.\ext\fts5\fts5Int.h	/^  int eContent;                   \/* An FTS5_CONTENT value *\/$/;"	m	struct:Fts5Config
eCoordType	.\ext\rtree\rtree.c	/^  u8 eCoordType;              \/* RTREE_COORD_REAL32 or RTREE_COORD_INT32 *\/$/;"	m	struct:Rtree	file:
eCreate	.\src\pcache.c	/^  u8 eCreate;                         \/* eCreate value for for xFetch() *\/$/;"	m	struct:PCache	file:
eDest	.\src\sqliteInt.h	/^  u8 eDest;            \/* How to dispose of the results.  On of SRT_* above. *\/$/;"	m	struct:SelectDest
eDistinct	.\src\whereInt.h	/^  u8 eDistinct;             \/* One of the WHERE_DISTINCT_* values below *\/$/;"	m	struct:WhereInfo
eEndLoopOp	.\src\whereInt.h	/^        u8 eEndLoopOp;         \/* IN Loop terminator. OP_Next or OP_Prev *\/$/;"	m	struct:WhereLevel::__anon26::__anon27::InLoop
eEvalmode	.\ext\fts3\fts3Int.h	/^  int eEvalmode;                  \/* An FTS3_EVAL_XX constant *\/$/;"	m	struct:Fts3Cursor
eFWErr	.\src\vdbesort.c	/^  int eFWErr;                     \/* Non-zero if in an error state *\/$/;"	m	struct:PmaWriter	file:
eFault	.\src\test_vfs.c	/^  int eFault;                     \/* A FAULT_INJECT_* value *\/$/;"	m	struct:TestFaultInject	file:
eFileLock	.\src\os_unix.c	/^  unsigned char eFileLock;            \/* The type of lock held on this fd *\/$/;"	m	struct:unixFile	file:
eFileLock	.\src\os_unix.c	/^  unsigned char eFileLock;        \/* One of SHARED_LOCK, RESERVED_LOCK etc. *\/$/;"	m	struct:unixInodeInfo	file:
eHalt	.\ext\async\sqlite3async.c	/^  volatile int eHalt;          \/* One of the SQLITEASYNC_HALT_XXX values *\/$/;"	m	struct:TestAsyncStaticData	file:
eLock	.\ext\async\sqlite3async.c	/^  int eLock;                \/* Internally visible lock state (sqlite pov) *\/$/;"	m	struct:AsyncFileLock	file:
eLock	.\ext\async\sqlite3async.c	/^  int eLock;$/;"	m	struct:AsyncLock	file:
eLock	.\src\btreeInt.h	/^  u8 eLock;             \/* READ_LOCK or WRITE_LOCK *\/$/;"	m	struct:BtLock
eLock	.\src\pager.c	/^  u8 eLock;                   \/* Current lock held on database file *\/$/;"	m	struct:Pager	file:
eLock	.\src\test_journal.c	/^  int eLock;               \/* Current lock held on the file *\/$/;"	m	struct:jt_file	file:
eMode	.\test\tt3_checkpoint.c	/^  int eMode;$/;"	m	struct:CheckpointStarvationCtx	file:
eOnePass	.\src\whereInt.h	/^  u8 eOnePass;              \/* ONEPASS_OFF, or _SINGLE, or _MULTI *\/$/;"	m	struct:WhereInfo
eOperator	.\src\whereInt.h	/^  u16 eOperator;          \/* A WO_xx value describing <op> *\/$/;"	m	struct:WhereTerm
eOrconf	.\src\sqliteInt.h	/^  u8 eOrconf;          \/* Default ON CONFLICT policy for trigger steps *\/$/;"	m	struct:Parse
eParentWithin	.\ext\rtree\sqlite3rtree.h	/^  int eParentWithin;                \/* Visibility of parent node *\/$/;"	m	struct:sqlite3_rtree_query_info
ePlan	.\ext\fts5\fts5_main.c	/^  int ePlan;                      \/* FTS5_PLAN_XXX value *\/$/;"	m	struct:Fts5Cursor	file:
ePragTyp	.\src\pragma.h	/^  u8 ePragTyp;              \/* PragTyp_XXX value *\/$/;"	m	struct:sPragmaNames
eScoreType	.\src\test_rtree.c	/^  int eScoreType;$/;"	m	struct:Circle	file:
eSearch	.\ext\fts3\fts3Int.h	/^  i16 eSearch;                    \/* Search strategy (see below) *\/$/;"	m	struct:Fts3Cursor
eStage	.\ext\rbu\sqlite3rbu.c	/^  int eStage;                     \/* Value of RBU_STATE_STAGE field *\/$/;"	m	struct:sqlite3rbu	file:
eStage	.\ext\rbu\sqlite3rbu.c	/^  int eStage;$/;"	m	struct:RbuState	file:
eState	.\ext\fts5\fts5_index.c	/^  int eState;                     \/* See above *\/$/;"	m	struct:PoslistCallbackCtx	file:
eState	.\ext\fts5\fts5_main.c	/^  int eState;                     \/* 0==closed, 1==open, 2==synced *\/$/;"	m	struct:Fts5TransactionState	file:
eState	.\src\btreeInt.h	/^  u8 eState;                \/* One of the CURSOR_XXX constants (see below) *\/$/;"	m	struct:BtCursor
eState	.\src\pager.c	/^  u8 eState;                  \/* Pager state (OPEN, READER, WRITER_LOCKED..) *\/$/;"	m	struct:Pager	file:
eSubtype	.\src\vdbeInt.h	/^  u8  eSubtype;       \/* Subtype for this value *\/$/;"	m	struct:Mem
eTnctType	.\src\select.c	/^  u8 eTnctType;   \/* One of the WHERE_DISTINCT_* operators *\/$/;"	m	struct:DistinctCtx	file:
eTriggerOp	.\src\sqliteInt.h	/^  u8 eTriggerOp;       \/* TK_UPDATE, TK_INSERT or TK_DELETE *\/$/;"	m	struct:Parse
eType	.\ext\fts3\fts3Int.h	/^  int eType;                 \/* One of the FTSQUERY_XXX values defined below *\/$/;"	m	struct:Fts3Expr
eType	.\ext\fts5\fts5_expr.c	/^  int eType;                      \/* Node type *\/$/;"	m	struct:Fts5ExprNode	file:
eType	.\ext\fts5\fts5_vocab.c	/^  int eType;                      \/* FTS5_VOCAB_COL or ROW *\/$/;"	m	struct:Fts5VocabTable	file:
eType	.\ext\misc\json1.c	/^  u8 eType;                  \/* Type of top-level element *\/$/;"	m	struct:JsonEachCursor	file:
eType	.\ext\misc\json1.c	/^  u8 eType;              \/* One of the JSON_ type values *\/$/;"	m	struct:JsonNode	file:
eType	.\ext\rbu\sqlite3rbu.c	/^  int eType;                      \/* Table type - an RBU_PK_XXX value *\/$/;"	m	struct:RbuObjIter	file:
eType	.\src\mem2.c	/^  u8 eType;                           \/* Allocation type code *\/$/;"	m	struct:MemBlockHdr	file:
eType	.\src\test_mutex.c	/^  int eType;$/;"	m	struct:sqlite3_mutex	file:
eType	.\src\test_onefile.c	/^  int eType;$/;"	m	struct:fs_file	file:
eWithin	.\ext\rtree\rtree.c	/^  u8 eWithin;            \/* PARTLY_WITHIN or FULLY_WITHIN *\/$/;"	m	struct:RtreeSearchPoint	file:
eWithin	.\ext\rtree\sqlite3rtree.h	/^  int eWithin;                      \/* OUT: Visiblity *\/$/;"	m	struct:sqlite3_rtree_query_info
e_action	.\tool\lemon.c	/^enum e_action {$/;"	g	file:
e_assoc	.\tool\lemon.c	/^enum e_assoc {$/;"	g	file:
e_state	.\tool\lemon.c	/^enum e_state {$/;"	g	file:
ebcdicToAscii	.\src\tokenize.c	/^const unsigned char ebcdicToAscii[] = {$/;"	v
echoBegin	.\src\test8.c	/^static int echoBegin(sqlite3_vtab *tab){$/;"	f	file:
echoBestIndex	.\src\test8.c	/^static int echoBestIndex(sqlite3_vtab *tab, sqlite3_index_info *pIdxInfo){$/;"	f	file:
echoClose	.\src\test8.c	/^static int echoClose(sqlite3_vtab_cursor *cur){$/;"	f	file:
echoColumn	.\src\test8.c	/^static int echoColumn(sqlite3_vtab_cursor *cur, sqlite3_context *ctx, int i){$/;"	f	file:
echoCommit	.\src\test8.c	/^static int echoCommit(sqlite3_vtab *tab){$/;"	f	file:
echoConnect	.\src\test8.c	/^static int echoConnect($/;"	f	file:
echoConstructor	.\src\test8.c	/^static int echoConstructor($/;"	f	file:
echoCreate	.\src\test8.c	/^static int echoCreate($/;"	f	file:
echoDeclareVtab	.\src\test8.c	/^static int echoDeclareVtab($/;"	f	file:
echoDestroy	.\src\test8.c	/^static int echoDestroy(sqlite3_vtab *pVtab){$/;"	f	file:
echoDestructor	.\src\test8.c	/^static int echoDestructor(sqlite3_vtab *pVtab){$/;"	f	file:
echoDisconnect	.\src\test8.c	/^static int echoDisconnect(sqlite3_vtab *pVtab){$/;"	f	file:
echoEof	.\src\test8.c	/^static int echoEof(sqlite3_vtab_cursor *cur){$/;"	f	file:
echoFilter	.\src\test8.c	/^static int echoFilter($/;"	f	file:
echoFindFunction	.\src\test8.c	/^static int echoFindFunction($/;"	f	file:
echoModule	.\src\test8.c	/^static sqlite3_module echoModule = {$/;"	v	file:
echoModuleV2	.\src\test8.c	/^static sqlite3_module echoModuleV2 = {$/;"	v	file:
echoNext	.\src\test8.c	/^static int echoNext(sqlite3_vtab_cursor *cur){$/;"	f	file:
echoOn	.\src\shell.c	/^  int echoOn;            \/* True to echo input commands *\/$/;"	m	struct:ShellState	file:
echoOpen	.\src\test8.c	/^static int echoOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor){$/;"	f	file:
echoRelease	.\src\test8.c	/^static int echoRelease(sqlite3_vtab *pVTab, int iSavepoint){$/;"	f	file:
echoRename	.\src\test8.c	/^static int echoRename(sqlite3_vtab *vtab, const char *zNewName){$/;"	f	file:
echoRollback	.\src\test8.c	/^static int echoRollback(sqlite3_vtab *tab){$/;"	f	file:
echoRollbackTo	.\src\test8.c	/^static int echoRollbackTo(sqlite3_vtab *pVTab, int iSavepoint){$/;"	f	file:
echoRowid	.\src\test8.c	/^static int echoRowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid){$/;"	f	file:
echoSavepoint	.\src\test8.c	/^static int echoSavepoint(sqlite3_vtab *pVTab, int iSavepoint){$/;"	f	file:
echoSync	.\src\test8.c	/^static int echoSync(sqlite3_vtab *tab){$/;"	f	file:
echoTransactionCall	.\src\test8.c	/^static int echoTransactionCall(sqlite3_vtab *tab, const char *zCall){$/;"	f	file:
echoUpdate	.\src\test8.c	/^int echoUpdate($/;"	f
echo_cursor	.\src\test8.c	/^struct echo_cursor {$/;"	s	file:
echo_cursor	.\src\test8.c	/^typedef struct echo_cursor echo_cursor;$/;"	t	typeref:struct:echo_cursor	file:
echo_vtab	.\src\test8.c	/^struct echo_vtab {$/;"	s	file:
echo_vtab	.\src\test8.c	/^typedef struct echo_vtab echo_vtab;$/;"	t	typeref:struct:echo_vtab	file:
ecmd	.\src\parse.y	/^ecmd ::= SEMI.$/;"	l
ecmd	.\src\parse.y	/^ecmd ::= explain cmdx SEMI.$/;"	l
editDist3ConfigClear	.\ext\misc\spellfix.c	/^static void editDist3ConfigClear(EditDist3Config *p){$/;"	f	file:
editDist3ConfigDelete	.\ext\misc\spellfix.c	/^static void editDist3ConfigDelete(void *pIn){$/;"	f	file:
editDist3ConfigLoad	.\ext\misc\spellfix.c	/^static int editDist3ConfigLoad($/;"	f	file:
editDist3Core	.\ext\misc\spellfix.c	/^static int editDist3Core($/;"	f	file:
editDist3FindLang	.\ext\misc\spellfix.c	/^static const EditDist3Lang *editDist3FindLang($/;"	f	file:
editDist3FromStringDelete	.\ext\misc\spellfix.c	/^static void editDist3FromStringDelete(EditDist3FromString *p){$/;"	f	file:
editDist3FromStringNew	.\ext\misc\spellfix.c	/^static EditDist3FromString *editDist3FromStringNew($/;"	f	file:
editDist3Install	.\ext\misc\spellfix.c	/^static int editDist3Install(sqlite3 *db){$/;"	f	file:
editDist3Lang	.\ext\misc\spellfix.c	/^static const EditDist3Lang editDist3Lang = { 0, 100, 100, 150, 0 };$/;"	v	file:
editDist3SqlFunc	.\ext\misc\spellfix.c	/^static void editDist3SqlFunc($/;"	f	file:
editPage	.\src\btree.c	/^static int editPage($/;"	f	file:
editdist1	.\ext\misc\spellfix.c	/^static int editdist1(const char *zA, const char *zB, int *pnMatch){$/;"	f	file:
editdistSqlFunc	.\ext\misc\spellfix.c	/^static void editdistSqlFunc($/;"	f	file:
emit_code	.\tool\lemon.c	/^PRIVATE void emit_code($/;"	f
emit_destructor_code	.\tool\lemon.c	/^void emit_destructor_code($/;"	f
emsg	.\tool\lemon.c	/^static char emsg[] = "Command line syntax error: ";$/;"	v	file:
enable	.\src\test_malloc.c	/^  u8 enable;              \/* True if enabled *\/$/;"	m	struct:MemFault	file:
enableTimer	.\src\shell.c	/^static int enableTimer = 0;$/;"	v	file:
enable_shared_cache	.\src\sqlite3ext.h	/^  int  (*enable_shared_cache)(int);$/;"	m	struct:sqlite3_api_routines
enable_simulated_io_errors	.\src\pager.c	/^void enable_simulated_io_errors(void){$/;"	f
enable_simulated_io_errors	.\src\pager.c	3724;"	d	file:
enable_simulated_io_errors	.\src\pager.h	215;"	d
enc	.\src\sqliteInt.h	/^  u8 enc;                       \/* Text encoding *\/$/;"	m	struct:sqlite3
enc	.\src\sqliteInt.h	/^  u8 enc;               \/* Text encoding handled by xCmp() *\/$/;"	m	struct:CollSeq
enc	.\src\sqliteInt.h	/^  u8 enc;              \/* Text encoding used by this database *\/$/;"	m	struct:Schema
enc	.\src\sqliteInt.h	/^  u8 enc;             \/* Text encoding - one of the SQLITE_UTF* values *\/$/;"	m	struct:KeyInfo
enc	.\src\vdbeInt.h	/^  u8  enc;            \/* SQLITE_UTF8, SQLITE_UTF16BE, SQLITE_UTF16LE *\/$/;"	m	struct:Mem
endTimer	.\src\shell.c	/^static void endTimer(void){$/;"	f	file:
end_of_file	.\tool\build-all-msvc.bat	/^:end_of_file$/;"	l
endpoint	.\src\memjournal.c	/^  FilePoint endpoint;             \/* Pointer to the end of the file *\/$/;"	m	struct:MemJournal	file:
endsInWhiteSpace	.\ext\fts2\fts2.c	/^static int endsInWhiteSpace(StringBuffer *p){$/;"	f	file:
enlargeAndAppend	.\src\printf.c	/^static void SQLITE_NOINLINE enlargeAndAppend(StrAccum *p, const char *z, int N){$/;"	f	file:
enterJtMutex	.\src\test_journal.c	/^static void enterJtMutex(void){$/;"	f	file:
enterMutex	.\src\notify.c	/^static void enterMutex(void){$/;"	f	file:
eof	.\ext\fts1\fts1.c	/^  int eof;                         \/* True if at End Of Results *\/$/;"	m	struct:fulltext_cursor	file:
eof	.\ext\fts1\fulltext.c	/^  int eof;$/;"	m	struct:fulltext_cursor	file:
eof	.\ext\fts2\fts2.c	/^  int eof;                         \/* True if at End Of Results *\/$/;"	m	struct:fulltext_cursor	file:
eof	.\ext\fts2\fts2.c	/^  int eof;                  \/* we've seen SQLITE_DONE from pStmt. *\/$/;"	m	struct:LeavesReader	file:
err	.\src\test1.c	/^  int err;            \/* True if an error occurs *\/$/;"	m	struct:win32FileLocker	file:
errCode	.\src\pager.c	/^  int errCode;                \/* One of several kinds of errors *\/$/;"	m	struct:Pager	file:
errCode	.\src\sqliteInt.h	/^  int errCode;                  \/* Most recent error code (SQLITE_*) *\/$/;"	m	struct:sqlite3
errCode	.\src\sqliteInt.h	/^  u8 errCode;         \/* Error detected by xRecordCompare (CORRUPT or NOMEM) *\/$/;"	m	struct:UnpackedRecord
errCode	.\src\test_server.c	/^  int errCode;                 \/* Error code returned *\/$/;"	m	struct:SqlMessage	file:
errMask	.\src\sqliteInt.h	/^  int errMask;                  \/* & result codes with this before returning *\/$/;"	m	struct:sqlite3
errMsg	.\src\btreeInt.h	/^  StrAccum errMsg;  \/* Accumulate the error message text here *\/$/;"	m	struct:IntegrityCk
errcode	.\src\sqlite3ext.h	/^  int  (*errcode)(sqlite3*db);$/;"	m	struct:sqlite3_api_routines
errline	.\tool\lemon.c	/^static void errline(int n, int k, FILE *err)$/;"	f	file:
errlogFunc	.\src\func.c	/^static void errlogFunc($/;"	f	file:
errmsg	.\src\sqlite3ext.h	/^  const char * (*errmsg)(sqlite3*);$/;"	m	struct:sqlite3_api_routines
errmsg16	.\src\sqlite3ext.h	/^  const void * (*errmsg16)(sqlite3*);$/;"	m	struct:sqlite3_api_routines
error	.\tool\lemon.c	/^  char *error;             \/* Code to execute when an error is seen *\/$/;"	m	struct:lemon	file:
errorAction	.\src\vdbeInt.h	/^  u8 errorAction;         \/* Recovery action to do in case of an error *\/$/;"	m	struct:Vdbe
errorMessage	.\mptest\mptest.c	/^static void errorMessage(const char *zFormat, ...){$/;"	f	file:
error_out	.\tool\loadfts.c	/^static void error_out(const char *zText){$/;"	f	file:
errorcnt	.\tool\lemon.c	/^  int errorcnt;            \/* Number of errors *\/$/;"	m	struct:lemon	file:
errorcnt	.\tool\lemon.c	/^  int errorcnt;         \/* Number of errors so far *\/$/;"	m	struct:pstate	file:
errors	.\tool\build-all-msvc.bat	/^:errors$/;"	l
errstr	.\src\sqlite3ext.h	/^  const char *(*errstr)(int);$/;"	m	struct:sqlite3_api_routines
errstream	.\tool\lemon.c	/^static FILE *errstream;$/;"	v	file:
errsym	.\tool\lemon.c	/^  struct symbol *errsym;   \/* The error symbol *\/$/;"	m	struct:lemon	typeref:struct:lemon::symbol	file:
estLog	.\src\where.c	/^static LogEst estLog(LogEst N){$/;"	f	file:
est_square_root	.\test\speedtest1.c	/^static int est_square_root(int x){$/;"	f	file:
estimateIndexWidth	.\src\build.c	/^static void estimateIndexWidth(Index *pIdx){$/;"	f	file:
estimateTableWidth	.\src\build.c	/^static void estimateTableWidth(Table *pTab){$/;"	f	file:
etBUFSIZE	.\src\printf.c	167;"	d	file:
etByte	.\src\printf.c	/^typedef unsigned char etByte;$/;"	t	file:
etCHARX	.\src\printf.c	26;"	d	file:
etDYNSTRING	.\src\printf.c	24;"	d	file:
etEXP	.\src\printf.c	20;"	d	file:
etFLOAT	.\src\printf.c	19;"	d	file:
etGENERIC	.\src\printf.c	21;"	d	file:
etINVALID	.\src\printf.c	37;"	d	file:
etORDINAL	.\src\printf.c	35;"	d	file:
etPERCENT	.\src\printf.c	25;"	d	file:
etPOINTER	.\src\printf.c	33;"	d	file:
etRADIX	.\src\printf.c	18;"	d	file:
etSIZE	.\src\printf.c	22;"	d	file:
etSQLESCAPE	.\src\printf.c	28;"	d	file:
etSQLESCAPE2	.\src\printf.c	29;"	d	file:
etSQLESCAPE3	.\src\printf.c	34;"	d	file:
etSRCLIST	.\src\printf.c	32;"	d	file:
etSTRING	.\src\printf.c	23;"	d	file:
etTOKEN	.\src\printf.c	31;"	d	file:
et_getdigit	.\src\printf.c	/^static char et_getdigit(LONGDOUBLE_TYPE *val, int *cnt){$/;"	f	file:
et_info	.\src\printf.c	/^typedef struct et_info {   \/* Information about each format field *\/$/;"	s	file:
et_info	.\src\printf.c	/^} et_info;$/;"	t	typeref:struct:et_info	file:
evName	.\src\test1.c	/^  char *evName;       \/* Name of event to signal thread startup *\/$/;"	m	struct:win32FileLocker	file:
evalCallback	.\mptest\mptest.c	/^static int evalCallback(void *pCData, int argc, char **argv, char **azCol){$/;"	f	file:
evalFunc	.\mptest\mptest.c	/^static void evalFunc($/;"	f	file:
evalSql	.\mptest\mptest.c	/^static int evalSql(String *p, const char *zFormat, ...){$/;"	f	file:
exclMask	.\src\os_unix.c	/^  u16 exclMask;              \/* Mask of exclusive locks held *\/$/;"	m	struct:unixShm	file:
exclMask	.\src\os_unix.c	/^  u8 exclMask;               \/* Mask of exclusive locks held *\/$/;"	m	struct:unixShmNode	file:
exclMask	.\src\os_win.c	/^  u16 exclMask;              \/* Mask of exclusive locks held *\/$/;"	m	struct:winShm	file:
excllock	.\src\test_vfs.c	/^  u32 excllock;                   \/* Mask of exclusive locks *\/$/;"	m	struct:TestvfsFd	file:
exclusiveMode	.\src\pager.c	/^  u8 exclusiveMode;           \/* Boolean. True if locking_mode==EXCLUSIVE *\/$/;"	m	struct:Pager	file:
exclusiveMode	.\src\wal.c	/^  u8 exclusiveMode;          \/* Non-zero if connection is in exclusive mode *\/$/;"	m	struct:Wal	file:
exec	.\src\sqlite3ext.h	/^  int  (*exec)(sqlite3*,const char*,sqlite3_callback,void*,char**);$/;"	m	struct:sqlite3_api_routines
execCallback	.\tool\fuzzershell.c	/^static int execCallback(void *NotUsed, int argc, char **argv, char **colv){$/;"	f	file:
execCallback	.\tool\rollback-test.c	/^static int execCallback(void *NotUsed, int nArg, char **azArg, char **azCol){$/;"	f	file:
execExecSql	.\src\vacuum.c	/^static int execExecSql(sqlite3 *db, char **pzErrMsg, const char *zSql){$/;"	f	file:
execExecSql	.\tool\fast_vacuum.c	/^static void execExecSql(sqlite3 *db, const char *zSql){$/;"	f	file:
execFuncCallback	.\src\test1.c	/^static int execFuncCallback(void *pData, int argc, char **argv, char **NotUsed){$/;"	f	file:
execNoop	.\tool\fuzzershell.c	/^static int execNoop(void *NotUsed, int argc, char **argv, char **colv){$/;"	f	file:
execSql	.\src\vacuum.c	/^static int execSql(sqlite3 *db, char **pzErrMsg, const char *zSql){$/;"	f	file:
execSql	.\tool\fast_vacuum.c	/^static void execSql(sqlite3 *db, const char *zSql){$/;"	f	file:
exec_printf_cb	.\src\test1.c	/^static int exec_printf_cb(void *pArg, int argc, char **argv, char **name){$/;"	f	file:
execpresql	.\test\tester.tcl	/^proc execpresql {handle args} {$/;"	p
execsql	.\test\tester.tcl	/^proc execsql {sql {db db}} {$/;"	p
execsql	.\test\thread_common.tcl	/^  proc execsql {sql} {$/;"	p
execsql	.\test\threadtest3.c	49;"	d	file:
execsql2	.\test\tester.tcl	/^proc execsql2 {sql} {$/;"	p
execsql_i64	.\test\threadtest3.c	47;"	d	file:
execsql_i64_x	.\test\threadtest3.c	/^static i64 execsql_i64_x($/;"	f	file:
execsql_text	.\test\threadtest3.c	48;"	d	file:
execsql_text_x	.\test\threadtest3.c	/^static char * execsql_text_x($/;"	f	file:
execsql_timed	.\test\tester.tcl	/^proc execsql_timed {sql {db db}} {$/;"	p
expired	.\src\sqlite3ext.h	/^  int  (*expired)(sqlite3_stmt*);$/;"	m	struct:sqlite3_api_routines
expired	.\src\vdbeInt.h	/^  bft expired:1;          \/* True if the VM needs to be recompiled *\/$/;"	m	struct:Vdbe
explain	.\src\parse.y	/^explain ::= .           { sqlite3BeginParse(pParse, 0); }$/;"	l
explain	.\src\parse.y	/^explain ::= EXPLAIN QUERY PLAN.   { sqlite3BeginParse(pParse, 2); }$/;"	l
explain	.\src\parse.y	/^explain ::= EXPLAIN.              { sqlite3BeginParse(pParse, 1); }$/;"	l
explain	.\src\sqliteInt.h	/^  u8 explain;               \/* True if the EXPLAIN flag is found on the query *\/$/;"	m	struct:Parse
explain	.\src\vdbeInt.h	/^  bft explain:2;          \/* True if EXPLAIN present on SQL command *\/$/;"	m	struct:Vdbe
explain	.\test\tester.tcl	/^proc explain {sql {db db}} {$/;"	p
explainAppendTerm	.\src\wherecode.c	/^static void explainAppendTerm($/;"	f	file:
explainComposite	.\src\select.c	/^static void explainComposite($/;"	f	file:
explainComposite	.\src\select.c	1168;"	d	file:
explainIndexColumnName	.\src\wherecode.c	/^static const char *explainIndexColumnName(Index *pIdx, int i){$/;"	f	file:
explainIndexRange	.\src\wherecode.c	/^static void explainIndexRange(StrAccum *pStr, WhereLoop *pLoop){$/;"	f	file:
explainSetInteger	.\src\select.c	1126;"	d	file:
explainSetInteger	.\src\select.c	1131;"	d	file:
explainSimpleCount	.\src\select.c	/^static void explainSimpleCount($/;"	f	file:
explainSimpleCount	.\src\select.c	4745;"	d	file:
explainTempTable	.\src\select.c	/^static void explainTempTable(Parse *pParse, const char *zUsage){$/;"	f	file:
explainTempTable	.\src\select.c	1130;"	d	file:
explain_data_delete	.\src\shell.c	/^static void explain_data_delete(ShellState *p){$/;"	f	file:
explain_data_prepare	.\src\shell.c	/^static void explain_data_prepare(ShellState *p, sqlite3_stmt *pSql){$/;"	f	file:
explain_i	.\test\tester.tcl	/^proc explain_i {sql {db db}} {$/;"	p
explain_no_trace	.\test\tester.tcl	/^proc explain_no_trace {sql} {$/;"	p
expmask	.\src\vdbeInt.h	/^  u32 expmask;            \/* Binding to these vars invalidates VM *\/$/;"	m	struct:Vdbe
exprAlwaysFalse	.\src\expr.c	/^static int exprAlwaysFalse(Expr *p){$/;"	f	file:
exprAlwaysTrue	.\src\expr.c	/^static int exprAlwaysTrue(Expr *p){$/;"	f	file:
exprAnalyze	.\src\whereexpr.c	/^static void exprAnalyze($/;"	f	file:
exprAnalyzeOrTerm	.\src\whereexpr.c	/^static void exprAnalyzeOrTerm($/;"	f	file:
exprCodeBetween	.\src\expr.c	/^static void exprCodeBetween($/;"	f	file:
exprCommute	.\src\whereexpr.c	/^static void exprCommute(Parse *pParse, Expr *pExpr){$/;"	f	file:
exprDup	.\src\expr.c	/^static Expr *exprDup(sqlite3 *db, Expr *p, int flags, u8 **pzBuffer){$/;"	f	file:
exprIsConst	.\src\expr.c	/^static int exprIsConst(Expr *p, int initFlag, int iCur){$/;"	f	file:
exprMightBeIndexed	.\src\whereexpr.c	/^static int exprMightBeIndexed($/;"	f	file:
exprNodeIsConstant	.\src\expr.c	/^static int exprNodeIsConstant(Walker *pWalker, Expr *pExpr){$/;"	f	file:
exprProbability	.\src\resolve.c	/^static int exprProbability(Expr *p){$/;"	f	file:
exprSelectUsage	.\src\whereexpr.c	/^static Bitmask exprSelectUsage(WhereMaskSet *pMaskSet, Select *pS){$/;"	f	file:
exprSetHeight	.\src\expr.c	/^static void exprSetHeight(Expr *p){$/;"	f	file:
exprSetHeight	.\src\expr.c	424;"	d	file:
exprSrcCount	.\src\expr.c	/^static int exprSrcCount(Walker *pWalker, Expr *pExpr){$/;"	f	file:
exprStructSize	.\src\expr.c	/^static int exprStructSize(Expr *p){$/;"	f	file:
exprTableColumn	.\src\fkey.c	/^static Expr *exprTableColumn($/;"	f	file:
exprTableRegister	.\src\fkey.c	/^static Expr *exprTableRegister($/;"	f	file:
exprToRegister	.\src\expr.c	/^static void exprToRegister(Expr *p, int iReg){$/;"	f	file:
exprToString	.\ext\fts3\fts3_expr.c	/^static char *exprToString(Fts3Expr *pExpr, char *zBuf){$/;"	f	file:
exprWalkNoop	.\src\select.c	/^static int exprWalkNoop(Walker *NotUsed, Expr *NotUsed2){$/;"	f	file:
extendCksum	.\tool\showwal.c	/^static void extendCksum($/;"	f	file:
extended_errcode	.\src\sqlite3ext.h	/^  int (*extended_errcode)(sqlite3*);$/;"	m	struct:sqlite3_api_routines
extended_result_codes	.\src\sqlite3ext.h	/^  int (*extended_result_codes)(sqlite3*,int);$/;"	m	struct:sqlite3_api_routines
extracode	.\tool\lemon.c	/^  char *extracode;         \/* Code appended to the generated file *\/$/;"	m	struct:lemon	file:
extractToken	.\mptest\mptest.c	/^static int extractToken(const char *zIn, int nIn, char *zOut, int nOut){$/;"	f	file:
extract_vars	.\test\randexpr1.tcl	/^proc extract_vars {a} {$/;"	p
f	.\ext\rtree\rtree.c	/^  RtreeValue f;      \/* Floating point value *\/$/;"	m	union:RtreeCoord	file:
f	.\src\test_quota.c	/^  FILE *f;                \/* Open stdio file pointer *\/$/;"	m	struct:quota_FILE	file:
f	.\tool\offsets.c	/^  FILE *f;              \/* Open database file *\/$/;"	m	struct:GState	file:
f5tCreateFunction	.\ext\fts5\fts5_tcl.c	/^static int f5tCreateFunction($/;"	f	file:
f5tCreateTokenizer	.\ext\fts5\fts5_tcl.c	/^static int f5tCreateTokenizer($/;"	f	file:
f5tDbAndApi	.\ext\fts5\fts5_tcl.c	/^static int f5tDbAndApi($/;"	f	file:
f5tDbPointer	.\ext\fts5\fts5_tcl.c	/^static int f5tDbPointer(Tcl_Interp *interp, Tcl_Obj *pObj, sqlite3 **ppDb){$/;"	f	file:
f5tDelTokenizer	.\ext\fts5\fts5_tcl.c	/^static void f5tDelTokenizer(void *pCtx){$/;"	f	file:
f5tMayBeCorrupt	.\ext\fts5\fts5_tcl.c	/^static int f5tMayBeCorrupt($/;"	f	file:
f5tRegisterMatchinfo	.\ext\fts5\fts5_tcl.c	/^static int f5tRegisterMatchinfo($/;"	f	file:
f5tResultToErrorCode	.\ext\fts5\fts5_tcl.c	/^static int f5tResultToErrorCode(const char *zRes){$/;"	f	file:
f5tTokenHash	.\ext\fts5\fts5_tcl.c	/^static int f5tTokenHash($/;"	f	file:
f5tTokenize	.\ext\fts5\fts5_tcl.c	/^static int f5tTokenize($/;"	f	file:
f5tTokenizerCreate	.\ext\fts5\fts5_tcl.c	/^static int f5tTokenizerCreate($/;"	f	file:
f5tTokenizerDelete	.\ext\fts5\fts5_tcl.c	/^static void f5tTokenizerDelete(Fts5Tokenizer *p){$/;"	f	file:
f5tTokenizerReturn	.\ext\fts5\fts5_tcl.c	/^static int f5tTokenizerReturn($/;"	f	file:
f5tTokenizerTokenize	.\ext\fts5\fts5_tcl.c	/^static int f5tTokenizerTokenize($/;"	f	file:
f5t_fts5HashKey	.\ext\fts5\fts5_tcl.c	/^static unsigned int f5t_fts5HashKey(int nSlot, const char *p, int n){$/;"	f	file:
fDebug	.\tool\sqldiff.c	/^  unsigned fDebug;          \/* Debug flags *\/$/;"	m	struct:GlobalVars	file:
fErrorOrAux	.\src\vdbeInt.h	/^  u8 fErrorOrAux;         \/* isError!=0 or pVdbe->pAuxData modified *\/$/;"	m	struct:sqlite3_context
fail	.\tool\mkvsix.tcl	/^proc fail { {error ""} {usage false} } {$/;"	p
fail_test	.\test\tester.tcl	/^proc fail_test {name} {$/;"	p
failure	.\tool\lemon.c	/^  char *failure;           \/* Code to execute on parser failure *\/$/;"	m	struct:lemon	file:
fake_big_file	.\src\test2.c	/^static int fake_big_file($/;"	f	file:
fallback	.\tool\lemon.c	/^  struct symbol *fallback;   \/* The fallback token *\/$/;"	m	struct:pstate	typeref:struct:pstate::symbol	file:
fallback	.\tool\lemon.c	/^  struct symbol *fallback; \/* fallback token in case this token doesn't parse *\/$/;"	m	struct:symbol	typeref:struct:symbol::symbol	file:
fatalError	.\mptest\mptest.c	/^static void fatalError(const char *zFormat, ...){$/;"	f	file:
fatalError	.\test\fuzzcheck.c	/^static void fatalError(const char *zFormat, ...){$/;"	f	file:
fatalError	.\tool\fuzzershell.c	/^static void fatalError(const char *zFormat, ...){$/;"	f	file:
fatal_error	.\test\speedtest1.c	/^static void fatal_error(const char *zMsg, ...){$/;"	f	file:
fatal_error	.\test\wordcount.c	/^static void fatal_error(const char *zMsg, ...){$/;"	f	file:
faultInstallCmd	.\src\test2.c	/^static int faultInstallCmd($/;"	f	file:
faultSimCallback	.\src\test2.c	/^static int faultSimCallback(int x){$/;"	f	file:
faultSimInterp	.\src\test2.c	/^static Tcl_Interp *faultSimInterp = 0;$/;"	v	file:
faultSimScript	.\src\test2.c	/^static char *faultSimScript;$/;"	v	file:
faultSimScriptSize	.\src\test2.c	/^static int faultSimScriptSize = 0;$/;"	v	file:
faultsimBeginBenign	.\src\test_malloc.c	/^static void faultsimBeginBenign(void){$/;"	f	file:
faultsimBenignFailures	.\src\test_malloc.c	/^static int faultsimBenignFailures(void){$/;"	f	file:
faultsimConfig	.\src\test_malloc.c	/^static void faultsimConfig(int nDelay, int nRepeat){$/;"	f	file:
faultsimEndBenign	.\src\test_malloc.c	/^static void faultsimEndBenign(void){$/;"	f	file:
faultsimFailures	.\src\test_malloc.c	/^static int faultsimFailures(void){$/;"	f	file:
faultsimFree	.\src\test_malloc.c	/^static void faultsimFree(void *p){$/;"	f	file:
faultsimInit	.\src\test_malloc.c	/^static int faultsimInit(void *p){$/;"	f	file:
faultsimInstall	.\src\test_malloc.c	/^static int faultsimInstall(int install){$/;"	f	file:
faultsimMalloc	.\src\test_malloc.c	/^static void *faultsimMalloc(int n){$/;"	f	file:
faultsimPending	.\src\test_malloc.c	/^static int faultsimPending(void){$/;"	f	file:
faultsimRealloc	.\src\test_malloc.c	/^static void *faultsimRealloc(void *pOld, int n){$/;"	f	file:
faultsimRoundup	.\src\test_malloc.c	/^static int faultsimRoundup(int n){$/;"	f	file:
faultsimShutdown	.\src\test_malloc.c	/^static void faultsimShutdown(void *p){$/;"	f	file:
faultsimSize	.\src\test_malloc.c	/^static int faultsimSize(void *p){$/;"	f	file:
faultsimStep	.\src\test_malloc.c	/^static int faultsimStep(void){$/;"	f	file:
faultsim_delete_and_reopen	.\test\malloc_common.tcl	/^proc faultsim_delete_and_reopen {args} {$/;"	p
faultsim_integrity_check	.\test\malloc_common.tcl	/^proc faultsim_integrity_check {{db db}} {$/;"	p
faultsim_restore	.\test\malloc_common.tcl	/^proc faultsim_restore {args} { uplevel db_restore $args }$/;"	p
faultsim_restore_and_reopen	.\test\malloc_common.tcl	/^proc faultsim_restore_and_reopen {args} { $/;"	p
faultsim_save	.\test\malloc_common.tcl	/^proc faultsim_save {args} { uplevel db_save $args }$/;"	p
faultsim_save_and_close	.\test\malloc_common.tcl	/^proc faultsim_save_and_close {args} { uplevel db_save_and_close $args }$/;"	p
faultsim_test_proc	.\test\malloc_common.tcl	/^  proc faultsim_test_proc {testrc testresult testnfail} $O(-test)$/;"	p
faultsim_test_result	.\test\malloc_common.tcl	/^  proc faultsim_test_result {args} "$/;"	p
faultsim_test_result_int	.\test\malloc_common.tcl	/^proc faultsim_test_result_int {args} {$/;"	p
fcntlSizeHint	.\src\os_unix.c	/^static int fcntlSizeHint(unixFile *pFile, i64 nByte){$/;"	f	file:
fd	.\src\os_unix.c	/^  int fd;                           \/* file desc to assoc this lock with *\/$/;"	m	struct:ByteRangeLockPB2	file:
fd	.\src\os_unix.c	/^  int fd;                   \/* File descriptor to close *\/$/;"	m	struct:UnixUnusedFd	file:
fd	.\src\pager.c	/^  sqlite3_file *fd;           \/* File descriptor for database *\/$/;"	m	struct:Pager	file:
fd	.\src\test_demovfs.c	/^  int fd;                         \/* File descriptor *\/$/;"	m	struct:DemoFile	file:
fd	.\src\test_sqllog.c	/^  FILE *fd;                       \/* File descriptor for log file *\/$/;"	m	struct:SLConn	file:
fd	.\tool\showwal.c	/^static int fd = -1;             \/* File descriptor for reading the WAL file *\/$/;"	v	file:
fdatasync	.\src\os_unix.c	3403;"	d	file:
fetchPayload	.\src\btree.c	/^static const void *fetchPayload($/;"	f	file:
fg	.\src\sqliteInt.h	/^    } fg;$/;"	m	struct:SrcList::SrcList_item	typeref:struct:SrcList::SrcList_item::__anon19
file	.\src\vdbesort.c	/^  SorterFile file;                \/* Temp file for level-0 PMAs *\/$/;"	m	struct:SortSubtask	file:
file2	.\src\vdbesort.c	/^  SorterFile file2;               \/* Space for other PMAs *\/$/;"	m	struct:SortSubtask	file:
fileClose	.\tool\showdb.c	/^static void fileClose(){$/;"	f	file:
fileGetsize	.\tool\showdb.c	/^static sqlite3_int64 fileGetsize(void){$/;"	f	file:
fileHasMoved	.\src\os_unix.c	/^static int fileHasMoved(unixFile *pFile){$/;"	f	file:
fileId	.\src\os_unix.c	/^  struct unixFileId fileId;       \/* The lookup key *\/$/;"	m	struct:unixInodeInfo	typeref:struct:unixInodeInfo::unixFileId	file:
fileOpen	.\tool\showdb.c	/^static void fileOpen(const char *zPrg, const char *zName){$/;"	f	file:
fileRead	.\tool\showdb.c	/^static unsigned char *fileRead(sqlite3_int64 ofst, int nByte){$/;"	f	file:
fileSize	.\tool\showjournal.c	/^static int fileSize = 0;$/;"	v	file:
fileTail	.\src\test_vfstrace.c	/^static const char *fileTail(const char *z){$/;"	f	file:
file_control	.\src\sqlite3ext.h	/^  int (*file_control)(sqlite3*,const char*,int,void*);$/;"	m	struct:sqlite3_api_routines
file_control_chunksize_test	.\src\test1.c	/^static int file_control_chunksize_test($/;"	f	file:
file_control_lasterrno_test	.\src\test1.c	/^static int file_control_lasterrno_test($/;"	f	file:
file_control_lockproxy_test	.\src\test1.c	/^static int file_control_lockproxy_test($/;"	f	file:
file_control_persist_wal	.\src\test1.c	/^static int file_control_persist_wal($/;"	f	file:
file_control_powersafe_overwrite	.\src\test1.c	/^static int file_control_powersafe_overwrite($/;"	f	file:
file_control_sizehint_test	.\src\test1.c	/^static int file_control_sizehint_test($/;"	f	file:
file_control_tempfilename	.\src\test1.c	/^static int file_control_tempfilename($/;"	f	file:
file_control_test	.\src\test1.c	/^static int file_control_test($/;"	f	file:
file_control_vfsname	.\src\test1.c	/^static int file_control_vfsname($/;"	f	file:
file_control_win32_av_retry	.\src\test1.c	/^static int file_control_win32_av_retry($/;"	f	file:
file_control_win32_set_handle	.\src\test1.c	/^static int file_control_win32_set_handle($/;"	f	file:
file_format	.\src\sqliteInt.h	/^  u8 file_format;      \/* Schema format version for this file *\/$/;"	m	struct:Schema
file_makename	.\tool\lemon.c	/^PRIVATE char *file_makename(struct lemon *lemp, const char *suffix)$/;"	f
file_open	.\tool\lemon.c	/^PRIVATE FILE *file_open($/;"	f
filecopy	.\test\threadtest3.c	68;"	d	file:
filecopy_x	.\test\threadtest3.c	/^static void filecopy_x($/;"	f	file:
filename	.\tool\lemon.c	/^  char *filename;          \/* Name of the input file *\/$/;"	m	struct:lemon	file:
filename	.\tool\lemon.c	/^  char *filename;       \/* Name of the input file *\/$/;"	m	struct:pstate	file:
filenameTail	.\mptest\mptest.c	/^static char *filenameTail(char *z){$/;"	f	file:
filepath_normalize	.\test\tester.tcl	/^proc filepath_normalize {p} {$/;"	p
filesize	.\test\threadtest3.c	67;"	d	file:
filesize_x	.\test\threadtest3.c	/^static i64 filesize_x($/;"	f	file:
fillInCell	.\src\btree.c	/^static int fillInCell($/;"	f	file:
fillInUnixFile	.\src\os_unix.c	/^static int fillInUnixFile($/;"	f	file:
filter	.\ext\fts3\fts3_aux.c	/^  Fts3SegFilter filter;$/;"	m	struct:Fts3auxCursor	file:
filter	.\ext\fts3\fts3_term.c	/^  Fts3SegFilter filter;$/;"	m	struct:Fts3termCursor	file:
finalDbSize	.\src\btree.c	/^static Pgno finalDbSize(BtShared *pBt, Pgno nOrig, Pgno nFree){$/;"	f	file:
finalHash	.\test\wordcount.c	/^static void finalHash(unsigned int *a, char *z){$/;"	f	file:
finalize	.\src\sqlite3ext.h	/^  int  (*finalize)(sqlite3_stmt*pStmt);$/;"	m	struct:sqlite3_api_routines
finalize	.\src\test_schema.c	/^static int finalize(sqlite3_stmt **ppStmt){$/;"	f	file:
finalize	.\tool\mkopts.tcl	/^proc finalize {} {$/;"	p
finalizeAggFunctions	.\src\select.c	/^static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo){$/;"	f	file:
finalizeTime	.\tool\speedtest16.c	/^static sqlite_uint64 finalizeTime = 0;$/;"	v	file:
finalizeTime	.\tool\speedtest8.c	/^static sqlite_uint64 finalizeTime = 0;$/;"	v	file:
finalize_testing	.\test\tester.tcl	/^proc finalize_testing {} {$/;"	p
findBtree	.\src\backup.c	/^static Btree *findBtree(sqlite3 *pErrorDb, sqlite3 *pDb, const char *zDb){$/;"	f	file:
findById	.\tool\mkkeywordhash.c	/^static Keyword *findById(int id){$/;"	f	file:
findCell	.\src\btree.c	994;"	d	file:
findCellPastPtr	.\src\btree.c	996;"	d	file:
findCollSeqEntry	.\src\callback.c	/^static CollSeq *findCollSeqEntry($/;"	f	file:
findCreateFileMode	.\src\os_unix.c	/^static int findCreateFileMode($/;"	f	file:
findElementGivenHash	.\ext\fts1\ft_hash.c	/^static HashElem *findElementGivenHash($/;"	f	file:
findElementGivenHash	.\ext\fts1\fts1_hash.c	/^static fts1HashElem *findElementGivenHash($/;"	f	file:
findElementGivenHash	.\ext\fts2\fts2_hash.c	/^static fts2HashElem *findElementGivenHash($/;"	f	file:
findElementWithHash	.\src\hash.c	/^static HashElem *findElementWithHash($/;"	f	file:
findEnd	.\mptest\mptest.c	/^static int findEnd(const char *z, int *pnLine){$/;"	f	file:
findEndif	.\mptest\mptest.c	/^static int findEndif(const char *z, int stopAtElse, int *pnLine){$/;"	f	file:
findIndexCol	.\src\where.c	/^static int findIndexCol($/;"	f	file:
findIndexOrPrimaryKey	.\src\analyze.c	/^static Index *findIndexOrPrimaryKey($/;"	f	file:
findInodeInfo	.\src\os_unix.c	/^static int findInodeInfo($/;"	f	file:
findLeafNode	.\ext\rtree\rtree.c	/^static int findLeafNode($/;"	f	file:
findLock	.\ext\async\sqlite3async.c	/^static AsyncLock *findLock(const char *zName, int nName){$/;"	f	file:
findNextChars	.\ext\misc\nextchar.c	/^static void findNextChars(nextCharContext *p){$/;"	f	file:
findNextHostParameter	.\src\vdbetrace.c	/^static int findNextHostParameter(const char *zSql, int *pnToken){$/;"	f	file:
findOption	.\ext\fts3\tool\fts3view.c	/^const char *findOption(const char *zName, int hasArg, const char *zDefault){$/;"	f
findOption	.\mptest\mptest.c	/^static char *findOption($/;"	f	file:
findReusableFd	.\src\os_unix.c	/^static UnixUnusedFd *findReusableFd(const char *zPath, int flags){$/;"	f	file:
findRightmost	.\src\select.c	/^static Select *findRightmost(Select *p){$/;"	f	file:
findSqlFunc	.\src\tclsqlite.c	/^static SqlFunc *findSqlFunc(SqliteDb *pDb, const char *zName){$/;"	f	file:
findVFile	.\test\fuzzcheck.c	/^static VFile *findVFile(const char *zName){$/;"	f	file:
find_home_dir	.\src\shell.c	/^static char *find_home_dir(void){$/;"	f	file:
finder_type	.\src\os_unix.c	/^typedef const sqlite3_io_methods *(*finder_type)(const char*,unixFile*);$/;"	t	file:
finishScript	.\mptest\mptest.c	/^static int finishScript(int iClient, int taskId, int bShutdown){$/;"	f	file:
finish_test	.\test\tester.tcl	/^proc finish_test {} {$/;"	p
fired	.\src\test_thread.c	/^  int fired;                         \/* True after unlock event has occurred *\/$/;"	m	struct:UnlockNotification	file:
first	.\ext\fts1\ft_hash.h	/^  HashElem *first;        \/* The first element of the array *\/$/;"	m	struct:Hash
first	.\ext\fts1\fts1_hash.h	/^  fts1HashElem *first;    \/* The first element of the array *\/$/;"	m	struct:fts1Hash
first	.\ext\fts2\fts2.c	/^  InteriorBlock *first, *last;$/;"	m	struct:InteriorWriter	file:
first	.\ext\fts2\fts2_hash.h	/^  fts2HashElem *first;    \/* The first element of the array *\/$/;"	m	struct:fts2Hash
first	.\ext\fts3\fts3_hash.h	/^  Fts3HashElem *first;    \/* The first element of the array *\/$/;"	m	struct:Fts3Hash
first	.\src\hash.h	/^  HashElem *first;          \/* The first element of the array *\/$/;"	m	struct:Hash
firstDocid	.\ext\fts1\fts1.c	/^static sqlite_int64 firstDocid(DocList *d){$/;"	f	file:
firstDocid	.\ext\fts1\fulltext.c	/^static sqlite_int64 firstDocid(DocList *d){$/;"	f	file:
firstToken	.\ext\fts1\fts1.c	/^static char *firstToken(char *zIn, char **pzTail){$/;"	f	file:
firstToken	.\ext\fts2\fts2.c	/^static char *firstToken(char *zIn, char **pzTail){$/;"	f	file:
firstrule	.\tool\lemon.c	/^  struct rule *firstrule;    \/* Pointer to first rule in the grammar *\/$/;"	m	struct:pstate	typeref:struct:pstate::rule	file:
firstset	.\tool\lemon.c	/^  char *firstset;          \/* First-set for all rules of this symbol *\/$/;"	m	struct:symbol	file:
fixBoundingBox	.\ext\rtree\rtree.c	/^static int fixBoundingBox(Rtree *pRtree, RtreeNode *pNode){$/;"	f	file:
fixLeafParent	.\ext\rtree\rtree.c	/^static int fixLeafParent(Rtree *pRtree, RtreeNode *pLeaf){$/;"	f	file:
fix_ifcapable_expr	.\test\tester.tcl	/^proc fix_ifcapable_expr {expr} {$/;"	p
fix_testname	.\test\tester.tcl	/^proc fix_testname {varname} {$/;"	p
fkActionTrigger	.\src\fkey.c	/^static Trigger *fkActionTrigger($/;"	f	file:
fkChildIsModified	.\src\fkey.c	/^static int fkChildIsModified($/;"	f	file:
fkLookupParent	.\src\fkey.c	/^static void fkLookupParent($/;"	f	file:
fkParentIsModified	.\src\fkey.c	/^static int fkParentIsModified($/;"	f	file:
fkScanChildren	.\src\fkey.c	/^static void fkScanChildren($/;"	f	file:
fkTriggerDelete	.\src\fkey.c	/^static void fkTriggerDelete(sqlite3 *dbMem, Trigger *p){$/;"	f	file:
fkeyHash	.\src\sqliteInt.h	/^  Hash fkeyHash;       \/* All foreign keys by referenced table name *\/$/;"	m	struct:Schema
flag	.\ext\fts3\fts3_snippet.c	/^  char flag;$/;"	m	struct:MatchInfo	file:
flags	.\ext\fts3\fts3Int.h	/^  int flags;$/;"	m	struct:Fts3SegFilter
flags	.\ext\fts5\fts5_index.c	/^  int flags;                      \/* Mask of configuration flags *\/$/;"	m	struct:Fts5SegIter	file:
flags	.\src\dbstat.c	/^  u8 flags;                       \/* Copy of flags byte *\/$/;"	m	struct:StatPage	file:
flags	.\src\journal.c	/^  int flags;                      \/* xOpen flags *\/$/;"	m	struct:JournalFile	file:
flags	.\src\os_unix.c	/^  int flags;                \/* Flags this file descriptor was opened with *\/$/;"	m	struct:UnixUnusedFd	file:
flags	.\src\pcache.h	/^  u16 flags;                     \/* PGHDR flags defined below *\/$/;"	m	struct:PgHdr
flags	.\src\printf.c	/^  etByte flags;            \/* One or more of FLAG_ constants below *\/$/;"	m	struct:et_info	file:
flags	.\src\sqliteInt.h	/^  int flags;                    \/* Miscellaneous flags. See below *\/$/;"	m	struct:sqlite3
flags	.\src\sqliteInt.h	/^  u32 flags;             \/* Various flags.  EP_* See below *\/$/;"	m	struct:Expr
flags	.\src\test6.c	/^  int flags;                           \/* Flags the file was opened with *\/$/;"	m	struct:CrashFile	file:
flags	.\src\test_journal.c	/^  int flags;               \/* Flags the file was opened with *\/$/;"	m	struct:jt_file	file:
flags	.\src\test_multiplex.c	/^  int flags;                       \/* Flags used for original opening *\/$/;"	m	struct:multiplexGroup	file:
flags	.\src\vdbeInt.h	/^  u16 flags;          \/* Some combination of MEM_Null, MEM_Str, MEM_Dyn, etc. *\/$/;"	m	struct:Mem
flags	.\src\vdbeblob.c	/^  int flags;              \/* Copy of "flags" passed to sqlite3_blob_open() *\/$/;"	m	struct:Incrblob	file:
flattenSubquery	.\src\select.c	/^static int flattenSubquery($/;"	f	file:
float	.\src\sqliteInt.h	447;"	d
floatSwap	.\src\vdbeaux.c	/^static u64 floatSwap(u64 in){$/;"	f	file:
flockCheckReservedLock	.\src\os_unix.c	/^static int flockCheckReservedLock(sqlite3_file *id, int *pResOut){$/;"	f	file:
flockClose	.\src\os_unix.c	/^static int flockClose(sqlite3_file *id) {$/;"	f	file:
flockLock	.\src\os_unix.c	/^static int flockLock(sqlite3_file *id, int eFileLock) {$/;"	f	file:
flockUnlock	.\src\os_unix.c	/^static int flockUnlock(sqlite3_file *id, int eFileLock) {$/;"	f	file:
flushPendingTerms	.\ext\fts2\fts2.c	/^static int flushPendingTerms(fulltext_vtab *v){$/;"	f	file:
flushStmtCache	.\src\tclsqlite.c	/^static void flushStmtCache(SqliteDb *pDb){$/;"	f	file:
fmtinfo	.\src\printf.c	/^static const et_info fmtinfo[] = {$/;"	v	file:
fmttype	.\src\printf.c	/^  char fmttype;            \/* The format field code letter *\/$/;"	m	struct:et_info	file:
fn_AppendVariable	.\tool\build-all-msvc.bat	/^:fn_AppendVariable$/;"	l
fn_CopyVariable	.\tool\build-all-msvc.bat	/^:fn_CopyVariable$/;"	l
fn_ResetErrorLevel	.\tool\build-all-msvc.bat	/^:fn_ResetErrorLevel$/;"	l
fn_SetErrorLevel	.\tool\build-all-msvc.bat	/^:fn_SetErrorLevel$/;"	l
fn_ShowVariable	.\tool\build-all-msvc.bat	/^:fn_ShowVariable$/;"	l
fn_UnsetVariable	.\tool\build-all-msvc.bat	/^:fn_UnsetVariable$/;"	l
forcecopy	.\test\tester.tcl	/^proc forcecopy {from to} {$/;"	p
forcedelete	.\test\tester.tcl	/^proc forcedelete {args} {$/;"	p
foreach_clause	.\src\parse.y	/^foreach_clause ::= .$/;"	l
foreach_clause	.\src\parse.y	/^foreach_clause ::= FOR EACH ROW.$/;"	l
formatVfs	.\test\fuzzcheck.c	/^static void formatVfs(void){$/;"	f	file:
fplp	.\tool\lemon.c	/^  struct plink *fplp;      \/* Follow-set forward propagation links *\/$/;"	m	struct:config	typeref:struct:config::plink	file:
free	.\src\sqlite3ext.h	/^  void  (*free)(void*);$/;"	m	struct:sqlite3_api_routines
freeCursorConstraints	.\ext\rtree\rtree.c	/^static void freeCursorConstraints(RtreeCursor *pCsr){$/;"	f	file:
freeEphemeralFunction	.\src\vdbeaux.c	/^static void freeEphemeralFunction(sqlite3 *db, FuncDef *pDef){$/;"	f	file:
freeIndex	.\src\build.c	/^static void freeIndex(sqlite3 *db, Index *p){$/;"	f	file:
freeP4	.\src\vdbeaux.c	/^static void freeP4(sqlite3 *db, int p4type, void *p4){$/;"	f	file:
freePage	.\src\btree.c	/^static void freePage(MemPage *pPage, int *pRC){$/;"	f	file:
freePage2	.\src\btree.c	/^static int freePage2(BtShared *pBt, MemPage *pMemPage, Pgno iPage){$/;"	f	file:
freeSpace	.\src\btree.c	/^static int freeSpace(MemPage *pPage, u16 iStart, u16 iSize){$/;"	f	file:
freeStringArray	.\ext\fts1\fts1.c	/^static void freeStringArray(int nString, const char **pString){$/;"	f	file:
freeStringArray	.\ext\fts2\fts2.c	/^static void freeStringArray(int nString, const char **pString){$/;"	f	file:
freeTempSpace	.\src\btree.c	/^static void freeTempSpace(BtShared *pBt){$/;"	f	file:
free_err	.\test\threadtest3.c	/^static void free_err(Error *p){$/;"	f	file:
free_table	.\src\sqlite3ext.h	/^  void  (*free_table)(char**result);$/;"	m	struct:sqlite3_api_routines
free_test_auxdata	.\src\test_func.c	/^static void free_test_auxdata(void *p) {sqlite3_free(p);}$/;"	f	file:
freelist	.\tool\lemon.c	/^static struct config *freelist = 0;      \/* List of free configurations *\/$/;"	v	typeref:struct:config	file:
from	.\tool\lemon.c	/^  struct s_x1node **from;  \/* Previous link *\/$/;"	m	struct:s_x1node	typeref:struct:s_x1node::s_x1node	file:
from	.\tool\lemon.c	/^  struct s_x2node **from;  \/* Previous link *\/$/;"	m	struct:s_x2node	typeref:struct:s_x2node::s_x2node	file:
from	.\tool\lemon.c	/^  struct s_x3node **from;  \/* Previous link *\/$/;"	m	struct:s_x3node	typeref:struct:s_x3node::s_x3node	file:
from	.\tool\lemon.c	/^  struct s_x4node **from;  \/* Previous link *\/$/;"	m	struct:s_x4node	typeref:struct:s_x4node::s_x4node	file:
fsAccess	.\src\test_onefile.c	/^static int fsAccess($/;"	f	file:
fsBestIndex	.\src\test_fs.c	/^static int fsBestIndex(sqlite3_vtab *tab, sqlite3_index_info *pIdxInfo){$/;"	f	file:
fsCheckReservedLock	.\src\test_onefile.c	/^static int fsCheckReservedLock(sqlite3_file *pFile, int *pResOut){$/;"	f	file:
fsClose	.\src\test_fs.c	/^static int fsClose(sqlite3_vtab_cursor *cur){$/;"	f	file:
fsClose	.\src\test_onefile.c	/^static int fsClose(sqlite3_file *pFile){$/;"	f	file:
fsColumn	.\src\test_fs.c	/^static int fsColumn(sqlite3_vtab_cursor *cur, sqlite3_context *ctx, int i){$/;"	f	file:
fsConnect	.\src\test_fs.c	/^static int fsConnect($/;"	f	file:
fsCurrentTime	.\src\test_onefile.c	/^static int fsCurrentTime(sqlite3_vfs *pVfs, double *pTimeOut){$/;"	f	file:
fsDelete	.\src\test_onefile.c	/^static int fsDelete(sqlite3_vfs *pVfs, const char *zPath, int dirSync){$/;"	f	file:
fsDeviceCharacteristics	.\src\test_onefile.c	/^static int fsDeviceCharacteristics(sqlite3_file *pFile){$/;"	f	file:
fsDisconnect	.\src\test_fs.c	/^static int fsDisconnect(sqlite3_vtab *pVtab){$/;"	f	file:
fsDlClose	.\src\test_onefile.c	/^static void fsDlClose(sqlite3_vfs *pVfs, void *pHandle){$/;"	f	file:
fsDlError	.\src\test_onefile.c	/^static void fsDlError(sqlite3_vfs *pVfs, int nByte, char *zErrMsg){$/;"	f	file:
fsDlOpen	.\src\test_onefile.c	/^static void *fsDlOpen(sqlite3_vfs *pVfs, const char *zPath){$/;"	f	file:
fsDlSym	.\src\test_onefile.c	/^static void (*fsDlSym(sqlite3_vfs *pVfs, void *pH, const char *zSym))(void){$/;"	f	file:
fsEof	.\src\test_fs.c	/^static int fsEof(sqlite3_vtab_cursor *cur){$/;"	f	file:
fsFileControl	.\src\test_onefile.c	/^static int fsFileControl(sqlite3_file *pFile, int op, void *pArg){$/;"	f	file:
fsFileSize	.\src\test_onefile.c	/^static int fsFileSize(sqlite3_file *pFile, sqlite_int64 *pSize){$/;"	f	file:
fsFilter	.\src\test_fs.c	/^static int fsFilter($/;"	f	file:
fsFlags	.\src\os_unix.c	/^  unsigned fsFlags;                   \/* cached details from statfs() *\/$/;"	m	struct:unixFile	file:
fsFullPathname	.\src\test_onefile.c	/^static int fsFullPathname($/;"	f	file:
fsLock	.\src\test_onefile.c	/^static int fsLock(sqlite3_file *pFile, int eLock){$/;"	f	file:
fsModule	.\src\test_fs.c	/^static sqlite3_module fsModule = {$/;"	v	file:
fsNext	.\src\test_fs.c	/^static int fsNext(sqlite3_vtab_cursor *cur){$/;"	f	file:
fsOpen	.\src\test_fs.c	/^static int fsOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor){$/;"	f	file:
fsOpen	.\src\test_onefile.c	/^static int fsOpen($/;"	f	file:
fsRandomness	.\src\test_onefile.c	/^static int fsRandomness(sqlite3_vfs *pVfs, int nByte, char *zBufOut){$/;"	f	file:
fsRead	.\src\test_onefile.c	/^static int fsRead($/;"	f	file:
fsRowid	.\src\test_fs.c	/^static int fsRowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid){$/;"	f	file:
fsSectorSize	.\src\test_onefile.c	/^static int fsSectorSize(sqlite3_file *pFile){$/;"	f	file:
fsSleep	.\src\test_onefile.c	/^static int fsSleep(sqlite3_vfs *pVfs, int nMicro){$/;"	f	file:
fsSync	.\src\test_onefile.c	/^static int fsSync(sqlite3_file *pFile, int flags){$/;"	f	file:
fsTruncate	.\src\test_onefile.c	/^static int fsTruncate(sqlite3_file *pFile, sqlite_int64 size){$/;"	f	file:
fsUnlock	.\src\test_onefile.c	/^static int fsUnlock(sqlite3_file *pFile, int eLock){$/;"	f	file:
fsWrite	.\src\test_onefile.c	/^static int fsWrite($/;"	f	file:
fs_cursor	.\src\test_fs.c	/^struct fs_cursor {$/;"	s	file:
fs_cursor	.\src\test_fs.c	/^typedef struct fs_cursor fs_cursor;$/;"	t	typeref:struct:fs_cursor	file:
fs_file	.\src\test_onefile.c	/^struct fs_file {$/;"	s	file:
fs_file	.\src\test_onefile.c	/^typedef struct fs_file fs_file;$/;"	t	typeref:struct:fs_file	file:
fs_io_methods	.\src\test_onefile.c	/^static sqlite3_io_methods fs_io_methods = {$/;"	v	file:
fs_real_file	.\src\test_onefile.c	/^struct fs_real_file {$/;"	s	file:
fs_real_file	.\src\test_onefile.c	/^typedef struct fs_real_file fs_real_file;$/;"	t	typeref:struct:fs_real_file	file:
fs_register	.\src\test_onefile.c	/^int fs_register(void){$/;"	f
fs_vfs	.\src\test_onefile.c	/^static fs_vfs_t fs_vfs = {$/;"	v	file:
fs_vfs_t	.\src\test_onefile.c	/^struct fs_vfs_t {$/;"	s	file:
fs_vfs_t	.\src\test_onefile.c	/^typedef struct fs_vfs_t fs_vfs_t;$/;"	t	typeref:struct:fs_vfs_t	file:
fs_vtab	.\src\test_fs.c	/^struct fs_vtab {$/;"	s	file:
fs_vtab	.\src\test_fs.c	/^typedef struct fs_vtab fs_vtab;$/;"	t	typeref:struct:fs_vtab	file:
ftKernelBegin	.\src\shell.c	/^static FILETIME ftKernelBegin;$/;"	v	file:
ftUserBegin	.\src\shell.c	/^static FILETIME ftUserBegin;$/;"	v	file:
ftWallBegin	.\src\shell.c	/^static sqlite3_int64 ftWallBegin;$/;"	v	file:
fts1Hash	.\ext\fts1\fts1_hash.h	/^struct fts1Hash {$/;"	s
fts1Hash	.\ext\fts1\fts1_hash.h	/^typedef struct fts1Hash fts1Hash;$/;"	t	typeref:struct:fts1Hash
fts1HashClear	.\ext\fts1\fts1_hash.h	87;"	d
fts1HashCount	.\ext\fts1\fts1_hash.h	110;"	d
fts1HashData	.\ext\fts1\fts1_hash.h	103;"	d
fts1HashElem	.\ext\fts1\fts1_hash.h	/^struct fts1HashElem {$/;"	s
fts1HashElem	.\ext\fts1\fts1_hash.h	/^typedef struct fts1HashElem fts1HashElem;$/;"	t	typeref:struct:fts1HashElem
fts1HashFind	.\ext\fts1\fts1_hash.h	86;"	d
fts1HashFirst	.\ext\fts1\fts1_hash.h	101;"	d
fts1HashInit	.\ext\fts1\fts1_hash.h	84;"	d
fts1HashInsert	.\ext\fts1\fts1_hash.h	85;"	d
fts1HashKey	.\ext\fts1\fts1_hash.h	104;"	d
fts1HashKeysize	.\ext\fts1\fts1_hash.h	105;"	d
fts1HashNext	.\ext\fts1\fts1_hash.h	102;"	d
fts2Hash	.\ext\fts2\fts2_hash.h	/^struct fts2Hash {$/;"	s
fts2Hash	.\ext\fts2\fts2_hash.h	/^typedef struct fts2Hash fts2Hash;$/;"	t	typeref:struct:fts2Hash
fts2HashClear	.\ext\fts2\fts2_hash.h	85;"	d
fts2HashCount	.\ext\fts2\fts2_hash.h	108;"	d
fts2HashData	.\ext\fts2\fts2_hash.h	101;"	d
fts2HashElem	.\ext\fts2\fts2_hash.h	/^struct fts2HashElem {$/;"	s
fts2HashElem	.\ext\fts2\fts2_hash.h	/^typedef struct fts2HashElem fts2HashElem;$/;"	t	typeref:struct:fts2HashElem
fts2HashFind	.\ext\fts2\fts2_hash.h	84;"	d
fts2HashFirst	.\ext\fts2\fts2_hash.h	99;"	d
fts2HashFree	.\ext\fts2\fts2_hash.c	/^static void fts2HashFree(void *p){$/;"	f	file:
fts2HashInit	.\ext\fts2\fts2_hash.h	82;"	d
fts2HashInsert	.\ext\fts2\fts2_hash.h	83;"	d
fts2HashKey	.\ext\fts2\fts2_hash.h	102;"	d
fts2HashKeysize	.\ext\fts2\fts2_hash.h	103;"	d
fts2HashMalloc	.\ext\fts2\fts2_hash.c	/^static void *fts2HashMalloc(int n){$/;"	f	file:
fts2HashNext	.\ext\fts2\fts2_hash.h	100;"	d
fts2Module	.\ext\fts2\fts2.c	/^static const sqlite3_module fts2Module = {$/;"	v	file:
fts2Module	.\ext\fts2\fts2.c	/^static const sqlite3_module fts2Module;   \/* forward declaration *\/$/;"	v	file:
fts3AllocateSegdirIdx	.\ext\fts3\fts3_write.c	/^static int fts3AllocateSegdirIdx($/;"	f	file:
fts3AppendToNode	.\ext\fts3\fts3_write.c	/^static int fts3AppendToNode($/;"	f	file:
fts3Appendf	.\ext\fts3\fts3.c	/^static void fts3Appendf($/;"	f	file:
fts3BeginMethod	.\ext\fts3\fts3.c	/^static int fts3BeginMethod(sqlite3_vtab *pVtab){$/;"	f	file:
fts3BestIndexMethod	.\ext\fts3\fts3.c	/^static int fts3BestIndexMethod(sqlite3_vtab *pVTab, sqlite3_index_info *pInfo){$/;"	f	file:
fts3BestSnippet	.\ext\fts3\fts3_snippet.c	/^static int fts3BestSnippet($/;"	f	file:
fts3BinCompare	.\ext\fts3\fts3_hash.c	/^static int fts3BinCompare(const void *pKey1, int n1, const void *pKey2, int n2){$/;"	f	file:
fts3BinHash	.\ext\fts3\fts3_hash.c	/^static int fts3BinHash(const void *pKey, int nKey){$/;"	f	file:
fts3ChecksumEntry	.\ext\fts3\fts3_write.c	/^static u64 fts3ChecksumEntry($/;"	f	file:
fts3ChecksumIndex	.\ext\fts3\fts3_write.c	/^static u64 fts3ChecksumIndex($/;"	f	file:
fts3CloseMethod	.\ext\fts3\fts3.c	/^static int fts3CloseMethod(sqlite3_vtab_cursor *pCursor){$/;"	f	file:
fts3ColumnFilter	.\ext\fts3\fts3_write.c	/^static void fts3ColumnFilter($/;"	f	file:
fts3ColumnMethod	.\ext\fts3\fts3.c	/^static int fts3ColumnMethod($/;"	f	file:
fts3ColumnlistCopy	.\ext\fts3\fts3.c	/^static void fts3ColumnlistCopy(char **pp, char **ppPoslist){$/;"	f	file:
fts3ColumnlistCount	.\ext\fts3\fts3_snippet.c	/^static int fts3ColumnlistCount(char **ppCollist){$/;"	f	file:
fts3CommitMethod	.\ext\fts3\fts3.c	/^static int fts3CommitMethod(sqlite3_vtab *pVtab){$/;"	f	file:
fts3CompareElemByTerm	.\ext\fts3\fts3_write.c	/^static int SQLITE_CDECL fts3CompareElemByTerm($/;"	f	file:
fts3ConnectMethod	.\ext\fts3\fts3.c	/^static int fts3ConnectMethod($/;"	f	file:
fts3ContentColumns	.\ext\fts3\fts3.c	/^static int fts3ContentColumns($/;"	f	file:
fts3CreateMethod	.\ext\fts3\fts3.c	/^static int fts3CreateMethod($/;"	f	file:
fts3CreateTables	.\ext\fts3\fts3.c	/^static int fts3CreateTables(Fts3Table *p){$/;"	f	file:
fts3CursorSeek	.\ext\fts3\fts3.c	/^static int fts3CursorSeek(sqlite3_context *pContext, Fts3Cursor *pCsr){$/;"	f	file:
fts3CursorSeekStmt	.\ext\fts3\fts3.c	/^static int fts3CursorSeekStmt(Fts3Cursor *pCsr, sqlite3_stmt **ppStmt){$/;"	f	file:
fts3DatabasePageSize	.\ext\fts3\fts3.c	/^static void fts3DatabasePageSize(int *pRc, Fts3Table *p){$/;"	f	file:
fts3DbExec	.\ext\fts3\fts3.c	/^static void fts3DbExec($/;"	f	file:
fts3DeclareVtab	.\ext\fts3\fts3.c	/^static void fts3DeclareVtab(int *pRc, Fts3Table *p){$/;"	f	file:
fts3DecodeIntArray	.\ext\fts3\fts3_write.c	/^static void fts3DecodeIntArray($/;"	f	file:
fts3DeleteAll	.\ext\fts3\fts3_write.c	/^static int fts3DeleteAll(Fts3Table *p, int bContent){$/;"	f	file:
fts3DeleteByRowid	.\ext\fts3\fts3_write.c	/^static int fts3DeleteByRowid($/;"	f	file:
fts3DeleteSegdir	.\ext\fts3\fts3_write.c	/^static int fts3DeleteSegdir($/;"	f	file:
fts3DeleteSegment	.\ext\fts3\fts3_write.c	/^static int fts3DeleteSegment($/;"	f	file:
fts3DeleteTerms	.\ext\fts3\fts3_write.c	/^static void fts3DeleteTerms( $/;"	f	file:
fts3DestroyMethod	.\ext\fts3\fts3.c	/^static int fts3DestroyMethod(sqlite3_vtab *pVtab){$/;"	f	file:
fts3DisconnectMethod	.\ext\fts3\fts3.c	/^static int fts3DisconnectMethod(sqlite3_vtab *pVtab){$/;"	f	file:
fts3DoAutoincrmerge	.\ext\fts3\fts3_write.c	/^static int fts3DoAutoincrmerge($/;"	f	file:
fts3DoIncrmerge	.\ext\fts3\fts3_write.c	/^static int fts3DoIncrmerge($/;"	f	file:
fts3DoIntegrityCheck	.\ext\fts3\fts3_write.c	/^static int fts3DoIntegrityCheck($/;"	f	file:
fts3DoOptimize	.\ext\fts3\fts3_write.c	/^static int fts3DoOptimize(Fts3Table *p, int bReturnDone){$/;"	f	file:
fts3DoRebuild	.\ext\fts3\fts3_write.c	/^static int fts3DoRebuild(Fts3Table *p){$/;"	f	file:
fts3DocidRange	.\ext\fts3\fts3.c	/^static sqlite3_int64 fts3DocidRange(sqlite3_value *pVal, i64 iDefault){$/;"	f	file:
fts3DoclistCountDocids	.\ext\fts3\fts3.c	/^static int fts3DoclistCountDocids(char *aList, int nList){$/;"	f	file:
fts3DoclistOrMerge	.\ext\fts3\fts3.c	/^static int fts3DoclistOrMerge($/;"	f	file:
fts3DoclistPhraseMerge	.\ext\fts3\fts3.c	/^static int fts3DoclistPhraseMerge($/;"	f	file:
fts3EncodeIntArray	.\ext\fts3\fts3_write.c	/^static void fts3EncodeIntArray($/;"	f	file:
fts3EofMethod	.\ext\fts3\fts3.c	/^static int fts3EofMethod(sqlite3_vtab_cursor *pCursor){$/;"	f	file:
fts3EvalAllocateReaders	.\ext\fts3\fts3.c	/^static void fts3EvalAllocateReaders($/;"	f	file:
fts3EvalAverageDocsize	.\ext\fts3\fts3.c	/^static int fts3EvalAverageDocsize(Fts3Cursor *pCsr, int *pnPage){$/;"	f	file:
fts3EvalDeferredPhrase	.\ext\fts3\fts3.c	/^static int fts3EvalDeferredPhrase(Fts3Cursor *pCsr, Fts3Phrase *pPhrase){$/;"	f	file:
fts3EvalDlPhraseNext	.\ext\fts3\fts3.c	/^static void fts3EvalDlPhraseNext($/;"	f	file:
fts3EvalGatherStats	.\ext\fts3\fts3.c	/^static int fts3EvalGatherStats($/;"	f	file:
fts3EvalIncrPhraseNext	.\ext\fts3\fts3.c	/^static int fts3EvalIncrPhraseNext($/;"	f	file:
fts3EvalInvalidatePoslist	.\ext\fts3\fts3.c	/^static void fts3EvalInvalidatePoslist(Fts3Phrase *pPhrase){$/;"	f	file:
fts3EvalNearTest	.\ext\fts3\fts3.c	/^static int fts3EvalNearTest(Fts3Expr *pExpr, int *pRc){$/;"	f	file:
fts3EvalNearTrim	.\ext\fts3\fts3.c	/^static int fts3EvalNearTrim($/;"	f	file:
fts3EvalNext	.\ext\fts3\fts3.c	/^static int fts3EvalNext(Fts3Cursor *pCsr){$/;"	f	file:
fts3EvalNextRow	.\ext\fts3\fts3.c	/^static void fts3EvalNextRow($/;"	f	file:
fts3EvalPhraseLoad	.\ext\fts3\fts3.c	/^static int fts3EvalPhraseLoad($/;"	f	file:
fts3EvalPhraseMergeToken	.\ext\fts3\fts3.c	/^static int fts3EvalPhraseMergeToken($/;"	f	file:
fts3EvalPhraseNext	.\ext\fts3\fts3.c	/^static int fts3EvalPhraseNext($/;"	f	file:
fts3EvalPhraseStart	.\ext\fts3\fts3.c	/^static int fts3EvalPhraseStart(Fts3Cursor *pCsr, int bOptOk, Fts3Phrase *p){$/;"	f	file:
fts3EvalRestart	.\ext\fts3\fts3.c	/^static void fts3EvalRestart($/;"	f	file:
fts3EvalSelectDeferred	.\ext\fts3\fts3.c	/^static int fts3EvalSelectDeferred($/;"	f	file:
fts3EvalStart	.\ext\fts3\fts3.c	/^static int fts3EvalStart(Fts3Cursor *pCsr){$/;"	f	file:
fts3EvalStartReaders	.\ext\fts3\fts3.c	/^static void fts3EvalStartReaders($/;"	f	file:
fts3EvalTestExpr	.\ext\fts3\fts3.c	/^static int fts3EvalTestExpr($/;"	f	file:
fts3EvalTokenCosts	.\ext\fts3\fts3.c	/^static void fts3EvalTokenCosts($/;"	f	file:
fts3EvalUpdateCounts	.\ext\fts3\fts3.c	/^static void fts3EvalUpdateCounts(Fts3Expr *pExpr){$/;"	f	file:
fts3ExprBalance	.\ext\fts3\fts3_expr.c	/^static int fts3ExprBalance(Fts3Expr **pp, int nMaxDepth){$/;"	f	file:
fts3ExprCheckDepth	.\ext\fts3\fts3_expr.c	/^static int fts3ExprCheckDepth(Fts3Expr *p, int nMaxDepth){$/;"	f	file:
fts3ExprGlobalHitsCb	.\ext\fts3\fts3_snippet.c	/^static int fts3ExprGlobalHitsCb($/;"	f	file:
fts3ExprIterate	.\ext\fts3\fts3_snippet.c	/^static int fts3ExprIterate($/;"	f	file:
fts3ExprIterate2	.\ext\fts3\fts3_snippet.c	/^static int fts3ExprIterate2($/;"	f	file:
fts3ExprLHitGather	.\ext\fts3\fts3_snippet.c	/^static void fts3ExprLHitGather($/;"	f	file:
fts3ExprLHits	.\ext\fts3\fts3_snippet.c	/^static void fts3ExprLHits($/;"	f	file:
fts3ExprLoadDoclists	.\ext\fts3\fts3_snippet.c	/^static int fts3ExprLoadDoclists($/;"	f	file:
fts3ExprLoadDoclistsCb	.\ext\fts3\fts3_snippet.c	/^static int fts3ExprLoadDoclistsCb(Fts3Expr *pExpr, int iPhrase, void *ctx){$/;"	f	file:
fts3ExprLocalHitsCb	.\ext\fts3\fts3_snippet.c	/^static int fts3ExprLocalHitsCb($/;"	f	file:
fts3ExprParse	.\ext\fts3\fts3_expr.c	/^static int fts3ExprParse($/;"	f	file:
fts3ExprParseUnbalanced	.\ext\fts3\fts3_expr.c	/^static int fts3ExprParseUnbalanced($/;"	f	file:
fts3ExprPhraseCount	.\ext\fts3\fts3_snippet.c	/^static int fts3ExprPhraseCount(Fts3Expr *pExpr){$/;"	f	file:
fts3ExprPhraseCountCb	.\ext\fts3\fts3_snippet.c	/^static int fts3ExprPhraseCountCb(Fts3Expr *pExpr, int iPhrase, void *ctx){$/;"	f	file:
fts3ExprTermOffsetInit	.\ext\fts3\fts3_snippet.c	/^static int fts3ExprTermOffsetInit(Fts3Expr *pExpr, int iPhrase, void *ctx){$/;"	f	file:
fts3ExprTest	.\ext\fts3\fts3_expr.c	/^static void fts3ExprTest($/;"	f	file:
fts3FilterMethod	.\ext\fts3\fts3.c	/^static int fts3FilterMethod($/;"	f	file:
fts3FindElementByHash	.\ext\fts3\fts3_hash.c	/^static Fts3HashElem *fts3FindElementByHash($/;"	f	file:
fts3FindFunctionMethod	.\ext\fts3\fts3.c	/^static int fts3FindFunctionMethod($/;"	f	file:
fts3FreeExprNode	.\ext\fts3\fts3_expr.c	/^static void fts3FreeExprNode(Fts3Expr *p){$/;"	f	file:
fts3FunctionArg	.\ext\fts3\fts3.c	/^static int fts3FunctionArg($/;"	f	file:
fts3GetDeltaPosition	.\ext\fts3\fts3_snippet.c	/^static void fts3GetDeltaPosition(char **pp, int *piPos){$/;"	f	file:
fts3GetDeltaVarint	.\ext\fts3\fts3.c	/^static void fts3GetDeltaVarint(char **pp, sqlite3_int64 *pVal){$/;"	f	file:
fts3GetDeltaVarint3	.\ext\fts3\fts3.c	/^static void fts3GetDeltaVarint3($/;"	f	file:
fts3GetMatchinfo	.\ext\fts3\fts3_snippet.c	/^static void fts3GetMatchinfo($/;"	f	file:
fts3GetReverseVarint	.\ext\fts3\fts3.c	/^static void fts3GetReverseVarint($/;"	f	file:
fts3GetVarint32	.\ext\fts3\fts3Int.h	540;"	d
fts3Getint	.\ext\fts3\fts3_write.c	/^static int fts3Getint(const char **pz){$/;"	f	file:
fts3GobbleInt	.\ext\fts3\fts3.c	/^static int fts3GobbleInt(const char **pp, int *pnOut){$/;"	f	file:
fts3HashClear	.\ext\fts3\fts3_hash.h	86;"	d
fts3HashCount	.\ext\fts3\fts3_hash.h	110;"	d
fts3HashData	.\ext\fts3\fts3_hash.h	103;"	d
fts3HashFind	.\ext\fts3\fts3_hash.h	85;"	d
fts3HashFindElem	.\ext\fts3\fts3_hash.h	87;"	d
fts3HashFirst	.\ext\fts3\fts3_hash.h	101;"	d
fts3HashFree	.\ext\fts3\fts3_hash.c	/^static void fts3HashFree(void *p){$/;"	f	file:
fts3HashInit	.\ext\fts3\fts3_hash.h	83;"	d
fts3HashInsert	.\ext\fts3\fts3_hash.h	84;"	d
fts3HashInsertElement	.\ext\fts3\fts3_hash.c	/^static void fts3HashInsertElement($/;"	f	file:
fts3HashKey	.\ext\fts3\fts3_hash.h	104;"	d
fts3HashKeysize	.\ext\fts3\fts3_hash.h	105;"	d
fts3HashMalloc	.\ext\fts3\fts3_hash.c	/^static void *fts3HashMalloc(int n){$/;"	f	file:
fts3HashNext	.\ext\fts3\fts3_hash.h	102;"	d
fts3IncrmergeAppend	.\ext\fts3\fts3_write.c	/^static int fts3IncrmergeAppend($/;"	f	file:
fts3IncrmergeChomp	.\ext\fts3\fts3_write.c	/^static int fts3IncrmergeChomp($/;"	f	file:
fts3IncrmergeCsr	.\ext\fts3\fts3_write.c	/^static int fts3IncrmergeCsr($/;"	f	file:
fts3IncrmergeHintLoad	.\ext\fts3\fts3_write.c	/^static int fts3IncrmergeHintLoad(Fts3Table *p, Blob *pHint){$/;"	f	file:
fts3IncrmergeHintPop	.\ext\fts3\fts3_write.c	/^static int fts3IncrmergeHintPop(Blob *pHint, i64 *piAbsLevel, int *pnInput){$/;"	f	file:
fts3IncrmergeHintPush	.\ext\fts3\fts3_write.c	/^static void fts3IncrmergeHintPush($/;"	f	file:
fts3IncrmergeHintStore	.\ext\fts3\fts3_write.c	/^static int fts3IncrmergeHintStore(Fts3Table *p, Blob *pHint){$/;"	f	file:
fts3IncrmergeLoad	.\ext\fts3\fts3_write.c	/^static int fts3IncrmergeLoad($/;"	f	file:
fts3IncrmergeOutputIdx	.\ext\fts3\fts3_write.c	/^static int fts3IncrmergeOutputIdx( $/;"	f	file:
fts3IncrmergePush	.\ext\fts3\fts3_write.c	/^static int fts3IncrmergePush($/;"	f	file:
fts3IncrmergeRelease	.\ext\fts3\fts3_write.c	/^static void fts3IncrmergeRelease($/;"	f	file:
fts3IncrmergeWriter	.\ext\fts3\fts3_write.c	/^static int fts3IncrmergeWriter( $/;"	f	file:
fts3InitVtab	.\ext\fts3\fts3.c	/^static int fts3InitVtab($/;"	f	file:
fts3InsertData	.\ext\fts3\fts3_write.c	/^static int fts3InsertData($/;"	f	file:
fts3InsertDocsize	.\ext\fts3\fts3_write.c	/^static void fts3InsertDocsize($/;"	f	file:
fts3InsertTerms	.\ext\fts3\fts3_write.c	/^static int fts3InsertTerms($/;"	f	file:
fts3IntegrityCheck	.\ext\fts3\fts3_write.c	/^static int fts3IntegrityCheck(Fts3Table *p, int *pbOk){$/;"	f	file:
fts3IsAppendable	.\ext\fts3\fts3_write.c	/^static int fts3IsAppendable(Fts3Table *p, sqlite3_int64 iEnd, int *pbRes){$/;"	f	file:
fts3IsEmpty	.\ext\fts3\fts3_write.c	/^static int fts3IsEmpty(Fts3Table *p, sqlite3_value *pRowid, int *pisEmpty){$/;"	f	file:
fts3IsSpecialColumn	.\ext\fts3\fts3.c	/^static int fts3IsSpecialColumn($/;"	f	file:
fts3LcsIteratorAdvance	.\ext\fts3\fts3_snippet.c	/^static int fts3LcsIteratorAdvance(LcsIterator *pIter){$/;"	f	file:
fts3LogMerge	.\ext\fts3\fts3_write.c	/^static void fts3LogMerge(int nMerge, sqlite3_int64 iAbsLevel){$/;"	f	file:
fts3LogMerge	.\ext\fts3\fts3_write.c	88;"	d	file:
fts3MIBufferAlloc	.\ext\fts3\fts3_snippet.c	/^static void (*fts3MIBufferAlloc(MatchinfoBuffer *p, u32 **paOut))(void*){$/;"	f	file:
fts3MIBufferFree	.\ext\fts3\fts3_snippet.c	/^static void fts3MIBufferFree(void *p){$/;"	f	file:
fts3MIBufferNew	.\ext\fts3\fts3_snippet.c	/^static MatchinfoBuffer *fts3MIBufferNew(int nElem, const char *zMatchinfo){$/;"	f	file:
fts3MIBufferSetGlobal	.\ext\fts3\fts3_snippet.c	/^static void fts3MIBufferSetGlobal(MatchinfoBuffer *p){$/;"	f	file:
fts3MallocZero	.\ext\fts3\fts3_expr.c	/^static void *fts3MallocZero(int nByte){$/;"	f	file:
fts3MatchinfoCheck	.\ext\fts3\fts3_snippet.c	/^static int fts3MatchinfoCheck($/;"	f	file:
fts3MatchinfoFunc	.\ext\fts3\fts3.c	/^static void fts3MatchinfoFunc($/;"	f	file:
fts3MatchinfoLcs	.\ext\fts3\fts3_snippet.c	/^static int fts3MatchinfoLcs(Fts3Cursor *pCsr, MatchInfo *pInfo){$/;"	f	file:
fts3MatchinfoLcsCb	.\ext\fts3\fts3_snippet.c	/^static int fts3MatchinfoLcsCb($/;"	f	file:
fts3MatchinfoSelectDoctotal	.\ext\fts3\fts3_snippet.c	/^static int fts3MatchinfoSelectDoctotal($/;"	f	file:
fts3MatchinfoSize	.\ext\fts3\fts3_snippet.c	/^static int fts3MatchinfoSize(MatchInfo *pInfo, char cArg){$/;"	f	file:
fts3MatchinfoValues	.\ext\fts3\fts3_snippet.c	/^static int fts3MatchinfoValues($/;"	f	file:
fts3Module	.\ext\fts3\fts3.c	/^static const sqlite3_module fts3Module = {$/;"	v	file:
fts3MsrBufferData	.\ext\fts3\fts3_write.c	/^static int fts3MsrBufferData($/;"	f	file:
fts3NextMethod	.\ext\fts3\fts3.c	/^static int fts3NextMethod(sqlite3_vtab_cursor *pCursor){$/;"	f	file:
fts3NodeAddTerm	.\ext\fts3\fts3_write.c	/^static int fts3NodeAddTerm($/;"	f	file:
fts3NodeFree	.\ext\fts3\fts3_write.c	/^static void fts3NodeFree(SegmentNode *pTree){$/;"	f	file:
fts3NodeWrite	.\ext\fts3\fts3_write.c	/^static int fts3NodeWrite($/;"	f	file:
fts3OffsetsFunc	.\ext\fts3\fts3.c	/^static void fts3OffsetsFunc($/;"	f	file:
fts3OpenMethod	.\ext\fts3\fts3.c	/^static int fts3OpenMethod(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCsr){$/;"	f	file:
fts3OptimizeFunc	.\ext\fts3\fts3.c	/^static void fts3OptimizeFunc($/;"	f	file:
fts3PendingListAppend	.\ext\fts3\fts3_write.c	/^static int fts3PendingListAppend($/;"	f	file:
fts3PendingListAppendVarint	.\ext\fts3\fts3_write.c	/^static int fts3PendingListAppendVarint($/;"	f	file:
fts3PendingListDelete	.\ext\fts3\fts3_write.c	/^static void fts3PendingListDelete(PendingList *pList){$/;"	f	file:
fts3PendingTermsAdd	.\ext\fts3\fts3_write.c	/^static int fts3PendingTermsAdd($/;"	f	file:
fts3PendingTermsAddOne	.\ext\fts3\fts3_write.c	/^static int fts3PendingTermsAddOne($/;"	f	file:
fts3PendingTermsDocid	.\ext\fts3\fts3_write.c	/^static int fts3PendingTermsDocid($/;"	f	file:
fts3PoslistCopy	.\ext\fts3\fts3.c	/^static void fts3PoslistCopy(char **pp, char **ppPoslist){$/;"	f	file:
fts3PoslistMerge	.\ext\fts3\fts3.c	/^static void fts3PoslistMerge($/;"	f	file:
fts3PoslistNearMerge	.\ext\fts3\fts3.c	/^static int fts3PoslistNearMerge($/;"	f	file:
fts3PoslistPhraseMerge	.\ext\fts3\fts3.c	/^static int fts3PoslistPhraseMerge($/;"	f	file:
fts3PrefixCompress	.\ext\fts3\fts3_write.c	/^static int fts3PrefixCompress($/;"	f	file:
fts3PrefixParameter	.\ext\fts3\fts3.c	/^static int fts3PrefixParameter($/;"	f	file:
fts3PromoteSegments	.\ext\fts3\fts3_write.c	/^static int fts3PromoteSegments($/;"	f	file:
fts3PutColNumber	.\ext\fts3\fts3.c	/^static int fts3PutColNumber(char **pp, int iCol){$/;"	f	file:
fts3PutDeltaVarint	.\ext\fts3\fts3.c	/^static void fts3PutDeltaVarint($/;"	f	file:
fts3PutDeltaVarint3	.\ext\fts3\fts3.c	/^static void fts3PutDeltaVarint3($/;"	f	file:
fts3QuoteId	.\ext\fts3\fts3.c	/^static char *fts3QuoteId(char const *zInput){$/;"	f	file:
fts3ReadEndBlockField	.\ext\fts3\fts3_write.c	/^static void fts3ReadEndBlockField($/;"	f	file:
fts3ReadExprList	.\ext\fts3\fts3.c	/^static char *fts3ReadExprList(Fts3Table *p, const char *zFunc, int *pRc){$/;"	f	file:
fts3ReadNextPos	.\ext\fts3\fts3.c	/^static void fts3ReadNextPos($/;"	f	file:
fts3ReallocOrFree	.\ext\fts3\fts3_expr.c	/^static void *fts3ReallocOrFree(void *pOrig, int nNew){$/;"	f	file:
fts3Rehash	.\ext\fts3\fts3_hash.c	/^static int fts3Rehash(Fts3Hash *pH, int new_size){$/;"	f	file:
fts3ReleaseMethod	.\ext\fts3\fts3.c	/^static int fts3ReleaseMethod(sqlite3_vtab *pVtab, int iSavepoint){$/;"	f	file:
fts3RemoveElementByHash	.\ext\fts3\fts3_hash.c	/^static void fts3RemoveElementByHash($/;"	f	file:
fts3RemoveSegdirEntry	.\ext\fts3\fts3_write.c	/^static int fts3RemoveSegdirEntry($/;"	f	file:
fts3RenameMethod	.\ext\fts3\fts3.c	/^static int fts3RenameMethod($/;"	f	file:
fts3RepackSegdirLevel	.\ext\fts3\fts3_write.c	/^static int fts3RepackSegdirLevel($/;"	f	file:
fts3ReversePoslist	.\ext\fts3\fts3.c	/^static void fts3ReversePoslist(char *pStart, char **ppPoslist){$/;"	f	file:
fts3RollbackMethod	.\ext\fts3\fts3.c	/^static int fts3RollbackMethod(sqlite3_vtab *pVtab){$/;"	f	file:
fts3RollbackToMethod	.\ext\fts3\fts3.c	/^static int fts3RollbackToMethod(sqlite3_vtab *pVtab, int iSavepoint){$/;"	f	file:
fts3RowidMethod	.\ext\fts3\fts3.c	/^static int fts3RowidMethod(sqlite3_vtab_cursor *pCursor, sqlite_int64 *pRowid){$/;"	f	file:
fts3SavepointMethod	.\ext\fts3\fts3.c	/^static int fts3SavepointMethod(sqlite3_vtab *pVtab, int iSavepoint){$/;"	f	file:
fts3ScanInteriorNode	.\ext\fts3\fts3.c	/^static int fts3ScanInteriorNode($/;"	f	file:
fts3SegReaderCmp	.\ext\fts3\fts3_write.c	/^static int fts3SegReaderCmp(Fts3SegReader *pLhs, Fts3SegReader *pRhs){$/;"	f	file:
fts3SegReaderCursor	.\ext\fts3\fts3.c	/^static int fts3SegReaderCursor($/;"	f	file:
fts3SegReaderCursorAddZero	.\ext\fts3\fts3.c	/^static int fts3SegReaderCursorAddZero($/;"	f	file:
fts3SegReaderCursorAppend	.\ext\fts3\fts3.c	/^static int fts3SegReaderCursorAppend($/;"	f	file:
fts3SegReaderCursorFree	.\ext\fts3\fts3.c	/^static void fts3SegReaderCursorFree(Fts3MultiSegReader *pSegcsr){$/;"	f	file:
fts3SegReaderDoclistCmp	.\ext\fts3\fts3_write.c	/^static int fts3SegReaderDoclistCmp(Fts3SegReader *pLhs, Fts3SegReader *pRhs){$/;"	f	file:
fts3SegReaderDoclistCmpRev	.\ext\fts3\fts3_write.c	/^static int fts3SegReaderDoclistCmpRev(Fts3SegReader *pLhs, Fts3SegReader *pRhs){$/;"	f	file:
fts3SegReaderFirstDocid	.\ext\fts3\fts3_write.c	/^static int fts3SegReaderFirstDocid(Fts3Table *pTab, Fts3SegReader *pReader){$/;"	f	file:
fts3SegReaderIncrRead	.\ext\fts3\fts3_write.c	/^static int fts3SegReaderIncrRead(Fts3SegReader *pReader){$/;"	f	file:
fts3SegReaderIsPending	.\ext\fts3\fts3_write.c	173;"	d	file:
fts3SegReaderIsRootOnly	.\ext\fts3\fts3_write.c	174;"	d	file:
fts3SegReaderNext	.\ext\fts3\fts3_write.c	/^static int fts3SegReaderNext($/;"	f	file:
fts3SegReaderNextDocid	.\ext\fts3\fts3_write.c	/^static int fts3SegReaderNextDocid($/;"	f	file:
fts3SegReaderRequire	.\ext\fts3\fts3_write.c	/^static int fts3SegReaderRequire(Fts3SegReader *pReader, char *pFrom, int nByte){$/;"	f	file:
fts3SegReaderSetEof	.\ext\fts3\fts3_write.c	/^static void fts3SegReaderSetEof(Fts3SegReader *pSeg){$/;"	f	file:
fts3SegReaderSort	.\ext\fts3\fts3_write.c	/^static void fts3SegReaderSort($/;"	f	file:
fts3SegReaderStart	.\ext\fts3\fts3_write.c	/^static int fts3SegReaderStart($/;"	f	file:
fts3SegReaderTermCmp	.\ext\fts3\fts3_write.c	/^static int fts3SegReaderTermCmp($/;"	f	file:
fts3SegWriterAdd	.\ext\fts3\fts3_write.c	/^static int fts3SegWriterAdd($/;"	f	file:
fts3SegWriterFlush	.\ext\fts3\fts3_write.c	/^static int fts3SegWriterFlush($/;"	f	file:
fts3SegWriterFree	.\ext\fts3\fts3_write.c	/^static void fts3SegWriterFree(SegmentWriter *pWriter){$/;"	f	file:
fts3SegmentIsMaxLevel	.\ext\fts3\fts3_write.c	/^static int fts3SegmentIsMaxLevel(Fts3Table *p, i64 iAbsLevel, int *pbMax){$/;"	f	file:
fts3SegmentMaxLevel	.\ext\fts3\fts3_write.c	/^static int fts3SegmentMaxLevel($/;"	f	file:
fts3SegmentMerge	.\ext\fts3\fts3_write.c	/^static int fts3SegmentMerge($/;"	f	file:
fts3SelectDocsize	.\ext\fts3\fts3_write.c	/^static int fts3SelectDocsize($/;"	f	file:
fts3SelectLeaf	.\ext\fts3\fts3.c	/^static int fts3SelectLeaf($/;"	f	file:
fts3SetEstimatedRows	.\ext\fts3\fts3.c	/^static void fts3SetEstimatedRows(sqlite3_index_info *pIdxInfo, i64 nRow){$/;"	f	file:
fts3SetHasStat	.\ext\fts3\fts3.c	/^static int fts3SetHasStat(Fts3Table *p){$/;"	f	file:
fts3SetUniqueFlag	.\ext\fts3\fts3.c	/^static void fts3SetUniqueFlag(sqlite3_index_info *pIdxInfo){$/;"	f	file:
fts3SnippetAdvance	.\ext\fts3\fts3_snippet.c	/^static void fts3SnippetAdvance(char **ppIter, int *piIter, int iNext){$/;"	f	file:
fts3SnippetDetails	.\ext\fts3\fts3_snippet.c	/^static void fts3SnippetDetails($/;"	f	file:
fts3SnippetFindPositions	.\ext\fts3\fts3_snippet.c	/^static int fts3SnippetFindPositions(Fts3Expr *pExpr, int iPhrase, void *ctx){$/;"	f	file:
fts3SnippetFunc	.\ext\fts3\fts3.c	/^static void fts3SnippetFunc($/;"	f	file:
fts3SnippetNextCandidate	.\ext\fts3\fts3_snippet.c	/^static int fts3SnippetNextCandidate(SnippetIter *pIter){$/;"	f	file:
fts3SnippetShift	.\ext\fts3\fts3_snippet.c	/^static int fts3SnippetShift($/;"	f	file:
fts3SnippetText	.\ext\fts3\fts3_snippet.c	/^static int fts3SnippetText($/;"	f	file:
fts3SpecialInsert	.\ext\fts3\fts3_write.c	/^static int fts3SpecialInsert(Fts3Table *p, sqlite3_value *pVal){$/;"	f	file:
fts3SqlExec	.\ext\fts3\fts3_write.c	/^static void fts3SqlExec($/;"	f	file:
fts3SqlStmt	.\ext\fts3\fts3_write.c	/^static int fts3SqlStmt($/;"	f	file:
fts3StartNode	.\ext\fts3\fts3_write.c	/^static void fts3StartNode(Blob *pNode, int iHeight, sqlite3_int64 iChild){$/;"	f	file:
fts3StrCompare	.\ext\fts3\fts3_hash.c	/^static int fts3StrCompare(const void *pKey1, int n1, const void *pKey2, int n2){$/;"	f	file:
fts3StrHash	.\ext\fts3\fts3_hash.c	/^static int fts3StrHash(const void *pKey, int nKey){$/;"	f	file:
fts3StringAppend	.\ext\fts3\fts3_snippet.c	/^static int fts3StringAppend($/;"	f	file:
fts3SyncMethod	.\ext\fts3\fts3.c	/^static int fts3SyncMethod(sqlite3_vtab *pVtab){$/;"	f	file:
fts3TermCmp	.\ext\fts3\fts3_write.c	/^static int fts3TermCmp($/;"	f	file:
fts3TermSegReaderCursor	.\ext\fts3\fts3.c	/^static int fts3TermSegReaderCursor($/;"	f	file:
fts3TermSelect	.\ext\fts3\fts3.c	/^static int fts3TermSelect($/;"	f	file:
fts3TermSelectFinishMerge	.\ext\fts3\fts3.c	/^static int fts3TermSelectFinishMerge(Fts3Table *p, TermSelect *pTS){$/;"	f	file:
fts3TermSelectMerge	.\ext\fts3\fts3.c	/^static int fts3TermSelectMerge($/;"	f	file:
fts3TreeFinishNode	.\ext\fts3\fts3_write.c	/^static int fts3TreeFinishNode($/;"	f	file:
fts3TruncateNode	.\ext\fts3\fts3_write.c	/^static int fts3TruncateNode($/;"	f	file:
fts3TruncateSegment	.\ext\fts3\fts3_write.c	/^static int fts3TruncateSegment($/;"	f	file:
fts3UpdateDocTotals	.\ext\fts3\fts3_write.c	/^static void fts3UpdateDocTotals($/;"	f	file:
fts3UpdateMethod	.\ext\fts3\fts3.c	/^static int fts3UpdateMethod($/;"	f	file:
fts3WriteExprList	.\ext\fts3\fts3.c	/^static char *fts3WriteExprList(Fts3Table *p, const char *zFunc, int *pRc){$/;"	f	file:
fts3WriteSegdir	.\ext\fts3\fts3_write.c	/^static int fts3WriteSegdir($/;"	f	file:
fts3WriteSegment	.\ext\fts3\fts3_write.c	/^static int fts3WriteSegment($/;"	f	file:
fts3Writelock	.\ext\fts3\fts3_write.c	/^static int fts3Writelock(Fts3Table *p){$/;"	f	file:
fts3_build_db_1	.\test\fts3_common.tcl	/^proc fts3_build_db_1 {args} {$/;"	p
fts3_build_db_2	.\test\fts3_common.tcl	/^proc fts3_build_db_2 {args} {$/;"	p
fts3_configure_incr_load_cmd	.\ext\fts3\fts3_test.c	/^static int fts3_configure_incr_load_cmd($/;"	f	file:
fts3_doclist	.\test\fts3_common.tcl	/^proc fts3_doclist {tbl term where} {$/;"	p
fts3_integrity_check	.\test\fts3_common.tcl	/^proc fts3_integrity_check {tbl} {$/;"	p
fts3_isalnum	.\ext\fts3\fts3_tokenizer1.c	/^static int fts3_isalnum(int x){$/;"	f	file:
fts3_near_match_cmd	.\ext\fts3\fts3_test.c	/^static int fts3_near_match_cmd($/;"	f	file:
fts3_read	.\test\fts3_common.tcl	/^proc fts3_read {tbl where varname} {$/;"	p
fts3_read2	.\test\fts3_common.tcl	/^proc fts3_read2 {tbl where varname} {$/;"	p
fts3_readleaf	.\test\fts3_common.tcl	/^proc fts3_readleaf {blob} {$/;"	p
fts3_terms	.\test\fts3_common.tcl	/^proc fts3_terms {tbl where} {$/;"	p
fts3_test_tokenizer_cmd	.\ext\fts3\fts3_test.c	/^static int fts3_test_tokenizer_cmd($/;"	f	file:
fts3_test_varint_cmd	.\ext\fts3\fts3_test.c	/^static int fts3_test_varint_cmd($/;"	f	file:
fts3auxBestIndexMethod	.\ext\fts3\fts3_aux.c	/^static int fts3auxBestIndexMethod($/;"	f	file:
fts3auxCloseMethod	.\ext\fts3\fts3_aux.c	/^static int fts3auxCloseMethod(sqlite3_vtab_cursor *pCursor){$/;"	f	file:
fts3auxColumnMethod	.\ext\fts3\fts3_aux.c	/^static int fts3auxColumnMethod($/;"	f	file:
fts3auxConnectMethod	.\ext\fts3\fts3_aux.c	/^static int fts3auxConnectMethod($/;"	f	file:
fts3auxDisconnectMethod	.\ext\fts3\fts3_aux.c	/^static int fts3auxDisconnectMethod(sqlite3_vtab *pVtab){$/;"	f	file:
fts3auxEofMethod	.\ext\fts3\fts3_aux.c	/^static int fts3auxEofMethod(sqlite3_vtab_cursor *pCursor){$/;"	f	file:
fts3auxFilterMethod	.\ext\fts3\fts3_aux.c	/^static int fts3auxFilterMethod($/;"	f	file:
fts3auxGrowStatArray	.\ext\fts3\fts3_aux.c	/^static int fts3auxGrowStatArray(Fts3auxCursor *pCsr, int nSize){$/;"	f	file:
fts3auxNextMethod	.\ext\fts3\fts3_aux.c	/^static int fts3auxNextMethod(sqlite3_vtab_cursor *pCursor){$/;"	f	file:
fts3auxOpenMethod	.\ext\fts3\fts3_aux.c	/^static int fts3auxOpenMethod(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCsr){$/;"	f	file:
fts3auxRowidMethod	.\ext\fts3\fts3_aux.c	/^static int fts3auxRowidMethod($/;"	f	file:
fts3isspace	.\ext\fts3\fts3_expr.c	/^static int fts3isspace(char c){$/;"	f	file:
fts3termBestIndexMethod	.\ext\fts3\fts3_term.c	/^static int fts3termBestIndexMethod($/;"	f	file:
fts3termCloseMethod	.\ext\fts3\fts3_term.c	/^static int fts3termCloseMethod(sqlite3_vtab_cursor *pCursor){$/;"	f	file:
fts3termColumnMethod	.\ext\fts3\fts3_term.c	/^static int fts3termColumnMethod($/;"	f	file:
fts3termConnectMethod	.\ext\fts3\fts3_term.c	/^static int fts3termConnectMethod($/;"	f	file:
fts3termDisconnectMethod	.\ext\fts3\fts3_term.c	/^static int fts3termDisconnectMethod(sqlite3_vtab *pVtab){$/;"	f	file:
fts3termEofMethod	.\ext\fts3\fts3_term.c	/^static int fts3termEofMethod(sqlite3_vtab_cursor *pCursor){$/;"	f	file:
fts3termFilterMethod	.\ext\fts3\fts3_term.c	/^static int fts3termFilterMethod($/;"	f	file:
fts3termNextMethod	.\ext\fts3\fts3_term.c	/^static int fts3termNextMethod(sqlite3_vtab_cursor *pCursor){$/;"	f	file:
fts3termOpenMethod	.\ext\fts3\fts3_term.c	/^static int fts3termOpenMethod(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCsr){$/;"	f	file:
fts3termRowidMethod	.\ext\fts3\fts3_term.c	/^static int fts3termRowidMethod($/;"	f	file:
fts3tokBestIndexMethod	.\ext\fts3\fts3_tokenize_vtab.c	/^static int fts3tokBestIndexMethod($/;"	f	file:
fts3tokCloseMethod	.\ext\fts3\fts3_tokenize_vtab.c	/^static int fts3tokCloseMethod(sqlite3_vtab_cursor *pCursor){$/;"	f	file:
fts3tokColumnMethod	.\ext\fts3\fts3_tokenize_vtab.c	/^static int fts3tokColumnMethod($/;"	f	file:
fts3tokConnectMethod	.\ext\fts3\fts3_tokenize_vtab.c	/^static int fts3tokConnectMethod($/;"	f	file:
fts3tokDequoteArray	.\ext\fts3\fts3_tokenize_vtab.c	/^static int fts3tokDequoteArray($/;"	f	file:
fts3tokDisconnectMethod	.\ext\fts3\fts3_tokenize_vtab.c	/^static int fts3tokDisconnectMethod(sqlite3_vtab *pVtab){$/;"	f	file:
fts3tokEofMethod	.\ext\fts3\fts3_tokenize_vtab.c	/^static int fts3tokEofMethod(sqlite3_vtab_cursor *pCursor){$/;"	f	file:
fts3tokFilterMethod	.\ext\fts3\fts3_tokenize_vtab.c	/^static int fts3tokFilterMethod($/;"	f	file:
fts3tokNextMethod	.\ext\fts3\fts3_tokenize_vtab.c	/^static int fts3tokNextMethod(sqlite3_vtab_cursor *pCursor){$/;"	f	file:
fts3tokOpenMethod	.\ext\fts3\fts3_tokenize_vtab.c	/^static int fts3tokOpenMethod(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCsr){$/;"	f	file:
fts3tokQueryTokenizer	.\ext\fts3\fts3_tokenize_vtab.c	/^static int fts3tokQueryTokenizer($/;"	f	file:
fts3tokResetCursor	.\ext\fts3\fts3_tokenize_vtab.c	/^static void fts3tokResetCursor(Fts3tokCursor *pCsr){$/;"	f	file:
fts3tokRowidMethod	.\ext\fts3\fts3_tokenize_vtab.c	/^static int fts3tokRowidMethod($/;"	f	file:
fts5AllocateSegid	.\ext\fts5\fts5_index.c	/^static int fts5AllocateSegid(Fts5Index *p, Fts5Structure *pStruct){$/;"	f	file:
fts5ApiCallback	.\ext\fts5\fts5_main.c	/^static void fts5ApiCallback($/;"	f	file:
fts5ApiColumnCount	.\ext\fts5\fts5_main.c	/^static int fts5ApiColumnCount(Fts5Context *pCtx){$/;"	f	file:
fts5ApiColumnSize	.\ext\fts5\fts5_main.c	/^static int fts5ApiColumnSize(Fts5Context *pCtx, int iCol, int *pnToken){$/;"	f	file:
fts5ApiColumnText	.\ext\fts5\fts5_main.c	/^static int fts5ApiColumnText($/;"	f	file:
fts5ApiColumnTotalSize	.\ext\fts5\fts5_main.c	/^static int fts5ApiColumnTotalSize($/;"	f	file:
fts5ApiGetAuxdata	.\ext\fts5\fts5_main.c	/^static void *fts5ApiGetAuxdata(Fts5Context *pCtx, int bClear){$/;"	f	file:
fts5ApiInst	.\ext\fts5\fts5_main.c	/^static int fts5ApiInst($/;"	f	file:
fts5ApiInstCount	.\ext\fts5\fts5_main.c	/^static int fts5ApiInstCount(Fts5Context *pCtx, int *pnInst){$/;"	f	file:
fts5ApiInvoke	.\ext\fts5\fts5_main.c	/^static void fts5ApiInvoke($/;"	f	file:
fts5ApiPhraseCount	.\ext\fts5\fts5_main.c	/^static int fts5ApiPhraseCount(Fts5Context *pCtx){$/;"	f	file:
fts5ApiPhraseFirst	.\ext\fts5\fts5_main.c	/^static void fts5ApiPhraseFirst($/;"	f	file:
fts5ApiPhraseNext	.\ext\fts5\fts5_main.c	/^static void fts5ApiPhraseNext($/;"	f	file:
fts5ApiPhraseSize	.\ext\fts5\fts5_main.c	/^static int fts5ApiPhraseSize(Fts5Context *pCtx, int iPhrase){$/;"	f	file:
fts5ApiQueryPhrase	.\ext\fts5\fts5_main.c	/^static int fts5ApiQueryPhrase($/;"	f	file:
fts5ApiRowCount	.\ext\fts5\fts5_main.c	/^static int fts5ApiRowCount(Fts5Context *pCtx, i64 *pnRow){$/;"	f	file:
fts5ApiRowid	.\ext\fts5\fts5_main.c	/^static sqlite3_int64 fts5ApiRowid(Fts5Context *pCtx){$/;"	f	file:
fts5ApiSetAuxdata	.\ext\fts5\fts5_main.c	/^static int fts5ApiSetAuxdata($/;"	f	file:
fts5ApiTokenize	.\ext\fts5\fts5_main.c	/^static int fts5ApiTokenize($/;"	f	file:
fts5ApiUserData	.\ext\fts5\fts5_main.c	/^static void *fts5ApiUserData(Fts5Context *pCtx){$/;"	f	file:
fts5AppendPoslist	.\ext\fts5\fts5_index.c	/^static int fts5AppendPoslist($/;"	f	file:
fts5AsciiAddExceptions	.\ext\fts5\fts5_tokenize.c	/^static void fts5AsciiAddExceptions($/;"	f	file:
fts5AsciiCreate	.\ext\fts5\fts5_tokenize.c	/^static int fts5AsciiCreate($/;"	f	file:
fts5AsciiDelete	.\ext\fts5\fts5_tokenize.c	/^static void fts5AsciiDelete(Fts5Tokenizer *p){$/;"	f	file:
fts5AsciiTokenize	.\ext\fts5\fts5_tokenize.c	/^static int fts5AsciiTokenize($/;"	f	file:
fts5AssertComparisonResult	.\ext\fts5\fts5_index.c	/^static void fts5AssertComparisonResult($/;"	f	file:
fts5AssertMultiIterSetup	.\ext\fts5\fts5_index.c	/^static void fts5AssertMultiIterSetup(Fts5Index *p, Fts5IndexIter *pIter){$/;"	f	file:
fts5AssertMultiIterSetup	.\ext\fts5\fts5_index.c	2312;"	d	file:
fts5BeginMethod	.\ext\fts5\fts5_main.c	/^static int fts5BeginMethod(sqlite3_vtab *pVtab){$/;"	f	file:
fts5BestIndexMethod	.\ext\fts5\fts5_main.c	/^static int fts5BestIndexMethod(sqlite3_vtab *pVTab, sqlite3_index_info *pInfo){$/;"	f	file:
fts5BlobCompare	.\ext\fts5\fts5_index.c	/^static int fts5BlobCompare($/;"	f	file:
fts5Bm25Function	.\ext\fts5\fts5_aux.c	/^static void fts5Bm25Function($/;"	f	file:
fts5Bm25GetData	.\ext\fts5\fts5_aux.c	/^static int fts5Bm25GetData($/;"	f	file:
fts5BufferAppend32	.\ext\fts5\fts5Int.h	245;"	d
fts5BufferAppendBlob	.\ext\fts5\fts5Int.h	243;"	d
fts5BufferAppendVarint	.\ext\fts5\fts5Int.h	241;"	d
fts5BufferCompare	.\ext\fts5\fts5_index.c	/^static int fts5BufferCompare(Fts5Buffer *pLeft, Fts5Buffer *pRight){$/;"	f	file:
fts5BufferCompareBlob	.\ext\fts5\fts5_index.c	/^static int fts5BufferCompareBlob($/;"	f	file:
fts5BufferFree	.\ext\fts5\fts5Int.h	242;"	d
fts5BufferGrow	.\ext\fts5\fts5Int.h	240;"	d
fts5BufferSafeAppendBlob	.\ext\fts5\fts5_index.c	3702;"	d	file:
fts5BufferSafeAppendVarint	.\ext\fts5\fts5_index.c	3708;"	d	file:
fts5BufferSet	.\ext\fts5\fts5Int.h	244;"	d
fts5BufferSwap	.\ext\fts5\fts5_index.c	/^static void fts5BufferSwap(Fts5Buffer *p1, Fts5Buffer *p2){$/;"	f	file:
fts5BufferZero	.\ext\fts5\fts5Int.h	239;"	d
fts5CInstIterInit	.\ext\fts5\fts5_aux.c	/^static int fts5CInstIterInit($/;"	f	file:
fts5CInstIterNext	.\ext\fts5\fts5_aux.c	/^static int fts5CInstIterNext(CInstIter *pIter){$/;"	f	file:
fts5CacheInstArray	.\ext\fts5\fts5_main.c	/^static int fts5CacheInstArray(Fts5Cursor *pCsr){$/;"	f	file:
fts5CheckTransactionState	.\ext\fts5\fts5_main.c	/^static void fts5CheckTransactionState(Fts5Table *p, int op, int iSavepoint){$/;"	f	file:
fts5CheckTransactionState	.\ext\fts5\fts5_main.c	302;"	d	file:
fts5ChunkIterate	.\ext\fts5\fts5_index.c	/^static void fts5ChunkIterate($/;"	f	file:
fts5CloseMethod	.\ext\fts5\fts5_main.c	/^static int fts5CloseMethod(sqlite3_vtab_cursor *pCursor){$/;"	f	file:
fts5CloseReader	.\ext\fts5\fts5_index.c	/^static void fts5CloseReader(Fts5Index *p){$/;"	f	file:
fts5ColumnMethod	.\ext\fts5\fts5_main.c	/^static int fts5ColumnMethod($/;"	f	file:
fts5ColumnSizeCb	.\ext\fts5\fts5_main.c	/^static int fts5ColumnSizeCb($/;"	f	file:
fts5CommitMethod	.\ext\fts5\fts5_main.c	/^static int fts5CommitMethod(sqlite3_vtab *pVtab){$/;"	f	file:
fts5ConfigDefaultTokenizer	.\ext\fts5\fts5_config.c	/^static int fts5ConfigDefaultTokenizer(Fts5Global *pGlobal, Fts5Config *pConfig){$/;"	f	file:
fts5ConfigGobbleWord	.\ext\fts5\fts5_config.c	/^static const char *fts5ConfigGobbleWord($/;"	f	file:
fts5ConfigMakeExprlist	.\ext\fts5\fts5_config.c	/^static int fts5ConfigMakeExprlist(Fts5Config *p){$/;"	f	file:
fts5ConfigParseColumn	.\ext\fts5\fts5_config.c	/^static int fts5ConfigParseColumn($/;"	f	file:
fts5ConfigParseSpecial	.\ext\fts5\fts5_config.c	/^static int fts5ConfigParseSpecial($/;"	f	file:
fts5ConfigSkipArgs	.\ext\fts5\fts5_config.c	/^static const char *fts5ConfigSkipArgs(const char *pIn){$/;"	f	file:
fts5ConfigSkipBareword	.\ext\fts5\fts5_config.c	/^static const char *fts5ConfigSkipBareword(const char *pIn){$/;"	f	file:
fts5ConfigSkipLiteral	.\ext\fts5\fts5_config.c	/^static const char *fts5ConfigSkipLiteral(const char *pIn){$/;"	f	file:
fts5ConfigSkipWhitespace	.\ext\fts5\fts5_config.c	/^static const char *fts5ConfigSkipWhitespace(const char *pIn){$/;"	f	file:
fts5ConnectMethod	.\ext\fts5\fts5_main.c	/^static int fts5ConnectMethod($/;"	f	file:
fts5CountCb	.\ext\fts5\fts5_aux.c	/^static int fts5CountCb($/;"	f	file:
fts5CreateAux	.\ext\fts5\fts5_main.c	/^static int fts5CreateAux($/;"	f	file:
fts5CreateMethod	.\ext\fts5\fts5_main.c	/^static int fts5CreateMethod($/;"	f	file:
fts5CreateTokenizer	.\ext\fts5\fts5_main.c	/^static int fts5CreateTokenizer($/;"	f	file:
fts5CsrNewrow	.\ext\fts5\fts5_main.c	/^static void fts5CsrNewrow(Fts5Cursor *pCsr){$/;"	f	file:
fts5CsrPoslist	.\ext\fts5\fts5_main.c	/^static int fts5CsrPoslist(Fts5Cursor *pCsr, int iPhrase, const u8 **pa){$/;"	f	file:
fts5CursorFirst	.\ext\fts5\fts5_main.c	/^static int fts5CursorFirst(Fts5Table *pTab, Fts5Cursor *pCsr, int bDesc){$/;"	f	file:
fts5CursorFirstSorted	.\ext\fts5\fts5_main.c	/^static int fts5CursorFirstSorted(Fts5Table *pTab, Fts5Cursor *pCsr, int bDesc){$/;"	f	file:
fts5CursorFromCsrid	.\ext\fts5\fts5_main.c	/^static Fts5Cursor *fts5CursorFromCsrid(Fts5Global *pGlobal, i64 iCsrId){$/;"	f	file:
fts5CursorParseRank	.\ext\fts5\fts5_main.c	/^static int fts5CursorParseRank($/;"	f	file:
fts5CursorReseek	.\ext\fts5\fts5_main.c	/^static int fts5CursorReseek(Fts5Cursor *pCsr, int *pbSkip){$/;"	f	file:
fts5CursorRowid	.\ext\fts5\fts5_main.c	/^static i64 fts5CursorRowid(Fts5Cursor *pCsr){$/;"	f	file:
fts5DataDelete	.\ext\fts5\fts5_index.c	/^static void fts5DataDelete(Fts5Index *p, i64 iFirst, i64 iLast){$/;"	f	file:
fts5DataRead	.\ext\fts5\fts5_index.c	/^static Fts5Data *fts5DataRead(Fts5Index *p, i64 iRowid){$/;"	f	file:
fts5DataRelease	.\ext\fts5\fts5_index.c	/^static void fts5DataRelease(Fts5Data *pData){$/;"	f	file:
fts5DataRemoveSegment	.\ext\fts5\fts5_index.c	/^static void fts5DataRemoveSegment(Fts5Index *p, int iSegid){$/;"	f	file:
fts5DataWrite	.\ext\fts5\fts5_index.c	/^static void fts5DataWrite(Fts5Index *p, i64 iRowid, const u8 *pData, int nData){$/;"	f	file:
fts5DebugRowid	.\ext\fts5\fts5_index.c	/^static void fts5DebugRowid(int *pRc, Fts5Buffer *pBuf, i64 iKey){$/;"	f	file:
fts5DebugStructure	.\ext\fts5\fts5_index.c	/^static void fts5DebugStructure($/;"	f	file:
fts5DecodeAverages	.\ext\fts5\fts5_index.c	/^static void fts5DecodeAverages($/;"	f	file:
fts5DecodeDoclist	.\ext\fts5\fts5_index.c	/^static int fts5DecodeDoclist(int *pRc, Fts5Buffer *pBuf, const u8 *a, int n){$/;"	f	file:
fts5DecodeFunction	.\ext\fts5\fts5_index.c	/^static void fts5DecodeFunction($/;"	f	file:
fts5DecodePoslist	.\ext\fts5\fts5_index.c	/^static int fts5DecodePoslist(int *pRc, Fts5Buffer *pBuf, const u8 *a, int n){$/;"	f	file:
fts5DecodeRowid	.\ext\fts5\fts5_index.c	/^static void fts5DecodeRowid($/;"	f	file:
fts5DecodeStructure	.\ext\fts5\fts5_index.c	/^static void fts5DecodeStructure($/;"	f	file:
fts5Dequote	.\ext\fts5\fts5_config.c	/^static int fts5Dequote(char *z){$/;"	f	file:
fts5DestroyMethod	.\ext\fts5\fts5_main.c	/^static int fts5DestroyMethod(sqlite3_vtab *pVtab){$/;"	f	file:
fts5DisconnectMethod	.\ext\fts5\fts5_main.c	/^static int fts5DisconnectMethod(sqlite3_vtab *pVtab){$/;"	f	file:
fts5DlidxExtractFirstRowid	.\ext\fts5\fts5_index.c	/^static i64 fts5DlidxExtractFirstRowid(Fts5Buffer *pBuf){$/;"	f	file:
fts5DlidxIterEof	.\ext\fts5\fts5_index.c	/^static int fts5DlidxIterEof(Fts5Index *p, Fts5DlidxIter *pIter){$/;"	f	file:
fts5DlidxIterFirst	.\ext\fts5\fts5_index.c	/^static int fts5DlidxIterFirst(Fts5DlidxIter *pIter){$/;"	f	file:
fts5DlidxIterFree	.\ext\fts5\fts5_index.c	/^static void fts5DlidxIterFree(Fts5DlidxIter *pIter){$/;"	f	file:
fts5DlidxIterInit	.\ext\fts5\fts5_index.c	/^static Fts5DlidxIter *fts5DlidxIterInit($/;"	f	file:
fts5DlidxIterLast	.\ext\fts5\fts5_index.c	/^static void fts5DlidxIterLast(Fts5Index *p, Fts5DlidxIter *pIter){$/;"	f	file:
fts5DlidxIterNext	.\ext\fts5\fts5_index.c	/^static int fts5DlidxIterNext(Fts5Index *p, Fts5DlidxIter *pIter){$/;"	f	file:
fts5DlidxIterNextR	.\ext\fts5\fts5_index.c	/^static int fts5DlidxIterNextR(Fts5Index *p, Fts5DlidxIter *pIter, int iLvl){$/;"	f	file:
fts5DlidxIterPgno	.\ext\fts5\fts5_index.c	/^static int fts5DlidxIterPgno(Fts5DlidxIter *pIter){$/;"	f	file:
fts5DlidxIterPrev	.\ext\fts5\fts5_index.c	/^static int fts5DlidxIterPrev(Fts5Index *p, Fts5DlidxIter *pIter){$/;"	f	file:
fts5DlidxIterPrevR	.\ext\fts5\fts5_index.c	/^static int fts5DlidxIterPrevR(Fts5Index *p, Fts5DlidxIter *pIter, int iLvl){$/;"	f	file:
fts5DlidxIterRowid	.\ext\fts5\fts5_index.c	/^static i64 fts5DlidxIterRowid(Fts5DlidxIter *pIter){$/;"	f	file:
fts5DlidxLvlNext	.\ext\fts5\fts5_index.c	/^static int fts5DlidxLvlNext(Fts5DlidxLvl *pLvl){$/;"	f	file:
fts5DlidxLvlPrev	.\ext\fts5\fts5_index.c	/^static int fts5DlidxLvlPrev(Fts5DlidxLvl *pLvl){$/;"	f	file:
fts5DoclistIterInit	.\ext\fts5\fts5_index.c	/^static void fts5DoclistIterInit($/;"	f	file:
fts5DoclistIterNext	.\ext\fts5\fts5_index.c	/^static void fts5DoclistIterNext(Fts5DoclistIter *pIter){$/;"	f	file:
fts5EofMethod	.\ext\fts5\fts5_main.c	/^static int fts5EofMethod(sqlite3_vtab_cursor *pCursor){$/;"	f	file:
fts5ExecPrintf	.\ext\fts5\fts5_storage.c	/^static int fts5ExecPrintf($/;"	f	file:
fts5ExprAddChildren	.\ext\fts5\fts5_expr.c	/^static void fts5ExprAddChildren(Fts5ExprNode *p, Fts5ExprNode *pSub){$/;"	f	file:
fts5ExprAdvanceto	.\ext\fts5\fts5_expr.c	/^static int fts5ExprAdvanceto($/;"	f	file:
fts5ExprAndNextRowid	.\ext\fts5\fts5_expr.c	/^static int fts5ExprAndNextRowid($/;"	f	file:
fts5ExprFold	.\ext\fts5\fts5_expr.c	/^static void fts5ExprFold($/;"	f	file:
fts5ExprFunction	.\ext\fts5\fts5_expr.c	/^static void fts5ExprFunction($/;"	f	file:
fts5ExprFunctionHr	.\ext\fts5\fts5_expr.c	/^static void fts5ExprFunctionHr($/;"	f	file:
fts5ExprFunctionTcl	.\ext\fts5\fts5_expr.c	/^static void fts5ExprFunctionTcl($/;"	f	file:
fts5ExprGetToken	.\ext\fts5\fts5_expr.c	/^static int fts5ExprGetToken($/;"	f	file:
fts5ExprIsAlnum	.\ext\fts5\fts5_expr.c	/^static void fts5ExprIsAlnum($/;"	f	file:
fts5ExprIsspace	.\ext\fts5\fts5_expr.c	/^static int fts5ExprIsspace(char t){$/;"	f	file:
fts5ExprNearAdvanceFirst	.\ext\fts5\fts5_expr.c	/^static int fts5ExprNearAdvanceFirst($/;"	f	file:
fts5ExprNearInitAll	.\ext\fts5\fts5_expr.c	/^static int fts5ExprNearInitAll($/;"	f	file:
fts5ExprNearIsMatch	.\ext\fts5\fts5_expr.c	/^static int fts5ExprNearIsMatch(int *pRc, Fts5ExprNearset *pNear){$/;"	f	file:
fts5ExprNearNextMatch	.\ext\fts5\fts5_expr.c	/^static int fts5ExprNearNextMatch($/;"	f	file:
fts5ExprNearTest	.\ext\fts5\fts5_expr.c	/^static int fts5ExprNearTest($/;"	f	file:
fts5ExprNodeFirst	.\ext\fts5\fts5_expr.c	/^static int fts5ExprNodeFirst(Fts5Expr *pExpr, Fts5ExprNode *pNode){$/;"	f	file:
fts5ExprNodeNext	.\ext\fts5\fts5_expr.c	/^static int fts5ExprNodeNext($/;"	f	file:
fts5ExprNodeNextMatch	.\ext\fts5\fts5_expr.c	/^static int fts5ExprNodeNextMatch($/;"	f	file:
fts5ExprNodeZeroPoslist	.\ext\fts5\fts5_expr.c	/^static void fts5ExprNodeZeroPoslist(Fts5ExprNode *pNode){$/;"	f	file:
fts5ExprPhraseFree	.\ext\fts5\fts5_expr.c	/^static void fts5ExprPhraseFree(Fts5ExprPhrase *pPhrase){$/;"	f	file:
fts5ExprPhraseIsMatch	.\ext\fts5\fts5_expr.c	/^static int fts5ExprPhraseIsMatch($/;"	f	file:
fts5ExprPrint	.\ext\fts5\fts5_expr.c	/^static char *fts5ExprPrint(Fts5Config *pConfig, Fts5ExprNode *pExpr){$/;"	f	file:
fts5ExprPrintTcl	.\ext\fts5\fts5_expr.c	/^static char *fts5ExprPrintTcl($/;"	f	file:
fts5ExprSetEof	.\ext\fts5\fts5_expr.c	/^static void fts5ExprSetEof(Fts5ExprNode *pNode){$/;"	f	file:
fts5ExprSynonymAdvanceto	.\ext\fts5\fts5_expr.c	/^static int fts5ExprSynonymAdvanceto($/;"	f	file:
fts5ExprSynonymPoslist	.\ext\fts5\fts5_expr.c	/^static int fts5ExprSynonymPoslist($/;"	f	file:
fts5ExprSynonymRowid	.\ext\fts5\fts5_expr.c	/^static i64 fts5ExprSynonymRowid(Fts5ExprTerm *pTerm, int bDesc, int *pbEof){$/;"	f	file:
fts5ExprTermPrint	.\ext\fts5\fts5_expr.c	/^static char *fts5ExprTermPrint(Fts5ExprTerm *pTerm){$/;"	f	file:
fts5ExprTokenTest	.\ext\fts5\fts5_expr.c	/^static int fts5ExprTokenTest($/;"	f	file:
fts5FastGetVarint32	.\ext\fts5\fts5Int.h	451;"	d
fts5FilterMethod	.\ext\fts5\fts5_main.c	/^static int fts5FilterMethod($/;"	f	file:
fts5FindAuxiliary	.\ext\fts5\fts5_main.c	/^static Fts5Auxiliary *fts5FindAuxiliary(Fts5Table *pTab, const char *zName){$/;"	f	file:
fts5FindFunctionMethod	.\ext\fts5\fts5_main.c	/^static int fts5FindFunctionMethod($/;"	f	file:
fts5FindRankFunction	.\ext\fts5\fts5_main.c	/^static int fts5FindRankFunction(Fts5Cursor *pCsr){$/;"	f	file:
fts5FindTokenizer	.\ext\fts5\fts5_main.c	/^static int fts5FindTokenizer($/;"	f	file:
fts5FlushOneHash	.\ext\fts5\fts5_index.c	/^static void fts5FlushOneHash(Fts5Index *p){$/;"	f	file:
fts5FreeCursorComponents	.\ext\fts5\fts5_main.c	/^static void fts5FreeCursorComponents(Fts5Cursor *pCsr){$/;"	f	file:
fts5FreeVtab	.\ext\fts5\fts5_main.c	/^static void fts5FreeVtab(Fts5Table *pTab){$/;"	f	file:
fts5Fts5Func	.\ext\fts5\fts5_main.c	/^static void fts5Fts5Func($/;"	f	file:
fts5GetPoslistSize	.\ext\fts5\fts5_index.c	/^static int fts5GetPoslistSize(const u8 *p, int *pnSz, int *pbDel){$/;"	f	file:
fts5GetRowidLimit	.\ext\fts5\fts5_main.c	/^static i64 fts5GetRowidLimit(sqlite3_value *pVal, i64 iDefault){$/;"	f	file:
fts5GetU16	.\ext\fts5\fts5_index.c	/^static u16 fts5GetU16(const u8 *aIn){$/;"	f	file:
fts5GetVarint	.\ext\fts5\fts5Int.h	449;"	d
fts5GetVarint32	.\ext\fts5\fts5Int.h	448;"	d
fts5HashAddPoslistSize	.\ext\fts5\fts5_hash.c	/^static void fts5HashAddPoslistSize(Fts5HashEntry *p){$/;"	f	file:
fts5HashEntryMerge	.\ext\fts5\fts5_hash.c	/^static Fts5HashEntry *fts5HashEntryMerge($/;"	f	file:
fts5HashEntrySort	.\ext\fts5\fts5_hash.c	/^static int fts5HashEntrySort($/;"	f	file:
fts5HashKey	.\ext\fts5\fts5_hash.c	/^static unsigned int fts5HashKey(int nSlot, const u8 *p, int n){$/;"	f	file:
fts5HashKey2	.\ext\fts5\fts5_hash.c	/^static unsigned int fts5HashKey2(int nSlot, u8 b, const u8 *p, int n){$/;"	f	file:
fts5HashResize	.\ext\fts5\fts5_hash.c	/^static int fts5HashResize(Fts5Hash *pHash){$/;"	f	file:
fts5HighlightAppend	.\ext\fts5\fts5_aux.c	/^static void fts5HighlightAppend($/;"	f	file:
fts5HighlightCb	.\ext\fts5\fts5_aux.c	/^static int fts5HighlightCb($/;"	f	file:
fts5HighlightFunction	.\ext\fts5\fts5_aux.c	/^static void fts5HighlightFunction($/;"	f	file:
fts5IdxMalloc	.\ext\fts5\fts5_index.c	/^static void *fts5IdxMalloc(Fts5Index *p, int nByte){$/;"	f	file:
fts5IndexAutomerge	.\ext\fts5\fts5_index.c	/^static void fts5IndexAutomerge($/;"	f	file:
fts5IndexCharlen	.\ext\fts5\fts5_index.c	/^static int fts5IndexCharlen(const char *pIn, int nIn){$/;"	f	file:
fts5IndexCharlenToBytelen	.\ext\fts5\fts5_index.c	/^static int fts5IndexCharlenToBytelen(const char *p, int nByte, int nChar){$/;"	f	file:
fts5IndexColsetTest	.\ext\fts5\fts5_index.c	/^static int fts5IndexColsetTest(Fts5Colset *pColset, int iCol){$/;"	f	file:
fts5IndexCrisismerge	.\ext\fts5\fts5_index.c	/^static void fts5IndexCrisismerge($/;"	f	file:
fts5IndexDiscardData	.\ext\fts5\fts5_index.c	/^static void fts5IndexDiscardData(Fts5Index *p){$/;"	f	file:
fts5IndexEntryCksum	.\ext\fts5\fts5_index.c	/^static u64 fts5IndexEntryCksum($/;"	f	file:
fts5IndexExtractCol	.\ext\fts5\fts5_index.c	/^static int fts5IndexExtractCol($/;"	f	file:
fts5IndexExtractColset	.\ext\fts5\fts5_index.c	/^static int fts5IndexExtractColset ($/;"	f	file:
fts5IndexFlush	.\ext\fts5\fts5_index.c	/^static void fts5IndexFlush(Fts5Index *p){$/;"	f	file:
fts5IndexIntegrityCheckEmpty	.\ext\fts5\fts5_index.c	/^static void fts5IndexIntegrityCheckEmpty($/;"	f	file:
fts5IndexIntegrityCheckSegment	.\ext\fts5\fts5_index.c	/^static void fts5IndexIntegrityCheckSegment($/;"	f	file:
fts5IndexMerge	.\ext\fts5\fts5_index.c	/^static void fts5IndexMerge($/;"	f	file:
fts5IndexMergeLevel	.\ext\fts5\fts5_index.c	/^static void fts5IndexMergeLevel($/;"	f	file:
fts5IndexPrepareStmt	.\ext\fts5\fts5_index.c	/^static int fts5IndexPrepareStmt($/;"	f	file:
fts5IndexReturn	.\ext\fts5\fts5_index.c	/^static int fts5IndexReturn(Fts5Index *p){$/;"	f	file:
fts5IndexSkipVarint	.\ext\fts5\fts5_index.c	1944;"	d	file:
fts5Init	.\ext\fts5\fts5_main.c	/^static int fts5Init(sqlite3 *db){$/;"	f	file:
fts5InitVtab	.\ext\fts5\fts5_main.c	/^static int fts5InitVtab($/;"	f	file:
fts5IntegrityCheckPgidx	.\ext\fts5\fts5_index.c	/^static void fts5IntegrityCheckPgidx(Fts5Index *p, Fts5Data *pLeaf){$/;"	f	file:
fts5IsContentless	.\ext\fts5\fts5_main.c	/^static int fts5IsContentless(Fts5Table *pTab){$/;"	f	file:
fts5LeafFirstRowidOff	.\ext\fts5\fts5_index.c	500;"	d	file:
fts5LeafFirstTermOff	.\ext\fts5\fts5_index.c	/^static int fts5LeafFirstTermOff(Fts5Data *pLeaf){$/;"	f	file:
fts5LeafIsTermless	.\ext\fts5\fts5_index.c	496;"	d	file:
fts5LeafSeek	.\ext\fts5\fts5_index.c	/^static void fts5LeafSeek($/;"	f	file:
fts5LeafTermOff	.\ext\fts5\fts5_index.c	498;"	d	file:
fts5LocateTokenizer	.\ext\fts5\fts5_main.c	/^static Fts5TokenizerModule *fts5LocateTokenizer($/;"	f	file:
fts5LookaheadReaderInit	.\ext\fts5\fts5_expr.c	/^static int fts5LookaheadReaderInit($/;"	f	file:
fts5LookaheadReaderNext	.\ext\fts5\fts5_expr.c	/^static int fts5LookaheadReaderNext(Fts5LookaheadReader *p){$/;"	f	file:
fts5MatchinfoFlagsize	.\ext\fts5\fts5_test_mi.c	/^static int fts5MatchinfoFlagsize(int nCol, int nPhrase, char f){$/;"	f	file:
fts5MatchinfoFunc	.\ext\fts5\fts5_test_mi.c	/^static void fts5MatchinfoFunc($/;"	f	file:
fts5MatchinfoGlobalCb	.\ext\fts5\fts5_test_mi.c	/^static int fts5MatchinfoGlobalCb($/;"	f	file:
fts5MatchinfoIter	.\ext\fts5\fts5_test_mi.c	/^static int fts5MatchinfoIter($/;"	f	file:
fts5MatchinfoLocalCb	.\ext\fts5\fts5_test_mi.c	/^static int fts5MatchinfoLocalCb($/;"	f	file:
fts5MatchinfoNew	.\ext\fts5\fts5_test_mi.c	/^static Fts5MatchinfoCtx *fts5MatchinfoNew($/;"	f	file:
fts5MatchinfoXCb	.\ext\fts5\fts5_test_mi.c	/^static int fts5MatchinfoXCb($/;"	f	file:
fts5MergeAppendDocid	.\ext\fts5\fts5_index.c	4209;"	d	file:
fts5MergeChunkCallback	.\ext\fts5\fts5_index.c	/^static void fts5MergeChunkCallback($/;"	f	file:
fts5MergePrefixLists	.\ext\fts5\fts5_index.c	/^static void fts5MergePrefixLists($/;"	f	file:
fts5ModuleDestroy	.\ext\fts5\fts5_main.c	/^static void fts5ModuleDestroy(void *pCtx){$/;"	f	file:
fts5MultiIterAdvanceRowid	.\ext\fts5\fts5_index.c	/^static int fts5MultiIterAdvanceRowid($/;"	f	file:
fts5MultiIterAdvanced	.\ext\fts5\fts5_index.c	/^static void fts5MultiIterAdvanced($/;"	f	file:
fts5MultiIterAlloc	.\ext\fts5\fts5_index.c	/^static Fts5IndexIter *fts5MultiIterAlloc($/;"	f	file:
fts5MultiIterDoCompare	.\ext\fts5\fts5_index.c	/^static int fts5MultiIterDoCompare(Fts5IndexIter *pIter, int iOut){$/;"	f	file:
fts5MultiIterEof	.\ext\fts5\fts5_index.c	/^static int fts5MultiIterEof(Fts5Index *p, Fts5IndexIter *pIter){$/;"	f	file:
fts5MultiIterFree	.\ext\fts5\fts5_index.c	/^static void fts5MultiIterFree(Fts5Index *p, Fts5IndexIter *pIter){$/;"	f	file:
fts5MultiIterIsEmpty	.\ext\fts5\fts5_index.c	/^static int fts5MultiIterIsEmpty(Fts5Index *p, Fts5IndexIter *pIter){$/;"	f	file:
fts5MultiIterNew	.\ext\fts5\fts5_index.c	/^static void fts5MultiIterNew($/;"	f	file:
fts5MultiIterNew2	.\ext\fts5\fts5_index.c	/^static void fts5MultiIterNew2($/;"	f	file:
fts5MultiIterNext	.\ext\fts5\fts5_index.c	/^static void fts5MultiIterNext($/;"	f	file:
fts5MultiIterNextFrom	.\ext\fts5\fts5_index.c	/^static void fts5MultiIterNextFrom($/;"	f	file:
fts5MultiIterRowid	.\ext\fts5\fts5_index.c	/^static i64 fts5MultiIterRowid(Fts5IndexIter *pIter){$/;"	f	file:
fts5MultiIterSetEof	.\ext\fts5\fts5_index.c	/^static void fts5MultiIterSetEof(Fts5IndexIter *pIter){$/;"	f	file:
fts5MultiIterTerm	.\ext\fts5\fts5_index.c	/^static const u8 *fts5MultiIterTerm(Fts5IndexIter *pIter, int *pn){$/;"	f	file:
fts5NextMethod	.\ext\fts5\fts5_main.c	/^static int fts5NextMethod(sqlite3_vtab_cursor *pCursor){$/;"	f	file:
fts5NodeCompare	.\ext\fts5\fts5_expr.c	/^static int fts5NodeCompare($/;"	f	file:
fts5OpenMethod	.\ext\fts5\fts5_main.c	/^static int fts5OpenMethod(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCsr){$/;"	f	file:
fts5ParseAlloc	.\ext\fts5\fts5_expr.c	/^static void *fts5ParseAlloc(u64 t){ return sqlite3_malloc((int)t); }$/;"	f	file:
fts5ParseColset	.\ext\fts5\fts5_expr.c	/^static Fts5Colset *fts5ParseColset($/;"	f	file:
fts5ParseFree	.\ext\fts5\fts5_expr.c	/^static void fts5ParseFree(void *p){ sqlite3_free(p); }$/;"	f	file:
fts5ParseStringFromToken	.\ext\fts5\fts5_expr.c	/^static int fts5ParseStringFromToken(Fts5Token *pToken, char **pz){$/;"	f	file:
fts5ParseTokenize	.\ext\fts5\fts5_expr.c	/^static int fts5ParseTokenize($/;"	f	file:
fts5PorterCb	.\ext\fts5\fts5_tokenize.c	/^static int fts5PorterCb($/;"	f	file:
fts5PorterCreate	.\ext\fts5\fts5_tokenize.c	/^static int fts5PorterCreate($/;"	f	file:
fts5PorterDelete	.\ext\fts5\fts5_tokenize.c	/^static void fts5PorterDelete(Fts5Tokenizer *pTok){$/;"	f	file:
fts5PorterGobbleVC	.\ext\fts5\fts5_tokenize.c	/^static int fts5PorterGobbleVC(char *zStem, int nStem, int bPrevCons){$/;"	f	file:
fts5PorterIsVowel	.\ext\fts5\fts5_tokenize.c	/^static int fts5PorterIsVowel(char c, int bYIsVowel){$/;"	f	file:
fts5PorterStep1A	.\ext\fts5\fts5_tokenize.c	/^static void fts5PorterStep1A(char *aBuf, int *pnBuf){$/;"	f	file:
fts5PorterStep1B	.\ext\fts5\fts5_tokenize.c	/^static int fts5PorterStep1B(char *aBuf, int *pnBuf){$/;"	f	file:
fts5PorterStep1B2	.\ext\fts5\fts5_tokenize.c	/^static int fts5PorterStep1B2(char *aBuf, int *pnBuf){$/;"	f	file:
fts5PorterStep2	.\ext\fts5\fts5_tokenize.c	/^static int fts5PorterStep2(char *aBuf, int *pnBuf){$/;"	f	file:
fts5PorterStep3	.\ext\fts5\fts5_tokenize.c	/^static int fts5PorterStep3(char *aBuf, int *pnBuf){$/;"	f	file:
fts5PorterStep4	.\ext\fts5\fts5_tokenize.c	/^static int fts5PorterStep4(char *aBuf, int *pnBuf){$/;"	f	file:
fts5PorterTokenize	.\ext\fts5\fts5_tokenize.c	/^static int fts5PorterTokenize($/;"	f	file:
fts5Porter_MEq1	.\ext\fts5\fts5_tokenize.c	/^static int fts5Porter_MEq1(char *zStem, int nStem){$/;"	f	file:
fts5Porter_MGt0	.\ext\fts5\fts5_tokenize.c	/^static int fts5Porter_MGt0(char *zStem, int nStem){$/;"	f	file:
fts5Porter_MGt1	.\ext\fts5\fts5_tokenize.c	/^static int fts5Porter_MGt1(char *zStem, int nStem){$/;"	f	file:
fts5Porter_MGt1_and_S_or_T	.\ext\fts5\fts5_tokenize.c	/^static int fts5Porter_MGt1_and_S_or_T(char *zStem, int nStem){$/;"	f	file:
fts5Porter_Ostar	.\ext\fts5\fts5_tokenize.c	/^static int fts5Porter_Ostar(char *zStem, int nStem){$/;"	f	file:
fts5Porter_Vowel	.\ext\fts5\fts5_tokenize.c	/^static int fts5Porter_Vowel(char *zStem, int nStem){$/;"	f	file:
fts5PoslistBlob	.\ext\fts5\fts5_main.c	/^static int fts5PoslistBlob(sqlite3_context *pCtx, Fts5Cursor *pCsr){$/;"	f	file:
fts5PoslistCallback	.\ext\fts5\fts5_index.c	/^static void fts5PoslistCallback($/;"	f	file:
fts5PoslistFilterCallback	.\ext\fts5\fts5_index.c	/^static void fts5PoslistFilterCallback($/;"	f	file:
fts5PoslistPrefix	.\ext\fts5\fts5_index.c	/^static int fts5PoslistPrefix(const u8 *aBuf, int nMax){$/;"	f	file:
fts5PrefixCompress	.\ext\fts5\fts5_index.c	/^static int fts5PrefixCompress($/;"	f	file:
fts5PrintStructure	.\ext\fts5\fts5_index.c	1066;"	d	file:
fts5PrintfAppend	.\ext\fts5\fts5_expr.c	/^static char *fts5PrintfAppend(char *zApp, const char *zFmt, ...){$/;"	f	file:
fts5PutU16	.\ext\fts5\fts5_index.c	/^static void fts5PutU16(u8 *aOut, u16 iVal){$/;"	f	file:
fts5PutVarint64	.\ext\fts5\fts5_varint.c	/^static int FTS5_NOINLINE fts5PutVarint64(unsigned char *p, u64 v){$/;"	f	file:
fts5QueryCksum	.\ext\fts5\fts5_index.c	/^static int fts5QueryCksum($/;"	f	file:
fts5ReleaseMethod	.\ext\fts5\fts5_main.c	/^static int fts5ReleaseMethod(sqlite3_vtab *pVtab, int iSavepoint){$/;"	f	file:
fts5RenameMethod	.\ext\fts5\fts5_main.c	/^static int fts5RenameMethod($/;"	f	file:
fts5RollbackMethod	.\ext\fts5\fts5_main.c	/^static int fts5RollbackMethod(sqlite3_vtab *pVtab){$/;"	f	file:
fts5RollbackToMethod	.\ext\fts5\fts5_main.c	/^static int fts5RollbackToMethod(sqlite3_vtab *pVtab, int iSavepoint){$/;"	f	file:
fts5RowidCmp	.\ext\fts5\fts5_expr.c	/^static int fts5RowidCmp($/;"	f	file:
fts5RowidFunction	.\ext\fts5\fts5_index.c	/^static void fts5RowidFunction($/;"	f	file:
fts5RowidMethod	.\ext\fts5\fts5_main.c	/^static int fts5RowidMethod(sqlite3_vtab_cursor *pCursor, sqlite_int64 *pRowid){$/;"	f	file:
fts5SavepointMethod	.\ext\fts5\fts5_main.c	/^static int fts5SavepointMethod(sqlite3_vtab *pVtab, int iSavepoint){$/;"	f	file:
fts5SeekCursor	.\ext\fts5\fts5_main.c	/^static int fts5SeekCursor(Fts5Cursor *pCsr, int bErrormsg){$/;"	f	file:
fts5SegIterClear	.\ext\fts5\fts5_index.c	/^static void fts5SegIterClear(Fts5SegIter *pIter){$/;"	f	file:
fts5SegIterGotoPage	.\ext\fts5\fts5_index.c	/^static void fts5SegIterGotoPage($/;"	f	file:
fts5SegIterHashInit	.\ext\fts5\fts5_index.c	/^static void fts5SegIterHashInit($/;"	f	file:
fts5SegIterInit	.\ext\fts5\fts5_index.c	/^static void fts5SegIterInit($/;"	f	file:
fts5SegIterLoadDlidx	.\ext\fts5\fts5_index.c	/^static void fts5SegIterLoadDlidx(Fts5Index *p, Fts5SegIter *pIter){$/;"	f	file:
fts5SegIterLoadNPos	.\ext\fts5\fts5_index.c	/^static void fts5SegIterLoadNPos(Fts5Index *p, Fts5SegIter *pIter){$/;"	f	file:
fts5SegIterLoadRowid	.\ext\fts5\fts5_index.c	/^static void fts5SegIterLoadRowid(Fts5Index *p, Fts5SegIter *pIter){$/;"	f	file:
fts5SegIterLoadTerm	.\ext\fts5\fts5_index.c	/^static void fts5SegIterLoadTerm(Fts5Index *p, Fts5SegIter *pIter, int nKeep){$/;"	f	file:
fts5SegIterNext	.\ext\fts5\fts5_index.c	/^static void fts5SegIterNext($/;"	f	file:
fts5SegIterNextFrom	.\ext\fts5\fts5_index.c	/^static void fts5SegIterNextFrom($/;"	f	file:
fts5SegIterNextPage	.\ext\fts5\fts5_index.c	/^static void fts5SegIterNextPage($/;"	f	file:
fts5SegIterReverse	.\ext\fts5\fts5_index.c	/^static void fts5SegIterReverse(Fts5Index *p, Fts5SegIter *pIter){$/;"	f	file:
fts5SegIterReverseInitPage	.\ext\fts5\fts5_index.c	/^static void fts5SegIterReverseInitPage(Fts5Index *p, Fts5SegIter *pIter){$/;"	f	file:
fts5SegIterReverseNewPage	.\ext\fts5\fts5_index.c	/^static void fts5SegIterReverseNewPage(Fts5Index *p, Fts5SegIter *pIter){$/;"	f	file:
fts5SegIterSeekInit	.\ext\fts5\fts5_index.c	/^static void fts5SegIterSeekInit($/;"	f	file:
fts5SegiterPoslist	.\ext\fts5\fts5_index.c	/^static void fts5SegiterPoslist($/;"	f	file:
fts5SegmentSize	.\ext\fts5\fts5_index.c	/^static int fts5SegmentSize(Fts5StructureSegment *pSeg){$/;"	f	file:
fts5SetUniqueFlag	.\ext\fts5\fts5_main.c	/^static void fts5SetUniqueFlag(sqlite3_index_info *pIdxInfo){$/;"	f	file:
fts5SetVtabError	.\ext\fts5\fts5_main.c	/^static void fts5SetVtabError(Fts5Table *p, const char *zFormat, ...){$/;"	f	file:
fts5SetupPrefixIter	.\ext\fts5\fts5_index.c	/^static void fts5SetupPrefixIter($/;"	f	file:
fts5SnippetFunction	.\ext\fts5\fts5_aux.c	/^static void fts5SnippetFunction($/;"	f	file:
fts5SorterNext	.\ext\fts5\fts5_main.c	/^static int fts5SorterNext(Fts5Cursor *pCsr){$/;"	f	file:
fts5SourceIdFunc	.\ext\fts5\fts5_main.c	/^static void fts5SourceIdFunc($/;"	f	file:
fts5SpecialDelete	.\ext\fts5\fts5_main.c	/^static int fts5SpecialDelete($/;"	f	file:
fts5SpecialInsert	.\ext\fts5\fts5_main.c	/^static int fts5SpecialInsert($/;"	f	file:
fts5SpecialMatch	.\ext\fts5\fts5_main.c	/^static int fts5SpecialMatch($/;"	f	file:
fts5StmtType	.\ext\fts5\fts5_main.c	/^static int fts5StmtType(Fts5Cursor *pCsr){$/;"	f	file:
fts5StorageCount	.\ext\fts5\fts5_storage.c	/^static int fts5StorageCount(Fts5Storage *p, const char *zSuffix, i64 *pnRow){$/;"	f	file:
fts5StorageDecodeSizeArray	.\ext\fts5\fts5_storage.c	/^static int fts5StorageDecodeSizeArray($/;"	f	file:
fts5StorageDeleteFromIndex	.\ext\fts5\fts5_storage.c	/^static int fts5StorageDeleteFromIndex(Fts5Storage *p, i64 iDel){$/;"	f	file:
fts5StorageGetStmt	.\ext\fts5\fts5_storage.c	/^static int fts5StorageGetStmt($/;"	f	file:
fts5StorageInsert	.\ext\fts5\fts5_main.c	/^static void fts5StorageInsert($/;"	f	file:
fts5StorageInsertCallback	.\ext\fts5\fts5_storage.c	/^static int fts5StorageInsertCallback($/;"	f	file:
fts5StorageInsertDocsize	.\ext\fts5\fts5_storage.c	/^static int fts5StorageInsertDocsize($/;"	f	file:
fts5StorageIntegrityCallback	.\ext\fts5\fts5_storage.c	/^static int fts5StorageIntegrityCallback($/;"	f	file:
fts5StorageLoadTotals	.\ext\fts5\fts5_storage.c	/^static int fts5StorageLoadTotals(Fts5Storage *p, int bCache){$/;"	f	file:
fts5StorageNewRowid	.\ext\fts5\fts5_storage.c	/^static int fts5StorageNewRowid(Fts5Storage *p, i64 *piRowid){$/;"	f	file:
fts5StorageRenameOne	.\ext\fts5\fts5_storage.c	/^static void fts5StorageRenameOne($/;"	f	file:
fts5StorageSaveTotals	.\ext\fts5\fts5_storage.c	/^static int fts5StorageSaveTotals(Fts5Storage *p){$/;"	f	file:
fts5StructureAddLevel	.\ext\fts5\fts5_index.c	/^static void fts5StructureAddLevel(int *pRc, Fts5Structure **ppStruct){$/;"	f	file:
fts5StructureCountSegments	.\ext\fts5\fts5_index.c	/^static int fts5StructureCountSegments(Fts5Structure *pStruct){$/;"	f	file:
fts5StructureDecode	.\ext\fts5\fts5_index.c	/^static int fts5StructureDecode($/;"	f	file:
fts5StructureExtendLevel	.\ext\fts5\fts5_index.c	/^static void fts5StructureExtendLevel($/;"	f	file:
fts5StructurePromote	.\ext\fts5\fts5_index.c	/^static void fts5StructurePromote($/;"	f	file:
fts5StructurePromoteTo	.\ext\fts5\fts5_index.c	/^static void fts5StructurePromoteTo($/;"	f	file:
fts5StructureRead	.\ext\fts5\fts5_index.c	/^static Fts5Structure *fts5StructureRead(Fts5Index *p){$/;"	f	file:
fts5StructureRef	.\ext\fts5\fts5_index.c	/^static void fts5StructureRef(Fts5Structure *pStruct){$/;"	f	file:
fts5StructureRelease	.\ext\fts5\fts5_index.c	/^static void fts5StructureRelease(Fts5Structure *pStruct){$/;"	f	file:
fts5StructureWrite	.\ext\fts5\fts5_index.c	/^static void fts5StructureWrite(Fts5Index *p, Fts5Structure *pStruct){$/;"	f	file:
fts5SyncMethod	.\ext\fts5\fts5_main.c	/^static int fts5SyncMethod(sqlite3_vtab *pVtab){$/;"	f	file:
fts5TestDlidxReverse	.\ext\fts5\fts5_index.c	/^static void fts5TestDlidxReverse($/;"	f	file:
fts5TestDlidxReverse	.\ext\fts5\fts5_index.c	5054;"	d	file:
fts5TestTerm	.\ext\fts5\fts5_index.c	/^static void fts5TestTerm($/;"	f	file:
fts5TestTerm	.\ext\fts5\fts5_index.c	5055;"	d	file:
fts5TrimSegments	.\ext\fts5\fts5_index.c	/^static void fts5TrimSegments(Fts5Index *p, Fts5IndexIter *pIter){$/;"	f	file:
fts5TripCursors	.\ext\fts5\fts5_main.c	/^static void fts5TripCursors(Fts5Table *pTab){$/;"	f	file:
fts5UnicodeAddExceptions	.\ext\fts5\fts5_tokenize.c	/^static int fts5UnicodeAddExceptions($/;"	f	file:
fts5UnicodeCreate	.\ext\fts5\fts5_tokenize.c	/^static int fts5UnicodeCreate($/;"	f	file:
fts5UnicodeDelete	.\ext\fts5\fts5_tokenize.c	/^static void fts5UnicodeDelete(Fts5Tokenizer *pTok){$/;"	f	file:
fts5UnicodeIsAlnum	.\ext\fts5\fts5_tokenize.c	/^static int fts5UnicodeIsAlnum(Unicode61Tokenizer *p, int iCode){$/;"	f	file:
fts5UnicodeIsException	.\ext\fts5\fts5_tokenize.c	/^static int fts5UnicodeIsException(Unicode61Tokenizer *p, int iCode){$/;"	f	file:
fts5UnicodeTokenize	.\ext\fts5\fts5_tokenize.c	/^static int fts5UnicodeTokenize($/;"	f	file:
fts5UpdateMethod	.\ext\fts5\fts5_main.c	/^static int fts5UpdateMethod($/;"	f	file:
fts5VocabBestIndexMethod	.\ext\fts5\fts5_vocab.c	/^static int fts5VocabBestIndexMethod($/;"	f	file:
fts5VocabCloseMethod	.\ext\fts5\fts5_vocab.c	/^static int fts5VocabCloseMethod(sqlite3_vtab_cursor *pCursor){$/;"	f	file:
fts5VocabColumnMethod	.\ext\fts5\fts5_vocab.c	/^static int fts5VocabColumnMethod($/;"	f	file:
fts5VocabConnectMethod	.\ext\fts5\fts5_vocab.c	/^static int fts5VocabConnectMethod($/;"	f	file:
fts5VocabCreateMethod	.\ext\fts5\fts5_vocab.c	/^static int fts5VocabCreateMethod($/;"	f	file:
fts5VocabDestroyMethod	.\ext\fts5\fts5_vocab.c	/^static int fts5VocabDestroyMethod(sqlite3_vtab *pVtab){$/;"	f	file:
fts5VocabDisconnectMethod	.\ext\fts5\fts5_vocab.c	/^static int fts5VocabDisconnectMethod(sqlite3_vtab *pVtab){$/;"	f	file:
fts5VocabEofMethod	.\ext\fts5\fts5_vocab.c	/^static int fts5VocabEofMethod(sqlite3_vtab_cursor *pCursor){$/;"	f	file:
fts5VocabFilterMethod	.\ext\fts5\fts5_vocab.c	/^static int fts5VocabFilterMethod($/;"	f	file:
fts5VocabInitVtab	.\ext\fts5\fts5_vocab.c	/^static int fts5VocabInitVtab($/;"	f	file:
fts5VocabNextMethod	.\ext\fts5\fts5_vocab.c	/^static int fts5VocabNextMethod(sqlite3_vtab_cursor *pCursor){$/;"	f	file:
fts5VocabOpenMethod	.\ext\fts5\fts5_vocab.c	/^static int fts5VocabOpenMethod($/;"	f	file:
fts5VocabResetCursor	.\ext\fts5\fts5_vocab.c	/^static void fts5VocabResetCursor(Fts5VocabCursor *pCsr){$/;"	f	file:
fts5VocabRowidMethod	.\ext\fts5\fts5_vocab.c	/^static int fts5VocabRowidMethod($/;"	f	file:
fts5VocabTableType	.\ext\fts5\fts5_vocab.c	/^static int fts5VocabTableType(const char *zType, char **pzErr, int *peType){$/;"	f	file:
fts5WriteAppendPoslistData	.\ext\fts5\fts5_index.c	/^static void fts5WriteAppendPoslistData($/;"	f	file:
fts5WriteAppendRowid	.\ext\fts5\fts5_index.c	/^static void fts5WriteAppendRowid($/;"	f	file:
fts5WriteAppendTerm	.\ext\fts5\fts5_index.c	/^static void fts5WriteAppendTerm($/;"	f	file:
fts5WriteBtreeNoTerm	.\ext\fts5\fts5_index.c	/^static void fts5WriteBtreeNoTerm($/;"	f	file:
fts5WriteBtreeTerm	.\ext\fts5\fts5_index.c	/^static void fts5WriteBtreeTerm($/;"	f	file:
fts5WriteDlidxAppend	.\ext\fts5\fts5_index.c	/^static void fts5WriteDlidxAppend($/;"	f	file:
fts5WriteDlidxClear	.\ext\fts5\fts5_index.c	/^static void fts5WriteDlidxClear($/;"	f	file:
fts5WriteDlidxGrow	.\ext\fts5\fts5_index.c	/^static int fts5WriteDlidxGrow($/;"	f	file:
fts5WriteFinish	.\ext\fts5\fts5_index.c	/^static void fts5WriteFinish($/;"	f	file:
fts5WriteFlushBtree	.\ext\fts5\fts5_index.c	/^static void fts5WriteFlushBtree(Fts5Index *p, Fts5SegWriter *pWriter){$/;"	f	file:
fts5WriteFlushDlidx	.\ext\fts5\fts5_index.c	/^static int fts5WriteFlushDlidx(Fts5Index *p, Fts5SegWriter *pWriter){$/;"	f	file:
fts5WriteFlushLeaf	.\ext\fts5\fts5_index.c	/^static void fts5WriteFlushLeaf(Fts5Index *p, Fts5SegWriter *pWriter){$/;"	f	file:
fts5WriteInit	.\ext\fts5\fts5_index.c	/^static void fts5WriteInit($/;"	f	file:
fts5_api	.\ext\fts5\fts5.h	/^struct fts5_api {$/;"	s
fts5_api	.\ext\fts5\fts5.h	/^typedef struct fts5_api fts5_api;$/;"	t	typeref:struct:fts5_api
fts5_api_from_db	.\ext\fts5\fts5_test_mi.c	/^static fts5_api *fts5_api_from_db(sqlite3 *db){$/;"	f	file:
fts5_aux_test_functions	.\ext\fts5\test\fts5_common.tcl	/^proc fts5_aux_test_functions {db} {$/;"	p
fts5_dri	.\ext\fts5\fts5_index.c	232;"	d	file:
fts5_extension_function	.\ext\fts5\fts5.h	/^typedef void (*fts5_extension_function)($/;"	t
fts5_isdigit	.\ext\fts5\fts5_config.c	/^static int fts5_isdigit(char a){$/;"	f	file:
fts5_isopenquote	.\ext\fts5\fts5_config.c	/^static int fts5_isopenquote(char x){$/;"	f	file:
fts5_iswhitespace	.\ext\fts5\fts5_config.c	/^static int fts5_iswhitespace(char x){$/;"	f	file:
fts5_level_segids	.\ext\fts5\test\fts5_common.tcl	/^proc fts5_level_segids {tbl} {$/;"	p
fts5_level_segs	.\ext\fts5\test\fts5_common.tcl	/^proc fts5_level_segs {tbl} {$/;"	p
fts5_remove_diacritic	.\ext\fts5\fts5_unicode2.c	/^static int fts5_remove_diacritic(int c){$/;"	f	file:
fts5_rnddoc	.\ext\fts5\test\fts5_common.tcl	/^proc fts5_rnddoc {n} {$/;"	p
fts5_source_id	.\ext\fts5\tool\mkfts5c.tcl	/^proc fts5_source_id {zDir} {$/;"	p
fts5_test_all	.\ext\fts5\test\fts5_common.tcl	/^proc fts5_test_all {cmd} {$/;"	p
fts5_test_columnsize	.\ext\fts5\test\fts5_common.tcl	/^proc fts5_test_columnsize {cmd} {$/;"	p
fts5_test_columntext	.\ext\fts5\test\fts5_common.tcl	/^proc fts5_test_columntext {cmd} {$/;"	p
fts5_test_columntotalsize	.\ext\fts5\test\fts5_common.tcl	/^proc fts5_test_columntotalsize {cmd} {$/;"	p
fts5_test_phrasecount	.\ext\fts5\test\fts5_common.tcl	/^proc fts5_test_phrasecount {cmd} {$/;"	p
fts5_test_poslist	.\ext\fts5\test\fts5_common.tcl	/^proc fts5_test_poslist {cmd} {$/;"	p
fts5_test_queryphrase	.\ext\fts5\test\fts5_common.tcl	/^proc fts5_test_queryphrase {cmd} {$/;"	p
fts5_test_rowcount	.\ext\fts5\test\fts5_common.tcl	/^proc fts5_test_rowcount {cmd} {$/;"	p
fts5_test_tokenize	.\ext\fts5\test\fts5_common.tcl	/^proc fts5_test_tokenize {cmd} {$/;"	p
fts5_tokenize_split	.\ext\fts5\test\fts5_common.tcl	/^proc fts5_tokenize_split {text} {$/;"	p
fts5_tokenizer	.\ext\fts5\fts5.h	/^struct fts5_tokenizer {$/;"	s
fts5_tokenizer	.\ext\fts5\fts5.h	/^typedef struct fts5_tokenizer fts5_tokenizer;$/;"	t	typeref:struct:fts5_tokenizer
fts5c_close	.\ext\fts5\tool\mkfts5c.tcl	/^proc fts5c_close {} {$/;"	p
fts5c_init	.\ext\fts5\tool\mkfts5c.tcl	/^proc fts5c_init {zOut} {$/;"	p
fts5c_printfile	.\ext\fts5\tool\mkfts5c.tcl	/^proc fts5c_printfile {zIn} {$/;"	p
ftsCompareFunction	.\ext\fts3\fts3_hash.c	/^static int (*ftsCompareFunction(int keyClass))(const void*,int,const void*,int){$/;"	f	file:
ftsHashFunction	.\ext\fts3\fts3_hash.c	/^static int (*ftsHashFunction(int keyClass))(const void*,int){$/;"	f	file:
fts_kjv_genesis	.\test\genesis.tcl	/^proc fts_kjv_genesis {} {$/;"	p
fullSync	.\src\pager.c	/^  u8 fullSync;                \/* Do extra syncs of the journal for robustness *\/$/;"	m	struct:Pager	file:
full_err	.\src\test_vfs.c	/^  TestFaultInject full_err;$/;"	m	struct:Testvfs	file:
full_fsync	.\src\os_unix.c	/^static int full_fsync(int fd, int fullSync, int dataOnly){$/;"	f	file:
fullerr_injectinstall	.\test\malloc_common.tcl	/^proc fullerr_injectinstall {} {$/;"	p
fullerr_injectstart	.\test\malloc_common.tcl	/^proc fullerr_injectstart {iFail} {$/;"	p
fullerr_injectstop	.\test\malloc_common.tcl	/^proc fullerr_injectstop {} {$/;"	p
fullerr_injectuninstall	.\test\malloc_common.tcl	/^proc fullerr_injectuninstall {} {$/;"	p
fulltextBegin	.\ext\fts2\fts2.c	/^static int fulltextBegin(sqlite3_vtab *pVtab){$/;"	f	file:
fulltextBestIndex	.\ext\fts1\fts1.c	/^static int fulltextBestIndex(sqlite3_vtab *pVTab, sqlite3_index_info *pInfo){$/;"	f	file:
fulltextBestIndex	.\ext\fts1\fulltext.c	/^static int fulltextBestIndex(sqlite3_vtab *pVTab, sqlite3_index_info *pInfo){$/;"	f	file:
fulltextBestIndex	.\ext\fts2\fts2.c	/^static int fulltextBestIndex(sqlite3_vtab *pVTab, sqlite3_index_info *pInfo){$/;"	f	file:
fulltextClose	.\ext\fts1\fts1.c	/^static int fulltextClose(sqlite3_vtab_cursor *pCursor){$/;"	f	file:
fulltextClose	.\ext\fts1\fulltext.c	/^static int fulltextClose(sqlite3_vtab_cursor *pCursor){$/;"	f	file:
fulltextClose	.\ext\fts2\fts2.c	/^static int fulltextClose(sqlite3_vtab_cursor *pCursor){$/;"	f	file:
fulltextColumn	.\ext\fts1\fts1.c	/^static int fulltextColumn(sqlite3_vtab_cursor *pCursor,$/;"	f	file:
fulltextColumn	.\ext\fts1\fulltext.c	/^static int fulltextColumn(sqlite3_vtab_cursor *pCursor,$/;"	f	file:
fulltextColumn	.\ext\fts2\fts2.c	/^static int fulltextColumn(sqlite3_vtab_cursor *pCursor,$/;"	f	file:
fulltextCommit	.\ext\fts2\fts2.c	/^static int fulltextCommit(sqlite3_vtab *pVtab){$/;"	f	file:
fulltextConnect	.\ext\fts1\fts1.c	/^static int fulltextConnect($/;"	f	file:
fulltextConnect	.\ext\fts1\fulltext.c	/^static int fulltextConnect($/;"	f	file:
fulltextConnect	.\ext\fts2\fts2.c	/^static int fulltextConnect($/;"	f	file:
fulltextCreate	.\ext\fts1\fts1.c	/^static int fulltextCreate(sqlite3 *db, void *pAux,$/;"	f	file:
fulltextCreate	.\ext\fts1\fulltext.c	/^static int fulltextCreate($/;"	f	file:
fulltextCreate	.\ext\fts2\fts2.c	/^static int fulltextCreate(sqlite3 *db, void *pAux,$/;"	f	file:
fulltextDestroy	.\ext\fts1\fts1.c	/^static int fulltextDestroy(sqlite3_vtab *pVTab){$/;"	f	file:
fulltextDestroy	.\ext\fts1\fulltext.c	/^static int fulltextDestroy(sqlite3_vtab *pVTab){$/;"	f	file:
fulltextDestroy	.\ext\fts2\fts2.c	/^static int fulltextDestroy(sqlite3_vtab *pVTab){$/;"	f	file:
fulltextDisconnect	.\ext\fts1\fts1.c	/^static int fulltextDisconnect(sqlite3_vtab *pVTab){$/;"	f	file:
fulltextDisconnect	.\ext\fts1\fulltext.c	/^static int fulltextDisconnect(sqlite3_vtab *pVTab){$/;"	f	file:
fulltextDisconnect	.\ext\fts2\fts2.c	/^static int fulltextDisconnect(sqlite3_vtab *pVTab){$/;"	f	file:
fulltextEof	.\ext\fts1\fts1.c	/^static int fulltextEof(sqlite3_vtab_cursor *pCursor){$/;"	f	file:
fulltextEof	.\ext\fts1\fulltext.c	/^static int fulltextEof(sqlite3_vtab_cursor *pCursor){$/;"	f	file:
fulltextEof	.\ext\fts2\fts2.c	/^static int fulltextEof(sqlite3_vtab_cursor *pCursor){$/;"	f	file:
fulltextFilter	.\ext\fts1\fts1.c	/^static int fulltextFilter($/;"	f	file:
fulltextFilter	.\ext\fts1\fulltext.c	/^static int fulltextFilter(sqlite3_vtab_cursor *pCursor,$/;"	f	file:
fulltextFilter	.\ext\fts2\fts2.c	/^static int fulltextFilter($/;"	f	file:
fulltextFindFunction	.\ext\fts1\fts1.c	/^static int fulltextFindFunction($/;"	f	file:
fulltextFindFunction	.\ext\fts2\fts2.c	/^static int fulltextFindFunction($/;"	f	file:
fulltextModule	.\ext\fts1\fts1.c	/^static const sqlite3_module fulltextModule = {$/;"	v	file:
fulltextModule	.\ext\fts1\fts1.c	/^static const sqlite3_module fulltextModule;   \/* forward declaration *\/$/;"	v	file:
fulltextModule	.\ext\fts1\fulltext.c	/^static sqlite3_module fulltextModule = {$/;"	v	file:
fulltextModule	.\ext\fts1\fulltext.c	/^static sqlite3_module fulltextModule;   \/* forward declaration *\/$/;"	v	file:
fulltextNext	.\ext\fts1\fts1.c	/^static int fulltextNext(sqlite3_vtab_cursor *pCursor){$/;"	f	file:
fulltextNext	.\ext\fts1\fulltext.c	/^static int fulltextNext(sqlite3_vtab_cursor *pCursor){$/;"	f	file:
fulltextNext	.\ext\fts2\fts2.c	/^static int fulltextNext(sqlite3_vtab_cursor *pCursor){$/;"	f	file:
fulltextOpen	.\ext\fts1\fts1.c	/^static int fulltextOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor){$/;"	f	file:
fulltextOpen	.\ext\fts1\fulltext.c	/^static int fulltextOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor){$/;"	f	file:
fulltextOpen	.\ext\fts2\fts2.c	/^static int fulltextOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor){$/;"	f	file:
fulltextQuery	.\ext\fts1\fts1.c	/^static int fulltextQuery($/;"	f	file:
fulltextQuery	.\ext\fts2\fts2.c	/^static int fulltextQuery($/;"	f	file:
fulltextRename	.\ext\fts1\fts1.c	/^static int fulltextRename($/;"	f	file:
fulltextRename	.\ext\fts2\fts2.c	/^static int fulltextRename($/;"	f	file:
fulltextRollback	.\ext\fts2\fts2.c	/^static int fulltextRollback(sqlite3_vtab *pVtab){$/;"	f	file:
fulltextRowid	.\ext\fts1\fts1.c	/^static int fulltextRowid(sqlite3_vtab_cursor *pCursor, sqlite_int64 *pRowid){$/;"	f	file:
fulltextRowid	.\ext\fts1\fulltext.c	/^static int fulltextRowid(sqlite3_vtab_cursor *pCursor, sqlite_int64 *pRowid){$/;"	f	file:
fulltextRowid	.\ext\fts2\fts2.c	/^static int fulltextRowid(sqlite3_vtab_cursor *pCursor, sqlite_int64 *pRowid){$/;"	f	file:
fulltextSchema	.\ext\fts1\fts1.c	/^static char *fulltextSchema($/;"	f	file:
fulltextSchema	.\ext\fts2\fts2.c	/^static char *fulltextSchema($/;"	f	file:
fulltextSync	.\ext\fts2\fts2.c	/^static int fulltextSync(sqlite3_vtab *pVtab){$/;"	f	file:
fulltextUpdate	.\ext\fts1\fts1.c	/^static int fulltextUpdate(sqlite3_vtab *pVtab, int nArg, sqlite3_value **ppArg,$/;"	f	file:
fulltextUpdate	.\ext\fts1\fulltext.c	/^static int fulltextUpdate(sqlite3_vtab *pVtab, int nArg, sqlite3_value **ppArg,$/;"	f	file:
fulltextUpdate	.\ext\fts2\fts2.c	/^static int fulltextUpdate(sqlite3_vtab *pVtab, int nArg, sqlite3_value **ppArg,$/;"	f	file:
fulltext_cursor	.\ext\fts1\fts1.c	/^typedef struct fulltext_cursor {$/;"	s	file:
fulltext_cursor	.\ext\fts1\fts1.c	/^} fulltext_cursor;$/;"	t	typeref:struct:fulltext_cursor	file:
fulltext_cursor	.\ext\fts1\fulltext.c	/^typedef struct fulltext_cursor {$/;"	s	file:
fulltext_cursor	.\ext\fts1\fulltext.c	/^} fulltext_cursor;$/;"	t	typeref:struct:fulltext_cursor	file:
fulltext_cursor	.\ext\fts2\fts2.c	/^typedef struct fulltext_cursor {$/;"	s	file:
fulltext_cursor	.\ext\fts2\fts2.c	/^} fulltext_cursor;$/;"	t	typeref:struct:fulltext_cursor	file:
fulltext_init	.\ext\fts1\fulltext.c	/^int fulltext_init(sqlite3 *db){$/;"	f
fulltext_query	.\ext\fts1\fulltext.c	/^static int fulltext_query(fulltext_vtab *v, const char *zQuery,$/;"	f	file:
fulltext_statement	.\ext\fts1\fts1.c	/^typedef enum fulltext_statement {$/;"	g	file:
fulltext_statement	.\ext\fts1\fts1.c	/^} fulltext_statement;$/;"	t	typeref:enum:fulltext_statement	file:
fulltext_statement	.\ext\fts1\fulltext.c	/^typedef enum fulltext_statement {$/;"	g	file:
fulltext_statement	.\ext\fts1\fulltext.c	/^} fulltext_statement;$/;"	t	typeref:enum:fulltext_statement	file:
fulltext_statement	.\ext\fts2\fts2.c	/^typedef enum fulltext_statement {$/;"	g	file:
fulltext_statement	.\ext\fts2\fts2.c	/^} fulltext_statement;$/;"	t	typeref:enum:fulltext_statement	file:
fulltext_vtab	.\ext\fts1\fts1.c	/^struct fulltext_vtab {$/;"	s	file:
fulltext_vtab	.\ext\fts1\fts1.c	/^typedef struct fulltext_vtab fulltext_vtab;$/;"	t	typeref:struct:fulltext_vtab	file:
fulltext_vtab	.\ext\fts1\fulltext.c	/^typedef struct fulltext_vtab {$/;"	s	file:
fulltext_vtab	.\ext\fts1\fulltext.c	/^} fulltext_vtab;$/;"	t	typeref:struct:fulltext_vtab	file:
fulltext_vtab	.\ext\fts2\fts2.c	/^struct fulltext_vtab {$/;"	s	file:
fulltext_vtab	.\ext\fts2\fts2.c	/^typedef struct fulltext_vtab fulltext_vtab;$/;"	t	typeref:struct:fulltext_vtab	file:
fulltext_vtab_destroy	.\ext\fts1\fts1.c	/^static void fulltext_vtab_destroy(fulltext_vtab *v){$/;"	f	file:
fulltext_vtab_destroy	.\ext\fts1\fulltext.c	/^static void fulltext_vtab_destroy(fulltext_vtab *v){$/;"	f	file:
fulltext_vtab_destroy	.\ext\fts2\fts2.c	/^static void fulltext_vtab_destroy(fulltext_vtab *v){$/;"	f	file:
fulltext_zStatement	.\ext\fts1\fts1.c	/^static const char *const fulltext_zStatement[MAX_STMT] = {$/;"	v	file:
fulltext_zStatement	.\ext\fts1\fulltext.c	/^static const char *fulltext_zStatement[MAX_STMT] = {$/;"	v	file:
fulltext_zStatement	.\ext\fts2\fts2.c	/^static const char *const fulltext_zStatement[MAX_STMT] = {$/;"	v	file:
funcFlags	.\src\sqliteInt.h	/^  u16 funcFlags;       \/* Some combination of SQLITE_FUNC_* *\/$/;"	m	struct:FuncDef
func_append	.\autoconf\ltmain.sh	/^func_append ()$/;"	f
func_append_quoted	.\autoconf\ltmain.sh	/^func_append_quoted ()$/;"	f
func_arith	.\autoconf\ltmain.sh	/^func_arith ()$/;"	f
func_basename	.\autoconf\ltmain.sh	/^func_basename ()$/;"	f
func_check_version_match	.\autoconf\ltmain.sh	/^func_check_version_match ()$/;"	f
func_check_version_match	.\ltmain.sh	/^func_check_version_match ()$/;"	f
func_config	.\autoconf\ltmain.sh	/^func_config ()$/;"	f
func_config	.\ltmain.sh	/^func_config ()$/;"	f
func_convert_core_file_wine_to_w32	.\autoconf\ltmain.sh	/^func_convert_core_file_wine_to_w32 ()$/;"	f
func_convert_core_msys_to_w32	.\autoconf\ltmain.sh	/^func_convert_core_msys_to_w32 ()$/;"	f
func_convert_core_path_wine_to_w32	.\autoconf\ltmain.sh	/^func_convert_core_path_wine_to_w32 ()$/;"	f
func_convert_file_check	.\autoconf\ltmain.sh	/^func_convert_file_check ()$/;"	f
func_convert_file_cygwin_to_w32	.\autoconf\ltmain.sh	/^func_convert_file_cygwin_to_w32 ()$/;"	f
func_convert_file_msys_to_cygwin	.\autoconf\ltmain.sh	/^func_convert_file_msys_to_cygwin ()$/;"	f
func_convert_file_msys_to_w32	.\autoconf\ltmain.sh	/^func_convert_file_msys_to_w32 ()$/;"	f
func_convert_file_nix_to_cygwin	.\autoconf\ltmain.sh	/^func_convert_file_nix_to_cygwin ()$/;"	f
func_convert_file_nix_to_w32	.\autoconf\ltmain.sh	/^func_convert_file_nix_to_w32 ()$/;"	f
func_convert_file_noop	.\autoconf\ltmain.sh	/^func_convert_file_noop ()$/;"	f
func_convert_path_check	.\autoconf\ltmain.sh	/^func_convert_path_check ()$/;"	f
func_convert_path_cygwin_to_w32	.\autoconf\ltmain.sh	/^func_convert_path_cygwin_to_w32 ()$/;"	f
func_convert_path_front_back_pathsep	.\autoconf\ltmain.sh	/^func_convert_path_front_back_pathsep ()$/;"	f
func_convert_path_msys_to_cygwin	.\autoconf\ltmain.sh	/^func_convert_path_msys_to_cygwin ()$/;"	f
func_convert_path_msys_to_w32	.\autoconf\ltmain.sh	/^func_convert_path_msys_to_w32 ()$/;"	f
func_convert_path_nix_to_cygwin	.\autoconf\ltmain.sh	/^func_convert_path_nix_to_cygwin ()$/;"	f
func_convert_path_nix_to_w32	.\autoconf\ltmain.sh	/^func_convert_path_nix_to_w32 ()$/;"	f
func_convert_path_noop	.\autoconf\ltmain.sh	/^func_convert_path_noop ()$/;"	f
func_cygming_dll_for_implib	.\autoconf\ltmain.sh	/^func_cygming_dll_for_implib ()$/;"	f
func_cygming_dll_for_implib_fallback	.\autoconf\ltmain.sh	/^func_cygming_dll_for_implib_fallback ()$/;"	f
func_cygming_dll_for_implib_fallback_core	.\autoconf\ltmain.sh	/^func_cygming_dll_for_implib_fallback_core ()$/;"	f
func_cygming_gnu_implib_p	.\autoconf\ltmain.sh	/^func_cygming_gnu_implib_p ()$/;"	f
func_cygming_ms_implib_p	.\autoconf\ltmain.sh	/^func_cygming_ms_implib_p ()$/;"	f
func_cygpath	.\autoconf\ltmain.sh	/^func_cygpath ()$/;"	f
func_dirname	.\autoconf\ltmain.sh	/^func_dirname ()$/;"	f
func_dirname_and_basename	.\autoconf\ltmain.sh	/^func_dirname_and_basename ()$/;"	f
func_dirname_and_basename	.\ltmain.sh	/^func_dirname_and_basename ()$/;"	f
func_echo	.\autoconf\ltmain.sh	/^func_echo ()$/;"	f
func_echo	.\ltmain.sh	/^func_echo ()$/;"	f
func_echo_all	.\autoconf\ltmain.sh	/^func_echo_all ()$/;"	f
func_emit_cwrapperexe_src	.\autoconf\ltmain.sh	/^func_emit_cwrapperexe_src ()$/;"	f
func_emit_cwrapperexe_src	.\ltmain.sh	/^func_emit_cwrapperexe_src ()$/;"	f
func_emit_wrapper	.\autoconf\ltmain.sh	/^func_emit_wrapper ()$/;"	f
func_emit_wrapper	.\ltmain.sh	/^func_emit_wrapper ()$/;"	f
func_emit_wrapper_part1	.\ltmain.sh	/^func_emit_wrapper_part1 ()$/;"	f
func_emit_wrapper_part2	.\ltmain.sh	/^func_emit_wrapper_part2 ()$/;"	f
func_enable_tag	.\autoconf\ltmain.sh	/^func_enable_tag ()$/;"	f
func_enable_tag	.\ltmain.sh	/^func_enable_tag ()$/;"	f
func_error	.\autoconf\ltmain.sh	/^func_error ()$/;"	f
func_error	.\ltmain.sh	/^func_error ()$/;"	f
func_exec_program	.\autoconf\ltmain.sh	/^func_exec_program ()$/;"	f
func_exec_program_core	.\autoconf\ltmain.sh	/^func_exec_program_core ()$/;"	f
func_execute_cmds	.\autoconf\ltmain.sh	/^func_execute_cmds ()$/;"	f
func_execute_cmds	.\ltmain.sh	/^func_execute_cmds ()$/;"	f
func_extract_an_archive	.\autoconf\ltmain.sh	/^func_extract_an_archive ()$/;"	f
func_extract_an_archive	.\ltmain.sh	/^func_extract_an_archive ()$/;"	f
func_extract_archives	.\autoconf\ltmain.sh	/^func_extract_archives ()$/;"	f
func_extract_archives	.\ltmain.sh	/^func_extract_archives ()$/;"	f
func_fallback_echo	.\autoconf\ltmain.sh	/^func_fallback_echo ()$/;"	f
func_fatal_configuration	.\autoconf\ltmain.sh	/^func_fatal_configuration ()$/;"	f
func_fatal_configuration	.\ltmain.sh	/^func_fatal_configuration ()$/;"	f
func_fatal_error	.\autoconf\ltmain.sh	/^func_fatal_error ()$/;"	f
func_fatal_error	.\ltmain.sh	/^func_fatal_error ()$/;"	f
func_fatal_help	.\autoconf\ltmain.sh	/^func_fatal_help ()$/;"	f
func_fatal_help	.\ltmain.sh	/^func_fatal_help ()$/;"	f
func_features	.\autoconf\ltmain.sh	/^func_features ()$/;"	f
func_features	.\ltmain.sh	/^func_features ()$/;"	f
func_generate_dlsyms	.\autoconf\ltmain.sh	/^func_generate_dlsyms ()$/;"	f
func_generate_dlsyms	.\ltmain.sh	/^func_generate_dlsyms ()$/;"	f
func_grep	.\autoconf\ltmain.sh	/^func_grep ()$/;"	f
func_grep	.\ltmain.sh	/^func_grep ()$/;"	f
func_help	.\autoconf\ltmain.sh	/^func_help ()$/;"	f
func_help	.\ltmain.sh	/^func_help ()$/;"	f
func_infer_tag	.\autoconf\ltmain.sh	/^func_infer_tag ()$/;"	f
func_infer_tag	.\ltmain.sh	/^func_infer_tag ()$/;"	f
func_init_to_host_path_cmd	.\autoconf\ltmain.sh	/^func_init_to_host_path_cmd ()$/;"	f
func_lalib_p	.\autoconf\ltmain.sh	/^func_lalib_p ()$/;"	f
func_lalib_p	.\ltmain.sh	/^func_lalib_p ()$/;"	f
func_lalib_unsafe_p	.\autoconf\ltmain.sh	/^func_lalib_unsafe_p ()$/;"	f
func_lalib_unsafe_p	.\ltmain.sh	/^func_lalib_unsafe_p ()$/;"	f
func_len	.\autoconf\ltmain.sh	/^func_len ()$/;"	f
func_lo2o	.\autoconf\ltmain.sh	/^func_lo2o ()$/;"	f
func_lt_dump_args	.\autoconf\ltmain.sh	/^func_lt_dump_args ()$/;"	f
func_ltwrapper_executable_p	.\autoconf\ltmain.sh	/^func_ltwrapper_executable_p ()$/;"	f
func_ltwrapper_executable_p	.\ltmain.sh	/^func_ltwrapper_executable_p ()$/;"	f
func_ltwrapper_p	.\autoconf\ltmain.sh	/^func_ltwrapper_p ()$/;"	f
func_ltwrapper_p	.\ltmain.sh	/^func_ltwrapper_p ()$/;"	f
func_ltwrapper_script_p	.\autoconf\ltmain.sh	/^func_ltwrapper_script_p ()$/;"	f
func_ltwrapper_script_p	.\ltmain.sh	/^func_ltwrapper_script_p ()$/;"	f
func_ltwrapper_scriptname	.\autoconf\ltmain.sh	/^func_ltwrapper_scriptname ()$/;"	f
func_ltwrapper_scriptname	.\ltmain.sh	/^func_ltwrapper_scriptname ()$/;"	f
func_missing_arg	.\autoconf\ltmain.sh	/^func_missing_arg ()$/;"	f
func_missing_arg	.\ltmain.sh	/^func_missing_arg ()$/;"	f
func_mkdir_p	.\autoconf\ltmain.sh	/^func_mkdir_p ()$/;"	f
func_mkdir_p	.\ltmain.sh	/^func_mkdir_p ()$/;"	f
func_mktempdir	.\autoconf\ltmain.sh	/^func_mktempdir ()$/;"	f
func_mktempdir	.\ltmain.sh	/^func_mktempdir ()$/;"	f
func_mode_compile	.\autoconf\ltmain.sh	/^func_mode_compile ()$/;"	f
func_mode_compile	.\ltmain.sh	/^func_mode_compile ()$/;"	f
func_mode_execute	.\autoconf\ltmain.sh	/^func_mode_execute ()$/;"	f
func_mode_execute	.\ltmain.sh	/^func_mode_execute ()$/;"	f
func_mode_finish	.\autoconf\ltmain.sh	/^func_mode_finish ()$/;"	f
func_mode_finish	.\ltmain.sh	/^func_mode_finish ()$/;"	f
func_mode_help	.\autoconf\ltmain.sh	/^func_mode_help ()$/;"	f
func_mode_help	.\ltmain.sh	/^func_mode_help ()$/;"	f
func_mode_install	.\autoconf\ltmain.sh	/^func_mode_install ()$/;"	f
func_mode_install	.\ltmain.sh	/^func_mode_install ()$/;"	f
func_mode_link	.\autoconf\ltmain.sh	/^func_mode_link ()$/;"	f
func_mode_link	.\ltmain.sh	/^func_mode_link ()$/;"	f
func_mode_uninstall	.\autoconf\ltmain.sh	/^func_mode_uninstall ()$/;"	f
func_mode_uninstall	.\ltmain.sh	/^func_mode_uninstall ()$/;"	f
func_normal_abspath	.\autoconf\ltmain.sh	/^func_normal_abspath ()$/;"	f
func_parse_lt_options	.\autoconf\ltmain.sh	/^func_parse_lt_options ()$/;"	f
func_quote_for_eval	.\autoconf\ltmain.sh	/^func_quote_for_eval ()$/;"	f
func_quote_for_eval	.\ltmain.sh	/^func_quote_for_eval ()$/;"	f
func_quote_for_expand	.\autoconf\ltmain.sh	/^func_quote_for_expand ()$/;"	f
func_quote_for_expand	.\ltmain.sh	/^func_quote_for_expand ()$/;"	f
func_relative_path	.\autoconf\ltmain.sh	/^func_relative_path ()$/;"	f
func_replace_sysroot	.\autoconf\ltmain.sh	/^func_replace_sysroot ()$/;"	f
func_resolve_sysroot	.\autoconf\ltmain.sh	/^func_resolve_sysroot ()$/;"	f
func_show_eval	.\autoconf\ltmain.sh	/^func_show_eval ()$/;"	f
func_show_eval	.\ltmain.sh	/^func_show_eval ()$/;"	f
func_show_eval_locale	.\autoconf\ltmain.sh	/^func_show_eval_locale ()$/;"	f
func_show_eval_locale	.\ltmain.sh	/^func_show_eval_locale ()$/;"	f
func_source	.\autoconf\ltmain.sh	/^func_source ()$/;"	f
func_source	.\ltmain.sh	/^func_source ()$/;"	f
func_split_long_opt	.\autoconf\ltmain.sh	/^func_split_long_opt ()$/;"	f
func_split_short_opt	.\autoconf\ltmain.sh	/^func_split_short_opt ()$/;"	f
func_stripname	.\autoconf\ltmain.sh	/^func_stripname ()$/;"	f
func_to_host_file	.\autoconf\ltmain.sh	/^func_to_host_file ()$/;"	f
func_to_host_path	.\autoconf\ltmain.sh	/^func_to_host_path ()$/;"	f
func_to_host_path	.\ltmain.sh	/^func_to_host_path ()$/;"	f
func_to_host_pathlist	.\ltmain.sh	/^func_to_host_pathlist ()$/;"	f
func_to_tool_file	.\autoconf\ltmain.sh	/^func_to_tool_file ()$/;"	f
func_tr_sh	.\autoconf\ltmain.sh	/^func_tr_sh ()$/;"	f
func_usage	.\autoconf\ltmain.sh	/^func_usage ()$/;"	f
func_usage	.\ltmain.sh	/^func_usage ()$/;"	f
func_verbose	.\autoconf\ltmain.sh	/^func_verbose ()$/;"	f
func_verbose	.\ltmain.sh	/^func_verbose ()$/;"	f
func_version	.\autoconf\ltmain.sh	/^func_version ()$/;"	f
func_version	.\ltmain.sh	/^func_version ()$/;"	f
func_warning	.\autoconf\ltmain.sh	/^func_warning ()$/;"	f
func_warning	.\ltmain.sh	/^func_warning ()$/;"	f
func_win32_import_lib_p	.\autoconf\ltmain.sh	/^func_win32_import_lib_p ()$/;"	f
func_win32_libid	.\autoconf\ltmain.sh	/^func_win32_libid ()$/;"	f
func_win32_libid	.\ltmain.sh	/^func_win32_libid ()$/;"	f
func_write_libtool_object	.\autoconf\ltmain.sh	/^func_write_libtool_object ()$/;"	f
func_write_libtool_object	.\ltmain.sh	/^func_write_libtool_object ()$/;"	f
func_xform	.\autoconf\ltmain.sh	/^func_xform ()$/;"	f
functionDestroy	.\src\main.c	/^static void functionDestroy(sqlite3 *db, FuncDef *p){$/;"	f	file:
functionSearch	.\src\callback.c	/^static FuncDef *functionSearch($/;"	f	file:
fuzz	.\test\fuzz_common.tcl	/^proc fuzz {TemplateList} {$/;"	p
fuzzerAdvance	.\ext\misc\fuzzer.c	/^static int fuzzerAdvance(fuzzer_cursor *pCur, fuzzer_stem *pStem){$/;"	f	file:
fuzzerBestIndex	.\ext\misc\fuzzer.c	/^static int fuzzerBestIndex(sqlite3_vtab *tab, sqlite3_index_info *pIdxInfo){$/;"	f	file:
fuzzerClearCursor	.\ext\misc\fuzzer.c	/^static void fuzzerClearCursor(fuzzer_cursor *pCur, int clearHash){$/;"	f	file:
fuzzerClearStemList	.\ext\misc\fuzzer.c	/^static void fuzzerClearStemList(fuzzer_stem *pStem){$/;"	f	file:
fuzzerClose	.\ext\misc\fuzzer.c	/^static int fuzzerClose(sqlite3_vtab_cursor *cur){$/;"	f	file:
fuzzerColumn	.\ext\misc\fuzzer.c	/^static int fuzzerColumn(sqlite3_vtab_cursor *cur, sqlite3_context *ctx, int i){$/;"	f	file:
fuzzerConnect	.\ext\misc\fuzzer.c	/^static int fuzzerConnect($/;"	f	file:
fuzzerCost	.\ext\misc\fuzzer.c	/^static fuzzer_cost fuzzerCost(fuzzer_stem *pStem){$/;"	f	file:
fuzzerDequote	.\ext\misc\fuzzer.c	/^static char *fuzzerDequote(const char *zIn){$/;"	f	file:
fuzzerDisconnect	.\ext\misc\fuzzer.c	/^static int fuzzerDisconnect(sqlite3_vtab *pVtab){$/;"	f	file:
fuzzerEof	.\ext\misc\fuzzer.c	/^static int fuzzerEof(sqlite3_vtab_cursor *cur){$/;"	f	file:
fuzzerFilter	.\ext\misc\fuzzer.c	/^static int fuzzerFilter($/;"	f	file:
fuzzerHash	.\ext\misc\fuzzer.c	/^static unsigned int fuzzerHash(const char *z){$/;"	f	file:
fuzzerInsert	.\ext\misc\fuzzer.c	/^static fuzzer_stem *fuzzerInsert(fuzzer_cursor *pCur, fuzzer_stem *pNew){$/;"	f	file:
fuzzerLoadOneRule	.\ext\misc\fuzzer.c	/^static int fuzzerLoadOneRule($/;"	f	file:
fuzzerLoadRules	.\ext\misc\fuzzer.c	/^static int fuzzerLoadRules($/;"	f	file:
fuzzerLowestCostStem	.\ext\misc\fuzzer.c	/^static fuzzer_stem *fuzzerLowestCostStem(fuzzer_cursor *pCur){$/;"	f	file:
fuzzerMergeRules	.\ext\misc\fuzzer.c	/^static fuzzer_rule *fuzzerMergeRules(fuzzer_rule *pA, fuzzer_rule *pB){$/;"	f	file:
fuzzerMergeStems	.\ext\misc\fuzzer.c	/^static fuzzer_stem *fuzzerMergeStems(fuzzer_stem *pA, fuzzer_stem *pB){$/;"	f	file:
fuzzerModule	.\ext\misc\fuzzer.c	/^static sqlite3_module fuzzerModule = {$/;"	v	file:
fuzzerNewStem	.\ext\misc\fuzzer.c	/^static fuzzer_stem *fuzzerNewStem($/;"	f	file:
fuzzerNext	.\ext\misc\fuzzer.c	/^static int fuzzerNext(sqlite3_vtab_cursor *cur){$/;"	f	file:
fuzzerOpen	.\ext\misc\fuzzer.c	/^static int fuzzerOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor){$/;"	f	file:
fuzzerRender	.\ext\misc\fuzzer.c	/^static int fuzzerRender($/;"	f	file:
fuzzerRowid	.\ext\misc\fuzzer.c	/^static int fuzzerRowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid){$/;"	f	file:
fuzzerSeen	.\ext\misc\fuzzer.c	/^static int fuzzerSeen(fuzzer_cursor *pCur, fuzzer_stem *pStem){$/;"	f	file:
fuzzerSkipRule	.\ext\misc\fuzzer.c	/^static int fuzzerSkipRule($/;"	f	file:
fuzzer_cost	.\ext\misc\fuzzer.c	/^typedef int fuzzer_cost;$/;"	t	file:
fuzzer_cursor	.\ext\misc\fuzzer.c	/^struct fuzzer_cursor {$/;"	s	file:
fuzzer_cursor	.\ext\misc\fuzzer.c	/^typedef struct fuzzer_cursor fuzzer_cursor;$/;"	t	typeref:struct:fuzzer_cursor	file:
fuzzer_len	.\ext\misc\fuzzer.c	/^typedef signed char fuzzer_len;$/;"	t	file:
fuzzer_rule	.\ext\misc\fuzzer.c	/^struct fuzzer_rule {$/;"	s	file:
fuzzer_rule	.\ext\misc\fuzzer.c	/^typedef struct fuzzer_rule fuzzer_rule;$/;"	t	typeref:struct:fuzzer_rule	file:
fuzzer_ruleid	.\ext\misc\fuzzer.c	/^typedef int fuzzer_ruleid;$/;"	t	file:
fuzzer_seen	.\ext\misc\fuzzer.c	/^typedef struct fuzzer_seen fuzzer_seen;$/;"	t	typeref:struct:fuzzer_seen	file:
fuzzer_stem	.\ext\misc\fuzzer.c	/^struct fuzzer_stem {$/;"	s	file:
fuzzer_stem	.\ext\misc\fuzzer.c	/^typedef struct fuzzer_stem fuzzer_stem;$/;"	t	typeref:struct:fuzzer_stem	file:
fuzzer_vtab	.\ext\misc\fuzzer.c	/^struct fuzzer_vtab {$/;"	s	file:
fuzzer_vtab	.\ext\misc\fuzzer.c	/^typedef struct fuzzer_vtab fuzzer_vtab;$/;"	t	typeref:struct:fuzzer_vtab	file:
fws	.\tool\lemon.c	/^  char *fws;               \/* Follow-set for this configuration only *\/$/;"	m	struct:config	file:
g	.\mptest\mptest.c	/^} g;$/;"	v	typeref:struct:Global	file:
g	.\src\test6.c	/^static CrashGlobal g = {0, 0, SQLITE_DEFAULT_SECTOR_SIZE, 0, 0};$/;"	v	file:
g	.\src\test_devsym.c	/^struct DevsymGlobal g = {0, 0, 512};$/;"	v	typeref:struct:DevsymGlobal
g	.\src\test_journal.c	/^static struct JtGlobal g = {0, 0};$/;"	v	typeref:struct:JtGlobal	file:
g	.\src\test_mutex.c	/^} g = {0};$/;"	v	typeref:struct:test_mutex_globals	file:
g	.\src\test_server.c	/^} g = {$/;"	v	typeref:struct:ServerState	file:
g	.\test\fuzzcheck.c	/^} g;$/;"	v	typeref:struct:GlobalVars	file:
g	.\test\speedtest1.c	/^} g;$/;"	v	typeref:struct:Global	file:
g	.\tool\fuzzershell.c	/^} g;$/;"	v	typeref:struct:GlobalVars
g	.\tool\showdb.c	/^} g = {1024, -1, 0, 16,   0, 0, 0};$/;"	v	typeref:struct:GlobalData	file:
g	.\tool\sqldiff.c	/^} g;$/;"	v	typeref:struct:GlobalVars
gHere	.\src\test_rtree.c	/^static int gHere = 42;$/;"	v	file:
gMultiplex	.\src\test_multiplex.c	/^} gMultiplex;$/;"	v	typeref:struct:__anon23	file:
gQuota	.\src\test_quota.c	/^} gQuota;$/;"	v	typeref:struct:__anon24	file:
gSyscall	.\src\test_syscall.c	/^} gSyscall = { 0, 0, 0, 0, 0 };$/;"	v	typeref:struct:TestSyscallGlobal	file:
g_elapsed	.\src\os_common.h	/^static sqlite_uint64 g_elapsed;$/;"	v
g_start	.\src\os_common.h	/^static sqlite_uint64 g_start;$/;"	v
gather_one_file	.\tool\split-sqlite3c.tcl	/^proc gather_one_file {firstline bufout nout} {$/;"	p
genCksum	.\src\test_journal.c	/^static u32 genCksum(const unsigned char *z, int n){$/;"	f	file:
generateColumnNames	.\src\select.c	/^static void generateColumnNames($/;"	f	file:
generateColumnTypes	.\src\select.c	/^static void generateColumnTypes($/;"	f	file:
generateError	.\ext\fts2\fts2.c	/^static void generateError(sqlite3_context *pContext,$/;"	f	file:
generateOutputSubroutine	.\src\select.c	/^static int generateOutputSubroutine($/;"	f	file:
generateSortTail	.\src\select.c	/^static void generateSortTail($/;"	f	file:
generateTermsResult	.\ext\fts2\fts2.c	/^static int generateTermsResult(sqlite3_context *pContext, fts2Hash *pTerms){$/;"	f	file:
generateWithRecursiveQuery	.\src\select.c	/^static void generateWithRecursiveQuery($/;"	f	file:
generate_expr	.\test\randexpr1.tcl	/^proc generate_expr {{e EXPR}} {$/;"	p
generate_makefile	.\tool\soak1.tcl	/^proc generate_makefile {pattern} {$/;"	p
geomCallback	.\ext\rtree\rtree.c	/^static void geomCallback(sqlite3_context *ctx, int nArg, sqlite3_value **aArg){$/;"	f	file:
get2byte	.\src\btreeInt.h	691;"	d
get2byte	.\src\dbstat.c	134;"	d	file:
get2byteAligned	.\src\btreeInt.h	702;"	d
get2byteAligned	.\src\btreeInt.h	705;"	d
get2byteAligned	.\src\btreeInt.h	708;"	d
get2byteAligned	.\src\btreeInt.h	710;"	d
get2byteInt	.\src\shell.c	/^unsigned int get2byteInt(unsigned char *a){$/;"	f
get2byteNotZero	.\src\btree.c	44;"	d	file:
get32bits	.\src\test_osinst.c	/^static unsigned int get32bits(unsigned char *p){$/;"	f	file:
get4byte	.\src\btreeInt.h	693;"	d
get4byteInt	.\src\shell.c	/^unsigned int get4byteInt(unsigned char *a){$/;"	f
getAbsoluteLevel	.\ext\fts3\fts3_write.c	/^static sqlite3_int64 getAbsoluteLevel($/;"	f	file:
getAndBindSqlStatement	.\test\threadtest3.c	/^static sqlite3_stmt *getAndBindSqlStatement($/;"	f	file:
getAndInitPage	.\src\btree.c	/^static int getAndInitPage($/;"	f	file:
getAutoVacuum	.\src\pragma.c	/^static int getAutoVacuum(const char *z){$/;"	f	file:
getCellInfo	.\src\btree.c	/^static SQLITE_NOINLINE void getCellInfo(BtCursor *pCur){$/;"	f	file:
getChildrenContaining	.\ext\fts2\fts2.c	/^static void getChildrenContaining(const char *pData, int nData,$/;"	f	file:
getColumnNames	.\src\test8.c	/^static int getColumnNames($/;"	f	file:
getContent	.\tool\showwal.c	/^static unsigned char *getContent(int ofst, int nByte){$/;"	f	file:
getDbPointer	.\src\test1.c	/^int getDbPointer(Tcl_Interp *interp, const char *zA, sqlite3 **ppDb){$/;"	f
getDbPointer	.\src\test_mutex.c	/^static sqlite3 *getDbPointer(Tcl_Interp *pInterp, Tcl_Obj *pObj){$/;"	f	file:
getDigits	.\src\date.c	/^static int getDigits(const char *zDate, ...){$/;"	f	file:
getDoubleArg	.\src\printf.c	/^static double getDoubleArg(PrintfArguments *p){$/;"	f	file:
getEnvironmentVariable	.\tool\mkvsix.tcl	/^proc getEnvironmentVariable { name } {$/;"	p
getExtraFileListXmlChunk	.\tool\mkvsix.tcl	/^proc getExtraFileListXmlChunk { packageFlavor vsVersion } {$/;"	p
getFileLock	.\ext\async\sqlite3async.c	/^static int getFileLock(AsyncLock *pLock){$/;"	f	file:
getFileRetries	.\test\tester.tcl	/^proc getFileRetries {} {$/;"	p
getFileRetryDelay	.\test\tester.tcl	/^proc getFileRetryDelay {} {$/;"	p
getFts3Varint	.\src\test_hexio.c	/^static int getFts3Varint(const char *p, sqlite_int64 *v){$/;"	f	file:
getIndexArray	.\src\test8.c	/^static int getIndexArray($/;"	f	file:
getInt32	.\tool\showwal.c	/^static unsigned int getInt32(const unsigned char *a){$/;"	f	file:
getIntArg	.\src\printf.c	/^static sqlite3_int64 getIntArg(PrintfArguments *p){$/;"	f	file:
getIntFromStmt	.\ext\rtree\rtree.c	/^static int getIntFromStmt(sqlite3 *db, const char *zSql, int *piVal){$/;"	f	file:
getLocalPayload	.\src\dbstat.c	/^static void getLocalPayload($/;"	f	file:
getLockingMode	.\src\pragma.c	/^static int getLockingMode(const char *z){$/;"	f	file:
getMaxPlatformVersionXmlChunk	.\tool\mkvsix.tcl	/^proc getMaxPlatformVersionXmlChunk { packageFlavor vsVersion } {$/;"	p
getMinVsVersionXmlChunk	.\tool\mkvsix.tcl	/^proc getMinVsVersionXmlChunk { vsVersion } {$/;"	p
getNextNode	.\ext\fts3\fts3_expr.c	/^static int getNextNode($/;"	f	file:
getNextString	.\ext\fts3\fts3_expr.c	/^static int getNextString($/;"	f	file:
getNextToken	.\ext\fts3\fts3_expr.c	/^static int getNextToken($/;"	f	file:
getNodeSize	.\ext\rtree\rtree.c	/^static int getNodeSize($/;"	f	file:
getOverflowPage	.\src\btree.c	/^static int getOverflowPage($/;"	f	file:
getPageReferenced	.\src\btree.c	/^static int getPageReferenced(IntegrityCk *pCheck, Pgno iPg){$/;"	f	file:
getProcessId	.\src\test_sqllog.c	/^static int getProcessId(void){$/;"	f	file:
getProcessTimesAddr	.\src\shell.c	/^static GETPROCTIMES getProcessTimesAddr = NULL;$/;"	v	file:
getRbudiffQuery	.\tool\sqldiff.c	/^static void getRbudiffQuery($/;"	f	file:
getRowTrigger	.\src\trigger.c	/^static TriggerPrg *getRowTrigger($/;"	f	file:
getSafetyLevel	.\src\pragma.c	/^static u8 getSafetyLevel(const char *z, int omitFull, u8 dflt){$/;"	f	file:
getSqlStatement	.\test\threadtest3.c	/^static Statement *getSqlStatement($/;"	f	file:
getStaticMutexPointer	.\src\test_mutex.c	/^static sqlite3_mutex *getStaticMutexPointer($/;"	f	file:
getStmtPointer	.\src\test1.c	/^static int getStmtPointer($/;"	f	file:
getTempStore	.\src\pragma.c	/^static int getTempStore(const char *z){$/;"	f	file:
getTemporaryPath	.\tool\mkvsix.tcl	/^proc getTemporaryPath {} {$/;"	p
getTextArg	.\src\printf.c	/^static char *getTextArg(PrintfArguments *p){$/;"	f	file:
getToken	.\ext\fts1\fts1.c	/^static int getToken(const char *z, int *tokenType){$/;"	f	file:
getToken	.\ext\fts2\fts2.c	/^static int getToken(const char *z, int *tokenType){$/;"	f	file:
getVarint	.\ext\fts1\fts1.c	/^static int getVarint(const char *p, sqlite_int64 *v){$/;"	f	file:
getVarint	.\ext\fts1\fulltext.c	/^static int getVarint(const char *p, sqlite_int64 *v){$/;"	f	file:
getVarint	.\ext\fts2\fts2.c	/^static int getVarint(const char *p, sqlite_int64 *v){$/;"	f	file:
getVarint	.\ext\fts3\tool\fts3view.c	/^int getVarint(const unsigned char *p, sqlite_int64 *v){$/;"	f
getVarint	.\src\sqliteInt.h	3584;"	d
getVarint32	.\ext\fts1\fts1.c	/^static int getVarint32(const char *p, int *pi){$/;"	f	file:
getVarint32	.\ext\fts1\fulltext.c	/^static int getVarint32(const char *p, int *pi){$/;"	f	file:
getVarint32	.\ext\fts2\fts2.c	/^static int getVarint32(const char *p, int *pi){$/;"	f	file:
getVarint32	.\src\sqliteInt.h	3579;"	d
getWin32Handle	.\src\test1.c	/^int getWin32Handle(Tcl_Interp *interp, const char *zA, LPHANDLE phFile){$/;"	f
get_api_docs	.\ext\fts5\extract_api_docs.tcl	/^proc get_api_docs {data} {$/;"	p
get_autocommit	.\src\sqlite3ext.h	/^  int  (*get_autocommit)(sqlite3*);$/;"	m	struct:sqlite3_api_routines
get_autocommit	.\src\test1.c	/^static int get_autocommit($/;"	f	file:
get_auxdata	.\src\sqlite3ext.h	/^  void * (*get_auxdata)(sqlite3_context*,int);$/;"	m	struct:sqlite3_api_routines
get_fts5_struct	.\ext\fts5\extract_api_docs.tcl	/^proc get_fts5_struct {data start end} {$/;"	p
get_pwd	.\test\tester.tcl	/^proc get_pwd {} {$/;"	p
get_simple_tokenizer_module	.\ext\fts1\simple_tokenizer.c	/^void get_simple_tokenizer_module($/;"	f
get_sqlite_pointer	.\src\test1.c	/^static int get_sqlite_pointer($/;"	f	file:
get_struct_docs	.\ext\fts5\extract_api_docs.tcl	/^proc get_struct_docs {data names} {$/;"	p
get_struct_members	.\ext\fts5\extract_api_docs.tcl	/^proc get_struct_members {data} {$/;"	p
get_table	.\src\sqlite3ext.h	/^  int  (*get_table)(sqlite3*,const char*,char***,int*,int*,char**);$/;"	m	struct:sqlite3_api_routines
get_tokenizer_docs	.\ext\fts5\extract_api_docs.tcl	/^proc get_tokenizer_docs {data} {$/;"	p
get_version	.\test\bc_common.tcl	/^proc get_version {binary} {$/;"	p
getrusage	.\src\shell.c	188;"	d	file:
getstate	.\tool\lemon.c	/^PRIVATE struct state *getstate(struct lemon *lemp)$/;"	f
globInfo	.\src\func.c	/^static const struct compareInfo globInfo = { '*', '?', '[', 0 };$/;"	v	typeref:struct:compareInfo	file:
globalDb	.\src\shell.c	/^static sqlite3 *globalDb = 0;$/;"	v	file:
global_recover	.\src\sqlite3ext.h	/^  int  (*global_recover)(void);$/;"	m	struct:sqlite3_api_routines
gobble_string	.\test\fts3_common.tcl	/^proc gobble_string {varname nLength} {$/;"	p
gobble_text	.\ext\fts5\test\fts5_common.tcl	/^proc gobble_text {textvar wordvar} {$/;"	p
gobble_varint	.\test\fts3_common.tcl	/^proc gobble_varint {varname} {$/;"	p
gobble_whitespace	.\ext\fts5\test\fts5_common.tcl	/^proc gobble_whitespace {textvar} {$/;"	p
gp	.\tool\lemon.c	/^  struct lemon *gp;     \/* Global state vector *\/$/;"	m	struct:pstate	typeref:struct:pstate::lemon	file:
groupConcatFinalize	.\src\func.c	/^static void groupConcatFinalize(sqlite3_context *context){$/;"	f	file:
groupConcatStep	.\src\func.c	/^static void groupConcatStep($/;"	f	file:
growOpArray	.\src\vdbeaux.c	/^static int growOpArray(Vdbe *v, int nOp){$/;"	f	file:
growVTrans	.\src\vtab.c	/^static int growVTrans(sqlite3 *db){$/;"	f	file:
grp	.\src\pcache1.c	/^  PGroup grp;                    \/* The global PGroup for mode (2) *\/$/;"	m	struct:PCacheGlobal	file:
h	.\src\date.c	/^  int h, m;          \/* Hour and minutes *\/$/;"	m	struct:DateTime	file:
h	.\src\os_unix.c	/^  int h;                              \/* The file descriptor *\/$/;"	m	struct:unixFile	file:
h	.\src\os_unix.c	/^  int h;                     \/* Open file descriptor *\/$/;"	m	struct:unixShmNode	file:
h	.\src\os_win.c	/^  HANDLE h;               \/* Handle for accessing the file *\/$/;"	m	struct:winFile	file:
h	.\src\test1.c	/^  HANDLE h;           \/* Handle of the file to be locked *\/$/;"	m	struct:win32FileLocker	file:
hFile	.\src\os_win.c	/^  winFile hFile;             \/* File handle from winOpen *\/$/;"	m	struct:winShmNode	file:
hHeap	.\src\os_win.c	/^  HANDLE hHeap; \/* The handle to our heap. *\/$/;"	m	struct:winMemData	file:
hMap	.\src\os_win.c	/^    HANDLE hMap;             \/* File handle from CreateFileMapping *\/$/;"	m	struct:winShmNode::ShmRegion	file:
hMap	.\src\os_win.c	/^  HANDLE hMap;                  \/* Handle for accessing memory mapping *\/$/;"	m	struct:winFile	file:
hMutex	.\src\os_win.c	/^  HANDLE hMutex;          \/* Mutex used to control access to shared lock *\/$/;"	m	struct:winFile	file:
hPending	.\ext\fts3\fts3Int.h	/^    Fts3Hash hPending;            \/* Pending terms table for this index *\/$/;"	m	struct:Fts3Table::Fts3Index
hProcess	.\src\shell.c	/^static HANDLE hProcess;$/;"	v	file:
hShared	.\src\os_win.c	/^  HANDLE hShared;         \/* Shared memory segment used for locking *\/$/;"	m	struct:winFile	file:
halfFunc	.\src\test_loadext.c	/^static void halfFunc($/;"	f	file:
handleDeferredMoveto	.\src\vdbeaux.c	/^static int SQLITE_NOINLINE handleDeferredMoveto(VdbeCursor *p){$/;"	f	file:
handleMovedCursor	.\src\vdbeaux.c	/^static int SQLITE_NOINLINE handleMovedCursor(VdbeCursor *p){$/;"	f	file:
handle_D_option	.\tool\lemon.c	/^static void handle_D_option(char *z){$/;"	f	file:
handle_T_option	.\tool\lemon.c	/^static void handle_T_option(char *z){$/;"	f	file:
handleflags	.\tool\lemon.c	/^static int handleflags(int i, FILE *err)$/;"	f	file:
handleswitch	.\tool\lemon.c	/^static int handleswitch(int i, FILE *err)$/;"	f	file:
hasColumn	.\src\build.c	/^static int hasColumn(const i16 *aiCol, int nCol, int x){$/;"	f	file:
hasCompound	.\src\sqliteInt.h	/^  u8 hasCompound;      \/* Need to invoke convertCompoundSelectToSubquery() *\/$/;"	m	struct:Parse
hasHeldSharedLock	.\src\pager.c	/^  u8 hasHeldSharedLock;       \/* True if a shared lock has ever been held *\/$/;"	m	struct:Pager	file:
hasHotJournal	.\src\pager.c	/^static int hasHotJournal(Pager *pPager, int *pExists){$/;"	f	file:
hasIncrblobCur	.\src\btreeInt.h	/^  u8 hasIncrblobCur; \/* True if there are one or more Incrblob cursors *\/$/;"	m	struct:Btree
hasMutex	.\src\os_unix.c	/^  u8 hasMutex;               \/* True if holding the unixShmNode mutex *\/$/;"	m	struct:unixShm	file:
hasMutex	.\src\os_win.c	/^  u8 hasMutex;               \/* True if holding the winShmNode mutex *\/$/;"	m	struct:winShm	file:
hasReadConflicts	.\src\btree.c	/^static int hasReadConflicts(Btree *pBtree, Pgno iRoot){$/;"	f	file:
hasReadConflicts	.\src\btree.c	112;"	d	file:
hasSharedCacheTableLock	.\src\btree.c	/^static int hasSharedCacheTableLock($/;"	f	file:
hasSharedCacheTableLock	.\src\btree.c	111;"	d	file:
hasTimer	.\src\shell.c	/^static int hasTimer(void){$/;"	f	file:
hasVowel	.\ext\fts1\fts1_porter.c	/^static int hasVowel(const char *z){$/;"	f	file:
hasVowel	.\ext\fts2\fts2_porter.c	/^static int hasVowel(const char *z){$/;"	f	file:
hasVowel	.\ext\fts3\fts3_porter.c	/^static int hasVowel(const char *z){$/;"	f	file:
has_destructor	.\tool\lemon.c	/^int has_destructor(struct symbol *sp, struct lemon *lemp)$/;"	f
has_fallback	.\tool\lemon.c	/^  int has_fallback;        \/* True if any %fallback is seen in the grammar *\/$/;"	m	struct:lemon	file:
has_iPrevDocid	.\ext\fts2\fts2.c	/^  int has_iPrevDocid;$/;"	m	struct:DLWriter	file:
has_parent	.\ext\fts2\fts2.c	/^  int has_parent;$/;"	m	struct:LeafWriter	file:
hash	.\tool\mkkeywordhash.c	/^  int hash;            \/* Hash on the keyword *\/$/;"	m	struct:Keyword	file:
hash	.\tool\sqldiff.c	/^struct hash {$/;"	s	file:
hash	.\tool\sqldiff.c	/^typedef struct hash hash;$/;"	t	typeref:struct:hash	file:
hashDestroy	.\ext\fts2\fts2.c	/^static void hashDestroy(void *p){$/;"	f	file:
hashDestroy	.\ext\fts3\fts3.c	/^static void hashDestroy(void *p){$/;"	f	file:
hashFunction	.\ext\fts1\ft_hash.c	/^static int (*hashFunction(int keyClass))(const void*,int){$/;"	f	file:
hashFunction	.\ext\fts1\fts1_hash.c	/^static int (*hashFunction(int keyClass))(const void*,int){$/;"	f	file:
hashFunction	.\ext\fts2\fts2_hash.c	/^static int (*hashFunction(int keyClass))(const void*,int){$/;"	f	file:
hashString	.\src\test8.c	/^static int hashString(const char *zString){$/;"	f	file:
hash_32bit	.\tool\sqldiff.c	/^static u32 hash_32bit(hash *pHash){$/;"	f	file:
hash_init	.\tool\sqldiff.c	/^static void hash_init(hash *pHash, const char *z){$/;"	f	file:
hash_next	.\tool\sqldiff.c	/^static void hash_next(hash *pHash, int c){$/;"	f	file:
hdr	.\src\mem3.c	/^    } hdr;$/;"	m	union:Mem3Block::__anon11	typeref:struct:Mem3Block::__anon11::__anon12	file:
hdr	.\src\wal.c	/^  WalIndexHdr hdr;           \/* Wal-index header for current transaction *\/$/;"	m	struct:Wal	file:
hdrOffset	.\src\btreeInt.h	/^  u8 hdrOffset;        \/* 100 for page 1.  0 otherwise *\/$/;"	m	struct:MemPage
heap	.\src\btreeInt.h	/^  u32 *heap;        \/* Min-heap used for analyzing cell coverage *\/$/;"	m	struct:IntegrityCk
height	.\ext\misc\amatch.c	/^  short int height;     \/* Height of this node.  Leaf==1 *\/$/;"	m	struct:amatch_avl	file:
height	.\ext\misc\closure.c	/^  short int height;     \/* Height of this node.  Leaf==1 *\/$/;"	m	struct:closure_avl	file:
height	.\src\test_rtree.c	/^  double height;$/;"	m	struct:Cube	file:
heightOfExpr	.\src\expr.c	/^static void heightOfExpr(Expr *p, int *pnHeight){$/;"	f	file:
heightOfExprList	.\src\expr.c	/^static void heightOfExprList(ExprList *p, int *pnHeight){$/;"	f	file:
heightOfSelect	.\src\expr.c	/^static void heightOfSelect(Select *p, int *pnHeight){$/;"	f	file:
hex16Func	.\src\test1.c	/^static void hex16Func(sqlite3_context *p, int argc, sqlite3_value **argv){$/;"	f	file:
hex8Func	.\src\test1.c	/^static void hex8Func(sqlite3_context *p, int argc, sqlite3_value **argv){$/;"	f	file:
hexDigitValue	.\src\shell.c	/^static int hexDigitValue(char c){$/;"	f	file:
hexDigitValue	.\test\fuzzcheck.c	/^static int hexDigitValue(char c){$/;"	f	file:
hexDigitValue	.\test\speedtest1.c	/^static int hexDigitValue(char c){$/;"	f	file:
hexDigitValue	.\tool\fuzzershell.c	/^static int hexDigitValue(char c){$/;"	f	file:
hexFunc	.\src\func.c	/^static void hexFunc($/;"	f	file:
hexToInt	.\src\test_malloc.c	/^static int hexToInt(int h){$/;"	f	file:
hexValue	.\tool\varint.c	/^static int hexValue(char c){$/;"	f	file:
hexdigits	.\src\func.c	/^static const char hexdigits[] = {$/;"	v	file:
hexio_get_int	.\src\test_hexio.c	/^static int hexio_get_int($/;"	f	file:
hexio_read	.\src\test_hexio.c	/^static int hexio_read($/;"	f	file:
hexio_render_int16	.\src\test_hexio.c	/^static int hexio_render_int16($/;"	f	file:
hexio_render_int32	.\src\test_hexio.c	/^static int hexio_render_int32($/;"	f	file:
hexio_write	.\src\test_hexio.c	/^static int hexio_write($/;"	f	file:
highStress	.\src\test_pcache.c	/^  unsigned highStress;      \/* Call xStress agressively *\/$/;"	m	struct:testpcacheGlobalType	file:
hints	.\src\btreeInt.h	/^  u8 hints;                 \/* As configured by CursorSetHints() *\/$/;"	m	struct:BtCursor
hlmask	.\ext\fts3\fts3_snippet.c	/^  u64 hlmask;                     \/* Mask of snippet terms to highlight *\/$/;"	m	struct:SnippetFragment	file:
ht	.\ext\fts1\ft_hash.h	/^  } *ht;$/;"	m	struct:Hash	typeref:struct:Hash::_ht
ht	.\ext\fts1\fts1_hash.h	/^  } *ht;$/;"	m	struct:fts1Hash	typeref:struct:fts1Hash::_fts1ht
ht	.\ext\fts2\fts2_hash.h	/^  } *ht;$/;"	m	struct:fts2Hash	typeref:struct:fts2Hash::_fts2ht
ht	.\ext\fts3\fts3_hash.h	/^  } *ht;$/;"	m	struct:Fts3Hash	typeref:struct:Fts3Hash::_fts3ht
ht	.\src\hash.h	/^  } *ht;$/;"	m	struct:Hash	typeref:struct:Hash::_ht
ht	.\tool\lemon.c	/^  struct s_x1node **ht;  \/* Hash table for lookups *\/$/;"	m	struct:s_x1	typeref:struct:s_x1::s_x1node	file:
ht	.\tool\lemon.c	/^  struct s_x2node **ht;  \/* Hash table for lookups *\/$/;"	m	struct:s_x2	typeref:struct:s_x2::s_x2node	file:
ht	.\tool\lemon.c	/^  struct s_x3node **ht;  \/* Hash table for lookups *\/$/;"	m	struct:s_x3	typeref:struct:s_x3::s_x3node	file:
ht	.\tool\lemon.c	/^  struct s_x4node **ht;  \/* Hash table for lookups *\/$/;"	m	struct:s_x4	typeref:struct:s_x4::s_x4node	file:
ht_slot	.\src\wal.c	/^typedef u16 ht_slot;$/;"	t	file:
htsize	.\ext\fts1\ft_hash.h	/^  int htsize;             \/* Number of buckets in the hash table *\/$/;"	m	struct:Hash
htsize	.\ext\fts1\fts1_hash.h	/^  int htsize;             \/* Number of buckets in the hash table *\/$/;"	m	struct:fts1Hash
htsize	.\ext\fts2\fts2_hash.h	/^  int htsize;             \/* Number of buckets in the hash table *\/$/;"	m	struct:fts2Hash
htsize	.\ext\fts3\fts3_hash.h	/^  int htsize;             \/* Number of buckets in the hash table *\/$/;"	m	struct:Fts3Hash
htsize	.\src\hash.h	/^  unsigned int htsize;      \/* Number of buckets in the hash table *\/$/;"	m	struct:Hash
i	.\ext\fts5\fts5Int.h	/^  int i;                          \/* Current offset in a[] *\/$/;"	m	struct:Fts5PoslistReader
i	.\ext\fts5\fts5_expr.c	/^  int i;                          \/* Current offset in position list *\/$/;"	m	struct:Fts5LookaheadReader	file:
i	.\ext\misc\json1.c	/^  u32 i;                     \/* Index in sParse.aNode[] of current row *\/$/;"	m	struct:JsonEachCursor	file:
i	.\ext\misc\regexp.c	/^  int i;                   \/* Next byte to read *\/$/;"	m	struct:ReInput	file:
i	.\ext\rtree\rtree.c	/^  int i;             \/* Integer value *\/$/;"	m	union:RtreeCoord	file:
i	.\src\random.c	/^  unsigned char i, j;            \/* State variables *\/$/;"	m	struct:sqlite3PrngType	file:
i	.\src\test_intarray.c	/^  int i;                       \/* Current cursor position *\/$/;"	m	struct:intarray_cursor	file:
i	.\src\vdbe.h	/^    int i;                 \/* Integer value if p4type==P4_INT32 *\/$/;"	m	union:VdbeOp::p4union
i	.\src\vdbeInt.h	/^    i64 i;              \/* Integer value used when MEM_Int is set in flags *\/$/;"	m	union:Mem::MemValue
i	.\tool\sqldiff.c	/^  u16 i;            \/* Start of the hash window *\/$/;"	m	struct:hash	file:
i1	.\src\test_tclvar.c	/^  int i1;              \/* Current item in pList1 *\/$/;"	m	struct:tclvar_cursor	file:
i16	.\ext\fts3\fts3Int.h	/^typedef short int i16;            \/* 2-byte (or larger) signed integer *\/$/;"	t
i16	.\src\sqliteInt.h	/^typedef INT16_TYPE i16;            \/* 2-byte signed integer *\/$/;"	t
i2	.\src\test_tclvar.c	/^  int i2;              \/* Current item (if any) in pList2 *\/$/;"	m	struct:tclvar_cursor	file:
i64	.\ext\fts3\fts3Int.h	/^typedef sqlite3_int64 i64;        \/* 8-byte signed integer *\/$/;"	t
i64	.\ext\fts5\fts5Int.h	/^typedef sqlite3_int64 i64;$/;"	t
i64	.\ext\rbu\sqlite3rbu.c	/^typedef sqlite3_int64 i64;$/;"	t	file:
i64	.\ext\rtree\rtree.c	/^typedef sqlite3_int64 i64;$/;"	t	file:
i64	.\src\sqliteInt.h	/^typedef sqlite_int64 i64;          \/* 8-byte signed integer *\/$/;"	t
i64	.\test\threadtest3.c	/^typedef sqlite3_int64 i64;$/;"	t	file:
i64	.\tool\showdb.c	/^typedef long long int i64;      \/* Datatype for 64-bit integers *\/$/;"	t	file:
i64	.\tool\showstat4.c	/^typedef sqlite3_int64 i64;   \/* 64-bit signed integer type *\/$/;"	t	file:
i64	.\tool\showwal.c	/^typedef long long int i64;      \/* Datatype for 64-bit integers *\/$/;"	t	file:
i64	.\tool\varint.c	/^  typedef __int64 i64;$/;"	t	file:
i64	.\tool\varint.c	/^  typedef long long int i64;$/;"	t	file:
i8	.\src\sqliteInt.h	/^typedef INT8_TYPE i8;              \/* 1-byte signed integer *\/$/;"	t
iAbsLevel	.\ext\fts3\fts3_write.c	/^  sqlite3_int64 iAbsLevel;        \/* Absolute level of input segments *\/$/;"	m	struct:IncrmergeWriter	file:
iAddr	.\src\vdbeaux.c	/^  int iAddr;                 \/* Address of next instruction to return *\/$/;"	m	struct:VdbeOpIter	file:
iAgg	.\src\sqliteInt.h	/^  i16 iAgg;              \/* Which entry in pAggInfo->aCol[] or ->aFunc[] *\/$/;"	m	struct:Expr
iAlias	.\src\sqliteInt.h	/^        u16 iAlias;           \/* Index into Parse.aAlias[] for zName *\/$/;"	m	struct:ExprList::ExprList_item::__anon17::__anon18
iAppend	.\ext\misc\json1.c	/^    u32 iAppend;           \/* More terms for ARRAY and OBJECT *\/$/;"	m	union:JsonNode::__anon4	file:
iArg	.\src\pragma.h	/^  u32 iArg;                 \/* Extra argument *\/$/;"	m	struct:sPragmaNames
iArg	.\src\vdbeInt.h	/^  int iArg;                       \/* Index of function argument. *\/$/;"	m	struct:AuxData
iBatch	.\src\rowset.c	/^  int iBatch;                    \/* Current insert batch *\/$/;"	m	struct:RowSet	file:
iBegin	.\ext\misc\json1.c	/^  u32 iBegin;                \/* The first node of the scan *\/$/;"	m	struct:JsonEachCursor	file:
iBegin	.\src\shell.c	/^static sqlite3_int64 iBegin;  \/* Wall-clock time at start *\/$/;"	v	file:
iBlock	.\ext\fts3\fts3_write.c	/^  sqlite3_int64 iBlock;           \/* Current block id *\/$/;"	m	struct:NodeWriter	file:
iBlockid	.\ext\fts2\fts2.c	/^  sqlite_int64 iBlockid;$/;"	m	struct:InteriorReader	file:
iBreak	.\src\whereInt.h	/^  int iBreak;               \/* Jump here to break out of the loop *\/$/;"	m	struct:WhereInfo
iBtPage	.\ext\fts5\fts5_index.c	/^  int iBtPage;                    \/* Page number corresponding to btterm *\/$/;"	m	struct:Fts5SegWriter	file:
iBufEnd	.\src\vdbesort.c	/^  int iBufEnd;                    \/* Last byte of buffer to write *\/$/;"	m	struct:PmaWriter	file:
iBufStart	.\src\vdbesort.c	/^  int iBufStart;                  \/* First byte of buffer to write *\/$/;"	m	struct:PmaWriter	file:
iBufferOfst	.\src\test_demovfs.c	/^  sqlite3_int64 iBufferOfst;      \/* Offset in file of zBuffer[0] *\/$/;"	m	struct:DemoFile	file:
iCacheCnt	.\src\sqliteInt.h	/^  int iCacheCnt;       \/* Counter used to generate aColCache[].lru values *\/$/;"	m	struct:Parse
iCacheLevel	.\src\sqliteInt.h	/^  int iCacheLevel;     \/* ColCache valid when aColCache[].iLevel<=iCacheLevel *\/$/;"	m	struct:Parse
iCallback	.\src\wal.c	/^  u32 iCallback;             \/* Value to pass to log callback (or 0) *\/$/;"	m	struct:Wal	file:
iCell	.\ext\rtree\rtree.c	/^  u8 iCell;              \/* Cell index within the node *\/$/;"	m	struct:RtreeSearchPoint	file:
iCell	.\src\dbstat.c	/^  int iCell;$/;"	m	struct:StatPage	file:
iChange	.\src\wal.c	/^  u32 iChange;                    \/* Counter incremented each transaction *\/$/;"	m	struct:WalIndexHdr	file:
iChild	.\ext\fts3\fts3_write.c	/^  sqlite3_int64 iChild;           \/* Pointer to child node *\/$/;"	m	struct:NodeReader	file:
iChildPg	.\src\dbstat.c	/^  u32 iChildPg;                   \/* Child node (or 0 if this is a leaf) *\/$/;"	m	struct:StatCell	file:
iClock	.\src\test_sqllog.c	/^  int iClock;                     \/* Clock value *\/$/;"	m	struct:SLGlobal	file:
iCnt	.\src\test_vfs.c	/^  int iCnt;                       \/* Remaining calls before fault injection *\/$/;"	m	struct:TestFaultInject	file:
iCol	.\ext\fts1\fts1.c	/^    short int iCol;      \/* The column that contains the match *\/$/;"	m	struct:Snippet::snippetMatch	file:
iCol	.\ext\fts2\fts2.c	/^    short int iCol;      \/* The column that contains the match *\/$/;"	m	struct:Snippet::snippetMatch	file:
iCol	.\ext\fts3\fts3.c	/^  int iCol;                       \/* The column the token must match *\/$/;"	m	struct:Fts3TokenAndCost	file:
iCol	.\ext\fts3\fts3Int.h	/^  int iCol;$/;"	m	struct:Fts3SegFilter
iCol	.\ext\fts3\fts3_aux.c	/^  int iCol;                       \/* Current value of 'col' column *\/$/;"	m	struct:Fts3auxCursor	file:
iCol	.\ext\fts3\fts3_snippet.c	/^  int iCol;                       \/* Column of table to populate aTerm for *\/$/;"	m	struct:TermOffsetCtx	file:
iCol	.\ext\fts3\fts3_snippet.c	/^  int iCol;                       \/* Column snippet is extracted from *\/$/;"	m	struct:SnippetFragment	file:
iCol	.\ext\fts3\fts3_snippet.c	/^  int iCol;                       \/* Extract snippet from this column *\/$/;"	m	struct:SnippetIter	file:
iCol	.\ext\fts3\fts3_term.c	/^  int iCol;                       \/* Current 'col' value *\/$/;"	m	struct:Fts3termCursor	file:
iCol	.\ext\fts3\fts3_write.c	/^  int iCol;                       \/* Column token must occur in *\/$/;"	m	struct:Fts3DeferredToken	file:
iCol	.\ext\fts5\fts5_aux.c	/^  int iCol;                       \/* Column to search *\/$/;"	m	struct:CInstIter	file:
iCol	.\ext\fts5\fts5_hash.c	/^  int iCol;                       \/* Column of last value written *\/$/;"	m	struct:Fts5HashEntry	file:
iCol	.\ext\fts5\fts5_storage.c	/^  int iCol;$/;"	m	struct:Fts5InsertCtx	file:
iCol	.\ext\fts5\fts5_storage.c	/^  int iCol;$/;"	m	struct:Fts5IntegrityCtx	file:
iCol	.\ext\fts5\fts5_vocab.c	/^  int iCol;$/;"	m	struct:Fts5VocabCursor	file:
iCol	.\src\analyze.c	/^  int iCol;                       \/* If !isPSample, the reason for inclusion *\/$/;"	m	struct:Stat4Sample	file:
iCol	.\src\vdbeblob.c	/^  int iCol;               \/* Table column this handle is open on *\/$/;"	m	struct:Incrblob	file:
iCol	.\tool\offsets.c	/^  int iCol;             \/* Column number for the column *\/$/;"	m	struct:GState	file:
iColFilter	.\ext\fts3\fts3Int.h	/^  int iColFilter;                 \/* If >=0, filter for this column *\/$/;"	m	struct:Fts3MultiSegReader
iColumn	.\ext\fts1\fts1.c	/^  int iColumn;                     \/* Column being searched *\/$/;"	m	struct:fulltext_cursor	file:
iColumn	.\ext\fts1\fts1.c	/^  short int iColumn; \/* Column of the index that must match this term *\/$/;"	m	struct:QueryTerm	file:
iColumn	.\ext\fts2\fts2.c	/^  int iColumn;                     \/* Column being searched *\/$/;"	m	struct:fulltext_cursor	file:
iColumn	.\ext\fts2\fts2.c	/^  int iColumn;         \/* the last column read *\/$/;"	m	struct:PLReader	file:
iColumn	.\ext\fts2\fts2.c	/^  int iColumn;    \/* the last column written *\/$/;"	m	struct:PLWriter	file:
iColumn	.\ext\fts2\fts2.c	/^  short int iColumn; \/* Column of the index that must match this term *\/$/;"	m	struct:QueryTerm	file:
iColumn	.\ext\fts3\fts3Int.h	/^  int iColumn;               \/* Index of column this phrase must match *\/$/;"	m	struct:Fts3Phrase
iColumn	.\src\sqliteInt.h	/^    i16 iColumn;          \/* Table column number *\/$/;"	m	struct:Parse::yColCache
iColumn	.\src\sqliteInt.h	/^    int iColumn;             \/* Column number within the source table *\/$/;"	m	struct:AggInfo::AggInfo_col
iColumn	.\src\sqliteInt.h	/^  ynVar iColumn;         \/* TK_COLUMN: column index.  -1 for rowid.$/;"	m	struct:Expr
iConstExprReg	.\src\sqliteInt.h	/^      int iConstExprReg;      \/* Register in which Expr value is cached *\/$/;"	m	union:ExprList::ExprList_item::__anon17
iContinue	.\src\whereInt.h	/^  int iContinue;            \/* Jump here to continue with next record *\/$/;"	m	struct:WhereInfo
iCookie	.\ext\fts5\fts5Int.h	/^  int iCookie;                    \/* Incremented when %_config is modified *\/$/;"	m	struct:Fts5Config
iCookie	.\ext\rbu\sqlite3rbu.c	/^  u32 iCookie;                    \/* Cookie value for main db files *\/$/;"	m	struct:rbu_file	file:
iCookie	.\ext\rbu\sqlite3rbu.c	/^  u32 iCookie;$/;"	m	struct:RbuState	file:
iCoord	.\ext\rtree\rtree.c	/^  int iCoord;                     \/* Index of constrained coordinate *\/$/;"	m	struct:RtreeConstraint	file:
iCost	.\ext\misc\spellfix.c	/^  u16 iCost;                \/* Cost of this transformation *\/$/;"	m	struct:EditDist3Cost	file:
iCountdown	.\src\test_malloc.c	/^  int iCountdown;         \/* Number of pending successes before a failure *\/$/;"	m	struct:MemFault	file:
iCrash	.\src\test6.c	/^  int iCrash;                  \/* Crash on the iCrash'th call to xSync() *\/$/;"	m	struct:CrashGlobal	file:
iCsrId	.\ext\fts5\fts5_main.c	/^  i64 iCsrId;                     \/* Cursor id *\/$/;"	m	struct:Fts5Cursor	file:
iCur	.\src\sqliteInt.h	/^    int iCur;                                  \/* A cursor number *\/$/;"	m	union:Walker::__anon22
iCur	.\src\whereInt.h	/^        int iCur;              \/* The VDBE cursor used by this IN operator *\/$/;"	m	struct:WhereLevel::__anon26::__anon27::InLoop
iCurrent	.\ext\fts3\fts3_snippet.c	/^  int iCurrent;                   \/* First token of current snippet *\/$/;"	m	struct:SnippetIter	file:
iCurrentBlock	.\ext\fts3\fts3_write.c	/^  sqlite3_int64 iCurrentBlock;    \/* Current leaf block (or 0) *\/$/;"	m	struct:Fts3SegReader	file:
iCurrentTime	.\src\vdbeInt.h	/^  i64 iCurrentTime;       \/* Value of julianday('now') for this statement *\/$/;"	m	struct:Vdbe
iCursor	.\src\sqliteInt.h	/^    int iCursor;      \/* The VDBE cursor number used to access this table *\/$/;"	m	struct:SrcList::SrcList_item
iCursorType	.\ext\fts1\fts1.c	/^  QueryType iCursorType;           \/* Copy of sqlite3_index_info.idxNum *\/$/;"	m	struct:fulltext_cursor	file:
iCursorType	.\ext\fts1\fulltext.c	/^  int iCursorType;  \/* QUERY_GENERIC or QUERY_FULLTEXT *\/$/;"	m	struct:fulltext_cursor	file:
iCursorType	.\ext\fts2\fts2.c	/^  QueryType iCursorType;           \/* Copy of sqlite3_index_info.idxNum *\/$/;"	m	struct:fulltext_cursor	file:
iDataVersion	.\src\btreeInt.h	/^  u32 iDataVersion;  \/* Combines with pBt->pPager->iDataVersion *\/$/;"	m	struct:Btree
iDataVersion	.\src\pager.c	/^  u32 iDataVersion;           \/* Changes whenever database content changes *\/$/;"	m	struct:Pager	file:
iDb	.\src\build.c	/^  int iDb;             \/* The database containing the table to be locked *\/$/;"	m	struct:TableLock	file:
iDb	.\src\dbstat.c	/^  int iDb;                        \/* Index of database to analyze *\/$/;"	m	struct:StatTable	file:
iDb	.\src\dbstat.c	/^  int iDb;                        \/* Schema used for this query *\/$/;"	m	struct:StatCursor	file:
iDb	.\src\sqliteInt.h	/^    u8 iDb;                     \/* Which db file is being initialized *\/$/;"	m	struct:sqlite3::sqlite3InitInfo
iDb	.\src\sqliteInt.h	/^  int iDb;              \/* Index in sqlite3.aDb[] of database holding pTab *\/$/;"	m	struct:AutoincInfo
iDb	.\src\sqliteInt.h	/^  int iDb;            \/* 0 for main database.  1 for TEMP, 2.. for ATTACHed *\/$/;"	m	struct:__anon21
iDb	.\src\vdbeInt.h	/^  i8 iDb;               \/* Index of cursor database in db->aDb[] (or -1) *\/$/;"	m	struct:VdbeCursor
iDbPage	.\ext\rbu\sqlite3rbu.c	/^  u32 iDbPage;$/;"	m	struct:RbuFrame	file:
iDefaultCol	.\ext\fts3\fts3_expr.c	/^  int iDefaultCol;                    \/* Default column to query *\/$/;"	m	struct:ParseContext	file:
iDelCost	.\ext\misc\spellfix.c	/^  int iDelCost;          \/* Default deletion cost *\/$/;"	m	struct:EditDist3Lang	file:
iDepth	.\ext\rtree\rtree.c	/^  int iDepth;                 \/* Current depth of the r-tree structure *\/$/;"	m	struct:Rtree	file:
iDestSchema	.\src\backup.c	/^  u32 iDestSchema;         \/* Original schema cookie in destination *\/$/;"	m	struct:sqlite3_backup	file:
iDevchar	.\src\test_vfs.c	/^  int iDevchar;$/;"	m	struct:Testvfs	file:
iDeviceChar	.\src\test_devsym.c	/^  int iDeviceChar;$/;"	m	struct:DevsymGlobal	file:
iDeviceCharacteristics	.\src\test6.c	/^  int iDeviceCharacteristics;  \/* Value of simulated device characteristics *\/$/;"	m	struct:CrashGlobal	file:
iDfltReduce	.\tool\lemon.c	/^  int iDfltReduce;         \/* Default action is to REDUCE by this rule *\/$/;"	m	struct:state	file:
iDistance	.\ext\misc\spellfix.c	/^    int iDistance;                \/* Distance from pattern for this row *\/$/;"	m	struct:spellfix1_cursor::spellfix1_row	file:
iDistinct	.\src\sqliteInt.h	/^    int iDistinct;           \/* Ephemeral table used to enforce DISTINCT *\/$/;"	m	struct:AggInfo::AggInfo_func
iDivisor	.\src\bitvec.c	/^  u32 iDivisor;   \/* Number of bits handled by each apSub[] entry. *\/$/;"	m	struct:Bitvec	file:
iDocid	.\ext\fts2\fts2.c	/^  sqlite_int64 iDocid;$/;"	m	struct:DLReader	file:
iDocid	.\ext\fts3\fts3.c	/^  sqlite3_int64 iDocid;$/;"	m	struct:TokenDoclist	file:
iDocid	.\ext\fts3\fts3Int.h	/^  sqlite3_int64 iDocid;          \/* Current docid (if pList!=0) *\/$/;"	m	struct:Fts3Doclist
iDocid	.\ext\fts3\fts3Int.h	/^  sqlite3_int64 iDocid;      \/* Current docid *\/$/;"	m	struct:Fts3Expr
iDocid	.\ext\fts3\fts3_snippet.c	/^  sqlite3_int64 iDocid;$/;"	m	struct:TermOffsetCtx	file:
iDocid	.\ext\fts3\fts3_term.c	/^  sqlite3_int64 iDocid;           \/* Current 'docid' value *\/$/;"	m	struct:Fts3termCursor	file:
iDocid	.\ext\fts3\fts3_write.c	/^  sqlite3_int64 iDocid;$/;"	m	struct:Fts3SegReader	file:
iDoclistToken	.\ext\fts3\fts3Int.h	/^  int iDoclistToken;$/;"	m	struct:Fts3Phrase
iECursor	.\src\select.c	/^  int iECursor;         \/* Cursor number for the sorter *\/$/;"	m	struct:SortCtx	file:
iEnd	.\ext\fts3\fts3_tokenize_vtab.c	/^  int iEnd;                       \/* Current 'end' value *\/$/;"	m	struct:Fts3tokCursor	file:
iEnd	.\ext\fts3\fts3_write.c	/^  sqlite3_int64 iEnd;             \/* Block number of last allocated block *\/$/;"	m	struct:IncrmergeWriter	file:
iEnd	.\ext\fts5\fts5_aux.c	/^  int iEnd;                       \/* Last token in coalesced phrase instance *\/$/;"	m	struct:CInstIter	file:
iEnd	.\ext\misc\json1.c	/^  u32 iEnd;                  \/* EOF when i equals or exceeds this value *\/$/;"	m	struct:JsonEachCursor	file:
iEndBlock	.\ext\fts3\fts3_write.c	/^  sqlite3_int64 iEndBlock;        \/* Rowid of final block in segment (or 0) *\/$/;"	m	struct:Fts3SegReader	file:
iEndBlockid	.\ext\fts2\fts2.c	/^  sqlite_int64 iEndBlockid;       \/* when we're done writing. *\/$/;"	m	struct:LeafWriter	file:
iEndOffset	.\ext\fts2\fts2.c	/^  int iEndOffset;      \/* the last end offset read *\/$/;"	m	struct:PLReader	file:
iEndofDoclist	.\ext\fts5\fts5_index.c	/^  int iEndofDoclist;$/;"	m	struct:Fts5SegIter	file:
iEof	.\src\vdbesort.c	/^  i64 iEof;                       \/* Bytes of data stored in pFd *\/$/;"	m	struct:SorterFile	file:
iEof	.\src\vdbesort.c	/^  i64 iEof;                   \/* 1 byte past EOF for this PmaReader *\/$/;"	m	struct:PmaReader	file:
iEquiv	.\src\whereInt.h	/^  unsigned char iEquiv;      \/* Next unused slot in aEquiv[] *\/$/;"	m	struct:WhereScan
iFileId	.\src\test_osinst.c	/^  int iFileId;                    \/* File id number *\/$/;"	m	struct:VfslogFile	file:
iFirst	.\ext\fts3\fts3_write.c	/^  sqlite3_int64 iFirst;           \/* First slot in %_segments written *\/$/;"	m	struct:SegmentWriter	file:
iFirst	.\ext\fts5\fts5_index.c	/^  u16 iFirst;                     \/* aSeg[] index of firstest iterator *\/$/;"	m	struct:Fts5CResult	file:
iFirstOff	.\ext\fts5\fts5_index.c	/^  int iFirstOff;                \/* Used by reverse iterators *\/$/;"	m	struct:Fts5DlidxLvl	file:
iFirstRowid	.\ext\fts5\fts5_main.c	/^  i64 iFirstRowid;                \/* Return no rowids earlier than this *\/$/;"	m	struct:Fts5Cursor	file:
iFixedOp	.\src\sqliteInt.h	/^  int iFixedOp;        \/* Never back out opcodes iFixedOp-1 or earlier *\/$/;"	m	struct:Parse
iForeGuard	.\src\mem2.c	/^  int iForeGuard;                     \/* Guard word for sanity *\/$/;"	m	struct:MemBlockHdr	file:
iFree	.\ext\fts3\fts3_write.c	/^  sqlite3_int64 iFree;            \/* Next free slot in %_segments *\/$/;"	m	struct:SegmentWriter	file:
iFrom	.\src\sqliteInt.h	/^    int iFrom;            \/* Index of column in pFrom *\/$/;"	m	struct:FKey::sColMap
iFrom	.\src\whereInt.h	/^  u8 iFrom;             \/* Which entry in the FROM clause *\/$/;"	m	struct:WhereLevel
iGeneration	.\ext\misc\closure.c	/^  int iGeneration;      \/* Which generation is this entry part of *\/$/;"	m	struct:closure_avl	file:
iGeneration	.\src\sqliteInt.h	/^  int iGeneration;     \/* Generation counter.  Incremented with each change *\/$/;"	m	struct:Schema
iGet	.\src\analyze.c	/^  int iGet;                 \/* Index of current sample accessed by stat_get() *\/$/;"	m	struct:Stat4Accum	file:
iHash	.\src\analyze.c	/^  u32 iHash;                      \/* Tiebreaker hash *\/$/;"	m	struct:Stat4Sample	file:
iHdrOffset	.\src\pager.c	/^  i64 iHdrOffset;              \/* See above *\/$/;"	m	struct:PagerSavepoint	file:
iHdrOffset	.\src\vdbeInt.h	/^  u32 iHdrOffset;       \/* Offset to next unparsed byte of the header *\/$/;"	m	struct:VdbeCursor
iHead	.\ext\fts3\fts3_snippet.c	/^  int iHead;                      \/* Next value in position list *\/$/;"	m	struct:SnippetPhrase	file:
iHeight	.\ext\fts2\fts2.c	/^  int iHeight;                   \/* from 0 at leaves. *\/$/;"	m	struct:InteriorWriter	file:
iIdx	.\ext\fts3\fts3_write.c	/^  int iIdx;                       \/* Index of *output* segment in iAbsLevel+1 *\/$/;"	m	struct:IncrmergeWriter	file:
iIdx	.\ext\fts3\fts3_write.c	/^  int iIdx;                       \/* Index within level, or 0x7FFFFFFF for PT *\/$/;"	m	struct:Fts3SegReader	file:
iIdxCur	.\src\whereInt.h	/^  int iIdxCur;          \/* The VDBE cursor used to access pIdx *\/$/;"	m	struct:WhereLevel
iIndent	.\src\shell.c	/^  int iIndent;           \/* Index of current op in aiIndent[] *\/$/;"	m	struct:ShellState	file:
iIndex	.\ext\fts3\fts3_term.c	/^  int iIndex;                     \/* Index for Fts3Table.aIndex[] *\/$/;"	m	struct:Fts3termTable	file:
iInput	.\ext\fts3\fts3_test.c	/^  int iInput;                  \/* Current offset in aInput *\/$/;"	m	struct:test_tokenizer_cursor	file:
iInsCost	.\ext\misc\spellfix.c	/^  int iInsCost;          \/* Default insertion cost *\/$/;"	m	struct:EditDist3Lang	file:
iInst	.\ext\fts5\fts5_aux.c	/^  int iInst;                      \/* Next phrase instance index *\/$/;"	m	struct:CInstIter	file:
iJD	.\src\date.c	/^  sqlite3_int64 iJD; \/* The julian day number times 86400000 *\/$/;"	m	struct:DateTime	file:
iKey	.\ext\misc\json1.c	/^    u32 iKey;              \/* Key for ARRAY objects in json_tree() *\/$/;"	m	union:JsonNode::__anon4	file:
iKey	.\src\pcache1.c	/^  unsigned int iKey;             \/* Key value (page number) *\/$/;"	m	struct:PgHdr1	file:
iLang	.\ext\misc\amatch.c	/^  amatch_langid iLang;       \/* Use this language ID *\/$/;"	m	struct:amatch_cursor	file:
iLang	.\ext\misc\amatch.c	/^  amatch_langid iLang;     \/* The langauge to which this rule belongs *\/$/;"	m	struct:amatch_rule	file:
iLang	.\ext\misc\spellfix.c	/^  int iLang;                       \/* The language id *\/$/;"	m	struct:MatchQuery	file:
iLang	.\ext\misc\spellfix.c	/^  int iLang;                   \/* Value of the langid= constraint *\/$/;"	m	struct:spellfix1_cursor	file:
iLang	.\ext\misc\spellfix.c	/^  int iLang;             \/* Language ID *\/$/;"	m	struct:EditDist3Lang	file:
iLangid	.\ext\fts3\fts3Int.h	/^  int iLangid;                    \/* Language being queried for *\/$/;"	m	struct:Fts3Cursor
iLangid	.\ext\fts3\fts3_aux.c	/^  int iLangid;                    \/* Language id to query *\/$/;"	m	struct:Fts3auxCursor	file:
iLangid	.\ext\fts3\fts3_expr.c	/^  int iLangid;                        \/* Language id used with tokenizer *\/$/;"	m	struct:ParseContext	file:
iLangid	.\ext\fts3\fts3_test.c	/^  int iLangid;                 \/* Configured language id *\/$/;"	m	struct:test_tokenizer_cursor	file:
iLastChildBlock	.\ext\fts2\fts2.c	/^  sqlite_int64 iLastChildBlock;  \/* for consistency checks. *\/$/;"	m	struct:InteriorWriter	file:
iLastCol	.\ext\fts3\fts3_write.c	/^  sqlite3_int64 iLastCol;$/;"	m	struct:PendingList	file:
iLastColumn	.\ext\fts1\fts1.c	/^  int iLastColumn;    \/* the last column written *\/$/;"	m	struct:DocList	file:
iLastColumn	.\ext\fts1\fts1.c	/^  int iLastColumn;$/;"	m	struct:DocListReader	file:
iLastDocid	.\ext\fts3\fts3_write.c	/^  sqlite3_int64 iLastDocid;$/;"	m	struct:PendingList	file:
iLastOffset	.\ext\fts1\fts1.c	/^  int iLastOffset;    \/* the last start offset written *\/$/;"	m	struct:DocList	file:
iLastOffset	.\ext\fts1\fulltext.c	/^  int iLastOffset;    \/* the last start offset written *\/$/;"	m	struct:DocList	file:
iLastPos	.\ext\fts1\fts1.c	/^  int iLastPos;       \/* the last position written *\/$/;"	m	struct:DocList	file:
iLastPos	.\ext\fts1\fts1.c	/^  int iLastPos;  \/* the last position read, or -1 when not in a position list *\/$/;"	m	struct:DocListReader	file:
iLastPos	.\ext\fts1\fulltext.c	/^  int iLastPos;       \/* the last position written *\/$/;"	m	struct:DocList	file:
iLastPos	.\ext\fts1\fulltext.c	/^  int iLastPos;    \/* the last position read *\/$/;"	m	struct:DocListReader	file:
iLastPos	.\ext\fts3\fts3_write.c	/^  sqlite3_int64 iLastPos;$/;"	m	struct:PendingList	file:
iLastRowid	.\ext\fts5\fts5_main.c	/^  i64 iLastRowid;                 \/* Return no rowids later than this *\/$/;"	m	struct:Fts5Cursor	file:
iLeafEndBlock	.\ext\fts3\fts3_write.c	/^  sqlite3_int64 iLeafEndBlock;    \/* Rowid of final leaf block to traverse *\/$/;"	m	struct:Fts3SegReader	file:
iLeafOffset	.\ext\fts5\fts5_index.c	/^  int iLeafOffset;                \/* Byte offset within current leaf *\/$/;"	m	struct:Fts5SegIter	file:
iLeafPgno	.\ext\fts5\fts5_index.c	/^  int iLeafPgno;                  \/* Current leaf page number *\/$/;"	m	struct:Fts5SegIter	file:
iLeafPgno	.\ext\fts5\fts5_index.c	/^  int iLeafPgno;                \/* Page number of current leaf page *\/$/;"	m	struct:Fts5DlidxLvl	file:
iLeftJoin	.\src\whereInt.h	/^  int iLeftJoin;        \/* Memory cell used to implement LEFT OUTER JOIN *\/$/;"	m	struct:WhereLevel
iLevel	.\ext\fts2\fts2.c	/^  int iLevel;$/;"	m	struct:LeafWriter	file:
iLevel	.\ext\rtree\rtree.c	/^  u8 iLevel;             \/* 0=entries.  1=leaf node.  2+ for higher *\/$/;"	m	struct:RtreeSearchPoint	file:
iLevel	.\ext\rtree\sqlite3rtree.h	/^  int iLevel;                       \/* Level of current node or entry *\/$/;"	m	struct:sqlite3_rtree_query_info
iLevel	.\src\sqliteInt.h	/^    int iLevel;           \/* Nesting level *\/$/;"	m	struct:Parse::yColCache
iLevel	.\src\sqliteInt.h	/^  int iLevel;             \/* Which level of the tree we are on *\/$/;"	m	struct:TreeView
iLikeRepCntr	.\src\whereInt.h	/^  int iLikeRepCntr;     \/* LIKE range processing counter register *\/$/;"	m	struct:WhereLevel
iLimit	.\src\sqliteInt.h	/^  int iLimit, iOffset;   \/* Memory registers holding LIMIT & OFFSET counters *\/$/;"	m	struct:Select
iLimit	.\src\test_quota.c	/^  sqlite3_int64 iLimit;          \/* Upper bound on total file size *\/$/;"	m	struct:quotaGroup	file:
iLine	.\test\threadtest3.c	/^  int iLine;$/;"	m	struct:Error	file:
iLog	.\src\test_sqllog.c	/^  int iLog;                       \/* First integer value used in file names *\/$/;"	m	struct:SLConn	file:
iLookahead	.\ext\fts5\fts5_expr.c	/^  i64 iLookahead;                 \/* Next position *\/$/;"	m	struct:Fts5LookaheadReader	file:
iMagic	.\src\test_pcache.c	/^  unsigned iMagic;          \/* Magic number for sanity checking *\/$/;"	m	struct:testpcache	file:
iMaster	.\src\mem3.c	/^  u32 iMaster;$/;"	m	struct:Mem3Global	file:
iMatchlen	.\ext\misc\spellfix.c	/^    int iMatchlen;                \/* Value of matchlen column (or -1) *\/$/;"	m	struct:spellfix1_cursor::spellfix1_row	file:
iMaxDist	.\ext\misc\spellfix.c	/^  int iMaxDist;                    \/* Maximum allowed edit distance, or -1 *\/$/;"	m	struct:MatchQuery	file:
iMaxDocid	.\ext\fts3\fts3Int.h	/^  i64 iMaxDocid;                  \/* Maximum docid to return *\/$/;"	m	struct:Fts3Cursor
iMaxFrame	.\ext\rbu\sqlite3rbu.c	/^  u32 iMaxFrame;                  \/* Largest iWalFrame value in aFrame[] *\/$/;"	m	struct:sqlite3rbu	file:
iMaxKey	.\src\pcache1.c	/^  unsigned int iMaxKey;               \/* Largest key seen since xTruncate() *\/$/;"	m	struct:PCache1	file:
iMaxOff	.\src\test_journal.c	/^  sqlite3_int64 iMaxOff;   \/* Maximum offset written to this transaction *\/$/;"	m	struct:jt_file	file:
iMaxTid	.\test\threadtest3.c	/^  int iMaxTid;                    \/* Largest iTid value allocated so far *\/$/;"	m	struct:Threadset	file:
iMem	.\src\sqliteInt.h	/^    int iMem;                \/* Memory location that acts as accumulator *\/$/;"	m	struct:AggInfo::AggInfo_col
iMem	.\src\sqliteInt.h	/^    int iMem;                \/* Memory location that acts as accumulator *\/$/;"	m	struct:AggInfo::AggInfo_func
iMemory	.\src\vdbesort.c	/^  int iMemory;                    \/* Offset of free space in list.aMemory *\/$/;"	m	struct:VdbeSorter	file:
iMin	.\src\analyze.c	/^  int iMin;                 \/* Index in a[] of entry with minimum score *\/$/;"	m	struct:Stat4Accum	file:
iMinDocid	.\ext\fts3\fts3Int.h	/^  i64 iMinDocid;                  \/* Minimum docid to return *\/$/;"	m	struct:Fts3Cursor
iNext	.\src\backup.c	/^  Pgno iNext;              \/* Page number of the next source page to copy *\/$/;"	m	struct:sqlite3_backup	file:
iNext	.\src\vdbesort.c	/^    int iNext;                    \/* Offset within aMemory of next record *\/$/;"	m	union:SorterRecord::__anon25	file:
iNext	.\src\wal.c	/^    int iNext;                    \/* Next slot in aIndex[] not yet returned *\/$/;"	m	struct:WalIterator::WalSegment	file:
iNext	.\tool\mkkeywordhash.c	/^  int iNext;           \/* Index in aKeywordTable[] of next with same hash *\/$/;"	m	struct:Keyword	file:
iNextDb	.\src\test_sqllog.c	/^  int iNextDb;                    \/* Used to allocate database file names *\/$/;"	m	struct:SLGlobal	file:
iNextFileId	.\src\test_osinst.c	/^  int iNextFileId;                \/* Next file id *\/$/;"	m	struct:VfslogVfs	file:
iNextId	.\ext\fts5\fts5_main.c	/^  i64 iNextId;                    \/* Used to allocate unique cursor ids *\/$/;"	m	struct:Fts5Global	file:
iNextLog	.\src\test_sqllog.c	/^  int iNextLog;                   \/* Used to allocate file names *\/$/;"	m	struct:SLGlobal	file:
iNextSelectId	.\src\sqliteInt.h	/^  int iNextSelectId;        \/* Next available select ID for EXPLAIN output *\/$/;"	m	struct:Parse
iNode	.\ext\rtree\rtree.c	/^  i64 iNode;                  \/* The node number *\/$/;"	m	struct:RtreeNode	file:
iNodeSize	.\ext\rtree\rtree.c	/^  int iNodeSize;              \/* Size in bytes of each node in the node table *\/$/;"	m	struct:Rtree	file:
iNtOfst	.\tool\lemon.c	/^  int iTknOfst, iNtOfst;   \/* yy_action[] offset for terminals and nonterms *\/$/;"	m	struct:state	file:
iOalSz	.\ext\rbu\sqlite3rbu.c	/^  i64 iOalSz;$/;"	m	struct:RbuState	file:
iOalSz	.\ext\rbu\sqlite3rbu.c	/^  i64 iOalSz;$/;"	m	struct:sqlite3rbu	file:
iOff	.\ext\fts3\fts3_snippet.c	/^  int iOff;                       \/* Offset of this term from read positions *\/$/;"	m	struct:TermOffset	file:
iOff	.\ext\fts3\fts3_unicode.c	/^  int iOff;                       \/* Current offset within aInput[] *\/$/;"	m	struct:unicode_cursor	file:
iOff	.\ext\fts3\fts3_write.c	/^  int iOff;                       \/* Current offset within aNode[] *\/$/;"	m	struct:NodeReader	file:
iOff	.\ext\fts5\fts5_aux.c	/^  int iOff;                       \/* Current offset within zIn[] *\/$/;"	m	struct:HighlightContext	file:
iOff	.\ext\fts5\fts5_index.c	/^  int iOff;                     \/* Current offset into pData *\/$/;"	m	struct:Fts5DlidxLvl	file:
iOffset	.\ext\async\sqlite3async.c	/^  sqlite_int64 iOffset;        \/* See above *\/$/;"	m	struct:AsyncWrite	file:
iOffset	.\ext\fts1\fts1_porter.c	/^  int iOffset;                 \/* current position in zInput *\/$/;"	m	struct:porter_tokenizer_cursor	file:
iOffset	.\ext\fts1\fts1_tokenizer1.c	/^  int iOffset;                 \/* current position in pInput *\/$/;"	m	struct:simple_tokenizer_cursor	file:
iOffset	.\ext\fts1\fulltext.c	/^  int iOffset;$/;"	m	struct:DocListMerge	file:
iOffset	.\ext\fts2\fts2.c	/^  int iOffset;    \/* the last start offset written *\/$/;"	m	struct:PLWriter	file:
iOffset	.\ext\fts2\fts2_porter.c	/^  int iOffset;                 \/* current position in zInput *\/$/;"	m	struct:porter_tokenizer_cursor	file:
iOffset	.\ext\fts2\fts2_tokenizer1.c	/^  int iOffset;                 \/* current position in pInput *\/$/;"	m	struct:simple_tokenizer_cursor	file:
iOffset	.\ext\fts3\fts3_porter.c	/^  int iOffset;                 \/* current position in zInput *\/$/;"	m	struct:porter_tokenizer_cursor	file:
iOffset	.\ext\fts3\fts3_tokenizer1.c	/^  int iOffset;                 \/* current position in pInput *\/$/;"	m	struct:simple_tokenizer_cursor	file:
iOffset	.\src\dbstat.c	/^  i64 iOffset;                    \/* Value of 'pgOffset' column *\/$/;"	m	struct:StatCursor	file:
iOffset	.\src\memjournal.c	/^  sqlite3_int64 iOffset;          \/* Offset from the beginning of the file *\/$/;"	m	struct:FilePoint	file:
iOffset	.\src\pager.c	/^  i64 iOffset;                 \/* Starting offset in main journal *\/$/;"	m	struct:PagerSavepoint	file:
iOffset	.\src\sqliteInt.h	/^  int iLimit, iOffset;   \/* Memory registers holding LIMIT & OFFSET counters *\/$/;"	m	struct:Select
iOffset	.\src\test6.c	/^  i64 iOffset;                 \/* Byte offset of the start of this write() *\/$/;"	m	struct:WriteBuffer	file:
iOffset	.\src\test_osinst.c	/^  sqlite3_int64 iOffset;          \/* Log file offset of start of write buffer *\/$/;"	m	struct:VfslogVfs	file:
iOffset	.\src\test_osinst.c	/^  sqlite3_int64 iOffset;          \/* Offset of next record in file *\/$/;"	m	struct:VfslogCsr	file:
iOffset	.\src\vdbeblob.c	/^  int iOffset;            \/* Byte offset of blob in cursor data *\/$/;"	m	struct:Incrblob	file:
iOfst	.\src\test_quota.c	/^  sqlite3_int64 iOfst;    \/* Current offset into the file *\/$/;"	m	struct:quota_FILE	file:
iOomCntdown	.\tool\fuzzershell.c	/^  int iOomCntdown;                 \/* Memory fails on 1 to 0 transition *\/$/;"	m	struct:GlobalVars	file:
iOp	.\src\vdbeInt.h	/^  int iOp;                        \/* Instruction number of OP_Function opcode *\/$/;"	m	struct:AuxData
iOp	.\src\vdbeInt.h	/^  int iOp;                \/* Instruction number of OP_Function *\/$/;"	m	struct:sqlite3_context
iOpeningChildBlock	.\ext\fts2\fts2.c	/^  sqlite_int64 iOpeningChildBlock; \/* First child block in block "last". *\/$/;"	m	struct:InteriorWriter	file:
iOrDocid	.\ext\fts3\fts3Int.h	/^  i64 iOrDocid;$/;"	m	struct:Fts3Phrase
iOrder	.\tool\lemon.c	/^  int iOrder;          \/* Original order of action sets *\/$/;"	m	struct:axset	file:
iOrderByCol	.\src\sqliteInt.h	/^        u16 iOrderByCol;      \/* For ORDER BY, column number in result set *\/$/;"	m	struct:ExprList::ExprList_item::__anon17::__anon18
iOverflow	.\src\btreeInt.h	/^  u16 iOverflow; \/* Offset to overflow page number.  Zero if no overflow *\/$/;"	m	struct:CellInfo
iOvfl	.\src\dbstat.c	/^  int iOvfl;                      \/* Iterates through aOvfl[] *\/$/;"	m	struct:StatCell	file:
iPKey	.\src\sqliteInt.h	/^  i16 iPKey;           \/* If not negative, use aCol[iPKey] as the rowid *\/$/;"	m	struct:Table
iPage	.\src\btreeInt.h	/^  i8 iPage;                 \/* Index of current page in apPage *\/$/;"	m	struct:BtCursor
iPage	.\src\dbstat.c	/^  int iPage;                      \/* Current entry in aPage[] *\/$/;"	m	struct:StatCursor	file:
iPageno	.\src\dbstat.c	/^  u32 iPageno;                    \/* Value of 'pageno' column *\/$/;"	m	struct:StatCursor	file:
iParent	.\src\whereInt.h	/^  int iParent;            \/* Disable pWC->a[iParent] when this term disabled *\/$/;"	m	struct:WhereTerm
iPgidxOff	.\ext\fts5\fts5_index.c	/^  int iPgidxOff;                  \/* Next offset in pgidx *\/$/;"	m	struct:Fts5SegIter	file:
iPgno	.\src\dbstat.c	/^  u32 iPgno;$/;"	m	struct:StatPage	file:
iPhrase	.\ext\fts1\fts1.c	/^  short int iPhrase; \/* This is the i-th term of a phrase. *\/$/;"	m	struct:QueryTerm	file:
iPhrase	.\ext\fts2\fts2.c	/^  short int iPhrase; \/* This is the i-th term of a phrase. *\/$/;"	m	struct:QueryTerm	file:
iPhrase	.\ext\fts3\fts3Int.h	/^  int iPhrase;               \/* Index of this phrase in matchinfo() results *\/$/;"	m	struct:Fts3Expr
iPkSortOrder	.\src\sqliteInt.h	/^  u8 iPkSortOrder;          \/* ASC or DESC for INTEGER PRIMARY KEY *\/$/;"	m	struct:Parse
iPkTnum	.\ext\rbu\sqlite3rbu.c	/^  int iPkTnum;                    \/* If eType==EXTERNAL, root of PK index *\/$/;"	m	struct:RbuObjIter	file:
iPos	.\ext\fts2\fts2.c	/^  int iPos;       \/* the last position written *\/$/;"	m	struct:PLWriter	file:
iPos	.\ext\fts3\fts3_snippet.c	/^  int iPos;                       \/* Current position *\/$/;"	m	struct:LcsIterator	file:
iPos	.\ext\fts3\fts3_snippet.c	/^  int iPos;                       \/* Index of first token in snippet *\/$/;"	m	struct:SnippetFragment	file:
iPos	.\ext\fts3\fts3_snippet.c	/^  int iPos;                       \/* Position just read from pList *\/$/;"	m	struct:TermOffset	file:
iPos	.\ext\fts3\fts3_term.c	/^  int iPos;                       \/* Current 'pos' value *\/$/;"	m	struct:Fts3termCursor	file:
iPos	.\ext\fts3\fts3_tokenize_vtab.c	/^  int iPos;                       \/* Current 'pos' value *\/$/;"	m	struct:Fts3tokCursor	file:
iPos	.\ext\fts5\fts5Int.h	/^  i64 iPos;                       \/* (iCol<<32) + iPos *\/$/;"	m	struct:Fts5PoslistReader
iPos	.\ext\fts5\fts5_aux.c	/^  int iPos;                       \/* Current token offset in zIn[] *\/$/;"	m	struct:HighlightContext	file:
iPos	.\ext\fts5\fts5_expr.c	/^  i64 iPos;                       \/* Current position *\/$/;"	m	struct:Fts5LookaheadReader	file:
iPos	.\ext\fts5\fts5_hash.c	/^  int iPos;                       \/* Position of last value written *\/$/;"	m	struct:Fts5HashEntry	file:
iPosOffset	.\ext\fts3\fts3_snippet.c	/^  int iPosOffset;                 \/* Tokens count up to end of this phrase *\/$/;"	m	struct:LcsIterator	file:
iPosition	.\ext\fts2\fts2.c	/^  int iPosition;       \/* the last position read *\/$/;"	m	struct:PLReader	file:
iPrev	.\ext\fts5\fts5Int.h	/^  i64 iPrev;$/;"	m	struct:Fts5PoslistWriter
iPrev	.\ext\fts5\fts5_index.c	/^  i64 iPrev;                      \/* Previous rowid value written to page *\/$/;"	m	struct:Fts5DlidxWriter	file:
iPrev	.\src\vdbesort.c	/^  u8 iPrev;                       \/* Previous thread used to flush PMA *\/$/;"	m	struct:VdbeSorter	file:
iPrevDocid	.\ext\fts2\fts2.c	/^  sqlite_int64 iPrevDocid;$/;"	m	struct:DLWriter	file:
iPrevDocid	.\ext\fts2\fts2.c	/^  sqlite_int64 iPrevDocid;$/;"	m	struct:fulltext_vtab	file:
iPrevDocid	.\ext\fts3\fts3Int.h	/^  sqlite_int64 iPrevDocid;        \/* Docid of most recently inserted document *\/$/;"	m	struct:Fts3Table
iPrevId	.\ext\fts3\fts3Int.h	/^  sqlite3_int64 iPrevId;          \/* Previous id read from aDoclist *\/$/;"	m	struct:Fts3Cursor
iPrevLangid	.\ext\fts3\fts3Int.h	/^  int iPrevLangid;                \/* Langid of recently inserted document *\/$/;"	m	struct:Fts3Table
iPrevPgidx	.\ext\fts5\fts5_index.c	/^  int iPrevPgidx;                 \/* Previous value written into pgidx *\/$/;"	m	struct:Fts5PageWriter	file:
iPrevRowid	.\ext\fts5\fts5_index.c	/^  i64 iPrevRowid;                 \/* Previous rowid written to current leaf *\/$/;"	m	struct:Fts5SegWriter	file:
iPrior	.\src\wal.c	/^  int iPrior;                     \/* Last result returned from the iterator *\/$/;"	m	struct:WalIterator	file:
iPrn	.\src\analyze.c	/^  u32 iPrn;                 \/* Pseudo-random number used for sampling *\/$/;"	m	struct:Stat4Accum	file:
iRand	.\src\test_pcache.c	/^  unsigned iRand;           \/* State of the PRNG *\/$/;"	m	struct:testpcache	file:
iRangeEnd	.\ext\fts5\fts5_aux.c	/^  int iRangeEnd;                  \/* If non-zero, last token to include *\/$/;"	m	struct:HighlightContext	file:
iRangeReg	.\src\sqliteInt.h	/^  int iRangeReg;       \/* First register in temporary register block *\/$/;"	m	struct:Parse
iRangeStart	.\ext\fts5\fts5_aux.c	/^  int iRangeStart;                \/* First token to include *\/$/;"	m	struct:HighlightContext	file:
iRank	.\ext\misc\spellfix.c	/^    int iRank;                    \/* Rank for this row *\/$/;"	m	struct:spellfix1_cursor::spellfix1_row	file:
iReadOff	.\src\vdbesort.c	/^  i64 iReadOff;               \/* Current read offset *\/$/;"	m	struct:PmaReader	file:
iReg	.\src\sqliteInt.h	/^    int iReg;             \/* Reg with value of this column. 0 means none. *\/$/;"	m	struct:Parse::yColCache
iReinsertHeight	.\ext\rtree\rtree.c	/^  int iReinsertHeight;        \/* Height of sub-trees Reinsert() has run on *\/$/;"	m	struct:Rtree	file:
iRightChildPg	.\src\dbstat.c	/^  u32 iRightChildPg;              \/* Right-child page number (or 0) *\/$/;"	m	struct:StatPage	file:
iRightJoinTable	.\src\sqliteInt.h	/^  i16 iRightJoinTable;   \/* If EP_FromJoin, the right table of the join *\/$/;"	m	struct:Expr
iRoot	.\tool\offsets.c	/^  int iRoot;            \/* Root page of the table *\/$/;"	m	struct:GState	file:
iRow	.\ext\misc\spellfix.c	/^  int iRow;                    \/* Current row of content *\/$/;"	m	struct:spellfix1_cursor	file:
iRowid	.\ext\fts3\fts3_aux.c	/^  sqlite3_int64 iRowid;           \/* Current rowid *\/$/;"	m	struct:Fts3auxCursor	file:
iRowid	.\ext\fts3\fts3_term.c	/^  sqlite3_int64 iRowid;           \/* Current 'rowid' value *\/$/;"	m	struct:Fts3termCursor	file:
iRowid	.\ext\fts3\fts3_tokenize_vtab.c	/^  int iRowid;                     \/* Current 'rowid' value *\/$/;"	m	struct:Fts3tokCursor	file:
iRowid	.\ext\fts5\fts5_expr.c	/^  i64 iRowid;                     \/* Current rowid *\/$/;"	m	struct:Fts5ExprNode	file:
iRowid	.\ext\fts5\fts5_hash.c	/^  i64 iRowid;                     \/* Rowid of last value written *\/$/;"	m	struct:Fts5HashEntry	file:
iRowid	.\ext\fts5\fts5_index.c	/^  i64 iRowid;                     \/* Current rowid *\/$/;"	m	struct:Fts5SegIter	file:
iRowid	.\ext\fts5\fts5_index.c	/^  i64 iRowid;                   \/* First rowid on leaf iLeafPgno *\/$/;"	m	struct:Fts5DlidxLvl	file:
iRowid	.\ext\fts5\fts5_index.c	/^  i64 iRowid;$/;"	m	struct:Fts5DoclistIter	file:
iRowid	.\ext\fts5\fts5_main.c	/^  i64 iRowid;                     \/* Current rowid *\/$/;"	m	struct:Fts5Sorter	file:
iRowid	.\ext\fts5\fts5_storage.c	/^  i64 iRowid;$/;"	m	struct:Fts5IntegrityCtx	file:
iRowid	.\ext\misc\amatch.c	/^  sqlite3_int64 iRowid;      \/* The rowid of the current word *\/$/;"	m	struct:amatch_cursor	file:
iRowid	.\ext\misc\fuzzer.c	/^  sqlite3_int64 iRowid;      \/* The rowid of the current word *\/$/;"	m	struct:fuzzer_cursor	file:
iRowid	.\ext\misc\json1.c	/^  u32 iRowid;                \/* The rowid *\/$/;"	m	struct:JsonEachCursor	file:
iRowid	.\ext\misc\series.c	/^  sqlite3_int64 iRowid;      \/* The rowid *\/$/;"	m	struct:series_cursor	file:
iRowid	.\ext\misc\spellfix.c	/^    sqlite3_int64 iRowid;         \/* Rowid for this row *\/$/;"	m	struct:spellfix1_cursor::spellfix1_row	file:
iRowid	.\ext\rtree\rtree.c	/^  i64 iRowid;                                 \/* Node or entry ID *\/$/;"	m	struct:RtreeCell	file:
iRowid	.\ext\rtree\sqlite3rtree.h	/^  sqlite3_int64 iRowid;             \/* Rowid for current entry *\/$/;"	m	struct:sqlite3_rtree_query_info
iRowid	.\src\analyze.c	/^    i64 iRowid;                     \/* Rowid in main table of the key *\/$/;"	m	union:Stat4Sample::__anon7	file:
iRowid	.\src\test_osinst.c	/^  sqlite3_int64 iRowid;           \/* Current rowid. *\/$/;"	m	struct:VfslogCsr	file:
iRowidOffset	.\ext\fts5\fts5_index.c	/^  int iRowidOffset;               \/* Current entry in aRowidOffset[] *\/$/;"	m	struct:Fts5SegIter	file:
iRuleset	.\ext\misc\fuzzer.c	/^  fuzzer_ruleid iRuleset;     \/* The rule set to which this rule belongs *\/$/;"	m	struct:fuzzer_rule	file:
iRuleset	.\ext\misc\fuzzer.c	/^  int iRuleset;              \/* Only process rules from this ruleset *\/$/;"	m	struct:fuzzer_cursor	file:
iSDParm	.\src\sqliteInt.h	/^  int iSDParm;         \/* A parameter used by the eDest disposal method *\/$/;"	m	struct:SelectDest
iSavepoint	.\ext\fts5\fts5_main.c	/^  int iSavepoint;                 \/* Number of open savepoints (0 -> none) *\/$/;"	m	struct:Fts5TransactionState	file:
iSavepoint	.\src\sqliteInt.h	/^  int iSavepoint;           \/* Depth of the SAVEPOINT stack *\/$/;"	m	struct:VTable
iScope	.\ext\misc\spellfix.c	/^  int iScope;                      \/* Default scope *\/$/;"	m	struct:MatchQuery	file:
iScope	.\ext\misc\spellfix.c	/^  int iScope;                  \/* Value of the scope= constraint *\/$/;"	m	struct:spellfix1_cursor	file:
iScore	.\ext\misc\spellfix.c	/^    int iScore;                   \/* Score for sorting *\/$/;"	m	struct:spellfix1_cursor::spellfix1_row	file:
iSdst	.\src\sqliteInt.h	/^  int iSdst;           \/* Base register where results are written *\/$/;"	m	struct:SelectDest
iSectorSize	.\src\test6.c	/^  int iSectorSize;             \/* Value of simulated sector size *\/$/;"	m	struct:CrashGlobal	file:
iSectorSize	.\src\test_devsym.c	/^  int iSectorSize;$/;"	m	struct:DevsymGlobal	file:
iSectorsize	.\src\test_vfs.c	/^  int iSectorsize;$/;"	m	struct:Testvfs	file:
iSeek	.\src\tclsqlite.c	/^  int iSeek;                \/* Current seek offset *\/$/;"	m	struct:IncrblobChannel	file:
iSegid	.\ext\fts5\fts5_index.c	/^  int iSegid;                     \/* Segid to write to *\/$/;"	m	struct:Fts5SegWriter	file:
iSegid	.\ext\fts5\fts5_index.c	/^  int iSegid;                     \/* Segment id *\/$/;"	m	struct:Fts5StructureSegment	file:
iSegid	.\ext\fts5\fts5_index.c	/^  int iSegid;$/;"	m	struct:Fts5DlidxIter	file:
iSelectID	.\src\vdbeInt.h	/^  int iSelectID;                  \/* The "Select-ID" for this loop *\/$/;"	m	struct:ScanStatus
iSelectId	.\src\sqliteInt.h	/^    u8 iSelectId;     \/* If pSelect!=0, the id of the sub-select in EQP *\/$/;"	m	struct:SrcList::SrcList_item
iSelectId	.\src\sqliteInt.h	/^  int iSelectId;            \/* ID of current select for EXPLAIN output *\/$/;"	m	struct:Parse
iSelfTab	.\src\sqliteInt.h	/^  int iSelfTab;        \/* Table of an index whose exprs are being coded *\/$/;"	m	struct:Parse
iSeq	.\ext\misc\amatch.c	/^  int iSeq;             \/* Sequence number *\/$/;"	m	struct:amatch_word	file:
iSize	.\src\bitvec.c	/^  u32 iSize;      \/* Maximum bit index.  Max iSize is 4,294,967,296. *\/$/;"	m	struct:Bitvec	file:
iSize	.\src\journal.c	/^  int iSize;                      \/* Amount of zBuf[] currently used *\/$/;"	m	struct:JournalFile	file:
iSize	.\src\mem2.c	/^  i64 iSize;                          \/* Size of this allocation *\/$/;"	m	struct:MemBlockHdr	file:
iSize	.\src\test6.c	/^  i64 iSize;                           \/* Size of file in bytes *\/$/;"	m	struct:CrashFile	file:
iSize	.\src\test_quota.c	/^  sqlite3_int64 iSize;            \/* Current size of this file *\/$/;"	m	struct:quotaFile	file:
iSize	.\src\test_quota.c	/^  sqlite3_int64 iSize;           \/* Current size of all files *\/$/;"	m	struct:quotaGroup	file:
iSortIdx	.\src\whereInt.h	/^  u8 iSortIdx;          \/* Sorting index number.  0==None *\/$/;"	m	struct:WhereLoop
iSorterColumn	.\src\sqliteInt.h	/^    int iSorterColumn;       \/* Column number in the sorting index *\/$/;"	m	struct:AggInfo::AggInfo_col
iSpecial	.\ext\fts5\fts5_main.c	/^  i64 iSpecial;                   \/* Result of special query *\/$/;"	m	struct:Fts5Cursor	file:
iSrcLine	.\src\vdbe.h	/^  int iSrcLine;            \/* Source-code line that generated this opcode *\/$/;"	m	struct:VdbeOp
iStart	.\ext\fts1\fts1.c	/^    int iStart;          \/* The offset to the first character of the term *\/$/;"	m	struct:Snippet::snippetMatch	file:
iStart	.\ext\fts2\fts2.c	/^    int iStart;          \/* The offset to the first character of the term *\/$/;"	m	struct:Snippet::snippetMatch	file:
iStart	.\ext\fts3\fts3_tokenize_vtab.c	/^  int iStart;                     \/* Current 'start' value *\/$/;"	m	struct:Fts3tokCursor	file:
iStart	.\ext\fts3\fts3_write.c	/^  sqlite3_int64 iStart;           \/* Block number of first allocated block *\/$/;"	m	struct:IncrmergeWriter	file:
iStart	.\ext\fts5\fts5_aux.c	/^  int iStart;                     \/* First token in coalesced phrase instance *\/$/;"	m	struct:CInstIter	file:
iStart	.\test\speedtest1.c	/^  sqlite3_int64 iStart;      \/* Start-time for the current test *\/$/;"	m	struct:Global	file:
iStartBlock	.\ext\fts3\fts3_write.c	/^  sqlite3_int64 iStartBlock;      \/* Rowid of first leaf block to traverse *\/$/;"	m	struct:Fts3SegReader	file:
iStartBlockid	.\ext\fts2\fts2.c	/^  sqlite_int64 iStartBlockid;     \/* needed to create the root info *\/$/;"	m	struct:LeafWriter	file:
iStartOff	.\src\vdbesort.c	/^  i64 iStartOff;                  \/* Offset to start writing file at *\/$/;"	m	struct:IncrMerger	file:
iStartOffset	.\ext\fts2\fts2.c	/^  int iStartOffset;    \/* the last start offset read *\/$/;"	m	struct:PLReader	file:
iStatement	.\src\vdbeInt.h	/^  int iStatement;         \/* Statement number (or 0 if has not opened stmt) *\/$/;"	m	struct:Vdbe
iStep	.\ext\misc\series.c	/^  sqlite3_int64 iStep;       \/* Increment ("step") *\/$/;"	m	struct:series_cursor	file:
iStrategy	.\ext\rtree\rtree.c	/^  int iStrategy;                    \/* Copy of idxNum search parameter *\/$/;"	m	struct:RtreeCursor	file:
iSub	.\src\vdbeaux.c	/^  int iSub;                  \/* 0 = main program, 1 = first sub-program etc. *\/$/;"	m	struct:VdbeOpIter	file:
iSubCost	.\ext\misc\spellfix.c	/^  int iSubCost;          \/* Default substitution cost *\/$/;"	m	struct:EditDist3Lang	file:
iSubRec	.\src\pager.c	/^  Pgno iSubRec;                \/* Index of first record in sub-journal *\/$/;"	m	struct:PagerSavepoint	file:
iSum	.\src\func.c	/^  i64 iSum;         \/* Integer sum *\/   $/;"	m	struct:SumCtx	file:
iSwitchRowid	.\ext\fts5\fts5_index.c	/^  i64 iSwitchRowid;               \/* Firstest rowid of other than aFirst[1] *\/$/;"	m	struct:Fts5IndexIter	file:
iSyncPoint	.\src\wal.c	/^  sqlite3_int64 iSyncPoint;    \/* Fsync at this offset *\/$/;"	m	struct:WalWriter	file:
iSzPoslist	.\ext\fts5\fts5_hash.c	/^  int iSzPoslist;                 \/* Offset of space for 4-byte poslist size *\/$/;"	m	struct:Fts5HashEntry	file:
iTab	.\src\build.c	/^  int iTab;            \/* The root page of the table to be locked *\/$/;"	m	struct:TableLock	file:
iTab	.\src\whereInt.h	/^  u8 iTab;              \/* Position in FROM clause of table for this loop *\/$/;"	m	struct:WhereLoop
iTabCur	.\src\whereInt.h	/^  int iTabCur;          \/* The VDBE cursor used to access the table *\/$/;"	m	struct:WhereLevel
iTable	.\src\btreeInt.h	/^  Pgno iTable;          \/* Root page of table *\/$/;"	m	struct:BtLock
iTable	.\src\sqliteInt.h	/^    int iTable;              \/* Cursor number of the source table *\/$/;"	m	struct:AggInfo::AggInfo_col
iTable	.\src\sqliteInt.h	/^    int iTable;           \/* Table cursor number *\/$/;"	m	struct:Parse::yColCache
iTable	.\src\sqliteInt.h	/^  int iTable;            \/* TK_COLUMN: cursor number of table holding column$/;"	m	struct:Expr
iTail	.\ext\fts3\fts3_snippet.c	/^  int iTail;                      \/* Next value in trailing position list *\/$/;"	m	struct:SnippetPhrase	file:
iTerm	.\ext\fts1\fts1.c	/^    short int iTerm;     \/* The index in Query.pTerms[] of the matching term *\/$/;"	m	struct:Snippet::snippetMatch	file:
iTerm	.\ext\fts2\fts2.c	/^    short int iTerm;     \/* The index in Query.pTerms[] of the matching term *\/$/;"	m	struct:Snippet::snippetMatch	file:
iTerm	.\ext\fts3\fts3_snippet.c	/^  int iTerm;$/;"	m	struct:TermOffsetCtx	file:
iTermLeafOffset	.\ext\fts5\fts5_index.c	/^  int iTermLeafOffset;$/;"	m	struct:Fts5SegIter	file:
iTermLeafPgno	.\ext\fts5\fts5_index.c	/^  int iTermLeafPgno;$/;"	m	struct:Fts5SegIter	file:
iTid	.\test\threadtest3.c	/^  int iTid;                       \/* Thread number within test *\/$/;"	m	struct:Thread	file:
iTimeout	.\mptest\mptest.c	/^  int iTimeout;          \/* Milliseconds until a busy timeout *\/$/;"	m	struct:Global	file:
iTknOfst	.\tool\lemon.c	/^  int iTknOfst, iNtOfst;   \/* yy_action[] offset for terminals and nonterms *\/$/;"	m	struct:state	file:
iTnum	.\ext\rbu\sqlite3rbu.c	/^  int iTnum;                      \/* Root page of current object *\/$/;"	m	struct:RbuObjIter	file:
iToken	.\ext\fts1\fts1_porter.c	/^  int iToken;                  \/* index of next token to be returned *\/$/;"	m	struct:porter_tokenizer_cursor	file:
iToken	.\ext\fts1\fts1_tokenizer1.c	/^  int iToken;                  \/* index of next token to be returned *\/$/;"	m	struct:simple_tokenizer_cursor	file:
iToken	.\ext\fts1\simple_tokenizer.c	/^  int iToken;                  \/* index of next token to be returned *\/$/;"	m	struct:simple_tokenizer_cursor	file:
iToken	.\ext\fts2\fts2_icu.c	/^  int iToken;$/;"	m	struct:IcuCursor	file:
iToken	.\ext\fts2\fts2_porter.c	/^  int iToken;                  \/* index of next token to be returned *\/$/;"	m	struct:porter_tokenizer_cursor	file:
iToken	.\ext\fts2\fts2_tokenizer1.c	/^  int iToken;                  \/* index of next token to be returned *\/$/;"	m	struct:simple_tokenizer_cursor	file:
iToken	.\ext\fts3\fts3.c	/^  int iToken;                     \/* Position of token in phrase *\/$/;"	m	struct:Fts3TokenAndCost	file:
iToken	.\ext\fts3\fts3_icu.c	/^  int iToken;$/;"	m	struct:IcuCursor	file:
iToken	.\ext\fts3\fts3_porter.c	/^  int iToken;                  \/* index of next token to be returned *\/$/;"	m	struct:porter_tokenizer_cursor	file:
iToken	.\ext\fts3\fts3_test.c	/^  int iToken;                  \/* Index of next token to be returned *\/$/;"	m	struct:test_tokenizer_cursor	file:
iToken	.\ext\fts3\fts3_tokenizer1.c	/^  int iToken;                  \/* index of next token to be returned *\/$/;"	m	struct:simple_tokenizer_cursor	file:
iToken	.\ext\fts3\fts3_unicode.c	/^  int iToken;                     \/* Index of next token to be returned *\/$/;"	m	struct:unicode_cursor	file:
iTop	.\ext\misc\spellfix.c	/^  int iTop;                    \/* Value of the top= constraint *\/$/;"	m	struct:spellfix1_cursor	file:
iTop	.\src\whereInt.h	/^  int iTop;                 \/* The very beginning of the WHERE loop *\/$/;"	m	struct:WhereInfo
iTotal	.\test\speedtest1.c	/^  sqlite3_int64 iTotal;      \/* Total time *\/$/;"	m	struct:Global	file:
iTrace	.\mptest\mptest.c	/^  int iTrace;            \/* Tracing level *\/$/;"	m	struct:Global	file:
iType	.\ext\fts1\fts1.c	/^  DocListType iType;$/;"	m	struct:DocList	file:
iType	.\ext\fts1\fulltext.c	/^  DocListType iType;$/;"	m	struct:DocList	file:
iType	.\ext\fts2\fts2.c	/^  DocListType iType;$/;"	m	struct:DLReader	file:
iType	.\ext\fts2\fts2.c	/^  DocListType iType;$/;"	m	struct:DLWriter	file:
iType	.\ext\fts2\fts2.c	/^  DocListType iType;$/;"	m	struct:PLReader	file:
iVal	.\ext\misc\json1.c	/^  u8 iVal;               \/* Replacement value when JNODE_REPLACE *\/$/;"	m	struct:JsonNode	file:
iVal	.\src\vdbemem.c	/^  int iVal;$/;"	m	struct:ValueNewStat4Ctx	file:
iValue	.\ext\misc\series.c	/^  sqlite3_int64 iValue;      \/* Current value ("value") *\/$/;"	m	struct:series_cursor	file:
iValue	.\ext\misc\wholenumber.c	/^  sqlite3_int64 iValue;      \/* Current value *\/$/;"	m	struct:wholenumber_cursor	file:
iValue	.\src\sqliteInt.h	/^    int iValue;            \/* Non-negative integer value if EP_IntValue *\/$/;"	m	union:Expr::__anon15
iVersion	.\ext\fts1\fts1_tokenizer.h	/^  int iVersion;                  \/* currently 0 *\/$/;"	m	struct:sqlite3_tokenizer_module
iVersion	.\ext\fts1\tokenizer.h	/^  int iVersion;                  \/* currently 0 *\/$/;"	m	struct:sqlite3_tokenizer_module
iVersion	.\ext\fts2\fts2_tokenizer.h	/^  int iVersion;$/;"	m	struct:sqlite3_tokenizer_module
iVersion	.\ext\fts3\fts3_tokenizer.h	/^  int iVersion;$/;"	m	struct:sqlite3_tokenizer_module
iVersion	.\ext\fts5\fts5.h	/^  int iVersion;                   \/* Currently always set to 1 *\/$/;"	m	struct:Fts5ExtensionApi
iVersion	.\ext\fts5\fts5.h	/^  int iVersion;                   \/* Currently always set to 2 *\/$/;"	m	struct:fts5_api
iVersion	.\src\wal.c	/^  u32 iVersion;                   \/* Wal-index version *\/$/;"	m	struct:WalIndexHdr	file:
iWalCksum	.\ext\rbu\sqlite3rbu.c	/^  i64 iWalCksum;$/;"	m	struct:RbuState	file:
iWalCksum	.\ext\rbu\sqlite3rbu.c	/^  i64 iWalCksum;$/;"	m	struct:sqlite3rbu	file:
iWalFrame	.\ext\rbu\sqlite3rbu.c	/^  u32 iWalFrame;$/;"	m	struct:RbuFrame	file:
iWriteOff	.\src\vdbesort.c	/^  i64 iWriteOff;                  \/* Offset of start of buffer in file *\/$/;"	m	struct:PmaWriter	file:
iWriteRowid	.\ext\fts5\fts5_index.c	/^  i64 iWriteRowid;                \/* Rowid for current doc being written *\/$/;"	m	struct:Fts5Index	file:
iWriteVer	.\ext\rbu\sqlite3rbu.c	/^  u8 iWriteVer;                   \/* "write-version" value for main db files *\/$/;"	m	struct:rbu_file	file:
iZero	.\src\wal.c	/^    int iZero;                    \/* Frame number associated with aPgno[0] *\/$/;"	m	struct:WalIterator::WalSegment	file:
icuCaseFunc16	.\ext\icu\icu.c	/^static void icuCaseFunc16(sqlite3_context *p, int nArg, sqlite3_value **apArg){$/;"	f	file:
icuClose	.\ext\fts2\fts2_icu.c	/^static int icuClose(sqlite3_tokenizer_cursor *pCursor){$/;"	f	file:
icuClose	.\ext\fts3\fts3_icu.c	/^static int icuClose(sqlite3_tokenizer_cursor *pCursor){$/;"	f	file:
icuCollationColl	.\ext\icu\icu.c	/^static int icuCollationColl($/;"	f	file:
icuCollationDel	.\ext\icu\icu.c	/^static void icuCollationDel(void *pCtx){$/;"	f	file:
icuCreate	.\ext\fts2\fts2_icu.c	/^static int icuCreate($/;"	f	file:
icuCreate	.\ext\fts3\fts3_icu.c	/^static int icuCreate($/;"	f	file:
icuDestroy	.\ext\fts2\fts2_icu.c	/^static int icuDestroy(sqlite3_tokenizer *pTokenizer){$/;"	f	file:
icuDestroy	.\ext\fts3\fts3_icu.c	/^static int icuDestroy(sqlite3_tokenizer *pTokenizer){$/;"	f	file:
icuFunctionError	.\ext\icu\icu.c	/^static void icuFunctionError($/;"	f	file:
icuLikeCompare	.\ext\icu\icu.c	/^static int icuLikeCompare($/;"	f	file:
icuLikeFunc	.\ext\icu\icu.c	/^static void icuLikeFunc($/;"	f	file:
icuLoadCollation	.\ext\icu\icu.c	/^static void icuLoadCollation($/;"	f	file:
icuNext	.\ext\fts2\fts2_icu.c	/^static int icuNext($/;"	f	file:
icuNext	.\ext\fts3\fts3_icu.c	/^static int icuNext($/;"	f	file:
icuOpen	.\ext\fts2\fts2_icu.c	/^static int icuOpen($/;"	f	file:
icuOpen	.\ext\fts3\fts3_icu.c	/^static int icuOpen($/;"	f	file:
icuRegexpDelete	.\ext\icu\icu.c	/^static void icuRegexpDelete(void *p){$/;"	f	file:
icuRegexpFunc	.\ext\icu\icu.c	/^static void icuRegexpFunc(sqlite3_context *p, int nArg, sqlite3_value **apArg){$/;"	f	file:
icuTokenizerModule	.\ext\fts2\fts2_icu.c	/^static const sqlite3_tokenizer_module icuTokenizerModule = {$/;"	v	file:
icuTokenizerModule	.\ext\fts3\fts3_icu.c	/^static const sqlite3_tokenizer_module icuTokenizerModule = {$/;"	v	file:
id	.\ext\misc\closure.c	/^  sqlite3_int64 id;     \/* Id of this entry in the table *\/$/;"	m	struct:closure_avl	file:
id	.\ext\rtree\rtree.c	/^  sqlite3_int64 id;      \/* Node ID *\/$/;"	m	struct:RtreeSearchPoint	file:
id	.\src\mutex_noop.c	/^  int id;     \/* The mutex type *\/$/;"	m	struct:sqlite3_debug_mutex	file:
id	.\src\mutex_unix.c	/^  int id;                    \/* Mutex type *\/$/;"	m	struct:sqlite3_mutex	file:
id	.\src\mutex_w32.c	/^  int id;                    \/* Mutex type *\/$/;"	m	struct:sqlite3_mutex	file:
id	.\src\os_unix.c	/^  u8 id;                     \/* Id of this connection within its unixShmNode *\/$/;"	m	struct:unixShm	file:
id	.\src\os_win.c	/^  u8 id;                     \/* Id of this connection with its winShmNode *\/$/;"	m	struct:winShm	file:
id	.\src\threads.c	/^  unsigned id;             \/* The thread identifier *\/$/;"	m	struct:SQLiteThread	file:
id	.\test\fuzzcheck.c	/^  int id;                 \/* Id of this Blob *\/$/;"	m	struct:Blob	file:
id	.\test\threadtest4.c	/^  pthread_t id;               \/* Thread id *\/$/;"	m	struct:WorkerInfo	file:
id	.\tool\mkkeywordhash.c	/^  int id;              \/* Unique ID for this record *\/$/;"	m	struct:Keyword	file:
idChar	.\ext\fts1\fts1_porter.c	571;"	d	file:
identLength	.\src\build.c	/^static int identLength(const char *z){$/;"	f	file:
identPut	.\src\build.c	/^static void identPut(char *z, int *pIdx, char *zSignedIdent){$/;"	f	file:
idx	.\ext\fts2\fts2.c	/^  int idx;                  \/* Index within the segment. *\/$/;"	m	struct:LeavesReader	file:
idx	.\ext\fts2\fts2.c	/^  int idx;$/;"	m	struct:LeafWriter	file:
idx	.\ext\fts2\fts2.c	/^  int idx;$/;"	m	struct:OrderedDLReader	file:
idx	.\src\sqliteInt.h	/^    int idx;          \/* Index in some Table.aCol[] of a column named zName *\/$/;"	m	struct:IdList::IdList_item
idxHash	.\src\sqliteInt.h	/^  Hash idxHash;        \/* All (named) indices indexed by name *\/$/;"	m	struct:Schema
idxNum	.\ext\misc\spellfix.c	/^  int idxNum;                  \/* idxNum value passed to xFilter() *\/$/;"	m	struct:spellfix1_cursor	file:
idxNum	.\src\whereInt.h	/^      int idxNum;            \/* Index number *\/$/;"	m	struct:WhereLoop::__anon28::__anon30
idxStr	.\src\whereInt.h	/^      char *idxStr;          \/* Index identifier string *\/$/;"	m	struct:WhereLoop::__anon28::__anon30
idxType	.\src\sqliteInt.h	/^  unsigned idxType:2;      \/* 1==UNIQUE, 2==PRIMARY KEY, 0==CREATE INDEX *\/$/;"	m	struct:Index
idxaff	.\src\whereInt.h	/^  char idxaff;               \/* Must match this affinity, if zCollName!=NULL *\/$/;"	m	struct:WhereScan
ieee754func	.\ext\misc\ieee754.c	/^static void ieee754func($/;"	f	file:
ifcapable	.\test\tester.tcl	/^proc ifcapable {expr code {else ""} {elsecode ""}} {$/;"	p
imbalance	.\ext\misc\amatch.c	/^  short int imbalance;  \/* Height difference between pBefore and pAfter *\/$/;"	m	struct:amatch_avl	file:
imbalance	.\ext\misc\closure.c	/^  short int imbalance;  \/* Height difference between pBefore and pAfter *\/$/;"	m	struct:closure_avl	file:
import_append_char	.\src\shell.c	/^static void import_append_char(ImportCtx *p, int c){$/;"	f	file:
imposterTable	.\src\sqliteInt.h	/^    u8 imposterTable;           \/* Building an imposter table *\/$/;"	m	struct:sqlite3::sqlite3InitInfo
in	.\ext\fts1\fulltext.c	/^  DocListReader in;$/;"	m	struct:DocListMerge	file:
in	.\src\shell.c	/^  FILE *in;           \/* Read the CSV text from this input stream *\/$/;"	m	struct:ImportCtx	file:
in	.\src\tclsqlite.c	/^  unsigned char in[64];$/;"	m	struct:MD5Context	file:
in	.\src\whereInt.h	/^    } in;                 \/* Used when pWLoop->wsFlags&WHERE_IN_ABLE *\/$/;"	m	union:WhereLevel::__anon26	typeref:struct:WhereLevel::__anon26::__anon27
in	.\test\threadtest3.c	/^    unsigned char in[64];$/;"	m	union:MD5Context::__anon32	file:
in32	.\test\threadtest3.c	/^    uint32 in32[16];$/;"	m	union:MD5Context::__anon32	file:
inNormalWrite	.\src\os_unix.c	/^  unsigned char inNormalWrite;   \/* True if in a normal write operation *\/$/;"	m	struct:unixFile	file:
inProgress	.\src\sqliteInt.h	/^  int inProgress;                   \/* True while initialization in progress *\/$/;"	m	struct:Sqlite3Config
inTrans	.\src\btreeInt.h	/^  u8 inTrans;        \/* TRANS_NONE, TRANS_READ or TRANS_WRITE *\/$/;"	m	struct:Btree
inTransaction	.\ext\fts3\fts3Int.h	/^  int inTransaction;     \/* True after xBegin but before xCommit\/xRollback *\/$/;"	m	struct:Fts3Table
inTransaction	.\src\btreeInt.h	/^  u8 inTransaction;     \/* Transaction state *\/$/;"	m	struct:BtShared
inTransaction	.\src\test8.c	/^  int inTransaction;      \/* True if within a transaction *\/$/;"	m	struct:echo_vtab	file:
include	.\tool\lemon.c	/^  char *include;           \/* Code to put at the start of the C file *\/$/;"	m	struct:lemon	file:
incrAggDepth	.\src\resolve.c	/^static int incrAggDepth(Walker *pWalker, Expr *pExpr){$/;"	f	file:
incrAggFunctionDepth	.\src\resolve.c	/^static void incrAggFunctionDepth(Expr *pExpr, int N){$/;"	f	file:
incrOpenFileCount	.\ext\async\sqlite3async.c	/^static void incrOpenFileCount(void){$/;"	f	file:
incrPhraseTokenNext	.\ext\fts3\fts3.c	/^static int incrPhraseTokenNext($/;"	f	file:
incrVacuum	.\src\btreeInt.h	/^  u8 incrVacuum;        \/* True if incr-vacuum is enabled *\/$/;"	m	struct:BtShared
incrVacuumStep	.\src\btree.c	/^static int incrVacuumStep(BtShared *pBt, Pgno nFin, Pgno iLastPg, int bCommit){$/;"	f	file:
incr_ntest	.\test\tester.tcl	/^proc incr_ntest {} {$/;"	p
incrblobClose	.\src\tclsqlite.c	/^static int incrblobClose(ClientData instanceData, Tcl_Interp *interp){$/;"	f	file:
incrblobHandle	.\src\tclsqlite.c	/^static int incrblobHandle(ClientData instanceData, int dir, ClientData *hPtr){$/;"	f	file:
incrblobInput	.\src\tclsqlite.c	/^static int incrblobInput($/;"	f	file:
incrblobOutput	.\src\tclsqlite.c	/^static int incrblobOutput($/;"	f	file:
incrblobSeek	.\src\tclsqlite.c	/^static int incrblobSeek($/;"	f	file:
incrblobWatch	.\src\tclsqlite.c	/^static void incrblobWatch(ClientData instanceData, int mode){ $/;"	f	file:
index	.\tool\lemon.c	/^  int index;               \/* An index number for this rule *\/$/;"	m	struct:rule	file:
index	.\tool\lemon.c	/^  int index;               \/* Index number for this symbol *\/$/;"	m	struct:symbol	file:
indexColumnNotNull	.\src\where.c	/^static int indexColumnNotNull(Index *pIdx, int iCol){$/;"	f	file:
indexMightHelpWithOrderBy	.\src\where.c	/^static int indexMightHelpWithOrderBy($/;"	f	file:
index_delete	.\ext\fts1\fts1.c	/^static int index_delete(fulltext_vtab *v, sqlite_int64 iRow, fts1Hash *pTerms){$/;"	f	file:
index_delete	.\ext\fts1\fulltext.c	/^static int index_delete(fulltext_vtab *v, sqlite_int64 iRow){$/;"	f	file:
index_delete	.\ext\fts2\fts2.c	/^static int index_delete(fulltext_vtab *v, sqlite_int64 iRow){$/;"	f	file:
index_delete_term	.\ext\fts1\fulltext.c	/^static int index_delete_term(fulltext_vtab *v, const char *zTerm, int nTerm,$/;"	f	file:
index_insert	.\ext\fts1\fts1.c	/^static int index_insert(fulltext_vtab *v, sqlite3_value *pRequestRowid,$/;"	f	file:
index_insert	.\ext\fts1\fulltext.c	/^static int index_insert(fulltext_vtab *v,$/;"	f	file:
index_insert	.\ext\fts2\fts2.c	/^static int index_insert(fulltext_vtab *v, sqlite3_value *pRequestRowid,$/;"	f	file:
index_insert_term	.\ext\fts1\fts1.c	/^static int index_insert_term(fulltext_vtab *v, const char *pTerm, int nTerm,$/;"	f	file:
index_insert_term	.\ext\fts1\fulltext.c	/^static int index_insert_term(fulltext_vtab *v, const char *zTerm, int nTerm,$/;"	f	file:
index_update	.\ext\fts1\fts1.c	/^static int index_update(fulltext_vtab *v, sqlite_int64 iRow,$/;"	f	file:
index_update	.\ext\fts2\fts2.c	/^static int index_update(fulltext_vtab *v, sqlite_int64 iRow,$/;"	f	file:
indexable	.\src\whereInt.h	/^  Bitmask indexable;       \/* Bitmask of all indexable tables in the clause *\/$/;"	m	struct:WhereOrInfo
info	.\src\btreeInt.h	/^  CellInfo info;            \/* A parse of the cell we are pointing at *\/$/;"	m	struct:BtCursor
init	.\src\sqliteInt.h	/^  } init;$/;"	m	struct:sqlite3	typeref:struct:sqlite3::sqlite3InitInfo
initAvgEq	.\src\analyze.c	/^static void initAvgEq(Index *pIdx){$/;"	f	file:
initClass	.\ext\misc\spellfix.c	/^static const unsigned char initClass[] = {$/;"	v	file:
initMaskSet	.\src\whereInt.h	376;"	d
initPendingTerms	.\ext\fts2\fts2.c	/^static int initPendingTerms(fulltext_vtab *v, sqlite_int64 iDocid){$/;"	f	file:
initStringBuffer	.\ext\fts1\fts1.c	/^static void initStringBuffer(StringBuffer *sb){$/;"	f	file:
initStringBuffer	.\ext\fts2\fts2.c	/^static void initStringBuffer(StringBuffer *sb){$/;"	f	file:
init_all	.\src\tclsqlite.c	/^static void init_all(Tcl_Interp *interp){$/;"	f	file:
init_all_cmd	.\src\tclsqlite.c	/^static int init_all_cmd($/;"	f	file:
init_wrapper_clear	.\src\test_init.c	/^static int init_wrapper_clear($/;"	f	file:
init_wrapper_install	.\src\test_init.c	/^static int init_wrapper_install($/;"	f	file:
init_wrapper_query	.\src\test_init.c	/^static int init_wrapper_query($/;"	f	file:
init_wrapper_uninstall	.\src\test_init.c	/^static int init_wrapper_uninstall($/;"	f	file:
inmemAccess	.\test\fuzzcheck.c	/^static int inmemAccess($/;"	f	file:
inmemCheckReservedLock	.\test\fuzzcheck.c	/^static int inmemCheckReservedLock(sqlite3_file *pFile, int *pOut){$/;"	f	file:
inmemClose	.\test\fuzzcheck.c	/^static int inmemClose(sqlite3_file *pFile){$/;"	f	file:
inmemDelete	.\test\fuzzcheck.c	/^static int inmemDelete($/;"	f	file:
inmemDeviceCharacteristics	.\test\fuzzcheck.c	/^static int inmemDeviceCharacteristics(sqlite3_file *pFile){$/;"	f	file:
inmemFileControl	.\test\fuzzcheck.c	/^static int inmemFileControl(sqlite3_file *pFile, int op, void *pArg){$/;"	f	file:
inmemFileSize	.\test\fuzzcheck.c	/^static int inmemFileSize(sqlite3_file *pFile, sqlite3_int64 *pSize){$/;"	f	file:
inmemFullPathname	.\test\fuzzcheck.c	/^static int inmemFullPathname($/;"	f	file:
inmemGetLastError	.\test\fuzzcheck.c	/^static int inmemGetLastError(sqlite3_vfs *pVfs, int n, char *z){$/;"	f	file:
inmemLock	.\test\fuzzcheck.c	/^static int inmemLock(sqlite3_file *pFile, int type){$/;"	f	file:
inmemOpen	.\test\fuzzcheck.c	/^static int inmemOpen($/;"	f	file:
inmemRead	.\test\fuzzcheck.c	/^static int inmemRead($/;"	f	file:
inmemSectorSize	.\test\fuzzcheck.c	/^static int inmemSectorSize(sqlite3_file *pFile){$/;"	f	file:
inmemSync	.\test\fuzzcheck.c	/^static int inmemSync(sqlite3_file *pFile, int flags){$/;"	f	file:
inmemTruncate	.\test\fuzzcheck.c	/^static int inmemTruncate(sqlite3_file *pFile, sqlite3_int64 iSize){$/;"	f	file:
inmemUnlock	.\test\fuzzcheck.c	/^static int inmemUnlock(sqlite3_file *pFile, int type){$/;"	f	file:
inmemVfsRegister	.\test\fuzzcheck.c	/^static void inmemVfsRegister(void){$/;"	f	file:
inmemWrite	.\test\fuzzcheck.c	/^static int inmemWrite($/;"	f	file:
ino	.\src\os_unix.c	/^  ino_t ino;                  \/* Inode number *\/$/;"	m	struct:unixFileId	file:
inodeList	.\src\os_unix.c	/^static unixInodeInfo *inodeList = 0;$/;"	v	file:
inop	.\test\randexpr1.tcl	/^proc inop {lhs args} {$/;"	p
input	.\ext\fts5\fts5parse.y	/^input ::= expr(X). { sqlite3Fts5ParseFinished(pParse, X); }$/;"	l
input	.\src\parse.y	/^input ::= cmdlist.$/;"	l
insertBinaryOperator	.\ext\fts3\fts3_expr.c	/^static void insertBinaryOperator($/;"	f	file:
insertCell	.\src\btree.c	/^static void insertCell($/;"	f	file:
insertElement	.\ext\fts1\ft_hash.c	/^static void insertElement($/;"	f	file:
insertElement	.\ext\fts1\fts1_hash.c	/^static void insertElement($/;"	f	file:
insertElement	.\ext\fts2\fts2_hash.c	/^static void insertElement($/;"	f	file:
insertElement	.\src\hash.c	/^static void insertElement($/;"	f	file:
insertLineMacro	.\tool\lemon.c	/^  int insertLineMacro;       \/* Add #line before declaration insert *\/$/;"	m	struct:pstate	file:
insertOrDeleteCost	.\ext\misc\spellfix.c	/^static int insertOrDeleteCost(char cPrev, char c, char cNext){$/;"	f	file:
insertTerms	.\ext\fts1\fts1.c	/^static int insertTerms(fulltext_vtab *v, fts1Hash *terms, sqlite_int64 iRowid,$/;"	f	file:
insertTerms	.\ext\fts2\fts2.c	/^static int insertTerms(fulltext_vtab *v, sqlite_int64 iRowid,$/;"	f	file:
installInitWrappers	.\src\test_init.c	/^static void installInitWrappers(void){$/;"	f	file:
installTestPCache	.\src\test_pcache.c	/^void installTestPCache($/;"	f
instcompare	.\ext\fts5\test\fts5_common.tcl	/^proc instcompare {lhs rhs} {$/;"	p
instrFunc	.\src\func.c	/^static void instrFunc($/;"	f	file:
intKey	.\src\btreeInt.h	/^  u8 intKey;           \/* True if table b-trees.  False for index b-trees *\/$/;"	m	struct:MemPage
intKeyLeaf	.\src\btreeInt.h	/^  u8 intKeyLeaf;       \/* True if the leaf of an intKey table *\/$/;"	m	struct:MemPage
intTestFunc	.\ext\fts2\fts2_tokenizer.c	/^static void intTestFunc($/;"	f	file:
intTestFunc	.\ext\fts3\fts3_tokenizer.c	/^static void intTestFunc($/;"	f	file:
intarrayBestIndex	.\src\test_intarray.c	/^static int intarrayBestIndex(sqlite3_vtab *tab, sqlite3_index_info *pIdxInfo){$/;"	f	file:
intarrayClose	.\src\test_intarray.c	/^static int intarrayClose(sqlite3_vtab_cursor *cur){$/;"	f	file:
intarrayColumn	.\src\test_intarray.c	/^static int intarrayColumn(sqlite3_vtab_cursor *cur, sqlite3_context *ctx, int i){$/;"	f	file:
intarrayCreate	.\src\test_intarray.c	/^static int intarrayCreate($/;"	f	file:
intarrayDestroy	.\src\test_intarray.c	/^static int intarrayDestroy(sqlite3_vtab *p){$/;"	f	file:
intarrayEof	.\src\test_intarray.c	/^static int intarrayEof(sqlite3_vtab_cursor *cur){$/;"	f	file:
intarrayFilter	.\src\test_intarray.c	/^static int intarrayFilter($/;"	f	file:
intarrayFree	.\src\test_intarray.c	/^static void intarrayFree(sqlite3_intarray *p){$/;"	f	file:
intarrayModule	.\src\test_intarray.c	/^static sqlite3_module intarrayModule = {$/;"	v	file:
intarrayNext	.\src\test_intarray.c	/^static int intarrayNext(sqlite3_vtab_cursor *cur){$/;"	f	file:
intarrayOpen	.\src\test_intarray.c	/^static int intarrayOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor){$/;"	f	file:
intarrayRowid	.\src\test_intarray.c	/^static int intarrayRowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid){$/;"	f	file:
intarray_cursor	.\src\test_intarray.c	/^struct intarray_cursor {$/;"	s	file:
intarray_cursor	.\src\test_intarray.c	/^typedef struct intarray_cursor intarray_cursor;$/;"	t	typeref:struct:intarray_cursor	file:
intarray_vtab	.\src\test_intarray.c	/^struct intarray_vtab {$/;"	s	file:
intarray_vtab	.\src\test_intarray.c	/^typedef struct intarray_vtab intarray_vtab;$/;"	t	typeref:struct:intarray_vtab	file:
integerValue	.\src\shell.c	/^static sqlite3_int64 integerValue(const char *zArg){$/;"	f	file:
integerValue	.\test\fuzzcheck.c	/^static int integerValue(const char *zArg){$/;"	f	file:
integerValue	.\test\speedtest1.c	/^static int integerValue(const char *zArg){$/;"	f	file:
integerValue	.\tool\fuzzershell.c	/^static int integerValue(const char *zArg){$/;"	f	file:
integerify	.\tool\spaceanal.tcl	/^proc integerify {real} {$/;"	p
integrity_check	.\test\tester.tcl	/^proc integrity_check {name {db db}} {$/;"	p
integrity_check	.\test\threadtest2.c	/^int integrity_check(sqlite *db, int id){$/;"	f
integrity_check	.\test\threadtest3.c	46;"	d	file:
integrity_check_x	.\test\threadtest3.c	/^static void integrity_check_x($/;"	f	file:
interiorBlockNew	.\ext\fts2\fts2.c	/^static InteriorBlock *interiorBlockNew(int iHeight, sqlite_int64 iChildBlock,$/;"	f	file:
interiorBlockValidate	.\ext\fts2\fts2.c	/^static void interiorBlockValidate(InteriorBlock *pBlock){$/;"	f	file:
interiorReaderAtEnd	.\ext\fts2\fts2.c	/^static int interiorReaderAtEnd(InteriorReader *pReader){$/;"	f	file:
interiorReaderCurrentBlockid	.\ext\fts2\fts2.c	/^static sqlite_int64 interiorReaderCurrentBlockid(InteriorReader *pReader){$/;"	f	file:
interiorReaderDestroy	.\ext\fts2\fts2.c	/^static void interiorReaderDestroy(InteriorReader *pReader){$/;"	f	file:
interiorReaderInit	.\ext\fts2\fts2.c	/^static void interiorReaderInit(const char *pData, int nData,$/;"	f	file:
interiorReaderStep	.\ext\fts2\fts2.c	/^static void interiorReaderStep(InteriorReader *pReader){$/;"	f	file:
interiorReaderTerm	.\ext\fts2\fts2.c	/^static const char *interiorReaderTerm(InteriorReader *pReader){$/;"	f	file:
interiorReaderTermBytes	.\ext\fts2\fts2.c	/^static int interiorReaderTermBytes(InteriorReader *pReader){$/;"	f	file:
interiorReaderTermCmp	.\ext\fts2\fts2.c	/^static int interiorReaderTermCmp(InteriorReader *pReader,$/;"	f	file:
interiorWriterAppend	.\ext\fts2\fts2.c	/^static void interiorWriterAppend(InteriorWriter *pWriter,$/;"	f	file:
interiorWriterDestroy	.\ext\fts2\fts2.c	/^static int interiorWriterDestroy(InteriorWriter *pWriter){$/;"	f	file:
interiorWriterInit	.\ext\fts2\fts2.c	/^static void interiorWriterInit(int iHeight, const char *pTerm, int nTerm,$/;"	f	file:
interiorWriterRootInfo	.\ext\fts2\fts2.c	/^static int interiorWriterRootInfo(fulltext_vtab *v, InteriorWriter *pWriter,$/;"	f	file:
interp	.\ext\fts5\fts5_tcl.c	/^  Tcl_Interp *interp;$/;"	m	struct:F5tFunction	file:
interp	.\ext\fts5\fts5_tcl.c	/^  Tcl_Interp *interp;$/;"	m	struct:F5tTokenizerInstance	file:
interp	.\ext\fts5\fts5_tcl.c	/^  Tcl_Interp *interp;$/;"	m	struct:F5tTokenizerModule	file:
interp	.\src\tclsqlite.c	/^  Tcl_Interp *interp;        \/* The interpreter used for this database *\/$/;"	m	struct:SqliteDb	file:
interp	.\src\tclsqlite.c	/^  Tcl_Interp *interp;   \/* The TCL interpret to execute the function *\/$/;"	m	struct:SqlCollate	file:
interp	.\src\tclsqlite.c	/^  Tcl_Interp *interp;   \/* The TCL interpret to execute the function *\/$/;"	m	struct:SqlFunc	file:
interp	.\src\test1.c	/^  Tcl_Interp *interp;$/;"	m	struct:CreateFunctionV2	file:
interp	.\src\test1.c	/^  Tcl_Interp *interp;$/;"	m	struct:TestCollationX	file:
interp	.\src\test8.c	/^  Tcl_Interp *interp;     \/* Tcl interpreter containing debug variables *\/$/;"	m	struct:echo_vtab	file:
interp	.\src\test8.c	/^  Tcl_Interp *interp;$/;"	m	struct:EchoModule	file:
interp	.\src\test_quota.c	/^  Tcl_Interp *interp;    \/* Interpreter in which to run the script *\/$/;"	m	struct:TclQuotaCallback	file:
interp	.\src\test_superlock.c	/^  Tcl_Interp *interp;$/;"	m	struct:InterpAndScript	file:
interp	.\src\test_tclvar.c	/^  Tcl_Interp *interp;$/;"	m	struct:tclvar_vtab	file:
interp	.\src\test_thread.c	/^  Tcl_Interp *interp;      \/* Parent interpreter *\/$/;"	m	struct:SqlThread	file:
interp	.\src\test_thread.c	/^  Tcl_Interp *interp;      \/* The interpreter to execute it in. *\/$/;"	m	struct:EvalEvent	file:
interp	.\src\test_vfs.c	/^  Tcl_Interp *interp;             \/* Interpreter to run script in *\/$/;"	m	struct:Testvfs	file:
interrupt_handler	.\src\shell.c	/^static void interrupt_handler(int NotUsed){$/;"	f	file:
interrupt_injectinstall	.\test\malloc_common.tcl	/^proc interrupt_injectinstall {} {$/;"	p
interrupt_injectstart	.\test\malloc_common.tcl	/^proc interrupt_injectstart {iFail} {$/;"	p
interrupt_injectstop	.\test\malloc_common.tcl	/^proc interrupt_injectstop {} {$/;"	p
interrupt_injectuninstall	.\test\malloc_common.tcl	/^proc interrupt_injectuninstall {} {$/;"	p
interruptx	.\src\sqlite3ext.h	/^  void  (*interruptx)(sqlite3*);$/;"	m	struct:sqlite3_api_routines
invalidateAllOverflowCache	.\src\btree.c	/^static void invalidateAllOverflowCache(BtShared *pBt){$/;"	f	file:
invalidateIncrblobCursors	.\src\btree.c	/^static void invalidateIncrblobCursors($/;"	f	file:
invalidateIncrblobCursors	.\src\btree.c	508;"	d	file:
invalidateOverflowCache	.\src\btree.c	459;"	d	file:
invalidateTempStorage	.\src\pragma.c	/^static int invalidateTempStorage(Parse *pParse){$/;"	f	file:
invokeProfileCallback	.\src\vdbeapi.c	/^static SQLITE_NOINLINE void invokeProfileCallback(sqlite3 *db, Vdbe *p){$/;"	f	file:
invokeValueDestructor	.\src\vdbeapi.c	/^static int invokeValueDestructor($/;"	f	file:
ioDelay	.\ext\async\sqlite3async.c	/^  volatile int ioDelay;        \/* Extra delay between write operations *\/$/;"	m	struct:TestAsyncStaticData	file:
ioError	.\ext\async\sqlite3async.c	/^  int ioError;                 \/* True if an IO error has occurred *\/$/;"	m	struct:TestAsyncStaticData	file:
io_trace_callback	.\src\test1.c	/^static void io_trace_callback(const char *zFormat, ...){$/;"	f	file:
ioerr_err	.\src\test_vfs.c	/^  TestFaultInject ioerr_err;$/;"	m	struct:Testvfs	file:
ioerr_injectstart	.\test\malloc_common.tcl	/^proc ioerr_injectstart {persist iFail} {$/;"	p
ioerr_injectstop	.\test\malloc_common.tcl	/^proc ioerr_injectstop {} {$/;"	p
iotrace	.\src\shell.c	/^static FILE *iotrace = 0;$/;"	v	file:
iotracePrintf	.\src\shell.c	/^static void SQLITE_CDECL iotracePrintf(const char *zFormat, ...){$/;"	f	file:
iotrace_file	.\src\test1.c	/^static FILE *iotrace_file = 0;$/;"	v	file:
isAnchor	.\src\pcache1.c	/^  u8 isAnchor;                   \/* This is the PGroup.lru element *\/$/;"	m	struct:PgHdr1	file:
isAttached	.\src\backup.c	/^  int isAttached;          \/* True once backup has been registered with pager *\/$/;"	m	struct:sqlite3_backup	file:
isBenignMode	.\src\test_malloc.c	/^  int isBenignMode;       \/* True if malloc failures are considered benign *\/$/;"	m	struct:MemFault	file:
isBulkLocal	.\src\pcache1.c	/^  u8 isBulkLocal;                \/* This page from bulk local storage *\/$/;"	m	struct:PgHdr1	file:
isCandidateForInOpt	.\src\expr.c	/^static int isCandidateForInOpt(Select *p){$/;"	f	file:
isConsonant	.\ext\fts1\fts1_porter.c	/^static int isConsonant(const char *z){$/;"	f	file:
isConsonant	.\ext\fts2\fts2_porter.c	/^static int isConsonant(const char *z){$/;"	f	file:
isConsonant	.\ext\fts3\fts3_porter.c	/^static int isConsonant(const char *z){$/;"	f	file:
isCorrelated	.\src\sqliteInt.h	/^      unsigned isCorrelated :1;  \/* True if sub-query is correlated *\/$/;"	m	struct:SrcList::SrcList_item::__anon19
isCovering	.\src\sqliteInt.h	/^  unsigned isCovering:1;   \/* True if this is a covering index *\/$/;"	m	struct:Index
isDate	.\src\date.c	/^static int isDate($/;"	f	file:
isDeferred	.\src\sqliteInt.h	/^  u8 isDeferred;       \/* True if constraint checking is deferred till COMMIT *\/$/;"	m	struct:FKey
isDelim	.\ext\fts1\fts1_porter.c	572;"	d	file:
isDelim	.\ext\fts1\fts1_tokenizer1.c	/^static int isDelim(simple_tokenizer *t, unsigned char c){$/;"	f	file:
isDelim	.\ext\fts2\fts2_porter.c	573;"	d	file:
isDelim	.\ext\fts3\fts3_porter.c	588;"	d	file:
isDesc	.\ext\misc\series.c	/^  int isDesc;                \/* True to count down rather than up *\/$/;"	m	struct:series_cursor	file:
isDirSep	.\mptest\mptest.c	58;"	d	file:
isDirSep	.\mptest\mptest.c	60;"	d	file:
isDirty	.\ext\rtree\rtree.c	/^  int isDirty;                \/* True if the node needs to be written to disk *\/$/;"	m	struct:RtreeNode	file:
isDistinctRedundant	.\src\where.c	/^static int isDistinctRedundant($/;"	f	file:
isEof	.\ext\fts3\fts3Int.h	/^  u8 isEof;                       \/* True if at End Of Results *\/$/;"	m	struct:Fts3Cursor
isEof	.\ext\fts3\fts3_aux.c	/^  int isEof;                      \/* True if cursor is at EOF *\/$/;"	m	struct:Fts3auxCursor	file:
isEof	.\ext\fts3\fts3_term.c	/^  int isEof;                      \/* True if cursor is at EOF *\/$/;"	m	struct:Fts3termCursor	file:
isEof	.\src\dbstat.c	/^  int isEof;                      \/* After pStmt has returned SQLITE_DONE *\/$/;"	m	struct:StatCursor	file:
isEphemeral	.\src\vdbeInt.h	/^  Bool isEphemeral:1;   \/* True for an ephemeral table *\/$/;"	m	struct:VdbeCursor
isErr	.\src\test_sqllog.c	/^  int isErr;                      \/* True if an error has occurred *\/$/;"	m	struct:SLConn	file:
isError	.\src\vdbeInt.h	/^  int isError;            \/* Error code returned by the function. *\/$/;"	m	struct:sqlite3_context
isFatalError	.\src\backup.c	/^static int isFatalError(int rc){$/;"	f	file:
isFloat	.\tool\logest.c	/^int isFloat(const char *z){$/;"	f
isFullshm	.\src\test_vfs.c	/^  int isFullshm;$/;"	m	struct:Testvfs	file:
isIdChar	.\ext\fts1\fts1.c	/^static const char isIdChar[] = {$/;"	v	file:
isIdChar	.\ext\fts1\fts1_porter.c	/^static const char isIdChar[] = {$/;"	v	file:
isIdChar	.\ext\fts2\fts2.c	/^static const char isIdChar[] = {$/;"	v	file:
isIndexedBy	.\src\sqliteInt.h	/^      unsigned isIndexedBy :1;   \/* True if there is an INDEXED BY clause *\/$/;"	m	struct:SrcList::SrcList_item::__anon19
isInfinity	.\ext\misc\percentile.c	/^static int isInfinity(double r){$/;"	f	file:
isInit	.\ext\async\sqlite3async.c	/^  int isInit;$/;"	m	struct:AsyncPrimitives	file:
isInit	.\src\btreeInt.h	/^  u8 isInit;           \/* True if previously initialized. MUST BE FIRST! *\/$/;"	m	struct:MemPage
isInit	.\src\pcache1.c	/^  int isInit;                    \/* True if initialized *\/$/;"	m	struct:PCacheGlobal	file:
isInit	.\src\random.c	/^  unsigned char isInit;          \/* True if initialized *\/$/;"	m	struct:sqlite3PrngType	file:
isInit	.\src\sqliteInt.h	/^  int isInit;                       \/* True after initialization has finished *\/$/;"	m	struct:Sqlite3Config
isInit	.\src\tclsqlite.c	/^  int isInit;$/;"	m	struct:MD5Context	file:
isInit	.\src\test_mutex.c	/^  int isInit;                \/* True if initialized *\/$/;"	m	struct:test_mutex_globals	file:
isInit	.\src\wal.c	/^  u8 isInit;                      \/* 1 when initialized *\/$/;"	m	struct:WalIndexHdr	file:
isInit	.\test\threadtest3.c	/^  int isInit;$/;"	m	struct:MD5Context	file:
isInitialized	.\src\test_multiplex.c	/^  int isInitialized;$/;"	m	struct:__anon23	file:
isInitialized	.\src\test_quota.c	/^  int isInitialized;$/;"	m	struct:__anon24	file:
isInstalled	.\src\test_async.c	/^  int isInstalled;                     \/* True when async VFS is installed *\/$/;"	m	struct:TestAsyncGlobal	file:
isInstalled	.\src\test_malloc.c	/^  int isInstalled;        \/* True if the fault simulation layer is installed *\/$/;"	m	struct:MemFault	file:
isInstalled	.\src\test_mutex.c	/^  int isInstalled;           \/* True if installed *\/$/;"	m	struct:test_mutex_globals	file:
isInteger	.\tool\logest.c	/^int isInteger(const char *z){$/;"	f
isInterrupted	.\src\sqliteInt.h	/^    volatile int isInterrupted; \/* True if sqlite3_interrupt has been called *\/$/;"	m	union:sqlite3::__anon14
isLikeOrGlob	.\src\whereexpr.c	/^static int isLikeOrGlob($/;"	f	file:
isLocked	.\tool\getlock.c	/^static int isLocked($/;"	f	file:
isLookaside	.\src\malloc.c	/^static int isLookaside(sqlite3 *db, void *p){$/;"	f	file:
isLookaside	.\src\malloc.c	402;"	d	file:
isMallocInit	.\src\sqliteInt.h	/^  int isMallocInit;                 \/* True after malloc is initialized *\/$/;"	m	struct:Sqlite3Config
isMatchOfColumn	.\src\whereexpr.c	/^static int isMatchOfColumn($/;"	f	file:
isMatchinfoNeeded	.\ext\fts3\fts3Int.h	/^  int isMatchinfoNeeded;          \/* True when aMatchinfo[] needs filling in *\/$/;"	m	struct:Fts3Cursor
isMultiWrite	.\src\sqliteInt.h	/^  u8 isMultiWrite;     \/* True if statement may modify\/insert multiple rows *\/$/;"	m	struct:Parse
isMutexInit	.\src\sqliteInt.h	/^  int isMutexInit;                  \/* True after mutexes are initialized *\/$/;"	m	struct:Sqlite3Config
isNoshm	.\src\test_vfs.c	/^  int isNoshm;$/;"	m	struct:Testvfs	file:
isNot	.\ext\fts1\fts1.c	/^  signed char isNot; \/* this term is preceded by "-" *\/$/;"	m	struct:QueryTerm	file:
isNot	.\ext\fts2\fts2.c	/^  signed char isNot; \/* this term is preceded by "-" *\/$/;"	m	struct:QueryTerm	file:
isNot	.\ext\fts3\fts3_expr.c	/^  int isNot;                          \/* True if getNextNode() sees a unary - *\/$/;"	m	struct:ParseContext	file:
isNullSegment	.\ext\fts3\tool\fts3view.c	/^static int isNullSegment(sqlite3 *db, const char *zTab, sqlite3_int64 iBlockId){$/;"	f	file:
isNumber	.\src\shell.c	/^static int isNumber(const char *z, int *realnum){$/;"	f	file:
isOpen	.\src\pager.c	811;"	d	file:
isOr	.\ext\fts1\fts1.c	/^  signed char isOr;  \/* this term is preceded by "OR" *\/$/;"	m	struct:QueryTerm	file:
isOr	.\ext\fts2\fts2.c	/^  signed char isOr;  \/* this term is preceded by "OR" *\/$/;"	m	struct:QueryTerm	file:
isOrdered	.\src\vdbeInt.h	/^  Bool isOrdered:1;     \/* True if the underlying table is BTREE_UNORDERED *\/$/;"	m	struct:VdbeCursor
isOrdered	.\src\whereInt.h	/^      i8 isOrdered;          \/* True if satisfies ORDER BY *\/$/;"	m	struct:WhereLoop::__anon28::__anon30
isOrdered	.\src\whereInt.h	/^  i8 isOrdered;         \/* No. of ORDER BY terms satisfied. -1 for unknown *\/$/;"	m	struct:WherePath
isPCacheInit	.\src\sqliteInt.h	/^  int isPCacheInit;                 \/* True after malloc is initialized *\/$/;"	m	struct:Sqlite3Config
isPSample	.\src\analyze.c	/^  u8 isPSample;                   \/* True if a periodic sample *\/$/;"	m	struct:Stat4Sample	file:
isPattern	.\src\test8.c	/^  int isPattern;$/;"	m	struct:echo_vtab	file:
isPinned	.\src\pcache1.c	/^  u8 isPinned;                   \/* Page in use, not on the LRU list *\/$/;"	m	struct:PgHdr1	file:
isPinned	.\src\test_pcache.c	/^    int isPinned;              \/* True if the page is pinned *\/$/;"	m	struct:testpcache::testpcachePage	file:
isPrefix	.\ext\fts2\fts2.c	/^  signed char isPrefix; \/* this term is followed by "*" *\/$/;"	m	struct:QueryTerm	file:
isPrefix	.\ext\fts3\fts3Int.h	/^  int isPrefix;                   \/* True if token ends with a "*" character *\/$/;"	m	struct:Fts3PhraseToken
isPrefix	.\ext\misc\spellfix.c	/^  int isPrefix;            \/* True if ends with '*' character *\/$/;"	m	struct:EditDist3FromString	file:
isPrepareV2	.\src\vdbeInt.h	/^  bft isPrepareV2:1;      \/* True if prepared with prepare_v2() *\/$/;"	m	struct:Vdbe
isReadonly	.\src\os_unix.c	/^  u8 isReadonly;             \/* True if read-only *\/$/;"	m	struct:unixShmNode	file:
isRecursive	.\src\sqliteInt.h	/^      unsigned isRecursive :1;   \/* True for recursive reference in WITH *\/$/;"	m	struct:SrcList::SrcList_item::__anon19
isRequireSeek	.\ext\fts3\fts3Int.h	/^  u8 isRequireSeek;               \/* True if must seek pStmt to %_content row *\/$/;"	m	struct:Fts3Cursor
isResized	.\src\sqliteInt.h	/^  unsigned isResized:1;    \/* True if resizeIndexObject() has been called *\/$/;"	m	struct:Index
isSetNullAction	.\src\fkey.c	/^static int isSetNullAction(Parse *pParse, FKey *pFKey){$/;"	f	file:
isSimpleCount	.\src\select.c	/^static Table *isSimpleCount(Select *p, AggInfo *pAggInfo){$/;"	f	file:
isSorter	.\src\vdbe.c	168;"	d	file:
isSystemTable	.\src\alter.c	/^static int isSystemTable(Parse *pParse, const char *zName){$/;"	f	file:
isTabFunc	.\src\sqliteInt.h	/^      unsigned isTabFunc :1;     \/* True if table-valued-function syntax *\/$/;"	m	struct:SrcList::SrcList_item::__anon19
isTable	.\src\vdbeInt.h	/^  Bool isTable:1;       \/* True if a table requiring integer keys *\/$/;"	m	struct:VdbeCursor
isTkn	.\tool\lemon.c	/^  int isTkn;           \/* True to use tokens.  False for non-terminals *\/$/;"	m	struct:axset	file:
isTnct	.\src\select.c	/^  u8 isTnct;      \/* True if the DISTINCT keyword is present *\/$/;"	m	struct:DistinctCtx	file:
isTransactionSavepoint	.\src\sqliteInt.h	/^  u8 isTransactionSavepoint;    \/* True if the outermost savepoint is a TS *\/$/;"	m	struct:sqlite3
isView	.\src\delete.c	286;"	d	file:
isView	.\src\delete.c	287;"	d	file:
isView	.\src\delete.c	586;"	d	file:
isView	.\src\insert.c	1049;"	d	file:
isView	.\src\insert.c	543;"	d	file:
isView	.\src\insert.c	544;"	d	file:
isView	.\src\update.c	170;"	d	file:
isView	.\src\update.c	171;"	d	file:
isView	.\src\update.c	677;"	d	file:
isVowel	.\ext\fts1\fts1_porter.c	/^static int isVowel(const char *z){$/;"	f	file:
isVowel	.\ext\fts2\fts2_porter.c	/^static int isVowel(const char *z){$/;"	f	file:
isVowel	.\ext\fts3\fts3_porter.c	/^static int isVowel(const char *z){$/;"	f	file:
isWriteLock	.\src\build.c	/^  u8 isWriteLock;      \/* True for write lock.  False for a read lock *\/$/;"	m	struct:TableLock	file:
is_phrase	.\ext\fts1\fulltext.c	/^  int is_phrase;    \/* true if this term begins a new phrase *\/$/;"	m	struct:QueryTerm	file:
is_relative_file	.\test\tester.tcl	/^proc is_relative_file { file } {$/;"	p
is_without_rowid	.\tool\spaceanal.tcl	/^proc is_without_rowid {tname} {$/;"	p
isatty	.\src\shell.c	104;"	d	file:
isatty	.\src\shell.c	131;"	d	file:
iter	.\ext\fts5\fts5_aux.c	/^  CInstIter iter;                 \/* Coalesced Instance Iterator *\/$/;"	m	struct:HighlightContext	file:
ix	.\src\whereInt.h	/^  int ix[BMS];                  \/* Cursor assigned to each bit *\/$/;"	m	struct:WhereMaskSet
j	.\src\random.c	/^  unsigned char i, j;            \/* State variables *\/$/;"	m	struct:sqlite3PrngType	file:
jfd	.\src\pager.c	/^  sqlite3_file *jfd;          \/* File descriptor for main journal *\/$/;"	m	struct:Pager	file:
jnFlags	.\ext\misc\json1.c	/^  u8 jnFlags;            \/* JNODE flags *\/$/;"	m	struct:JsonNode	file:
join_all_threads	.\test\threadtest3.c	56;"	d	file:
join_all_threads_x	.\test\threadtest3.c	/^static void join_all_threads_x($/;"	f	file:
jointype	.\src\sqliteInt.h	/^      u8 jointype;      \/* Type of join between this able and the previous *\/$/;"	m	struct:SrcList::SrcList_item::__anon19
journalHdr	.\src\pager.c	/^  i64 journalHdr;             \/* Byte offset to previous journal header *\/$/;"	m	struct:Pager	file:
journalHdrOffset	.\src\pager.c	/^static i64 journalHdrOffset(Pager *pPager){$/;"	f	file:
journalMode	.\src\pager.c	/^  u8 journalMode;             \/* One of the PAGER_JOURNALMODE_* values *\/$/;"	m	struct:Pager	file:
journalOff	.\src\pager.c	/^  i64 journalOff;             \/* Current write offset in the journal file *\/$/;"	m	struct:Pager	file:
journalSizeLimit	.\src\pager.c	/^  i64 journalSizeLimit;       \/* Size limit for persistent journal files *\/$/;"	m	struct:Pager	file:
jrnlBufferSize	.\src\pager.c	/^static int jrnlBufferSize(Pager *pPager){$/;"	f	file:
jrnlClose	.\src\journal.c	/^static int jrnlClose(sqlite3_file *pJfd){$/;"	f	file:
jrnlFileSize	.\src\journal.c	/^static int jrnlFileSize(sqlite3_file *pJfd, sqlite_int64 *pSize){$/;"	f	file:
jrnlRead	.\src\journal.c	/^static int jrnlRead($/;"	f	file:
jrnlSync	.\src\journal.c	/^static int jrnlSync(sqlite3_file *pJfd, int flags){$/;"	f	file:
jrnlTruncate	.\src\journal.c	/^static int jrnlTruncate(sqlite3_file *pJfd, sqlite_int64 size){$/;"	f	file:
jrnlWrite	.\src\journal.c	/^static int jrnlWrite($/;"	f	file:
jsonAppendChar	.\ext\misc\json1.c	/^static void jsonAppendChar(JsonString *p, char c){$/;"	f	file:
jsonAppendRaw	.\ext\misc\json1.c	/^static void jsonAppendRaw(JsonString *p, const char *zIn, u32 N){$/;"	f	file:
jsonAppendSeparator	.\ext\misc\json1.c	/^static void jsonAppendSeparator(JsonString *p){$/;"	f	file:
jsonAppendString	.\ext\misc\json1.c	/^static void jsonAppendString(JsonString *p, const char *zIn, u32 N){$/;"	f	file:
jsonAppendValue	.\ext\misc\json1.c	/^static void jsonAppendValue($/;"	f	file:
jsonArrayFunc	.\ext\misc\json1.c	/^static void jsonArrayFunc($/;"	f	file:
jsonArrayLengthFunc	.\ext\misc\json1.c	/^static void jsonArrayLengthFunc($/;"	f	file:
jsonEachBestIndex	.\ext\misc\json1.c	/^static int jsonEachBestIndex($/;"	f	file:
jsonEachClose	.\ext\misc\json1.c	/^static int jsonEachClose(sqlite3_vtab_cursor *cur){$/;"	f	file:
jsonEachColumn	.\ext\misc\json1.c	/^static int jsonEachColumn($/;"	f	file:
jsonEachComputePath	.\ext\misc\json1.c	/^static void jsonEachComputePath($/;"	f	file:
jsonEachConnect	.\ext\misc\json1.c	/^static int jsonEachConnect($/;"	f	file:
jsonEachCursorReset	.\ext\misc\json1.c	/^static void jsonEachCursorReset(JsonEachCursor *p){$/;"	f	file:
jsonEachDisconnect	.\ext\misc\json1.c	/^static int jsonEachDisconnect(sqlite3_vtab *pVtab){$/;"	f	file:
jsonEachEof	.\ext\misc\json1.c	/^static int jsonEachEof(sqlite3_vtab_cursor *cur){$/;"	f	file:
jsonEachFilter	.\ext\misc\json1.c	/^static int jsonEachFilter($/;"	f	file:
jsonEachModule	.\ext\misc\json1.c	/^static sqlite3_module jsonEachModule = {$/;"	v	file:
jsonEachNext	.\ext\misc\json1.c	/^static int jsonEachNext(sqlite3_vtab_cursor *cur){$/;"	f	file:
jsonEachOpenEach	.\ext\misc\json1.c	/^static int jsonEachOpenEach(sqlite3_vtab *p, sqlite3_vtab_cursor **ppCursor){$/;"	f	file:
jsonEachOpenTree	.\ext\misc\json1.c	/^static int jsonEachOpenTree(sqlite3_vtab *p, sqlite3_vtab_cursor **ppCursor){$/;"	f	file:
jsonEachRowid	.\ext\misc\json1.c	/^static int jsonEachRowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid){$/;"	f	file:
jsonExtractFunc	.\ext\misc\json1.c	/^static void jsonExtractFunc($/;"	f	file:
jsonGrow	.\ext\misc\json1.c	/^static int jsonGrow(JsonString *p, u32 N){$/;"	f	file:
jsonInit	.\ext\misc\json1.c	/^static void jsonInit(JsonString *p, sqlite3_context *pCtx){$/;"	f	file:
jsonIsSpace	.\ext\misc\json1.c	/^static const char jsonIsSpace[] = {$/;"	v	file:
jsonLabelCompare	.\ext\misc\json1.c	/^static int jsonLabelCompare(JsonNode *pNode, const char *zKey, u32 nKey){$/;"	f	file:
jsonLookup	.\ext\misc\json1.c	/^static JsonNode *jsonLookup($/;"	f	file:
jsonLookupAppend	.\ext\misc\json1.c	/^static JsonNode *jsonLookupAppend($/;"	f	file:
jsonLookupStep	.\ext\misc\json1.c	/^static JsonNode *jsonLookupStep($/;"	f	file:
jsonNodeSize	.\ext\misc\json1.c	/^static u32 jsonNodeSize(JsonNode *pNode){$/;"	f	file:
jsonObjectFunc	.\ext\misc\json1.c	/^static void jsonObjectFunc($/;"	f	file:
jsonOom	.\ext\misc\json1.c	/^static void jsonOom(JsonString *p){$/;"	f	file:
jsonParse	.\ext\misc\json1.c	/^static int jsonParse($/;"	f	file:
jsonParseAddNode	.\ext\misc\json1.c	/^static int jsonParseAddNode($/;"	f	file:
jsonParseAddNodeExpand	.\ext\misc\json1.c	/^static JSON_NOINLINE int jsonParseAddNodeExpand($/;"	f	file:
jsonParseFillInParentage	.\ext\misc\json1.c	/^static void jsonParseFillInParentage(JsonParse *pParse, u32 i, u32 iParent){$/;"	f	file:
jsonParseFindParents	.\ext\misc\json1.c	/^static int jsonParseFindParents(JsonParse *pParse){$/;"	f	file:
jsonParseFunc	.\ext\misc\json1.c	/^static void jsonParseFunc($/;"	f	file:
jsonParseReset	.\ext\misc\json1.c	/^static void jsonParseReset(JsonParse *pParse){$/;"	f	file:
jsonParseValue	.\ext\misc\json1.c	/^static int jsonParseValue(JsonParse *pParse, u32 i){$/;"	f	file:
jsonPathSyntaxError	.\ext\misc\json1.c	/^static char *jsonPathSyntaxError(const char *zErr){$/;"	f	file:
jsonPrintf	.\ext\misc\json1.c	/^static void jsonPrintf(int N, JsonString *p, const char *zFormat, ...){$/;"	f	file:
jsonRemoveFunc	.\ext\misc\json1.c	/^static void jsonRemoveFunc($/;"	f	file:
jsonRenderNode	.\ext\misc\json1.c	/^static void jsonRenderNode($/;"	f	file:
jsonReplaceFunc	.\ext\misc\json1.c	/^static void jsonReplaceFunc($/;"	f	file:
jsonReset	.\ext\misc\json1.c	/^static void jsonReset(JsonString *p){$/;"	f	file:
jsonResult	.\ext\misc\json1.c	/^static void jsonResult(JsonString *p){$/;"	f	file:
jsonReturn	.\ext\misc\json1.c	/^static void jsonReturn($/;"	f	file:
jsonReturnJson	.\ext\misc\json1.c	/^static void jsonReturnJson($/;"	f	file:
jsonSetFunc	.\ext\misc\json1.c	/^static void jsonSetFunc($/;"	f	file:
jsonTest1Func	.\ext\misc\json1.c	/^static void jsonTest1Func($/;"	f	file:
jsonTreeModule	.\ext\misc\json1.c	/^static sqlite3_module jsonTreeModule = {$/;"	v	file:
jsonType	.\ext\misc\json1.c	/^static const char * const jsonType[] = {$/;"	v	file:
jsonTypeFunc	.\ext\misc\json1.c	/^static void jsonTypeFunc($/;"	f	file:
jsonValidFunc	.\ext\misc\json1.c	/^static void jsonValidFunc($/;"	f	file:
jsonWrongNumArgs	.\ext\misc\json1.c	/^static void jsonWrongNumArgs($/;"	f	file:
jsonZero	.\ext\misc\json1.c	/^static void jsonZero(JsonString *p){$/;"	f	file:
jtAccess	.\src\test_journal.c	/^static int jtAccess($/;"	f	file:
jtCheckReservedLock	.\src\test_journal.c	/^static int jtCheckReservedLock(sqlite3_file *pFile, int *pResOut){$/;"	f	file:
jtClose	.\src\test_journal.c	/^static int jtClose(sqlite3_file *pFile){$/;"	f	file:
jtCurrentTime	.\src\test_journal.c	/^static int jtCurrentTime(sqlite3_vfs *pVfs, double *pTimeOut){$/;"	f	file:
jtCurrentTimeInt64	.\src\test_journal.c	/^static int jtCurrentTimeInt64(sqlite3_vfs *pVfs, sqlite3_int64 *pTimeOut){$/;"	f	file:
jtDelete	.\src\test_journal.c	/^static int jtDelete(sqlite3_vfs *pVfs, const char *zPath, int dirSync){$/;"	f	file:
jtDeviceCharacteristics	.\src\test_journal.c	/^static int jtDeviceCharacteristics(sqlite3_file *pFile){$/;"	f	file:
jtDlClose	.\src\test_journal.c	/^static void jtDlClose(sqlite3_vfs *pVfs, void *pHandle){$/;"	f	file:
jtDlError	.\src\test_journal.c	/^static void jtDlError(sqlite3_vfs *pVfs, int nByte, char *zErrMsg){$/;"	f	file:
jtDlOpen	.\src\test_journal.c	/^static void *jtDlOpen(sqlite3_vfs *pVfs, const char *zPath){$/;"	f	file:
jtDlSym	.\src\test_journal.c	/^static void (*jtDlSym(sqlite3_vfs *pVfs, void *p, const char *zSym))(void){$/;"	f	file:
jtFileControl	.\src\test_journal.c	/^static int jtFileControl(sqlite3_file *pFile, int op, void *pArg){$/;"	f	file:
jtFileSize	.\src\test_journal.c	/^static int jtFileSize(sqlite3_file *pFile, sqlite_int64 *pSize){$/;"	f	file:
jtFullPathname	.\src\test_journal.c	/^static int jtFullPathname($/;"	f	file:
jtLock	.\src\test_journal.c	/^static int jtLock(sqlite3_file *pFile, int eLock){$/;"	f	file:
jtObjCmd	.\src\test6.c	/^static int jtObjCmd($/;"	f	file:
jtOpen	.\src\test_journal.c	/^static int jtOpen($/;"	f	file:
jtRandomness	.\src\test_journal.c	/^static int jtRandomness(sqlite3_vfs *pVfs, int nByte, char *zBufOut){$/;"	f	file:
jtRead	.\src\test_journal.c	/^static int jtRead($/;"	f	file:
jtSectorSize	.\src\test_journal.c	/^static int jtSectorSize(sqlite3_file *pFile){$/;"	f	file:
jtSleep	.\src\test_journal.c	/^static int jtSleep(sqlite3_vfs *pVfs, int nMicro){$/;"	f	file:
jtSync	.\src\test_journal.c	/^static int jtSync(sqlite3_file *pFile, int flags){$/;"	f	file:
jtTruncate	.\src\test_journal.c	/^static int jtTruncate(sqlite3_file *pFile, sqlite_int64 size){$/;"	f	file:
jtUnlock	.\src\test_journal.c	/^static int jtUnlock(sqlite3_file *pFile, int eLock){$/;"	f	file:
jtUnregisterObjCmd	.\src\test6.c	/^static int jtUnregisterObjCmd($/;"	f	file:
jtWrite	.\src\test_journal.c	/^static int jtWrite($/;"	f	file:
jt_file	.\src\test_journal.c	/^struct jt_file {$/;"	s	file:
jt_file	.\src\test_journal.c	/^typedef struct jt_file jt_file;$/;"	t	typeref:struct:jt_file	file:
jt_io_methods	.\src\test_journal.c	/^static sqlite3_io_methods jt_io_methods = {$/;"	v	file:
jt_register	.\src\test_journal.c	/^int jt_register(char *zWrap, int isDefault){$/;"	f
jt_unregister	.\src\test_journal.c	/^void jt_unregister(void){$/;"	f
jt_vfs	.\src\test_journal.c	/^static sqlite3_vfs jt_vfs = {$/;"	v	file:
juliandayFunc	.\src\date.c	/^static void juliandayFunc($/;"	f	file:
k	.\src\whereInt.h	/^  int k;                     \/* Resume scanning at this->pWC->a[this->k] *\/$/;"	m	struct:WhereScan
kPendingThreshold	.\ext\fts2\fts2.c	1876;"	d	file:
key	.\autoconf\tea\win\nmakehlp.c	/^    char * key;$/;"	m	struct:list_item_t	file:
key	.\ext\fts3\fts3_write.c	/^  Blob key;                       \/* Last key written to the current block *\/$/;"	m	struct:NodeWriter	file:
key	.\src\test_pcache.c	/^    unsigned key;              \/* The key for this page. 0 means unallocated *\/$/;"	m	struct:testpcache::testpcachePage	file:
key	.\tool\lemon.c	/^  const char *key;         \/* The key *\/$/;"	m	struct:s_x2node	file:
key	.\tool\lemon.c	/^  struct config *key;                   \/* The key *\/$/;"	m	struct:s_x3node	typeref:struct:s_x3node::config	file:
keyClass	.\ext\fts1\ft_hash.h	/^  char keyClass;          \/* HASH_INT, _POINTER, _STRING, _BINARY *\/$/;"	m	struct:Hash
keyClass	.\ext\fts1\fts1_hash.h	/^  char keyClass;          \/* HASH_INT, _POINTER, _STRING, _BINARY *\/$/;"	m	struct:fts1Hash
keyClass	.\ext\fts2\fts2_hash.h	/^  char keyClass;          \/* HASH_INT, _POINTER, _STRING, _BINARY *\/$/;"	m	struct:fts2Hash
keyClass	.\ext\fts3\fts3_hash.h	/^  char keyClass;          \/* HASH_INT, _POINTER, _STRING, _BINARY *\/$/;"	m	struct:Fts3Hash
keyConf	.\src\sqliteInt.h	/^  u8 keyConf;          \/* What to do in case of uniqueness conflict on iPKey *\/$/;"	m	struct:Table
keyInfoFromExprList	.\src\select.c	/^static KeyInfo *keyInfoFromExprList($/;"	f	file:
keywordCompare1	.\tool\mkkeywordhash.c	/^static int keywordCompare1(const void *a, const void *b){$/;"	f	file:
keywordCompare2	.\tool\mkkeywordhash.c	/^static int keywordCompare2(const void *a, const void *b){$/;"	f	file:
keywordCompare3	.\tool\mkkeywordhash.c	/^static int keywordCompare3(const void *a, const void *b){$/;"	f	file:
kwcolumn_opt	.\src\parse.y	/^kwcolumn_opt ::= .$/;"	l
kwcolumn_opt	.\src\parse.y	/^kwcolumn_opt ::= COLUMNKW.$/;"	l
label	.\tool\lemon.c	/^  const char *label;$/;"	m	struct:s_options	file:
labelBkOut	.\src\select.c	/^  int labelBkOut;       \/* Start label for the block-output subroutine *\/$/;"	m	struct:SortCtx	file:
lambda	.\tool\lemon.c	/^  Boolean lambda;          \/* True if NT and can generate an empty string *\/$/;"	m	struct:symbol	file:
langidFromSelect	.\ext\fts3\fts3_write.c	/^static int langidFromSelect(Fts3Table *p, sqlite3_stmt *pSelect){$/;"	f	file:
last	.\ext\fts2\fts2.c	/^  InteriorBlock *first, *last;$/;"	m	struct:InteriorWriter	file:
lastErrno	.\src\os_unix.c	/^  int lastErrno;                      \/* The unix errno from last I\/O error *\/$/;"	m	struct:unixFile	file:
lastErrno	.\src\os_win.c	/^  DWORD lastErrno;           \/* The Windows errno from the last I\/O error *\/$/;"	m	struct:winShmNode	file:
lastErrno	.\src\os_win.c	/^  DWORD lastErrno;        \/* The Windows errno from the last I\/O error *\/$/;"	m	struct:winFile	file:
lastRowid	.\src\sqliteInt.h	/^  i64 lastRowid;                \/* ROWID of most recent insert (see above) *\/$/;"	m	struct:sqlite3
lastRowid	.\src\vdbeInt.h	/^  i64 lastRowid;          \/* Last insert rowid (sqlite3.lastRowid) *\/$/;"	m	struct:VdbeFrame
last_insert_rowid	.\src\func.c	/^static void last_insert_rowid($/;"	f	file:
last_insert_rowid	.\src\sqlite3ext.h	/^  sqlite_int64  (*last_insert_rowid)(sqlite3*);$/;"	m	struct:sqlite3_api_routines
lastrule	.\tool\lemon.c	/^  struct rule *lastrule;     \/* Pointer to the most recently parsed rule *\/$/;"	m	struct:pstate	typeref:struct:pstate::rule	file:
launch_testfixture	.\test\lock_common.tcl	/^proc launch_testfixture {{prg ""}} {$/;"	p
launch_thread	.\test\threadtest3.c	55;"	d	file:
launch_thread_main	.\test\threadtest3.c	/^static void *launch_thread_main(void *pArg){$/;"	f	file:
launch_thread_x	.\test\threadtest3.c	/^static void launch_thread_x($/;"	f	file:
leaf	.\src\btreeInt.h	/^  u8 leaf;             \/* True if a leaf page *\/$/;"	m	struct:MemPage
leafNodeValidate	.\ext\fts2\fts2.c	/^static void leafNodeValidate(const char *pData, int nData){$/;"	f	file:
leafReader	.\ext\fts2\fts2.c	/^  LeafReader leafReader;    \/* reader for the current leaf. *\/$/;"	m	struct:LeavesReader	file:
leafReaderAtEnd	.\ext\fts2\fts2.c	/^static int leafReaderAtEnd(LeafReader *pReader){$/;"	f	file:
leafReaderData	.\ext\fts2\fts2.c	/^static const char *leafReaderData(LeafReader *pReader){$/;"	f	file:
leafReaderDataBytes	.\ext\fts2\fts2.c	/^static int leafReaderDataBytes(LeafReader *pReader){$/;"	f	file:
leafReaderDestroy	.\ext\fts2\fts2.c	/^static void leafReaderDestroy(LeafReader *pReader){$/;"	f	file:
leafReaderInit	.\ext\fts2\fts2.c	/^static void leafReaderInit(const char *pData, int nData,$/;"	f	file:
leafReaderStep	.\ext\fts2\fts2.c	/^static void leafReaderStep(LeafReader *pReader){$/;"	f	file:
leafReaderTerm	.\ext\fts2\fts2.c	/^static const char *leafReaderTerm(LeafReader *pReader){$/;"	f	file:
leafReaderTermBytes	.\ext\fts2\fts2.c	/^static int leafReaderTermBytes(LeafReader *pReader){$/;"	f	file:
leafReaderTermCmp	.\ext\fts2\fts2.c	/^static int leafReaderTermCmp(LeafReader *pReader,$/;"	f	file:
leafWriterDestroy	.\ext\fts2\fts2.c	/^static void leafWriterDestroy(LeafWriter *pWriter){$/;"	f	file:
leafWriterEncodeTerm	.\ext\fts2\fts2.c	/^static int leafWriterEncodeTerm(LeafWriter *pWriter,$/;"	f	file:
leafWriterFinalize	.\ext\fts2\fts2.c	/^static int leafWriterFinalize(fulltext_vtab *v, LeafWriter *pWriter){$/;"	f	file:
leafWriterFlush	.\ext\fts2\fts2.c	/^static int leafWriterFlush(fulltext_vtab *v, LeafWriter *pWriter){$/;"	f	file:
leafWriterInit	.\ext\fts2\fts2.c	/^static void leafWriterInit(int iLevel, int idx, LeafWriter *pWriter){$/;"	f	file:
leafWriterInlineFlush	.\ext\fts2\fts2.c	/^static int leafWriterInlineFlush(fulltext_vtab *v, LeafWriter *pWriter,$/;"	f	file:
leafWriterInternalFlush	.\ext\fts2\fts2.c	/^static int leafWriterInternalFlush(fulltext_vtab *v, LeafWriter *pWriter,$/;"	f	file:
leafWriterRootInfo	.\ext\fts2\fts2.c	/^static int leafWriterRootInfo(fulltext_vtab *v, LeafWriter *pWriter,$/;"	f	file:
leafWriterStep	.\ext\fts2\fts2.c	/^static int leafWriterStep(fulltext_vtab *v, LeafWriter *pWriter,$/;"	f	file:
leafWriterStepMerge	.\ext\fts2\fts2.c	/^static int leafWriterStepMerge(fulltext_vtab *v, LeafWriter *pWriter,$/;"	f	file:
leaveJtMutex	.\src\test_journal.c	/^static void leaveJtMutex(void){$/;"	f	file:
leaveMutex	.\src\notify.c	/^static void leaveMutex(void){$/;"	f	file:
leavesReaderAtEnd	.\ext\fts2\fts2.c	/^static int leavesReaderAtEnd(LeavesReader *pReader){$/;"	f	file:
leavesReaderCmp	.\ext\fts2\fts2.c	/^static int leavesReaderCmp(LeavesReader *lr1, LeavesReader *lr2){$/;"	f	file:
leavesReaderData	.\ext\fts2\fts2.c	/^static const char *leavesReaderData(LeavesReader *pReader){$/;"	f	file:
leavesReaderDataBytes	.\ext\fts2\fts2.c	/^static int leavesReaderDataBytes(LeavesReader *pReader){$/;"	f	file:
leavesReaderDestroy	.\ext\fts2\fts2.c	/^static void leavesReaderDestroy(LeavesReader *pReader){$/;"	f	file:
leavesReaderInit	.\ext\fts2\fts2.c	/^static int leavesReaderInit(fulltext_vtab *v,$/;"	f	file:
leavesReaderReorder	.\ext\fts2\fts2.c	/^static void leavesReaderReorder(LeavesReader *pLr, int nLr){$/;"	f	file:
leavesReaderReset	.\ext\fts2\fts2.c	/^static int leavesReaderReset(LeavesReader *pReader){$/;"	f	file:
leavesReaderStep	.\ext\fts2\fts2.c	/^static int leavesReaderStep(fulltext_vtab *v, LeavesReader *pReader){$/;"	f	file:
leavesReaderTerm	.\ext\fts2\fts2.c	/^static const char *leavesReaderTerm(LeavesReader *pReader){$/;"	f	file:
leavesReaderTermBytes	.\ext\fts2\fts2.c	/^static int leavesReaderTermBytes(LeavesReader *pReader){$/;"	f	file:
leavesReaderTermCmp	.\ext\fts2\fts2.c	/^static int leavesReaderTermCmp(LeavesReader *lr1, LeavesReader *lr2){$/;"	f	file:
leavesReadersInit	.\ext\fts2\fts2.c	/^static int leavesReadersInit(fulltext_vtab *v, int iLevel,$/;"	f	file:
leavesReadersMerge	.\ext\fts2\fts2.c	/^static int leavesReadersMerge(fulltext_vtab *v,$/;"	f	file:
leftColumn	.\src\whereInt.h	/^    int leftColumn;         \/* Column number of X in "X <op> <expr>" *\/$/;"	m	union:WhereTerm::__anon31
leftCursor	.\src\whereInt.h	/^  int leftCursor;         \/* Cursor number of X in "X <op> <expr>" *\/$/;"	m	struct:WhereTerm
legacyCountFinalize	.\src\test1.c	/^static void legacyCountFinalize(sqlite3_context *context){$/;"	f	file:
legacyCountStep	.\src\test1.c	/^static void legacyCountStep($/;"	f	file:
lemon	.\tool\lemon.c	/^struct lemon {$/;"	s	file:
lemonStrlen	.\tool\lemon.c	51;"	d	file:
lemon_addtext	.\tool\lemon.c	/^static void lemon_addtext($/;"	f	file:
lemon_sprintf	.\tool\lemon.c	/^static int lemon_sprintf(char *str, const char *format, ...){$/;"	f	file:
lemon_strcat	.\tool\lemon.c	/^static void lemon_strcat(char *dest, const char *src){$/;"	f	file:
lemon_strcpy	.\tool\lemon.c	/^static void lemon_strcpy(char *dest, const char *src){$/;"	f	file:
lemon_vsprintf	.\tool\lemon.c	/^static int lemon_vsprintf(char *str, const char *zFormat, va_list ap){$/;"	f	file:
len	.\ext\fts1\fts1.c	/^  int len;      \/* length, not including null terminator *\/$/;"	m	struct:StringBuffer	file:
len	.\tool\mkkeywordhash.c	/^  int len;             \/* Length of this keyword, not counting final \\000 *\/$/;"	m	struct:Keyword	file:
length	.\src\os_unix.c	/^  unsigned long long length;        \/* nbr of bytes to lock *\/$/;"	m	struct:ByteRangeLockPB2	file:
lengthFunc	.\src\func.c	/^static void lengthFunc($/;"	f	file:
lhs	.\src\lempar.c	/^  YYCODETYPE lhs;         \/* Symbol on the left-hand side of the rule *\/$/;"	m	struct:__anon9	file:
lhs	.\tool\lemon.c	/^  struct symbol *lhs;        \/* Left-hand side of current rule *\/$/;"	m	struct:pstate	typeref:struct:pstate::symbol	file:
lhs	.\tool\lemon.c	/^  struct symbol *lhs;      \/* Left-hand side of the rule *\/$/;"	m	struct:rule	typeref:struct:rule::symbol	file:
lhs	.\tool\lempar.c	/^  YYCODETYPE lhs;         \/* Symbol on the left-hand side of the rule *\/$/;"	m	struct:__anon35	file:
lhsStart	.\tool\lemon.c	/^  int lhsStart;            \/* True if left-hand side is the start symbol *\/$/;"	m	struct:rule	file:
lhsalias	.\tool\lemon.c	/^  const char *lhsalias;      \/* Alias for the LHS *\/$/;"	m	struct:pstate	file:
lhsalias	.\tool\lemon.c	/^  const char *lhsalias;    \/* Alias for the LHS (NULL if none) *\/$/;"	m	struct:rule	file:
libversion	.\src\sqlite3ext.h	/^  const char * (*libversion)(void);$/;"	m	struct:sqlite3_api_routines
libversion_number	.\src\sqlite3ext.h	/^  int  (*libversion_number)(void);$/;"	m	struct:sqlite3_api_routines
likeFunc	.\src\func.c	/^static void likeFunc($/;"	f	file:
likeInfoAlt	.\src\func.c	/^static const struct compareInfo likeInfoAlt = { '%', '_',   0, 0 };$/;"	v	typeref:struct:compareInfo	file:
likeInfoNorm	.\src\func.c	/^static const struct compareInfo likeInfoNorm = { '%', '_',   0, 1 };$/;"	v	typeref:struct:compareInfo	file:
likely	.\src\sqliteInt.h	430;"	d
limit	.\src\sqlite3ext.h	/^  int (*limit)(sqlite3*,int,int);$/;"	m	struct:sqlite3_api_routines
line	.\tool\lemon.c	/^  int line;                \/* Line number at which code begins *\/$/;"	m	struct:rule	file:
line_contains_semicolon	.\src\shell.c	/^static int line_contains_semicolon(const char *z, int N){$/;"	f	file:
line_is_command_terminator	.\src\shell.c	/^static int line_is_command_terminator(const char *zLine){$/;"	f	file:
line_is_complete	.\src\shell.c	/^static int line_is_complete(char *zSql, int nSql){$/;"	f	file:
list	.\src\mem3.c	/^    } list;$/;"	m	union:Mem3Block::__anon11	typeref:struct:Mem3Block::__anon11::__anon13	file:
list	.\src\vdbesort.c	/^  SorterList list;                \/* List for thread to write to a PMA *\/$/;"	m	struct:SortSubtask	file:
list	.\src\vdbesort.c	/^  SorterList list;                \/* List of in-memory records *\/$/;"	m	struct:VdbeSorter	file:
listBigSegments	.\ext\fts3\tool\fts3view.c	/^static void listBigSegments(sqlite3 *db, const char *zTab){$/;"	f	file:
list_free	.\autoconf\tea\win\nmakehlp.c	/^list_free(list_item_t **listPtrPtr)$/;"	f	file:
list_insert	.\autoconf\tea\win\nmakehlp.c	/^list_insert(list_item_t **listPtrPtr, const char *key, const char *value)$/;"	f	file:
list_item_t	.\autoconf\tea\win\nmakehlp.c	/^typedef struct list_item_t {$/;"	s	file:
list_item_t	.\autoconf\tea\win\nmakehlp.c	/^} list_item_t;$/;"	t	typeref:struct:list_item_t	file:
listbox_click	.\ext\rtree\viewrtree.tcl	/^proc listbox_click {sel} {$/;"	p
listbox_mouseover	.\ext\rtree\viewrtree.tcl	/^proc listbox_mouseover {i} {$/;"	p
loadAnalysis	.\src\analyze.c	/^static void loadAnalysis(Parse *pParse, int iDb){$/;"	f	file:
loadAndGetChildrenContaining	.\ext\fts2\fts2.c	/^static int loadAndGetChildrenContaining($/;"	f	file:
loadExt	.\src\func.c	/^static void loadExt(sqlite3_context *context, int argc, sqlite3_value **argv){$/;"	f	file:
loadSegment	.\ext\fts2\fts2.c	/^static int loadSegment(fulltext_vtab *v, const char *pData, int nData,$/;"	f	file:
loadSegmentInt	.\ext\fts2\fts2.c	/^static int loadSegmentInt(fulltext_vtab *v, const char *pData, int nData,$/;"	f	file:
loadSegmentLeaf	.\ext\fts2\fts2.c	/^static int loadSegmentLeaf(fulltext_vtab *v, const char *pData, int nData,$/;"	f	file:
loadSegmentLeaves	.\ext\fts2\fts2.c	/^static int loadSegmentLeaves(fulltext_vtab *v,$/;"	f	file:
loadSegmentLeavesInt	.\ext\fts2\fts2.c	/^static int loadSegmentLeavesInt(fulltext_vtab *v, LeavesReader *pReader,$/;"	f	file:
loadStat4	.\src\analyze.c	/^static int loadStat4(sqlite3 *db, const char *zDb){$/;"	f	file:
loadStatTbl	.\src\analyze.c	/^static int loadStatTbl($/;"	f	file:
load_extension	.\src\sqlite3ext.h	/^  int (*load_extension)(sqlite3*,const char*,const char*,char**);$/;"	m	struct:sqlite3_api_routines
load_hierachy	.\ext\fts5\tool\loadfts5.tcl	/^proc load_hierachy {dir} {$/;"	p
loadfile	.\ext\fts5\tool\loadfts5.tcl	/^proc loadfile {f} {$/;"	p
local	.\src\os_win.c	/^  winceLock local;        \/* Locks obtained by this instance of winFile *\/$/;"	m	struct:winFile	file:
localPayload	.\tool\showdb.c	/^static i64 localPayload(i64 nPayload, char cType){$/;"	f	file:
localPayload	.\tool\showwal.c	/^static i64 localPayload(i64 nPayload, char cType){$/;"	f	file:
local_getline	.\src\shell.c	/^static char *local_getline(char *zLine, FILE *in){$/;"	f	file:
local_getline	.\src\tclsqlite.c	/^static char *local_getline(char *zPrompt, FILE *in){$/;"	f	file:
local_ioerr	.\src\os_common.h	/^static void local_ioerr(){$/;"	f
localtime	.\src\os_win.c	/^struct tm *__cdecl localtime(const time_t *t)$/;"	f
localtimeOffset	.\src\date.c	/^static sqlite3_int64 localtimeOffset($/;"	f	file:
locateDatabaseHandle	.\src\test_journal.c	/^static jt_file *locateDatabaseHandle(const char *zJournal){$/;"	f	file:
lock	.\ext\async\sqlite3async.c	/^  AsyncFileLock lock;        \/* Lock state for this handle *\/$/;"	m	struct:AsyncFileData	file:
lock	.\src\btreeInt.h	/^  BtLock lock;       \/* Object used to lock page 1 *\/$/;"	m	struct:Btree
lock	.\test\threadtest1.c	/^pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;$/;"	v
lockBtree	.\src\btree.c	/^static int lockBtree(BtShared *pBt){$/;"	f	file:
lockBtreeMutex	.\src\btmutex.c	/^static void lockBtreeMutex(Btree *p){$/;"	f	file:
lockError	.\src\wal.c	/^  u8 lockError;              \/* True if a locking error has occurred *\/$/;"	m	struct:Wal	file:
lockMask	.\src\vdbeInt.h	/^  yDbMask lockMask;       \/* Subset of btreeMask that requires a lock *\/$/;"	m	struct:Vdbe
lockName	.\src\test_vfstrace.c	/^static const char *lockName(int eLock){$/;"	f	file:
lockProxy	.\src\os_unix.c	/^  unixFile *lockProxy;         \/* Open proxy lock file *\/$/;"	m	struct:proxyLockingContext	file:
lockProxyPath	.\src\os_unix.c	/^  char *lockProxyPath;         \/* Name of the proxy lock file *\/$/;"	m	struct:proxyLockingContext	file:
lockTrace	.\src\os_unix.c	/^static int lockTrace(int fd, int op, struct flock *p){$/;"	f	file:
locked	.\src\btreeInt.h	/^  u8 locked;         \/* True if db currently has pBt locked *\/$/;"	m	struct:Btree
lockingContext	.\src\os_unix.c	/^  void *lockingContext;               \/* Locking style specific state *\/$/;"	m	struct:unixFile	file:
locktype	.\src\os_win.c	/^  u8 locktype;            \/* Type of lock currently held on this file *\/$/;"	m	struct:winFile	file:
log	.\src\sqlite3ext.h	/^  void (*log)(int,const char*,...);$/;"	m	struct:sqlite3_api_routines
logBadConnection	.\src\util.c	/^static void logBadConnection(const char *zType){$/;"	f	file:
logEstAdd	.\tool\logest.c	/^LogEst logEstAdd(LogEst a, LogEst b){$/;"	f
logEstFromDouble	.\tool\logest.c	/^static LogEst logEstFromDouble(double x){$/;"	f	file:
logEstFromInteger	.\tool\logest.c	/^LogEst logEstFromInteger(sqlite3_uint64 x){$/;"	f
logEstMultiply	.\tool\logest.c	/^LogEst logEstMultiply(LogEst a, LogEst b){ return a+b; }$/;"	f
logEstToInt	.\tool\logest.c	/^static sqlite3_uint64 logEstToInt(LogEst x){$/;"	f	file:
logMessage	.\mptest\mptest.c	/^static void logMessage(const char *zFormat, ...){$/;"	f	file:
logcallback	.\src\test1.c	/^} logcallback = {0, 0};$/;"	v	typeref:struct:LogCallback	file:
longestSuffix	.\tool\mkkeywordhash.c	/^  int longestSuffix;   \/* Longest suffix that is a prefix on another word *\/$/;"	m	struct:Keyword	file:
lookahead	.\tool\lemon.c	/^  int lookahead;             \/* Value of the lookahead token *\/$/;"	m	struct:lookahead_action	file:
lookahead_action	.\tool\lemon.c	/^struct lookahead_action {$/;"	s	file:
lookaside	.\src\sqliteInt.h	/^  Lookaside lookaside;          \/* Lookaside malloc configuration *\/$/;"	m	struct:sqlite3
lookaside1	.\test\tt3_lookaside1.c	/^static void lookaside1(int nMs){$/;"	f	file:
lookaside1_thread_reader	.\test\tt3_lookaside1.c	/^static char *lookaside1_thread_reader(int iTid, void *pArg){$/;"	f	file:
lookaside1_thread_writer	.\test\tt3_lookaside1.c	/^static char *lookaside1_thread_writer(int iTid, void *pArg){$/;"	f	file:
lookupName	.\src\resolve.c	/^static int lookupName($/;"	f	file:
lowerFunc	.\src\func.c	/^static void lowerFunc(sqlite3_context *context, int argc, sqlite3_value **argv){$/;"	f	file:
lp	.\src\parse.y	/^lp ::= LP(X).                       {sqlite3VtabArgExtend(pParse,&X);}$/;"	l
lru	.\src\pcache1.c	/^  PgHdr1 lru;                    \/* The beginning and end of the LRU list *\/$/;"	m	struct:PGroup	file:
lru	.\src\sqliteInt.h	/^    int lru;              \/* Least recently used entry has the smallest value *\/$/;"	m	struct:Parse::yColCache
lseek	.\src\os_unix.c	312;"	d	file:
m	.\src\date.c	/^  int h, m;          \/* Hour and minutes *\/$/;"	m	struct:DateTime	file:
m	.\src\sqliteInt.h	/^  sqlite3_mem_methods m;            \/* Low-level memory allocation interface *\/$/;"	m	struct:Sqlite3Config
m	.\src\test_malloc.c	/^  sqlite3_mem_methods m;  \/* 'Real' malloc implementation *\/$/;"	m	struct:MemFault	file:
m	.\src\test_mutex.c	/^  sqlite3_mutex_methods m;   \/* Interface to "real" mutex system *\/$/;"	m	struct:test_mutex_globals	file:
mLock	.\ext\rbu\sqlite3rbu.c	/^  u32 mLock;$/;"	m	struct:sqlite3rbu	file:
mPragFlag	.\src\pragma.h	/^  u8 mPragFlag;             \/* Zero or more PragFlag_XXX values *\/$/;"	m	struct:sPragmaNames
m_eq_1	.\ext\fts1\fts1_porter.c	/^static int m_eq_1(const char *z){$/;"	f	file:
m_eq_1	.\ext\fts2\fts2_porter.c	/^static int m_eq_1(const char *z){$/;"	f	file:
m_eq_1	.\ext\fts3\fts3_porter.c	/^static int m_eq_1(const char *z){$/;"	f	file:
m_gt_0	.\ext\fts1\fts1_porter.c	/^static int m_gt_0(const char *z){$/;"	f	file:
m_gt_0	.\ext\fts2\fts2_porter.c	/^static int m_gt_0(const char *z){$/;"	f	file:
m_gt_0	.\ext\fts3\fts3_porter.c	/^static int m_gt_0(const char *z){$/;"	f	file:
m_gt_1	.\ext\fts1\fts1_porter.c	/^static int m_gt_1(const char *z){$/;"	f	file:
m_gt_1	.\ext\fts2\fts2_porter.c	/^static int m_gt_1(const char *z){$/;"	f	file:
m_gt_1	.\ext\fts3\fts3_porter.c	/^static int m_gt_1(const char *z){$/;"	f	file:
magic	.\ext\rtree\rtree.c	/^  u32 magic;                  \/* Always RTREE_GEOMETRY_MAGIC *\/$/;"	m	struct:RtreeMatchArg	file:
magic	.\src\sqliteInt.h	/^  u32 magic;                    \/* Magic number for detect library misuse *\/$/;"	m	struct:sqlite3
magic	.\src\vdbeInt.h	/^  u32 magic;              \/* Magic number for sanity checking *\/$/;"	m	struct:Vdbe
magic1	.\src\os_win.c	/^  u32 magic1;   \/* Magic number to detect structure corruption. *\/$/;"	m	struct:winMemData	file:
magic2	.\src\os_win.c	/^  u32 magic2;   \/* Magic number to detect structure corruption. *\/$/;"	m	struct:winMemData	file:
main	.\autoconf\tea\win\nmakehlp.c	/^main($/;"	f
main	.\ext\fts3\tool\fts3view.c	/^int main(int argc, char **argv){$/;"	f
main	.\ext\fts5\extract_api_docs.tcl	/^proc main {data} {$/;"	p
main	.\ext\rbu\rbu.c	/^int main(int argc, char **argv){$/;"	f
main	.\mptest\mptest.c	/^int SQLITE_CDECL main(int argc, char **argv){$/;"	f
main	.\src\shell.c	/^int SQLITE_CDECL main(int argc, char **argv){$/;"	f
main	.\test\crashtest1.c	/^int main(int argc, char **argv){$/;"	f
main	.\test\fuzzcheck.c	/^int main(int argc, char **argv){$/;"	f
main	.\test\releasetest.tcl	/^proc main {argv} {$/;"	p
main	.\test\speedtest1.c	/^int main(int argc, char **argv){$/;"	f
main	.\test\threadtest1.c	/^int main(int argc, char **argv){$/;"	f
main	.\test\threadtest2.c	/^int main(int argc, char **argv){$/;"	f
main	.\test\threadtest3.c	/^int main(int argc, char **argv){$/;"	f
main	.\test\threadtest4.c	/^int main(int argc, char **argv){$/;"	f
main	.\test\wordcount.c	/^int main(int argc, char **argv){$/;"	f
main	.\tool\checkSpacing.c	/^int main(int argc, char **argv){$/;"	f
main	.\tool\extract.c	/^int main(int argc, char **argv){$/;"	f
main	.\tool\fast_vacuum.c	/^int main(int argc, char **argv){$/;"	f
main	.\tool\fuzzershell.c	/^int main(int argc, char **argv){$/;"	f
main	.\tool\getlock.c	/^int main(int argc, char **argv){$/;"	f
main	.\tool\lemon.c	/^int main(int argc, char **argv)$/;"	f
main	.\tool\loadfts.c	/^int main(int argc, char **argv){$/;"	f
main	.\tool\logest.c	/^int main(int argc, char **argv){$/;"	f
main	.\tool\mkkeywordhash.c	/^int main(int argc, char **argv){$/;"	f
main	.\tool\offsets.c	/^int main(int argc, char **argv){$/;"	f
main	.\tool\omittest.tcl	/^proc main {argv} {$/;"	p
main	.\tool\pagesig.c	/^int main(int argc, char **argv){$/;"	f
main	.\tool\rollback-test.c	/^int main(int argc, char **argv){$/;"	f
main	.\tool\showdb.c	/^int main(int argc, char **argv){$/;"	f
main	.\tool\showjournal.c	/^int main(int argc, char **argv){$/;"	f
main	.\tool\showlocks.c	/^int main(int argc, char **argv){$/;"	f
main	.\tool\showstat4.c	/^int main(int argc, char **argv){$/;"	f
main	.\tool\showwal.c	/^int main(int argc, char **argv){$/;"	f
main	.\tool\speedtest16.c	/^int main(int argc, char **argv){$/;"	f
main	.\tool\speedtest8.c	/^int main(int argc, char **argv){$/;"	f
main	.\tool\speedtest8inst1.c	/^int main(int argc, char **argv){$/;"	f
main	.\tool\sqldiff.c	/^int main(int argc, char **argv){$/;"	f
main	.\tool\varint.c	/^int main(int argc, char **argv){$/;"	f
mainDb	.\test\threadtest4.c	/^  sqlite3 *mainDb;            \/* Database connection of the main thread *\/$/;"	m	struct:WorkerInfo	file:
mainPrompt	.\src\shell.c	/^static char mainPrompt[20];     \/* First line prompt. default: "sqlite> "*\/$/;"	v	file:
main_init	.\src\shell.c	/^static void main_init(ShellState *data) {$/;"	f	file:
major	.\src\lempar.c	/^  YYCODETYPE major;      \/* The major token value.  This is the code$/;"	m	struct:yyStackEntry	file:
major	.\tool\lempar.c	/^  YYCODETYPE major;      \/* The major token value.  This is the code$/;"	m	struct:yyStackEntry	file:
makeCommand	.\test\releasetest.tcl	/^proc makeCommand { targets cflags opts } {$/;"	p
make_test_case	.\test\randexpr1.tcl	/^proc make_test_case {sql result} {$/;"	p
maketest	.\test\boundary4.tcl	/^proc maketest {tnum sql answer} {$/;"	p
malloc	.\src\sqlite3ext.h	/^  void *(*malloc)(int);$/;"	m	struct:sqlite3_api_routines
malloc64	.\src\sqlite3ext.h	/^  void *(*malloc64)(sqlite3_uint64);$/;"	m	struct:sqlite3_api_routines
mallocFailed	.\ext\misc\nextchar.c	/^  int mallocFailed;                 \/* True if malloc fails *\/$/;"	m	struct:nextCharContext	file:
mallocFailed	.\src\btreeInt.h	/^  int mallocFailed; \/* A memory allocation error has occurred *\/$/;"	m	struct:IntegrityCk
mallocFailed	.\src\sqliteInt.h	/^  u8 mallocFailed;              \/* True if we have seen a malloc failure *\/$/;"	m	struct:sqlite3
mallocLogEnabled	.\src\test_malloc.c	/^static int mallocLogEnabled = 0;$/;"	v	file:
mallocWithAlarm	.\src\malloc.c	/^static int mallocWithAlarm(int n, void **pp){$/;"	f	file:
malloc_and_zero	.\ext\fts1\ft_hash.c	/^void *malloc_and_zero(int n){$/;"	f
malloc_and_zero	.\ext\fts1\fts1_hash.c	/^static void *malloc_and_zero(int n){$/;"	f	file:
markTermAsChild	.\src\whereexpr.c	/^static void markTermAsChild(WhereClause *pWC, int iChild, int iParent){$/;"	f	file:
mask	.\src\test_vfs.c	/^  int mask;                       \/* Mask controlling [script] and [ioerr] *\/$/;"	m	struct:Testvfs	file:
mask	.\tool\mkkeywordhash.c	/^  int mask;            \/* Code this keyword if non-zero *\/$/;"	m	struct:Keyword	file:
maskLoop	.\src\whereInt.h	/^  Bitmask maskLoop;     \/* Bitmask of all WhereLoop objects in this path *\/$/;"	m	struct:WherePath
maskPage	.\src\btreeInt.h	/^  u16 maskPage;        \/* Mask for page offset *\/$/;"	m	struct:MemPage
maskSelf	.\src\whereInt.h	/^  Bitmask maskSelf;     \/* Bitmask identifying table iTab *\/$/;"	m	struct:WhereLoop
maskUsed	.\src\vdbeInt.h	/^  u64 maskUsed;         \/* Mask of columns used by this cursor *\/$/;"	m	struct:VdbeCursor
matchAll	.\src\func.c	/^  u8 matchAll;$/;"	m	struct:compareInfo	file:
matchFrom	.\ext\misc\spellfix.c	/^static int matchFrom(EditDist3Cost *p, const char *z, int n){$/;"	f	file:
matchFromTo	.\ext\misc\spellfix.c	/^static int matchFromTo($/;"	f	file:
matchOne	.\src\func.c	/^  u8 matchOne;$/;"	m	struct:compareInfo	file:
matchQuality	.\src\callback.c	/^static int matchQuality($/;"	f	file:
matchSet	.\src\func.c	/^  u8 matchSet;$/;"	m	struct:compareInfo	file:
matchTo	.\ext\misc\spellfix.c	/^static int matchTo(EditDist3Cost *p, const char *z, int n){$/;"	f	file:
max1bytePayload	.\src\btreeInt.h	/^  u8 max1bytePayload;   \/* Maximum first byte of cell for a 1-byte payload *\/$/;"	m	struct:BtShared
max1bytePayload	.\src\btreeInt.h	/^  u8 max1bytePayload;  \/* min(maxLocal,127) *\/$/;"	m	struct:MemPage
maxCount	.\src\mem5.c	/^  u32 maxCount;       \/* Maximum instantaneous currentCount *\/$/;"	m	struct:Mem5Global	file:
maxLeaf	.\src\btreeInt.h	/^  u16 maxLeaf;          \/* Maximum local payload in a LEAFDATA table *\/$/;"	m	struct:BtShared
maxLocal	.\src\btreeInt.h	/^  u16 maxLocal;         \/* Maximum local payload in non-LEAFDATA tables *\/$/;"	m	struct:BtShared
maxLocal	.\src\btreeInt.h	/^  u16 maxLocal;        \/* Copy of BtShared.maxLocal or BtShared.maxLeaf *\/$/;"	m	struct:MemPage
maxOut	.\src\mem5.c	/^  u32 maxOut;         \/* Maximum instantaneous currentOut *\/$/;"	m	struct:Mem5Global	file:
maxRequest	.\src\mem5.c	/^  u32 maxRequest;     \/* Largest allocation (exclusive of internal frag) *\/$/;"	m	struct:Mem5Global	file:
maxStmt	.\src\tclsqlite.c	/^  int maxStmt;               \/* The next maximum number of stmtList *\/$/;"	m	struct:SqliteDb	file:
mayAbort	.\src\sqliteInt.h	/^  u8 mayAbort;         \/* True if statement may throw an ABORT exception *\/$/;"	m	struct:Parse
maybeClose	.\mptest\mptest.c	/^static void maybeClose(FILE *pOut){$/;"	f	file:
md5_cmd	.\src\tclsqlite.c	/^static int md5_cmd(void*cd, Tcl_Interp *interp, int argc, const char **argv){$/;"	f	file:
md5file_cmd	.\src\tclsqlite.c	/^static int md5file_cmd(void*cd, Tcl_Interp*interp, int argc, const char **argv){$/;"	f	file:
md5finalize	.\src\tclsqlite.c	/^static void md5finalize(sqlite3_context *context){$/;"	f	file:
md5finalize	.\test\threadtest3.c	/^static void md5finalize(sqlite3_context *context){$/;"	f	file:
md5step	.\src\tclsqlite.c	/^static void md5step(sqlite3_context *context, int argc, sqlite3_value **argv){$/;"	f	file:
md5step	.\test\threadtest3.c	/^static void md5step(sqlite3_context *context, int argc, sqlite3_value **argv){$/;"	f	file:
measureAllocationSize	.\src\malloc.c	/^static SQLITE_NOINLINE void measureAllocationSize(sqlite3 *db, void *p){$/;"	f	file:
mem	.\src\mem2.c	/^} mem;$/;"	v	typeref:struct:__anon10	file:
mem	.\src\test_init.c	/^  sqlite3_mem_methods     mem;$/;"	m	struct:Wrapped	file:
mem0	.\src\malloc.c	/^} mem0 = { 0, 0, 0, 0, 0, 0 };$/;"	v	typeref:struct:Mem0Global	file:
mem0	.\src\malloc.c	67;"	d	file:
mem3	.\src\mem3.c	/^} mem3 = { 97535575 };$/;"	v	typeref:struct:Mem3Global	file:
mem3	.\src\mem3.c	141;"	d	file:
mem5	.\src\mem5.c	/^} mem5;$/;"	v	typeref:struct:Mem5Global	file:
mem5	.\src\mem5.c	135;"	d	file:
memAboutToChange	.\src\vdbe.c	34;"	d	file:
memAboutToChange	.\src\vdbe.c	36;"	d	file:
memDb	.\src\pager.c	/^  u8 memDb;                   \/* True to inhibit all file I\/O *\/$/;"	m	struct:Pager	file:
memIsValid	.\src\vdbeInt.h	251;"	d
memTracePrint	.\src\vdbe.c	/^static void memTracePrint(Mem *p){$/;"	f	file:
mem_fail	.\src\test_init.c	/^  int mem_fail;                \/* True to fail mem subsystem inialization *\/$/;"	m	struct:Wrapped	file:
mem_init	.\src\test_init.c	/^  int mem_init;                \/* True if mem subsystem is initalized *\/$/;"	m	struct:Wrapped	file:
memdbsql	.\test\tester.tcl	/^proc memdbsql {sql} {$/;"	p
memdebug_log_sql	.\test\tester.tcl	/^proc memdebug_log_sql {{filename mallocs.sql}} {$/;"	p
memfault	.\src\test_malloc.c	/^} memfault;$/;"	v	typeref:struct:MemFault	file:
memjrnlClose	.\src\memjournal.c	/^static int memjrnlClose(sqlite3_file *pJfd){$/;"	f	file:
memjrnlFileSize	.\src\memjournal.c	/^static int memjrnlFileSize(sqlite3_file *pJfd, sqlite_int64 *pSize){$/;"	f	file:
memjrnlRead	.\src\memjournal.c	/^static int memjrnlRead($/;"	f	file:
memjrnlSync	.\src\memjournal.c	/^static int memjrnlSync(sqlite3_file *NotUsed, int NotUsed2){$/;"	f	file:
memjrnlTruncate	.\src\memjournal.c	/^static int memjrnlTruncate(sqlite3_file *pJfd, sqlite_int64 size){$/;"	f	file:
memjrnlWrite	.\src\memjournal.c	/^static int memjrnlWrite($/;"	f	file:
memory_error	.\tool\lemon.c	/^void memory_error(){$/;"	f
memory_highwater	.\src\sqlite3ext.h	/^  sqlite3_int64 (*memory_highwater)(int);$/;"	m	struct:sqlite3_api_routines
memory_used	.\src\sqlite3ext.h	/^  sqlite3_int64 (*memory_used)(void);$/;"	m	struct:sqlite3_api_routines
memsys3Checkout	.\src\mem3.c	/^static void *memsys3Checkout(u32 i, u32 nBlock){$/;"	f	file:
memsys3Enter	.\src\mem3.c	/^static void memsys3Enter(void){$/;"	f	file:
memsys3Free	.\src\mem3.c	/^static void memsys3Free(void *pPrior){$/;"	f	file:
memsys3FreeUnsafe	.\src\mem3.c	/^static void memsys3FreeUnsafe(void *pOld){$/;"	f	file:
memsys3FromMaster	.\src\mem3.c	/^static void *memsys3FromMaster(u32 nBlock){$/;"	f	file:
memsys3Init	.\src\mem3.c	/^static int memsys3Init(void *NotUsed){$/;"	f	file:
memsys3Leave	.\src\mem3.c	/^static void memsys3Leave(void){$/;"	f	file:
memsys3Link	.\src\mem3.c	/^static void memsys3Link(u32 i){$/;"	f	file:
memsys3LinkIntoList	.\src\mem3.c	/^static void memsys3LinkIntoList(u32 i, u32 *pRoot){$/;"	f	file:
memsys3Malloc	.\src\mem3.c	/^static void *memsys3Malloc(int nBytes){$/;"	f	file:
memsys3MallocUnsafe	.\src\mem3.c	/^static void *memsys3MallocUnsafe(int nByte){$/;"	f	file:
memsys3Merge	.\src\mem3.c	/^static void memsys3Merge(u32 *pRoot){$/;"	f	file:
memsys3OutOfMemory	.\src\mem3.c	/^static void memsys3OutOfMemory(int nByte){$/;"	f	file:
memsys3Realloc	.\src\mem3.c	/^static void *memsys3Realloc(void *pPrior, int nBytes){$/;"	f	file:
memsys3Roundup	.\src\mem3.c	/^static int memsys3Roundup(int n){$/;"	f	file:
memsys3Shutdown	.\src\mem3.c	/^static void memsys3Shutdown(void *NotUsed){$/;"	f	file:
memsys3Size	.\src\mem3.c	/^static int memsys3Size(void *p){$/;"	f	file:
memsys3Unlink	.\src\mem3.c	/^static void memsys3Unlink(u32 i){$/;"	f	file:
memsys3UnlinkFromList	.\src\mem3.c	/^static void memsys3UnlinkFromList(u32 i, u32 *pRoot){$/;"	f	file:
memsys5Enter	.\src\mem5.c	/^static void memsys5Enter(void){$/;"	f	file:
memsys5Free	.\src\mem5.c	/^static void memsys5Free(void *pPrior){$/;"	f	file:
memsys5FreeUnsafe	.\src\mem5.c	/^static void memsys5FreeUnsafe(void *pOld){$/;"	f	file:
memsys5Init	.\src\mem5.c	/^static int memsys5Init(void *NotUsed){$/;"	f	file:
memsys5Leave	.\src\mem5.c	/^static void memsys5Leave(void){$/;"	f	file:
memsys5Link	.\src\mem5.c	/^static void memsys5Link(int i, int iLogsize){$/;"	f	file:
memsys5Log	.\src\mem5.c	/^static int memsys5Log(int iValue){$/;"	f	file:
memsys5Malloc	.\src\mem5.c	/^static void *memsys5Malloc(int nBytes){$/;"	f	file:
memsys5MallocUnsafe	.\src\mem5.c	/^static void *memsys5MallocUnsafe(int nByte){$/;"	f	file:
memsys5Realloc	.\src\mem5.c	/^static void *memsys5Realloc(void *pPrior, int nBytes){$/;"	f	file:
memsys5Roundup	.\src\mem5.c	/^static int memsys5Roundup(int n){$/;"	f	file:
memsys5Shutdown	.\src\mem5.c	/^static void memsys5Shutdown(void *NotUsed){$/;"	f	file:
memsys5Size	.\src\mem5.c	/^static int memsys5Size(void *p){$/;"	f	file:
memsys5Unlink	.\src\mem5.c	/^static void memsys5Unlink(int i, int iLogsize){$/;"	f	file:
merge	.\tool\lemon.c	/^static char *merge($/;"	f	file:
mergeBlock	.\ext\fts1\fulltext.c	/^static void mergeBlock(DocListMerge *m, DocList *pBlock){$/;"	f	file:
mergeInit	.\ext\fts1\fulltext.c	/^static void mergeInit(DocListMerge *m,$/;"	f	file:
mergePosList	.\ext\fts1\fts1.c	/^static void mergePosList($/;"	f	file:
mergePosList	.\ext\fts1\fulltext.c	/^static void mergePosList(DocListMerge *m, sqlite_int64 iDocid,$/;"	f	file:
message	.\tool\lemon.c	/^  const char *message;$/;"	m	struct:s_options	file:
midClass	.\ext\misc\spellfix.c	/^static const unsigned char midClass[] = {$/;"	v	file:
minFrame	.\src\wal.c	/^  u32 minFrame;              \/* Ignore wal frames before this one *\/$/;"	m	struct:Wal	file:
minLeaf	.\src\btreeInt.h	/^  u16 minLeaf;          \/* Minimum local payload in a LEAFDATA table *\/$/;"	m	struct:BtShared
minLocal	.\src\btreeInt.h	/^  u16 minLocal;         \/* Minimum local payload in non-LEAFDATA tables *\/$/;"	m	struct:BtShared
minLocal	.\src\btreeInt.h	/^  u16 minLocal;        \/* Copy of BtShared.minLocal or BtShared.minLeaf *\/$/;"	m	struct:MemPage
minMaxFinalize	.\src\func.c	/^static void minMaxFinalize(sqlite3_context *context){$/;"	f	file:
minMaxQuery	.\src\select.c	/^static u8 minMaxQuery(AggInfo *pAggInfo, ExprList **ppMinMax){$/;"	f	file:
minWriteFileFormat	.\src\vdbeInt.h	/^  u8 minWriteFileFormat;  \/* Minimum file format for writable database files *\/$/;"	m	struct:Vdbe
minimum_size_type	.\tool\lemon.c	/^static const char *minimum_size_type(int lwr, int upr, int *pnByte){$/;"	f	file:
minmaxFunc	.\src\func.c	/^static void minmaxFunc($/;"	f	file:
minmaxStep	.\src\func.c	/^static void minmaxStep($/;"	f	file:
minor	.\src\lempar.c	/^  YYMINORTYPE minor;     \/* The user-supplied minor token value.  This$/;"	m	struct:yyStackEntry	file:
minor	.\tool\lempar.c	/^  YYMINORTYPE minor;     \/* The user-supplied minor token value.  This$/;"	m	struct:yyStackEntry	file:
mmapSize	.\src\os_unix.c	/^  sqlite3_int64 mmapSize;             \/* Usable size of mapping at pMapRegion *\/$/;"	m	struct:unixFile	file:
mmapSize	.\src\os_win.c	/^  sqlite3_int64 mmapSize;       \/* Usable size of mapped region *\/$/;"	m	struct:winFile	file:
mmapSizeActual	.\src\os_unix.c	/^  sqlite3_int64 mmapSizeActual;       \/* Actual size of mapping at pMapRegion *\/$/;"	m	struct:unixFile	file:
mmapSizeActual	.\src\os_win.c	/^  sqlite3_int64 mmapSizeActual; \/* Actual size of mapped region *\/$/;"	m	struct:winFile	file:
mmapSizeMax	.\src\os_unix.c	/^  sqlite3_int64 mmapSizeMax;          \/* Configured FCNTL_MMAP_SIZE value *\/$/;"	m	struct:unixFile	file:
mmapSizeMax	.\src\os_win.c	/^  sqlite3_int64 mmapSizeMax;    \/* Configured FCNTL_MMAP_SIZE value *\/$/;"	m	struct:winFile	file:
mnAction	.\tool\lemon.c	/^  int mnAction;                \/* Action associated with mnLookahead *\/$/;"	m	struct:acttab	file:
mnLookahead	.\tool\lemon.c	/^  int mnLookahead;             \/* Minimum aLookahead[].lookahead *\/$/;"	m	struct:acttab	file:
mnMaster	.\src\mem3.c	/^  u32 mnMaster;$/;"	m	struct:Mem3Global	file:
mnPmaSize	.\src\vdbesort.c	/^  int mnPmaSize;                  \/* Minimum PMA size, in bytes *\/$/;"	m	struct:VdbeSorter	file:
mnReg	.\src\sqliteInt.h	/^  int mnReg, mxReg;       \/* Range of registers allocated for aCol and aFunc *\/$/;"	m	struct:AggInfo
mnReq	.\src\sqliteInt.h	/^  int mnReq, mxReq;                 \/* Min and max heap requests sizes *\/$/;"	m	struct:Sqlite3Config
mnValue	.\ext\misc\series.c	/^  sqlite3_int64 mnValue;     \/* Mimimum value ("start") *\/$/;"	m	struct:series_cursor	file:
mode	.\src\shell.c	/^  int mode;              \/* An output mode setting *\/$/;"	m	struct:ShellState	file:
mode	.\src\shell.c	/^  int mode;           \/* Mode prior to ".explain on" *\/$/;"	m	struct:SavedModeInfo	file:
modeDescr	.\src\shell.c	/^static const char *modeDescr[] = {$/;"	v	file:
modifyPagePointer	.\src\btree.c	/^static int modifyPagePointer(MemPage *pPage, Pgno iFrom, Pgno iTo, u8 eType){$/;"	f	file:
moduleDestroy	.\src\test8.c	/^static void moduleDestroy(void *p){$/;"	f	file:
moveToChild	.\src\btree.c	/^static int moveToChild(BtCursor *pCur, u32 newPgno){$/;"	f	file:
moveToLeftmost	.\src\btree.c	/^static int moveToLeftmost(BtCursor *pCur){$/;"	f	file:
moveToParent	.\src\btree.c	/^static void moveToParent(BtCursor *pCur){$/;"	f	file:
moveToRightmost	.\src\btree.c	/^static int moveToRightmost(BtCursor *pCur){$/;"	f	file:
moveToRoot	.\src\btree.c	/^static int moveToRoot(BtCursor *pCur){$/;"	f	file:
movetoTarget	.\src\vdbeInt.h	/^  i64 movetoTarget;     \/* Argument to the deferred sqlite3BtreeMoveto() *\/$/;"	m	struct:VdbeCursor
mprintf	.\src\sqlite3ext.h	/^  char * (*mprintf)(const char*,...);$/;"	m	struct:sqlite3_api_routines
msize	.\src\sqlite3ext.h	/^  sqlite3_uint64 (*msize)(void*);$/;"	m	struct:sqlite3_api_routines
msort	.\tool\lemon.c	/^static char *msort($/;"	f	file:
multiSelect	.\src\select.c	/^static int multiSelect($/;"	f	file:
multiSelectCollSeq	.\src\select.c	/^static CollSeq *multiSelectCollSeq(Parse *pParse, Select *p, int iCol){$/;"	f	file:
multiSelectOrderBy	.\src\select.c	/^static int multiSelectOrderBy($/;"	f	file:
multiSelectOrderByKeyInfo	.\src\select.c	/^static KeyInfo *multiSelectOrderByKeyInfo(Parse *pParse, Select *p, int nExtra){$/;"	f	file:
multiSelectValues	.\src\select.c	/^static int multiSelectValues($/;"	f	file:
multiplexAccess	.\src\test_multiplex.c	/^static int multiplexAccess(sqlite3_vfs *a, const char *b, int c, int *d){$/;"	f	file:
multiplexCheckReservedLock	.\src\test_multiplex.c	/^static int multiplexCheckReservedLock(sqlite3_file *pConn, int *pResOut){$/;"	f	file:
multiplexClose	.\src\test_multiplex.c	/^static int multiplexClose(sqlite3_file *pConn){$/;"	f	file:
multiplexConn	.\src\test_multiplex.c	/^struct multiplexConn {$/;"	s	file:
multiplexConn	.\src\test_multiplex.c	/^typedef struct multiplexConn multiplexConn;$/;"	t	typeref:struct:multiplexConn	file:
multiplexControlFunc	.\src\test_multiplex.c	/^static void multiplexControlFunc($/;"	f	file:
multiplexCurrentTime	.\src\test_multiplex.c	/^static int multiplexCurrentTime(sqlite3_vfs *a, double *b){$/;"	f	file:
multiplexCurrentTimeInt64	.\src\test_multiplex.c	/^static int multiplexCurrentTimeInt64(sqlite3_vfs *a, sqlite3_int64 *b){$/;"	f	file:
multiplexDelete	.\src\test_multiplex.c	/^static int multiplexDelete($/;"	f	file:
multiplexDeviceCharacteristics	.\src\test_multiplex.c	/^static int multiplexDeviceCharacteristics(sqlite3_file *pConn){$/;"	f	file:
multiplexDlClose	.\src\test_multiplex.c	/^static void multiplexDlClose(sqlite3_vfs *a, void *b){$/;"	f	file:
multiplexDlError	.\src\test_multiplex.c	/^static void multiplexDlError(sqlite3_vfs *a, int b, char *c){$/;"	f	file:
multiplexDlOpen	.\src\test_multiplex.c	/^static void *multiplexDlOpen(sqlite3_vfs *a, const char *b){$/;"	f	file:
multiplexDlSym	.\src\test_multiplex.c	/^static void (*multiplexDlSym(sqlite3_vfs *a, void *b, const char *c))(void){$/;"	f	file:
multiplexEnter	.\src\test_multiplex.c	/^static void multiplexEnter(void){ sqlite3_mutex_enter(gMultiplex.pMutex); }$/;"	f	file:
multiplexFileControl	.\src\test_multiplex.c	/^static int multiplexFileControl(sqlite3_file *pConn, int op, void *pArg){$/;"	f	file:
multiplexFileSize	.\src\test_multiplex.c	/^static int multiplexFileSize(sqlite3_file *pConn, sqlite3_int64 *pSize){$/;"	f	file:
multiplexFilename	.\src\test_multiplex.c	/^static void multiplexFilename($/;"	f	file:
multiplexFreeComponents	.\src\test_multiplex.c	/^static void multiplexFreeComponents(multiplexGroup *pGroup){$/;"	f	file:
multiplexFullPathname	.\src\test_multiplex.c	/^static int multiplexFullPathname(sqlite3_vfs *a, const char *b, int c, char *d){$/;"	f	file:
multiplexFuncInit	.\src\test_multiplex.c	/^static int multiplexFuncInit($/;"	f	file:
multiplexGetLastError	.\src\test_multiplex.c	/^static int multiplexGetLastError(sqlite3_vfs *a, int b, char *c){$/;"	f	file:
multiplexGroup	.\src\test_multiplex.c	/^struct multiplexGroup {$/;"	s	file:
multiplexGroup	.\src\test_multiplex.c	/^typedef struct multiplexGroup multiplexGroup;$/;"	t	typeref:struct:multiplexGroup	file:
multiplexLeave	.\src\test_multiplex.c	/^static void multiplexLeave(void){ sqlite3_mutex_leave(gMultiplex.pMutex); }$/;"	f	file:
multiplexLock	.\src\test_multiplex.c	/^static int multiplexLock(sqlite3_file *pConn, int lock){$/;"	f	file:
multiplexOpen	.\src\test_multiplex.c	/^static int multiplexOpen($/;"	f	file:
multiplexRandomness	.\src\test_multiplex.c	/^static int multiplexRandomness(sqlite3_vfs *a, int b, char *c){$/;"	f	file:
multiplexRead	.\src\test_multiplex.c	/^static int multiplexRead($/;"	f	file:
multiplexReal	.\src\test_multiplex.c	/^  struct multiplexReal {           \/* For each chunk *\/$/;"	s	struct:multiplexGroup	file:
multiplexSectorSize	.\src\test_multiplex.c	/^static int multiplexSectorSize(sqlite3_file *pConn){$/;"	f	file:
multiplexShmBarrier	.\src\test_multiplex.c	/^static void multiplexShmBarrier(sqlite3_file *pConn){$/;"	f	file:
multiplexShmLock	.\src\test_multiplex.c	/^static int multiplexShmLock($/;"	f	file:
multiplexShmMap	.\src\test_multiplex.c	/^static int multiplexShmMap($/;"	f	file:
multiplexShmUnmap	.\src\test_multiplex.c	/^static int multiplexShmUnmap(sqlite3_file *pConn, int deleteFlag){$/;"	f	file:
multiplexSleep	.\src\test_multiplex.c	/^static int multiplexSleep(sqlite3_vfs *a, int b){$/;"	f	file:
multiplexStrlen30	.\src\test_multiplex.c	/^static int multiplexStrlen30(const char *z){$/;"	f	file:
multiplexSubClose	.\src\test_multiplex.c	/^static void multiplexSubClose($/;"	f	file:
multiplexSubFilename	.\src\test_multiplex.c	/^static int multiplexSubFilename(multiplexGroup *pGroup, int iChunk){$/;"	f	file:
multiplexSubOpen	.\src\test_multiplex.c	/^static sqlite3_file *multiplexSubOpen($/;"	f	file:
multiplexSubSize	.\src\test_multiplex.c	/^static sqlite3_int64 multiplexSubSize($/;"	f	file:
multiplexSync	.\src\test_multiplex.c	/^static int multiplexSync(sqlite3_file *pConn, int flags){$/;"	f	file:
multiplexTruncate	.\src\test_multiplex.c	/^static int multiplexTruncate(sqlite3_file *pConn, sqlite3_int64 size){$/;"	f	file:
multiplexUnlock	.\src\test_multiplex.c	/^static int multiplexUnlock(sqlite3_file *pConn, int lock){$/;"	f	file:
multiplexWrite	.\src\test_multiplex.c	/^static int multiplexWrite($/;"	f	file:
mutex	.\ext\rbu\sqlite3rbu.c	/^  sqlite3_mutex *mutex;           \/* Mutex to protect pMain *\/$/;"	m	struct:rbu_vfs	file:
mutex	.\src\btreeInt.h	/^  sqlite3_mutex *mutex; \/* Non-recursive mutex required to access this object *\/$/;"	m	struct:BtShared
mutex	.\src\malloc.c	/^  sqlite3_mutex *mutex;         \/* Mutex to serialize access *\/$/;"	m	struct:Mem0Global	file:
mutex	.\src\mem2.c	/^  sqlite3_mutex *mutex;$/;"	m	struct:__anon10	file:
mutex	.\src\mem3.c	/^  sqlite3_mutex *mutex;$/;"	m	struct:Mem3Global	file:
mutex	.\src\mem5.c	/^  sqlite3_mutex *mutex;$/;"	m	struct:Mem5Global	file:
mutex	.\src\mutex_unix.c	/^  pthread_mutex_t mutex;     \/* Mutex controlling the lock *\/$/;"	m	struct:sqlite3_mutex	file:
mutex	.\src\mutex_w32.c	/^  CRITICAL_SECTION mutex;    \/* Mutex controlling the lock *\/$/;"	m	struct:sqlite3_mutex	file:
mutex	.\src\os_unix.c	/^  sqlite3_mutex *mutex;      \/* Mutex to access this object *\/$/;"	m	struct:unixShmNode	file:
mutex	.\src\os_win.c	/^  sqlite3_mutex *mutex;      \/* Mutex to access this object *\/$/;"	m	struct:winShmNode	file:
mutex	.\src\pcache1.c	/^  sqlite3_mutex *mutex;          \/* MUTEX_STATIC_LRU or NULL *\/$/;"	m	struct:PGroup	file:
mutex	.\src\pcache1.c	/^  sqlite3_mutex *mutex;          \/* Mutex for accessing the following: *\/$/;"	m	struct:PCacheGlobal	file:
mutex	.\src\sqliteInt.h	/^  sqlite3_mutex *mutex;         \/* Connection mutex *\/$/;"	m	struct:sqlite3
mutex	.\src\sqliteInt.h	/^  sqlite3_mutex_methods mutex;      \/* Low-level mutex interface *\/$/;"	m	struct:Sqlite3Config
mutex	.\src\test_init.c	/^  sqlite3_mutex_methods   mutex;$/;"	m	struct:Wrapped	file:
mutex	.\src\test_sqllog.c	/^  sqlite3_mutex *mutex;           \/* Recursive mutex *\/$/;"	m	struct:SLGlobal	file:
mutex	.\src\test_thread.c	/^  pthread_mutex_t mutex;             \/* Mutex to protect structure *\/$/;"	m	struct:UnlockNotification	file:
mutexIsInit	.\src\mutex.c	/^static SQLITE_WSD int mutexIsInit = 0;$/;"	v	file:
mutex_alloc	.\src\sqlite3ext.h	/^  sqlite3_mutex *(*mutex_alloc)(int);$/;"	m	struct:sqlite3_api_routines
mutex_enter	.\src\sqlite3ext.h	/^  void (*mutex_enter)(sqlite3_mutex*);$/;"	m	struct:sqlite3_api_routines
mutex_fail	.\src\test_init.c	/^  int mutex_fail;              \/* True to fail mutex subsystem inialization *\/$/;"	m	struct:Wrapped	file:
mutex_free	.\src\sqlite3ext.h	/^  void (*mutex_free)(sqlite3_mutex*);$/;"	m	struct:sqlite3_api_routines
mutex_held	.\ext\async\sqlite3async.c	254;"	d	file:
mutex_held	.\ext\async\sqlite3async.c	320;"	d	file:
mutex_init	.\src\test_init.c	/^  int mutex_init;              \/* True if mutex subsystem is initalized *\/$/;"	m	struct:Wrapped	file:
mutex_leave	.\src\sqlite3ext.h	/^  void (*mutex_leave)(sqlite3_mutex*);$/;"	m	struct:sqlite3_api_routines
mutex_try	.\src\sqlite3ext.h	/^  int (*mutex_try)(sqlite3_mutex*);$/;"	m	struct:sqlite3_api_routines
mx	.\ext\misc\regexp.c	/^  int mx;                  \/* EOF when i>=mx *\/$/;"	m	struct:ReInput	file:
mxAlloc	.\src\sqliteInt.h	/^  int  mxAlloc;        \/* Maximum allowed allocation.  0 for no malloc usage *\/$/;"	m	struct:StrAccum
mxArea	.\src\test_rtree.c	/^  double mxArea;$/;"	m	struct:Circle	file:
mxCurrent	.\src\mem2.c	/^  int mxCurrent[NCSIZE];   \/* Highwater mark for nCurrent *\/$/;"	m	struct:__anon10	file:
mxErr	.\src\btreeInt.h	/^  int mxErr;        \/* Stop accumulating errors when this reaches zero *\/$/;"	m	struct:IntegrityCk
mxFrame	.\src\wal.c	/^  u32 mxFrame;                    \/* Index of last valid frame in the WAL *\/$/;"	m	struct:WalIndexHdr	file:
mxFrame	.\tool\showwal.c	/^static int mxFrame = 0;         \/* Last frame *\/$/;"	v	file:
mxKeysize	.\src\vdbesort.c	/^  int mxKeysize;                  \/* Largest serialized key seen so far *\/$/;"	m	struct:VdbeSorter	file:
mxLevel	.\ext\rtree\rtree.c	/^  int mxLevel;                      \/* iLevel value for root of the tree *\/$/;"	m	struct:RtreeCursor	file:
mxLevel	.\ext\rtree\sqlite3rtree.h	/^  int mxLevel;                      \/* The largest iLevel value in the tree *\/$/;"	m	struct:sqlite3_rtree_query_info
mxLookahead	.\tool\lemon.c	/^  int mxLookahead;             \/* Maximum aLookahead[].lookahead *\/$/;"	m	struct:acttab	file:
mxMmap	.\src\sqliteInt.h	/^  sqlite3_int64 mxMmap;             \/* Maximum value for szMmap *\/$/;"	m	struct:Sqlite3Config
mxOut	.\src\sqliteInt.h	/^  int mxOut;              \/* Highwater mark for nOut *\/$/;"	m	struct:Lookaside
mxPage	.\tool\showdb.c	/^  int mxPage;                     \/* Last page number *\/$/;"	m	struct:GlobalData	file:
mxParserStack	.\src\sqliteInt.h	/^  int mxParserStack;                \/* maximum depth of the parser stack *\/$/;"	m	struct:Sqlite3Config
mxPgno	.\src\pager.c	/^  Pgno mxPgno;                \/* Maximum allowed size of the database *\/$/;"	m	struct:Pager	file:
mxPinned	.\src\pcache1.c	/^  unsigned int mxPinned;         \/* nMaxpage + 10 - nMinPage *\/$/;"	m	struct:PGroup	file:
mxPmaSize	.\src\vdbesort.c	/^  int mxPmaSize;                  \/* Maximum PMA size, in bytes.  0==no limit *\/$/;"	m	struct:VdbeSorter	file:
mxQueue	.\ext\misc\fuzzer.c	/^  int mxQueue;               \/* Largest used index in aQueue[] *\/$/;"	m	struct:fuzzer_cursor	file:
mxReg	.\src\sqliteInt.h	/^  int mnReg, mxReg;       \/* Range of registers allocated for aCol and aFunc *\/$/;"	m	struct:AggInfo
mxReq	.\src\sqliteInt.h	/^  int mnReq, mxReq;                 \/* Min and max heap requests sizes *\/$/;"	m	struct:Sqlite3Config
mxSample	.\src\analyze.c	/^  int mxSample;             \/* Maximum number of samples to accumulate *\/$/;"	m	struct:Stat4Accum	file:
mxSavepoint	.\ext\fts3\fts3Int.h	/^  int mxSavepoint;       \/* Largest valid xSavepoint integer *\/$/;"	m	struct:Fts3Table
mxStrlen	.\src\sqliteInt.h	/^  int mxStrlen;                     \/* Maximum string length *\/$/;"	m	struct:Sqlite3Config
mxSz	.\src\vdbesort.c	/^  int mxSz;                       \/* Maximum bytes of data to store *\/$/;"	m	struct:IncrMerger	file:
mxValue	.\ext\misc\series.c	/^  sqlite3_int64 mxValue;     \/* Maximum value ("stop") *\/$/;"	m	struct:series_cursor	file:
mxValue	.\ext\misc\wholenumber.c	/^  sqlite3_int64 mxValue;     \/* Maximum value *\/$/;"	m	struct:wholenumber_cursor	file:
mxValue	.\src\status.c	/^  sqlite3_int64 mxValue[10];          \/* Maximum value *\/$/;"	m	struct:sqlite3StatType	file:
mxWalSize	.\src\wal.c	/^  i64 mxWalSize;             \/* Truncate WAL to this size upon reset *\/$/;"	m	struct:Wal	file:
n	.\ext\fts1\fts1.c	/^  short int n;         \/* Length of the token text in bytes. *\/$/;"	m	struct:Token	file:
n	.\ext\fts2\fts2.c	/^  short int n;         \/* Length of the token text in bytes. *\/$/;"	m	struct:Token	file:
n	.\ext\fts3\fts3Int.h	/^  int n;                          \/* Number of bytes in buffer z *\/$/;"	m	struct:Fts3PhraseToken
n	.\ext\fts3\fts3_snippet.c	/^  int n;                          \/* Length of z in bytes (excl. nul-term) *\/$/;"	m	struct:StrBuffer	file:
n	.\ext\fts3\fts3_test.c	/^  int n;                          \/* Length of token in bytes *\/$/;"	m	struct:NearToken	file:
n	.\ext\fts3\fts3_write.c	/^  int n;                          \/* Number of valid bytes of data in a[] *\/$/;"	m	struct:Blob	file:
n	.\ext\fts5\fts5Int.h	/^  int n;                          \/* Size of buffer at a[] in bytes *\/$/;"	m	struct:Fts5PoslistReader
n	.\ext\fts5\fts5Int.h	/^  int n;                          \/* Size of buffer p in bytes *\/$/;"	m	struct:Fts5Token
n	.\ext\fts5\fts5Int.h	/^  int n;$/;"	m	struct:Fts5Buffer
n	.\ext\fts5\fts5_expr.c	/^  int n;                          \/* Size of buffer a[] in bytes *\/$/;"	m	struct:Fts5LookaheadReader	file:
n	.\ext\misc\fuzzer.c	/^  fuzzer_len n;              \/* Apply pRule at this character offset *\/$/;"	m	struct:fuzzer_stem	file:
n	.\ext\misc\json1.c	/^  u32 n;                 \/* Bytes of content, or number of sub-nodes *\/$/;"	m	struct:JsonNode	file:
n	.\ext\misc\spellfix.c	/^  int n;                   \/* Number of characters in the FROM string *\/$/;"	m	struct:EditDist3FromString	file:
n	.\ext\misc\spellfix.c	/^  int n;                   \/* Number of characters in the TO string *\/$/;"	m	struct:EditDist3ToString	file:
n	.\mptest\mptest.c	/^  int n;           \/* Slots of z[] used *\/$/;"	m	struct:String	file:
n	.\src\func.c	/^  i64 n;$/;"	m	struct:CountCtx	file:
n	.\src\shell.c	/^  int n;              \/* Number of bytes in z *\/$/;"	m	struct:ImportCtx	file:
n	.\src\sqliteInt.h	/^    int n;                                     \/* A counter *\/$/;"	m	union:Walker::__anon22
n	.\src\sqliteInt.h	/^  int n;            \/* Size of record in bytes *\/$/;"	m	struct:IndexSample
n	.\src\sqliteInt.h	/^  unsigned int n;    \/* Number of characters in this token *\/$/;"	m	struct:Token
n	.\src\test1.c	/^  int n;$/;"	m	struct:t1CountCtx	file:
n	.\src\test_intarray.c	/^  int n;                    \/* Number of elements in the array *\/$/;"	m	struct:sqlite3_intarray	file:
n	.\src\vdbeInt.h	/^  int n;              \/* Number of characters in string value, excluding '\\0' *\/$/;"	m	struct:Mem
n	.\src\whereInt.h	/^  int n;                        \/* Number of assigned cursor values *\/$/;"	m	struct:WhereMaskSet
n	.\src\whereInt.h	/^  u16 n;                      \/* Number of valid a[] entries *\/$/;"	m	struct:WhereOrSet
n90pct	.\src\pcache1.c	/^  unsigned int n90pct;                \/* nMax*9\/10 *\/$/;"	m	struct:PCache1	file:
nAccumulator	.\src\sqliteInt.h	/^  int nAccumulator;       \/* Number of columns that show through to the output.$/;"	m	struct:AggInfo
nAction	.\tool\lemon.c	/^  int nAction;                 \/* Number of used slots in aAction[] *\/$/;"	m	struct:acttab	file:
nAction	.\tool\lemon.c	/^  int nAction;         \/* Number of actions *\/$/;"	m	struct:axset	file:
nActionAlloc	.\tool\lemon.c	/^  int nActionAlloc;            \/* Slots allocated for aAction[] *\/$/;"	m	struct:acttab	file:
nAdvance	.\ext\fts3\fts3Int.h	/^  int nAdvance;                   \/* How many seg-readers to advance *\/$/;"	m	struct:Fts3MultiSegReader
nAlias	.\src\sqliteInt.h	/^  int nAlias;               \/* Number of aliased result set columns *\/$/;"	m	struct:Parse
nAll	.\ext\fts3\fts3Int.h	/^  int nAll;                      \/* Size of a[] in bytes *\/$/;"	m	struct:Fts3Doclist
nAlloc	.\ext\fts1\fts1.c	/^  int nAlloc;     \/* Space allocated for aMatch[] *\/$/;"	m	struct:Snippet	file:
nAlloc	.\ext\fts2\fts2.c	/^  int nAlloc;     \/* Space allocated for aMatch[] *\/$/;"	m	struct:Snippet	file:
nAlloc	.\ext\fts3\fts3_snippet.c	/^  int nAlloc;                     \/* Allocated size of buffer z in bytes *\/$/;"	m	struct:StrBuffer	file:
nAlloc	.\ext\fts3\fts3_unicode.c	/^  int nAlloc;                     \/* space allocated at zToken *\/$/;"	m	struct:unicode_cursor	file:
nAlloc	.\ext\fts3\fts3_write.c	/^  int nAlloc;                     \/* Allocated size of a[] (nAlloc>=n) *\/$/;"	m	struct:Blob	file:
nAlloc	.\ext\fts5\fts5_hash.c	/^  int nAlloc;                     \/* Total size of allocation *\/$/;"	m	struct:Fts5HashEntry	file:
nAlloc	.\ext\misc\eval.c	/^  sqlite3_int64 nAlloc;  \/* Number of bytes allocated for z[] *\/$/;"	m	struct:EvalResult	file:
nAlloc	.\ext\misc\json1.c	/^  u32 nAlloc;        \/* Number of slots of aNode[] allocated *\/$/;"	m	struct:JsonParse	file:
nAlloc	.\ext\misc\json1.c	/^  u64 nAlloc;              \/* Bytes of storage available in zBuf[] *\/$/;"	m	struct:JsonString	file:
nAlloc	.\ext\misc\nextchar.c	/^  int nAlloc;                       \/* Space allocated to aResult *\/$/;"	m	struct:nextCharContext	file:
nAlloc	.\ext\misc\percentile.c	/^  unsigned nAlloc;     \/* Number of slots allocated for a[] *\/$/;"	m	struct:Percentile	file:
nAlloc	.\ext\misc\regexp.c	/^  unsigned nAlloc;            \/* Slots allocated for aOp[] and aArg[] *\/$/;"	m	struct:ReCompiled	file:
nAlloc	.\ext\misc\spellfix.c	/^  int nAlloc;                  \/* Number of allocated rows *\/$/;"	m	struct:spellfix1_cursor	file:
nAlloc	.\mptest\mptest.c	/^  int nAlloc;      \/* Slots of z[] allocated *\/$/;"	m	struct:String	file:
nAlloc	.\src\mem2.c	/^  int nAlloc[NCSIZE];      \/* Total number of allocations *\/$/;"	m	struct:__anon10	file:
nAlloc	.\src\mem5.c	/^  u64 nAlloc;         \/* Total number of calls to malloc *\/$/;"	m	struct:Mem5Global	file:
nAlloc	.\src\shell.c	/^  int nAlloc;         \/* Space allocated for z[] *\/$/;"	m	struct:ImportCtx	file:
nAlloc	.\src\sqliteInt.h	/^  int  nAlloc;         \/* Amount of space allocated in zText *\/$/;"	m	struct:StrAccum
nAlloc	.\src\sqliteInt.h	/^  u32 nAlloc;      \/* Number of entries allocated in a[] below *\/$/;"	m	struct:SrcList
nAlloc	.\src\table.c	/^  u32 nAlloc;        \/* Slots allocated for azResult[] *\/$/;"	m	struct:TabResult	file:
nAlloc	.\src\test1.c	/^  int nAlloc;  \/* Space allocated *\/$/;"	m	struct:dstr	file:
nAlloc	.\src\test_fs.c	/^  int nAlloc;$/;"	m	struct:fs_cursor	file:
nAlloc	.\src\test_onefile.c	/^  int nAlloc;$/;"	m	struct:tmp_file	file:
nAlloc	.\src\vdbesort.c	/^  int nAlloc;                 \/* Bytes of space at aAlloc *\/$/;"	m	struct:PmaReader	file:
nAlloc	.\test\threadtest1.c	/^  int nAlloc;         \/* Number of slots allocated for azElem[] *\/$/;"	m	struct:QueryResult	file:
nAlloc	.\tool\fuzzershell.c	/^  sqlite3_int64 nAlloc;  \/* Number of bytes allocated for z[] *\/$/;"	m	struct:EvalResult	file:
nAlloc	.\tool\sqldiff.c	/^  int nAlloc;     \/* Bytes allocated in z[] *\/$/;"	m	struct:Str	file:
nAllocated	.\ext\fts1\fts1_porter.c	/^  int nAllocated;              \/* space allocated to zToken buffer *\/$/;"	m	struct:porter_tokenizer_cursor	file:
nAllocated	.\ext\fts2\fts2_porter.c	/^  int nAllocated;              \/* space allocated to zToken buffer *\/$/;"	m	struct:porter_tokenizer_cursor	file:
nAllocated	.\ext\fts3\fts3_porter.c	/^  int nAllocated;              \/* space allocated to zToken buffer *\/$/;"	m	struct:porter_tokenizer_cursor	file:
nArg	.\src\sqliteInt.h	/^  i16 nArg;            \/* Number of arguments.  -1 means unlimited *\/$/;"	m	struct:FuncDef
nArg	.\src\sqliteInt.h	/^  int nArg;                \/* Total number of arguments *\/$/;"	m	struct:PrintfArguments
nAuthPW	.\src\sqliteInt.h	/^  int nAuthPW;                  \/* Size of the zAuthPW in bytes *\/$/;"	m	struct:sqlite3_userauth
nAutoincrmerge	.\ext\fts3\fts3Int.h	/^  int nAutoincrmerge;             \/* Value configured by 'automerge' *\/$/;"	m	struct:Fts3Table
nAutomerge	.\ext\fts5\fts5Int.h	/^  int nAutomerge;                 \/* 'automerge' setting *\/$/;"	m	struct:Fts5Config
nBackfill	.\src\wal.c	/^  u32 nBackfill;                  \/* Number of WAL frames backfilled into DB *\/$/;"	m	struct:WalCkptInfo	file:
nBacktrace	.\src\mem2.c	/^  char nBacktrace;                    \/* Number of backtraces on this alloc *\/$/;"	m	struct:MemBlockHdr	file:
nBacktrace	.\src\mem2.c	/^  int nBacktrace;$/;"	m	struct:__anon10	file:
nBacktraceSlots	.\src\mem2.c	/^  char nBacktraceSlots;               \/* Available backtrace slots *\/$/;"	m	struct:MemBlockHdr	file:
nBackup	.\src\btreeInt.h	/^  int nBackup;       \/* Number of backup operations reading this btree *\/$/;"	m	struct:Btree
nBasis	.\ext\misc\fuzzer.c	/^  fuzzer_len nBasis;         \/* Length of the zBasis string *\/$/;"	m	struct:fuzzer_stem	file:
nBenign	.\src\test_malloc.c	/^  int nBenign;            \/* Number of benign failures seen since last config *\/$/;"	m	struct:MemFault	file:
nBlob	.\src\test_onefile.c	/^  int nBlob;                  \/* Total size of allocated blob *\/$/;"	m	struct:fs_real_file	file:
nBlock	.\src\mem5.c	/^  int nBlock;      \/* Number of szAtom sized blocks in zPool *\/$/;"	m	struct:Mem5Global	file:
nBuf	.\ext\misc\amatch.c	/^  int nBuf;                  \/* Space allocated for zBuf *\/$/;"	m	struct:amatch_cursor	file:
nBuf	.\ext\misc\fuzzer.c	/^  int nBuf;                  \/* Bytes allocated for zBuf *\/$/;"	m	struct:fuzzer_cursor	file:
nBuf	.\src\journal.c	/^  int nBuf;                       \/* Size of zBuf[] in bytes *\/$/;"	m	struct:JournalFile	file:
nBuf	.\src\test6.c	/^  int nBuf;                    \/* Number of bytes written *\/$/;"	m	struct:WriteBuffer	file:
nBuf	.\src\test_fs.c	/^  int nBuf;$/;"	m	struct:fs_cursor	file:
nBuf	.\src\test_osinst.c	/^  int nBuf;                       \/* Number of valid bytes in aBuf[] *\/$/;"	m	struct:VfslogVfs	file:
nBuffer	.\ext\fts2\fts2_icu.c	/^  int nBuffer;$/;"	m	struct:IcuCursor	file:
nBuffer	.\ext\fts3\fts3Int.h	/^  int nBuffer;                    \/* Allocated size of aBuffer[] in bytes *\/$/;"	m	struct:Fts3MultiSegReader
nBuffer	.\ext\fts3\fts3_icu.c	/^  int nBuffer;$/;"	m	struct:IcuCursor	file:
nBuffer	.\ext\fts3\fts3_test.c	/^  int nBuffer;                 \/* Number of bytes allocated at pToken *\/$/;"	m	struct:test_tokenizer_cursor	file:
nBuffer	.\src\test_demovfs.c	/^  int nBuffer;                    \/* Valid bytes of data in zBuffer *\/$/;"	m	struct:DemoFile	file:
nBuffer	.\src\vdbesort.c	/^  int nBuffer;                    \/* Size of write buffer in bytes *\/$/;"	m	struct:PmaWriter	file:
nBuffer	.\src\vdbesort.c	/^  int nBuffer;                \/* Size of read buffer in bytes *\/$/;"	m	struct:PmaReader	file:
nBusy	.\ext\rtree\rtree.c	/^  int nBusy;                  \/* Current number of users of this structure *\/$/;"	m	struct:Rtree	file:
nBusy	.\src\sqliteInt.h	/^  int nBusy;                 \/* Incremented with each busy call *\/$/;"	m	struct:BusyHandler
nBusy	.\src\test_superlock.c	/^  int nBusy;                      \/* Number of times xBusy has been invoked *\/$/;"	m	struct:SuperlockBusy	file:
nByte	.\ext\async\sqlite3async.c	/^  int nByte;          \/* See above *\/$/;"	m	struct:AsyncWrite	file:
nByte	.\ext\fts1\fts1.c	/^    short int nByte;     \/* Number of bytes in the term *\/$/;"	m	struct:Snippet::snippetMatch	file:
nByte	.\ext\fts2\fts2.c	/^    short int nByte;     \/* Number of bytes in the term *\/$/;"	m	struct:Snippet::snippetMatch	file:
nByte	.\ext\misc\spellfix.c	/^  int nByte;               \/* Number of bytes in this character *\/$/;"	m	struct:EditDist3From	file:
nByte	.\ext\misc\spellfix.c	/^  int nByte;               \/* Number of bytes in this character *\/$/;"	m	struct:EditDist3To	file:
nByte	.\src\test_malloc.c	/^  int nByte;$/;"	m	struct:MallocLog	file:
nByte	.\src\test_osinst.c	/^  sqlite3_int64 nByte;            \/* Size of file in bytes *\/$/;"	m	struct:VfslogVtab	file:
nByte	.\src\test_server.c	/^  int nByte;                   \/* Size of the zIn parameter for prepare() *\/$/;"	m	struct:SqlMessage	file:
nByte	.\src\vdbeblob.c	/^  int nByte;              \/* Size of open blob, in bytes *\/$/;"	m	struct:Incrblob	file:
nBytes	.\ext\fts1\fts1_tokenizer1.c	/^  int nBytes;                  \/* size of the input *\/$/;"	m	struct:simple_tokenizer_cursor	file:
nBytes	.\ext\fts1\simple_tokenizer.c	/^  int nBytes;                  \/* size of the input *\/$/;"	m	struct:simple_tokenizer_cursor	file:
nBytes	.\ext\fts2\fts2_tokenizer1.c	/^  int nBytes;                  \/* size of the input *\/$/;"	m	struct:simple_tokenizer_cursor	file:
nBytes	.\ext\fts3\fts3_tokenizer1.c	/^  int nBytes;                  \/* size of the input *\/$/;"	m	struct:simple_tokenizer_cursor	file:
nBytesPerCell	.\ext\rtree\rtree.c	/^  u8 nBytesPerCell;           \/* Bytes consumed per cell *\/$/;"	m	struct:Rtree	file:
nCall	.\src\test_malloc.c	/^  int nCall;$/;"	m	struct:MallocLog	file:
nCapacity	.\ext\fts2\fts2.c	/^  int nCapacity;        \/* Size of pData buffer. *\/$/;"	m	struct:DataBuffer	file:
nCell	.\src\btree.c	/^  int nCell;              \/* Number of cells in apCell[] *\/$/;"	m	struct:CellArray	file:
nCell	.\src\btreeInt.h	/^  u16 nCell;           \/* Number of cells on this page, local and ovfl *\/$/;"	m	struct:MemPage
nCell	.\src\dbstat.c	/^  int nCell;                      \/* Number of cells on page *\/$/;"	m	struct:StatPage	file:
nCell	.\src\dbstat.c	/^  int nCell;                      \/* Value of 'ncell' column *\/$/;"	m	struct:StatCursor	file:
nChange	.\src\sqliteInt.h	/^  int nChange;                  \/* Value returned by sqlite3_changes() *\/$/;"	m	struct:sqlite3
nChange	.\src\vdbeInt.h	/^  int nChange;            \/* Number of db changes made since last reset *\/$/;"	m	struct:Vdbe
nChange	.\src\vdbeInt.h	/^  int nChange;            \/* Statement changes (Vdbe.nChange)     *\/$/;"	m	struct:VdbeFrame
nChar	.\ext\fts2\fts2_icu.c	/^  int nChar;                  \/* Number of UChar elements in pInput *\/$/;"	m	struct:IcuCursor	file:
nChar	.\ext\fts3\fts3_icu.c	/^  int nChar;                  \/* Number of UChar elements in pInput *\/$/;"	m	struct:IcuCursor	file:
nChar	.\src\sqliteInt.h	/^  int  nChar;          \/* Length of the string so far *\/$/;"	m	struct:StrAccum
nChild	.\ext\fts5\fts5_expr.c	/^  int nChild;                     \/* Number of child nodes *\/$/;"	m	struct:Fts5ExprNode	file:
nChild	.\src\whereInt.h	/^  u8 nChild;              \/* Number of children that must disable us *\/$/;"	m	struct:WhereTerm
nChildCsr	.\src\vdbeInt.h	/^  int nChildCsr;          \/* Number of cursors for child frame *\/$/;"	m	struct:VdbeFrame
nChildMem	.\src\vdbeInt.h	/^  int nChildMem;          \/* Number of memory cells for child frame *\/$/;"	m	struct:VdbeFrame
nCkpt	.\src\wal.c	/^  u32 nCkpt;                 \/* Checkpoint sequence counter in the wal-header *\/$/;"	m	struct:Wal	file:
nCol	.\ext\fts3\fts3_expr.c	/^  int nCol;                           \/* Number of entries in azCol[] *\/$/;"	m	struct:ParseContext	file:
nCol	.\ext\fts3\fts3_snippet.c	/^  int nCol;                       \/* Number of columns in table *\/$/;"	m	struct:MatchInfo	file:
nCol	.\ext\fts5\fts5Int.h	/^  int nCol;                       \/* Number of columns *\/$/;"	m	struct:Fts5Config
nCol	.\ext\fts5\fts5Int.h	/^  int nCol;$/;"	m	struct:Fts5Colset
nCol	.\ext\fts5\fts5_test_mi.c	/^  int nCol;                       \/* Number of cols in FTS5 table *\/$/;"	m	struct:Fts5MatchinfoCtx	file:
nCol	.\ext\fts5\fts5_vocab.c	/^  int nCol;$/;"	m	struct:Fts5VocabCursor	file:
nCol	.\ext\rbu\sqlite3rbu.c	/^  int nCol;                       \/* Number of columns in current object *\/$/;"	m	struct:RbuObjIter	file:
nCol	.\src\analyze.c	/^  int nCol;                 \/* Number of columns in index + pk\/rowid *\/$/;"	m	struct:Stat4Accum	file:
nCol	.\src\sqliteInt.h	/^  i16 nCol;            \/* Number of columns in this table *\/$/;"	m	struct:Table
nCol	.\src\sqliteInt.h	/^  int nCol;         \/* Number of columns in this key *\/$/;"	m	struct:FKey
nCol	.\src\tclsqlite.c	/^  int nCol;                       \/* Number of columns returned by pStmt *\/$/;"	m	struct:DbEvalContext	file:
nCol	.\src\test8.c	/^  int nCol;               \/* Number of columns in the real table *\/$/;"	m	struct:echo_vtab	file:
nColumn	.\ext\fts1\fts1.c	/^  int nColumn;                     \/* number of columns in virtual table *\/$/;"	m	struct:fulltext_vtab	file:
nColumn	.\ext\fts1\fts1.c	/^  int nColumn;             \/* Number of columns to be indexed *\/$/;"	m	struct:TableSpec	file:
nColumn	.\ext\fts2\fts2.c	/^  int nColumn;                     \/* number of columns in virtual table *\/$/;"	m	struct:fulltext_vtab	file:
nColumn	.\ext\fts2\fts2.c	/^  int nColumn;             \/* Number of columns to be indexed *\/$/;"	m	struct:TableSpec	file:
nColumn	.\ext\fts3\fts3Int.h	/^  int nColumn;                    \/* number of named columns in virtual table *\/$/;"	m	struct:Fts3Table
nColumn	.\src\sqliteInt.h	/^  int nColumn;            \/* Number of used entries in aCol[] *\/$/;"	m	struct:AggInfo
nColumn	.\src\sqliteInt.h	/^  u16 nColumn;             \/* Number of columns stored in the index *\/$/;"	m	struct:Index
nColumn	.\src\table.c	/^  u32 nColumn;       \/* Number of columns in the result *\/$/;"	m	struct:TabResult	file:
nConn	.\src\test_sqllog.c	/^  int nConn;                      \/* Size of aConn[] array *\/$/;"	m	struct:SLGlobal	file:
nConstraint	.\ext\rtree\rtree.c	/^  int nConstraint;                  \/* Number of entries in aConstraint *\/$/;"	m	struct:RtreeCursor	file:
nCoord	.\ext\rtree\sqlite3rtree.h	/^  int nCoord;                       \/* Number of coordinates *\/$/;"	m	struct:sqlite3_rtree_query_info
nCost	.\ext\fts3\fts3Int.h	/^  int nCost;                      \/* Cost of running iterator *\/$/;"	m	struct:Fts3MultiSegReader
nCount	.\src\test_syscall.c	/^  int nCount;                     \/* Fail after this many more calls *\/$/;"	m	struct:TestSyscallGlobal	file:
nCrisisMerge	.\ext\fts5\fts5Int.h	/^  int nCrisisMerge;               \/* Maximum allowed segments per level *\/$/;"	m	struct:Fts5Config
nCsr	.\src\vdbe.h	/^  int nCsr;                     \/* Number of cursors required *\/$/;"	m	struct:SubProgram
nCte	.\src\sqliteInt.h	/^  int nCte;                       \/* Number of CTEs in the WITH clause *\/$/;"	m	struct:With
nCurrent	.\src\mem2.c	/^  int nCurrent[NCSIZE];    \/* Current number of allocations *\/$/;"	m	struct:__anon10	file:
nCurrentPage	.\src\pcache1.c	/^  unsigned int nCurrentPage;     \/* Number of purgeable pages allocated *\/$/;"	m	struct:PGroup	file:
nCursor	.\ext\misc\amatch.c	/^  int nCursor;               \/* Number of active cursors *\/$/;"	m	struct:amatch_vtab	file:
nCursor	.\ext\misc\closure.c	/^  int nCursor;               \/* Number of pending cursors *\/$/;"	m	struct:closure_vtab	file:
nCursor	.\ext\misc\fuzzer.c	/^  int nCursor;               \/* Number of active cursors *\/$/;"	m	struct:fuzzer_vtab	file:
nCursor	.\src\vdbeInt.h	/^  int nCursor;            \/* Number of entries in apCsr *\/$/;"	m	struct:VdbeFrame
nCursor	.\src\vdbeInt.h	/^  int nCursor;            \/* Number of slots in apCsr[] *\/$/;"	m	struct:Vdbe
nData	.\ext\fts1\fts1.c	/^  int nData;$/;"	m	struct:DocList	file:
nData	.\ext\fts1\fulltext.c	/^  int nData;$/;"	m	struct:DocList	file:
nData	.\ext\fts2\fts2.c	/^  int nData;            \/* End of data loaded into pData. *\/$/;"	m	struct:DataBuffer	file:
nData	.\ext\fts2\fts2.c	/^  int nData;$/;"	m	struct:DLReader	file:
nData	.\ext\fts2\fts2.c	/^  int nData;$/;"	m	struct:InteriorReader	file:
nData	.\ext\fts2\fts2.c	/^  int nData;$/;"	m	struct:LeafReader	file:
nData	.\ext\fts2\fts2.c	/^  int nData;$/;"	m	struct:PLReader	file:
nData	.\ext\fts3\fts3_write.c	/^  int nData;                      \/* Bytes of data in aData *\/$/;"	m	struct:SegmentWriter	file:
nData	.\ext\fts3\fts3_write.c	/^  int nData;                      \/* Bytes of valid data so far *\/$/;"	m	struct:SegmentNode	file:
nData	.\ext\fts3\fts3_write.c	/^  int nData;$/;"	m	struct:PendingList	file:
nData	.\ext\fts5\fts5_hash.c	/^  int nData;                      \/* Total bytes of data (incl. structure) *\/$/;"	m	struct:Fts5HashEntry	file:
nData	.\src\table.c	/^  u32 nData;         \/* Slots used in azResult[].  (nRow+1)*nColumn *\/$/;"	m	struct:TabResult	file:
nData	.\src\test6.c	/^  int nData;                           \/* Size of buffer allocated at zData *\/$/;"	m	struct:CrashFile	file:
nDatabase	.\src\test_onefile.c	/^  int nDatabase;              \/* Current size of database region *\/$/;"	m	struct:fs_real_file	file:
nDb	.\src\sqliteInt.h	/^  int nDb;                      \/* Number of backends currently in use *\/$/;"	m	struct:sqlite3
nDb	.\test\fuzzcheck.c	/^  int nDb;                         \/* Number of template databases *\/$/;"	m	struct:GlobalVars	file:
nDbChange	.\src\vdbeInt.h	/^  int nDbChange;          \/* Value of db->nChange *\/$/;"	m	struct:VdbeFrame
nDeferredCons	.\src\sqliteInt.h	/^  i64 nDeferredCons;                  \/* Number of deferred fk violations *\/$/;"	m	struct:Savepoint
nDeferredCons	.\src\sqliteInt.h	/^  i64 nDeferredCons;            \/* Net deferred constraints this transaction. *\/$/;"	m	struct:sqlite3
nDeferredImmCons	.\src\sqliteInt.h	/^  i64 nDeferredImmCons;               \/* Number of deferred imm fk. *\/$/;"	m	struct:Savepoint
nDeferredImmCons	.\src\sqliteInt.h	/^  i64 nDeferredImmCons;         \/* Net deferred immediate constraints *\/$/;"	m	struct:sqlite3
nDefine	.\tool\lemon.c	/^static int nDefine = 0;      \/* Number of -D options on the command line *\/$/;"	v	file:
nDel	.\ext\misc\spellfix.c	/^  int nDel;                \/* Number of deletion cost entries *\/$/;"	m	struct:EditDist3From	file:
nDim	.\ext\rtree\rtree.c	/^  u8 nDim;                    \/* Number of dimensions *\/$/;"	m	struct:Rtree	file:
nDlidx	.\ext\fts5\fts5_index.c	/^  int nDlidx;                     \/* Allocated size of aDlidx[] array *\/$/;"	m	struct:Fts5SegWriter	file:
nDoc	.\ext\fts3\fts3Int.h	/^  sqlite3_int64 nDoc;             \/* Documents in table *\/$/;"	m	struct:Fts3Cursor
nDoc	.\ext\fts3\fts3_aux.c	/^    sqlite3_int64 nDoc;           \/* 'documents' values for current csr row *\/$/;"	m	struct:Fts3auxCursor::Fts3auxColstats	file:
nDoc	.\ext\fts3\fts3_snippet.c	/^  sqlite3_int64 nDoc;             \/* Number of docs in database *\/$/;"	m	struct:MatchInfo	file:
nDoclist	.\ext\fts3\fts3Int.h	/^  int nDoclist;                   \/* Size of aDoclist[] in bytes *\/$/;"	m	struct:Fts3MultiSegReader
nDoclist	.\ext\fts3\fts3Int.h	/^  int nDoclist;                   \/* Size of buffer at aDoclist *\/$/;"	m	struct:Fts3Cursor
nDoclist	.\ext\fts3\fts3_write.c	/^  int nDoclist;                   \/* Size of doclist in bytes *\/$/;"	m	struct:NodeReader	file:
nDoclist	.\ext\fts3\fts3_write.c	/^  int nDoclist;                   \/* Size of doclist in current entry *\/$/;"	m	struct:Fts3SegReader	file:
nElem	.\ext\fts3\fts3_snippet.c	/^  int nElem;$/;"	m	struct:MatchinfoBuffer	file:
nElem	.\test\threadtest1.c	/^  int nElem;          \/* Number of used entries in azElem[] *\/$/;"	m	struct:QueryResult	file:
nElement	.\ext\fts2\fts2.c	/^  int nElement;$/;"	m	struct:DLReader	file:
nEmpty	.\ext\fts5\fts5_index.c	/^  int nEmpty;                     \/* Number of contiguous term-less nodes *\/$/;"	m	struct:Fts5SegWriter	file:
nEntry	.\ext\fts3\fts3_write.c	/^  int nEntry;                     \/* Number of terms written to node so far *\/$/;"	m	struct:SegmentNode	file:
nEntry	.\ext\fts5\fts5_hash.c	/^  int nEntry;                     \/* Number of entries currently in hash *\/$/;"	m	struct:Fts5Hash	file:
nEntry	.\src\wal.c	/^    int nEntry;                   \/* Nr. of entries in aPgno[] and aIndex[] *\/$/;"	m	struct:WalIterator::WalSegment	file:
nEq	.\src\whereInt.h	/^      u16 nEq;               \/* Number of equality constraints *\/$/;"	m	struct:WhereLoop::__anon28::__anon29
nEquiv	.\src\whereInt.h	/^  unsigned char nEquiv;      \/* Number of entries in aEquiv[] *\/$/;"	m	struct:WhereScan
nErr	.\ext\misc\json1.c	/^  u8 nErr;           \/* Number of errors seen *\/$/;"	m	struct:JsonParse	file:
nErr	.\src\btreeInt.h	/^  int nErr;         \/* Number of messages written to zErrMsg so far *\/$/;"	m	struct:IntegrityCk
nErr	.\src\shell.c	/^  int nErr;              \/* Number of errors seen *\/$/;"	m	struct:ShellState	file:
nErr	.\src\sqliteInt.h	/^  int nErr;            \/* Number of errors encountered while resolving names *\/$/;"	m	struct:NameContext
nErr	.\src\sqliteInt.h	/^  int nErr;            \/* Number of errors seen *\/$/;"	m	struct:Parse
nErr	.\test\threadtest4.c	/^  int nErr;                   \/* Number of errors seen by this thread *\/$/;"	m	struct:WorkerInfo	file:
nError	.\mptest\mptest.c	/^  int nError;            \/* Number of errors *\/$/;"	m	struct:Global	file:
nEst	.\src\vdbeInt.h	/^  LogEst nEst;                    \/* Estimated output rows per loop *\/$/;"	m	struct:ScanStatus
nException	.\ext\fts3\fts3_unicode.c	/^  int nException;$/;"	m	struct:unicode_tokenizer	file:
nException	.\ext\fts5\fts5_tokenize.c	/^  int nException;$/;"	m	struct:Unicode61Tokenizer	file:
nExpr	.\src\sqliteInt.h	/^  int nExpr;             \/* Number of expressions on the list *\/$/;"	m	struct:ExprList
nExt	.\src\loadext.c	/^  u32 nExt;              \/* Number of entries in aExt[] *\/          $/;"	m	struct:sqlite3AutoExtList	file:
nExtension	.\src\sqliteInt.h	/^  int nExtension;               \/* Number of loaded extensions *\/$/;"	m	struct:sqlite3
nExtra	.\ext\fts3\tool\fts3view.c	/^int nExtra;$/;"	v
nExtra	.\src\pager.c	/^  u16 nExtra;                 \/* Add this many bytes to each in-memory page *\/$/;"	m	struct:Pager	file:
nFail	.\src\test_malloc.c	/^  int nFail;              \/* Number of failures seen since last config *\/$/;"	m	struct:MemFault	file:
nFail	.\src\test_syscall.c	/^  int nFail;                      \/* Number of failures that have occurred *\/$/;"	m	struct:TestSyscallGlobal	file:
nFail	.\src\test_vfs.c	/^  int nFail;                      \/* Number of faults injected *\/$/;"	m	struct:TestFaultInject	file:
nFails	.\src\os_unix.c	/^  int nFails;                  \/* Number of conch taking failures *\/$/;"	m	struct:proxyLockingContext	file:
nFetchOut	.\src\os_unix.c	/^  int nFetchOut;                      \/* Number of outstanding xFetch refs *\/$/;"	m	struct:unixFile	file:
nFetchOut	.\src\os_win.c	/^  int nFetchOut;                \/* Number of outstanding xFetch references *\/$/;"	m	struct:winFile	file:
nField	.\src\sqliteInt.h	/^  u16 nField;         \/* Number of entries in apMem[] *\/$/;"	m	struct:UnpackedRecord
nField	.\src\sqliteInt.h	/^  u16 nField;         \/* Number of key columns in the index *\/$/;"	m	struct:KeyInfo
nField	.\src\vdbeInt.h	/^  i16 nField;           \/* Number of fields in the header *\/$/;"	m	struct:VdbeCursor
nFile	.\ext\async\sqlite3async.c	/^  int nFile;                   \/* Number of open files (from sqlite pov) *\/$/;"	m	struct:TestAsyncStaticData	file:
nFile	.\ext\async\sqlite3async.c	/^  int nFile;$/;"	m	struct:AsyncLock	file:
nFile	.\src\test_osinst.c	/^  int nFile;                      \/* Size of array azFile[] *\/$/;"	m	struct:VfslogCsr	file:
nFilename	.\ext\misc\vfslog.c	/^  int nFilename;                  \/* Length of zFilename in bytes *\/$/;"	m	struct:VLogLog	file:
nFkConstraint	.\src\vdbeInt.h	/^  i64 nFkConstraint;      \/* Number of imm. FK constraints this VM *\/$/;"	m	struct:Vdbe
nFold	.\ext\fts5\fts5_tokenize.c	/^  int nFold;                      \/* Size of aFold[] in bytes *\/$/;"	m	struct:Unicode61Tokenizer	file:
nFrame	.\ext\rbu\sqlite3rbu.c	/^  int nFrame;                     \/* Entries in aFrame[] array *\/$/;"	m	struct:sqlite3rbu	file:
nFrame	.\src\vdbeInt.h	/^  int nFrame;             \/* Number of frames in pFrame list *\/$/;"	m	struct:Vdbe
nFrameAlloc	.\ext\rbu\sqlite3rbu.c	/^  int nFrameAlloc;                \/* Allocated size of aFrame[] array *\/$/;"	m	struct:sqlite3rbu	file:
nFree	.\src\btreeInt.h	/^  u16 nFree;           \/* Number of free bytes on the page *\/$/;"	m	struct:MemPage
nFree	.\src\test_pcache.c	/^  int nFree;                \/* Number of unused slots in a[] *\/$/;"	m	struct:testpcache	file:
nFree	.\src\test_wsd.c	/^  int nFree;$/;"	m	struct:ProcessLocalStorage	file:
nFreeSlot	.\src\pcache1.c	/^  int nFreeSlot;                 \/* Number of unused pcache slots *\/$/;"	m	struct:PCacheGlobal	file:
nFresh	.\src\rowset.c	/^  u16 nFresh;                    \/* Number of objects on pFresh *\/$/;"	m	struct:RowSet	file:
nFrom	.\ext\misc\amatch.c	/^  amatch_len nFrom, nTo;   \/* Length of the zFrom and zTo strings *\/$/;"	m	struct:amatch_rule	file:
nFrom	.\ext\misc\fuzzer.c	/^  fuzzer_len nFrom, nTo;      \/* Length of the zFrom and zTo strings *\/$/;"	m	struct:fuzzer_rule	file:
nFrom	.\ext\misc\spellfix.c	/^  u8 nFrom;                 \/* Number of bytes in aFrom *\/$/;"	m	struct:EditDist3Cost	file:
nFunc	.\src\sqliteInt.h	/^  int nFunc;              \/* Number of entries in aFunc[] *\/$/;"	m	struct:AggInfo
nGlobalErr	.\test\threadtest3.c	/^static int nGlobalErr = 0;$/;"	v	file:
nHash	.\src\pcache1.c	/^  unsigned int nHash;                 \/* Number of slots in apHash[] *\/$/;"	m	struct:PCache1	file:
nHdrParsed	.\src\vdbeInt.h	/^  u16 nHdrParsed;       \/* Number of header fields parsed so far *\/$/;"	m	struct:VdbeCursor
nHeap	.\src\sqliteInt.h	/^  int nHeap;                        \/* Size of pHeap[] *\/$/;"	m	struct:Sqlite3Config
nHeight	.\src\sqliteInt.h	/^  int nHeight;              \/* Expression tree height of current sub-select *\/$/;"	m	struct:Parse
nHeight	.\src\sqliteInt.h	/^  int nHeight;           \/* Height of the tree headed by this node *\/$/;"	m	struct:Expr
nId	.\src\sqliteInt.h	/^  int nId;         \/* Number of identifiers on the list *\/$/;"	m	struct:IdList
nIdx	.\ext\fts5\fts5_main.c	/^  int nIdx;                       \/* Number of entries in aIdx[] *\/$/;"	m	struct:Fts5Sorter	file:
nIn	.\ext\fts5\fts5_aux.c	/^  int nIn;                        \/* Size of input text in bytes *\/$/;"	m	struct:HighlightContext	file:
nIn	.\src\whereInt.h	/^      int nIn;              \/* Number of entries in aInLoop[] *\/$/;"	m	struct:WhereLevel::__anon26::__anon27
nIndent	.\src\shell.c	/^  int nIndent;           \/* Size of array aiIndent[] *\/$/;"	m	struct:ShellState	file:
nIndent	.\src\vdbeInt.h	/^  int nIndent;       \/* Number of elements in aIndent *\/$/;"	m	struct:Explain
nIndex	.\ext\fts3\fts3Int.h	/^  int nIndex;                     \/* Size of aIndex[] *\/$/;"	m	struct:Fts3Table
nIndex	.\src\tclsqlite.c	/^  int nStep, nSort, nIndex;  \/* Statistics for most recent operation *\/$/;"	m	struct:SqliteDb	file:
nInit	.\ext\misc\regexp.c	/^  int nInit;                  \/* Number of characters in zInit *\/$/;"	m	struct:ReCompiled	file:
nInitPage	.\src\pcache1.c	/^  int nInitPage;                 \/* Initial bulk allocation size *\/   $/;"	m	struct:PCacheGlobal	file:
nInput	.\ext\fts1\fts1_porter.c	/^  int nInput;                  \/* size of the input *\/$/;"	m	struct:porter_tokenizer_cursor	file:
nInput	.\ext\fts2\fts2_porter.c	/^  int nInput;                  \/* size of the input *\/$/;"	m	struct:porter_tokenizer_cursor	file:
nInput	.\ext\fts3\fts3_porter.c	/^  int nInput;                  \/* size of the input *\/$/;"	m	struct:porter_tokenizer_cursor	file:
nInput	.\ext\fts3\fts3_test.c	/^  int nInput;                  \/* Size of the input in bytes *\/$/;"	m	struct:test_tokenizer_cursor	file:
nInput	.\ext\fts3\fts3_unicode.c	/^  int nInput;                     \/* Size of aInput[] in bytes *\/$/;"	m	struct:unicode_cursor	file:
nIns	.\ext\misc\spellfix.c	/^  int nIns;                \/* Number of insertion cost entries *\/$/;"	m	struct:EditDist3To	file:
nInst	.\ext\fts5\fts5_aux.c	/^  int nInst;                      \/* Total number of phrase instances *\/$/;"	m	struct:CInstIter	file:
nInstAlloc	.\ext\fts5\fts5_main.c	/^  int nInstAlloc;                 \/* Size of aInst[] array (entries \/ 3) *\/$/;"	m	struct:Fts5Cursor	file:
nInstCount	.\ext\fts5\fts5_main.c	/^  int nInstCount;                 \/* Number of phrase instances *\/$/;"	m	struct:Fts5Cursor	file:
nInstance	.\src\test_pcache.c	/^  int nInstance;            \/* Number of current instances *\/$/;"	m	struct:testpcacheGlobalType	file:
nJournal	.\src\test_onefile.c	/^  int nJournal;               \/* Current size of journal region *\/$/;"	m	struct:fs_real_file	file:
nKey	.\ext\fts1\ft_hash.h	/^  void *pKey; int nKey;    \/* Key associated with this element *\/$/;"	m	struct:HashElem
nKey	.\ext\fts1\fts1_hash.h	/^  void *pKey; int nKey;      \/* Key associated with this element *\/$/;"	m	struct:fts1HashElem
nKey	.\ext\fts2\fts2_hash.h	/^  void *pKey; int nKey;      \/* Key associated with this element *\/$/;"	m	struct:fts2HashElem
nKey	.\ext\fts3\fts3_hash.h	/^  void *pKey; int nKey;      \/* Key associated with this element *\/$/;"	m	struct:Fts3HashElem
nKey	.\src\btreeInt.h	/^  i64 nKey;                 \/* Size of pKey, or last integer key *\/$/;"	m	struct:BtCursor
nKey	.\src\btreeInt.h	/^  i64 nKey;      \/* The key for INTKEY tables, or nPayload otherwise *\/$/;"	m	struct:CellInfo
nKey	.\src\vdbesort.c	/^  int nKey;                   \/* Number of bytes in key *\/$/;"	m	struct:PmaReader	file:
nKeyCol	.\src\analyze.c	/^  int nKeyCol;              \/* Number of index columns w\/o the pk\/rowid *\/$/;"	m	struct:Stat4Accum	file:
nKeyCol	.\src\sqliteInt.h	/^  u16 nKeyCol;             \/* Number of columns forming the key *\/$/;"	m	struct:Index
nKeyword	.\tool\mkkeywordhash.c	/^static int nKeyword = (sizeof(aKeywordTable)\/sizeof(aKeywordTable[0]));$/;"	v	file:
nLSlot	.\src\whereInt.h	/^  u16 nLSlot;           \/* Number of slots allocated for aLTerm[] *\/$/;"	m	struct:WhereLoop
nLTerm	.\src\whereInt.h	/^  u16 nLTerm;           \/* Number of entries in aLTerm[] *\/$/;"	m	struct:WhereLoop
nLabel	.\src\sqliteInt.h	/^  int nLabel;          \/* Number of labels used *\/$/;"	m	struct:Parse
nLang	.\ext\misc\spellfix.c	/^  int nLang;             \/* Number of language IDs.  Size of a[] *\/$/;"	m	struct:EditDist3Config	file:
nLastOvfl	.\src\dbstat.c	/^  int nLastOvfl;                  \/* Bytes of payload on final overflow page *\/$/;"	m	struct:StatCell	file:
nLeafAdd	.\ext\fts3\fts3Int.h	/^  u32 nLeafAdd;                   \/* Number of leaf blocks added this trans *\/$/;"	m	struct:Fts3Table
nLeafData	.\ext\fts3\fts3_write.c	/^  i64 nLeafData;                  \/* Number of bytes of leaf data written *\/$/;"	m	struct:SegmentWriter	file:
nLeafData	.\ext\fts3\fts3_write.c	/^  sqlite3_int64 nLeafData;        \/* Bytes of leaf page data so far *\/$/;"	m	struct:IncrmergeWriter	file:
nLeafEst	.\ext\fts3\fts3_write.c	/^  int nLeafEst;                   \/* Space allocated for leaf blocks *\/$/;"	m	struct:IncrmergeWriter	file:
nLeafWritten	.\ext\fts5\fts5_index.c	/^  int nLeafWritten;               \/* Number of leaf pages written *\/$/;"	m	struct:Fts5SegWriter	file:
nLevel	.\ext\fts5\fts5_index.c	/^  int nLevel;                     \/* Number of levels in this index *\/$/;"	m	struct:Fts5Structure	file:
nLevel	.\src\whereInt.h	/^  u8 nLevel;                \/* Number of nested loop *\/$/;"	m	struct:WhereInfo
nLine	.\src\shell.c	/^  int nLine;          \/* Current line number *\/$/;"	m	struct:ImportCtx	file:
nList	.\ext\fts3\fts3.c	/^  int nList;$/;"	m	struct:TokenDoclist	file:
nList	.\ext\fts3\fts3Int.h	/^  int nList;                     \/* Length of position list *\/$/;"	m	struct:Fts3Doclist
nLocal	.\src\btreeInt.h	/^  u16 nLocal;    \/* Amount of payload held locally, not on overflow *\/$/;"	m	struct:CellInfo
nLocal	.\src\dbstat.c	/^  int nLocal;                     \/* Bytes of local payload *\/$/;"	m	struct:StatCell	file:
nLock	.\src\os_unix.c	/^  int nLock;                      \/* Number of outstanding file locks *\/$/;"	m	struct:unixInodeInfo	file:
nLookahead	.\tool\lemon.c	/^  int nLookahead;              \/* Used slots in aLookahead[] *\/$/;"	m	struct:acttab	file:
nLookaheadAlloc	.\tool\lemon.c	/^  int nLookaheadAlloc;         \/* Slots allocated in aLookahead[] *\/$/;"	m	struct:acttab	file:
nLookaside	.\src\sqliteInt.h	/^  int nLookaside;                   \/* Default lookaside buffer count *\/$/;"	m	struct:Sqlite3Config
nLvl	.\ext\fts5\fts5_index.c	/^  int nLvl;$/;"	m	struct:Fts5DlidxIter	file:
nMalloc	.\ext\fts3\fts3_write.c	/^  int nMalloc;                    \/* Size of malloc'd buffer at zMalloc *\/$/;"	m	struct:SegmentNode	file:
nMalloc	.\ext\fts3\fts3_write.c	/^  int nMalloc;                    \/* Size of malloc'd buffer at zMalloc *\/$/;"	m	struct:SegmentWriter	file:
nMatch	.\ext\fts1\fts1.c	/^  int nMatch;     \/* Total number of matches *\/$/;"	m	struct:Snippet	file:
nMatch	.\ext\fts2\fts2.c	/^  int nMatch;     \/* Total number of matches *\/$/;"	m	struct:Snippet	file:
nMatch	.\ext\misc\amatch.c	/^  short int nMatch;     \/* Input characters matched *\/$/;"	m	struct:amatch_word	file:
nMax	.\src\pcache1.c	/^  unsigned int nMax;                  \/* Configured "cache_size" value *\/$/;"	m	struct:PCache1	file:
nMaxArg	.\src\sqliteInt.h	/^  int nMaxArg;         \/* Max args passed to user function by sub-program *\/$/;"	m	struct:Parse
nMaxFrame	.\test\tt3_checkpoint.c	/^  int nMaxFrame;$/;"	m	struct:CheckpointStarvationCtx	file:
nMaxPage	.\src\pcache1.c	/^  unsigned int nMaxPage;         \/* Sum of nMax for purgeable caches *\/$/;"	m	struct:PGroup	file:
nMaxPendingData	.\ext\fts3\fts3Int.h	/^  int nMaxPendingData;            \/* Max pending data before flush to disk *\/$/;"	m	struct:Fts3Table
nMaxPendingData	.\ext\fts5\fts5_index.c	/^  int nMaxPendingData;            \/* Max pending data before flush to disk *\/$/;"	m	struct:Fts5Index	file:
nMaxSorterMmap	.\src\sqliteInt.h	/^  int nMaxSorterMmap;           \/* Maximum size of regions mapped by sorter *\/$/;"	m	struct:sqlite3
nMem	.\src\sqliteInt.h	/^  int nMem;            \/* Number of memory cells used so far *\/$/;"	m	struct:Parse
nMem	.\src\vdbe.h	/^  int nMem;                     \/* Number of memory cells required *\/$/;"	m	struct:SubProgram
nMem	.\src\vdbeInt.h	/^  int nMem;               \/* Number of entries in aMem *\/$/;"	m	struct:VdbeFrame
nMem	.\src\vdbeInt.h	/^  int nMem;               \/* Number of memory locations currently allocated *\/$/;"	m	struct:Vdbe
nMemory	.\src\vdbesort.c	/^  int nMemory;                    \/* Size of list.aMemory allocation in bytes *\/$/;"	m	struct:VdbeSorter	file:
nMerge	.\ext\fts5\fts5_index.c	/^  int nMerge;                     \/* Number of segments in incr-merge *\/$/;"	m	struct:Fts5StructureLevel	file:
nMin	.\src\pcache1.c	/^  unsigned int nMin;                  \/* Minimum number of pages reserved *\/$/;"	m	struct:PCache1	file:
nMinPage	.\src\pcache1.c	/^  unsigned int nMinPage;         \/* Sum of nMin for purgeable caches *\/$/;"	m	struct:PGroup	file:
nMmapOut	.\src\pager.c	/^  int nMmapOut;               \/* Number of mmap pages currently outstanding *\/$/;"	m	struct:Pager	file:
nModuleArg	.\src\sqliteInt.h	/^  int nModuleArg;      \/* Number of arguments to the module *\/$/;"	m	struct:Table
nMxPayload	.\src\dbstat.c	/^  int nMxPayload;                 \/* Largest payload of any cell on this page *\/$/;"	m	struct:StatPage	file:
nMxPayload	.\src\dbstat.c	/^  int nMxPayload;                 \/* Value of 'mx_payload' column *\/$/;"	m	struct:StatCursor	file:
nName	.\ext\async\sqlite3async.c	/^  int nName;                 \/* Number of characters in zName *\/$/;"	m	struct:AsyncFileData	file:
nName	.\src\os_unix.c	/^  int nName;                    \/* Length of the zCanonicalName[] string *\/$/;"	m	struct:vxworksFileId	file:
nName	.\src\test_multiplex.c	/^  int nName;                       \/* Length of base filename *\/$/;"	m	struct:multiplexGroup	file:
nNear	.\ext\fts3\fts3Int.h	/^  int nNear;                 \/* Valid if eType==FTSQUERY_NEAR *\/$/;"	m	struct:Fts3Expr
nNear	.\ext\fts3\fts3_test.c	/^  int nNear;                      \/* Preceding NEAR value *\/$/;"	m	struct:NearPhrase	file:
nNear	.\ext\fts5\fts5_expr.c	/^  int nNear;                      \/* NEAR parameter *\/$/;"	m	struct:Fts5ExprNearset	file:
nNest	.\ext\fts3\fts3_expr.c	/^  int nNest;                          \/* Number of nested brackets *\/$/;"	m	struct:ParseContext	file:
nNode	.\ext\fts3\fts3_write.c	/^  int nNode;                      \/* Size of buffer at aNode (or 0) *\/$/;"	m	struct:Fts3SegReader	file:
nNode	.\ext\fts3\fts3_write.c	/^  int nNode;$/;"	m	struct:NodeReader	file:
nNode	.\ext\misc\json1.c	/^  u32 nNode;         \/* Number of slots of aNode[] used *\/$/;"	m	struct:JsonParse	file:
nNodeSize	.\ext\fts3\fts3Int.h	/^  int nNodeSize;                  \/* Soft limit for node size *\/$/;"	m	struct:Fts3Table
nNtAct	.\tool\lemon.c	/^  int nTknAct, nNtAct;     \/* Number of actions on terminals and nonterminals *\/$/;"	m	struct:state	file:
nOBSat	.\src\select.c	/^  int nOBSat;           \/* Number of ORDER BY terms satisfied by indices *\/$/;"	m	struct:SortCtx	file:
nOBSat	.\src\whereInt.h	/^  i8 nOBSat;                \/* Number of ORDER BY terms satisfied by indices *\/$/;"	m	struct:WhereInfo
nOcc	.\ext\fts3\fts3_aux.c	/^    sqlite3_int64 nOcc;           \/* 'occurrences' values for current csr row *\/$/;"	m	struct:Fts3auxCursor::Fts3auxColstats	file:
nOffset	.\ext\fts1\fts1.c	/^  int nOffset;    \/* strlen(zOffset) *\/$/;"	m	struct:Snippet	file:
nOffset	.\ext\fts2\fts2.c	/^  int nOffset;    \/* strlen(zOffset) *\/$/;"	m	struct:Snippet	file:
nOffsetList	.\ext\fts3\fts3_write.c	/^  int nOffsetList;                \/* For descending pending seg-readers only *\/$/;"	m	struct:Fts3SegReader	file:
nOnce	.\src\sqliteInt.h	/^  int nOnce;           \/* Number of OP_Once instructions so far *\/$/;"	m	struct:Parse
nOnce	.\src\vdbe.h	/^  int nOnce;                    \/* Number of OP_Once instructions *\/$/;"	m	struct:SubProgram
nOnceFlag	.\src\vdbeInt.h	/^  int nOnceFlag;          \/* Number of entries in aOnceFlag *\/$/;"	m	struct:VdbeFrame
nOnceFlag	.\src\vdbeInt.h	/^  int nOnceFlag;          \/* Size of array aOnceFlag[] *\/$/;"	m	struct:Vdbe
nOomBrkpt	.\tool\fuzzershell.c	/^  int nOomBrkpt;                   \/* Number of calls to oomFault() *\/$/;"	m	struct:GlobalVars	file:
nOomFault	.\tool\fuzzershell.c	/^  int nOomFault;                   \/* Increments for each OOM fault *\/$/;"	m	struct:GlobalVars	file:
nOp	.\src\vdbe.h	/^  int nOp;                      \/* Elements in aOp[] *\/$/;"	m	struct:SubProgram
nOp	.\src\vdbeInt.h	/^  int nOp;                \/* Number of instructions in the program *\/$/;"	m	struct:Vdbe
nOp	.\src\vdbeInt.h	/^  int nOp;                \/* Size of aOp array *\/$/;"	m	struct:VdbeFrame
nOpAlloc	.\src\sqliteInt.h	/^  int nOpAlloc;        \/* Number of slots allocated for Vdbe.aOp[] *\/$/;"	m	struct:Parse
nOrig	.\src\pager.c	/^  Pgno nOrig;                  \/* Original number of pages in file *\/$/;"	m	struct:PagerSavepoint	file:
nOther	.\src\expr.c	/^  int nOther;      \/* Number of references to columns in other FROM clauses *\/$/;"	m	struct:SrcCount	file:
nOut	.\src\sqliteInt.h	/^  int nOut;               \/* Number of buffers currently checked out *\/$/;"	m	struct:Lookaside
nOut	.\src\whereInt.h	/^  LogEst nOut;          \/* Estimated number of output rows *\/$/;"	m	struct:WhereLoop
nOut	.\src\whereInt.h	/^  LogEst nOut;        \/* Number of outputs for this subquery *\/$/;"	m	struct:WhereOrCost
nOutput	.\ext\fts5\fts5_tokenize.c	/^  int nOutput;$/;"	m	struct:PorterRule	file:
nOverflow	.\src\btreeInt.h	/^  u8 nOverflow;        \/* Number of overflow cell bodies in aCell[] *\/$/;"	m	struct:MemPage
nOvfl	.\ext\fts3\fts3.c	/^  int nOvfl;                      \/* Number of overflow pages to load doclist *\/$/;"	m	struct:Fts3TokenAndCost	file:
nOvfl	.\src\dbstat.c	/^  int nOvfl;                      \/* Entries in aOvfl[] *\/$/;"	m	struct:StatCell	file:
nOvflAlloc	.\src\btreeInt.h	/^  int nOvflAlloc;           \/* Allocated size of aOverflow[] array *\/$/;"	m	struct:BtCursor
nPMA	.\src\vdbesort.c	/^  int nPMA;                       \/* Number of PMAs currently in file *\/$/;"	m	struct:SortSubtask	file:
nPSample	.\src\analyze.c	/^  tRowcnt nPSample;         \/* How often to do a periodic sample *\/$/;"	m	struct:Stat4Accum	file:
nPage	.\src\btreeInt.h	/^  Pgno nPage;       \/* Number of pages in the database *\/$/;"	m	struct:IntegrityCk
nPage	.\src\btreeInt.h	/^  u32 nPage;            \/* Number of pages in the database *\/$/;"	m	struct:BtShared
nPage	.\src\pcache1.c	/^  unsigned int nPage;                 \/* Total number of pages in apHash *\/$/;"	m	struct:PCache1	file:
nPage	.\src\sqliteInt.h	/^  int nPage;                        \/* Number of pages in pPage[] *\/$/;"	m	struct:Sqlite3Config
nPage	.\src\test_journal.c	/^  u32 nPage;               \/* Size of file in pages when transaction started *\/$/;"	m	struct:jt_file	file:
nPage	.\src\wal.c	/^  u32 nPage;                      \/* Size of database in pages *\/$/;"	m	struct:WalIndexHdr	file:
nPagecount	.\src\backup.c	/^  Pgno nPagecount;         \/* Total number of pages to copy *\/$/;"	m	struct:sqlite3_backup	file:
nPagesize	.\src\test_journal.c	/^  u32 nPagesize;           \/* Page size when transaction started *\/$/;"	m	struct:jt_file	file:
nParam	.\ext\rtree\rtree.c	/^  int nParam;                 \/* Number of parameters to the SQL function *\/$/;"	m	struct:RtreeMatchArg	file:
nParam	.\ext\rtree\sqlite3rtree.h	/^  int nParam;                       \/* Number of function parameters *\/$/;"	m	struct:sqlite3_rtree_query_info
nParam	.\ext\rtree\sqlite3rtree.h	/^  int nParam;                     \/* Size of array aParam[] *\/$/;"	m	struct:sqlite3_rtree_geometry
nParm	.\src\tclsqlite.c	/^  int nParm;               \/* Size of apParm array *\/$/;"	m	struct:SqlPreparedStmt	file:
nPattern	.\ext\misc\spellfix.c	/^  int nPattern;                    \/* Length of zPattern *\/$/;"	m	struct:MatchQuery	file:
nPayload	.\src\btreeInt.h	/^  u32 nPayload;  \/* Bytes of payload *\/$/;"	m	struct:CellInfo
nPayload	.\src\dbstat.c	/^  int nPayload;                   \/* Value of 'payload' column *\/$/;"	m	struct:StatCursor	file:
nPendingData	.\ext\fts2\fts2.c	/^  int nPendingData;$/;"	m	struct:fulltext_vtab	file:
nPendingData	.\ext\fts3\fts3Int.h	/^  int nPendingData;               \/* Current bytes of pending data *\/$/;"	m	struct:Fts3Table
nPendingData	.\ext\fts5\fts5_index.c	/^  int nPendingData;               \/* Current bytes of pending data *\/$/;"	m	struct:Fts5Index	file:
nPgsz	.\ext\fts3\fts3Int.h	/^  int nPgsz;                      \/* Page size for host database *\/$/;"	m	struct:Fts3Table
nPhrase	.\ext\fts1\fts1.c	/^  short int nPhrase; \/* How many following terms are part of the same phrase *\/$/;"	m	struct:QueryTerm	file:
nPhrase	.\ext\fts2\fts2.c	/^  short int nPhrase; \/* How many following terms are part of the same phrase *\/$/;"	m	struct:QueryTerm	file:
nPhrase	.\ext\fts3\fts3Int.h	/^  int nPhrase;                    \/* Number of matchable phrases in query *\/$/;"	m	struct:Fts3Cursor
nPhrase	.\ext\fts3\fts3_snippet.c	/^  int nPhrase;                    \/* Number of matchable phrases in query *\/$/;"	m	struct:MatchInfo	file:
nPhrase	.\ext\fts3\fts3_snippet.c	/^  int nPhrase;                    \/* Number of phrases in query *\/$/;"	m	struct:SnippetIter	file:
nPhrase	.\ext\fts3\fts3_snippet.c	/^  int nPhrase;                    \/* Number of phrases seen so far *\/$/;"	m	struct:LoadDoclistCtx	file:
nPhrase	.\ext\fts5\fts5_aux.c	/^  int nPhrase;                    \/* Number of phrases in query *\/$/;"	m	struct:Fts5Bm25Data	file:
nPhrase	.\ext\fts5\fts5_expr.c	/^  int nPhrase;                    \/* Number of entries in aPhrase[] array *\/$/;"	m	struct:Fts5ExprNearset	file:
nPhrase	.\ext\fts5\fts5_expr.c	/^  int nPhrase;                    \/* Number of phrases in expression *\/$/;"	m	struct:Fts5Expr	file:
nPhrase	.\ext\fts5\fts5_expr.c	/^  int nPhrase;                    \/* Size of apPhrase array *\/$/;"	m	struct:Fts5Parse	file:
nPhrase	.\ext\fts5\fts5_test_mi.c	/^  int nPhrase;                    \/* Number of phrases in FTS5 query *\/$/;"	m	struct:Fts5MatchinfoCtx	file:
nPinned	.\src\test_pcache.c	/^  int nPinned;              \/* Number of pinned slots in a[] *\/$/;"	m	struct:testpcache	file:
nPoint	.\ext\rtree\rtree.c	/^  int nPoint;                       \/* Number of slots used in aPoint[] *\/$/;"	m	struct:RtreeCursor	file:
nPointAlloc	.\ext\rtree\rtree.c	/^  int nPointAlloc;                  \/* Number of slots allocated for aPoint[] *\/$/;"	m	struct:RtreeCursor	file:
nPool	.\src\mem3.c	/^  u32 nPool;$/;"	m	struct:Mem3Global	file:
nPopulate	.\ext\fts3\fts3_write.c	/^  int nPopulate;                  \/* If >0, bytes of buffer aNode[] loaded *\/$/;"	m	struct:Fts3SegReader	file:
nPos	.\ext\fts5\fts5_index.c	/^  int nPos;                       \/* Number of bytes in current position list *\/$/;"	m	struct:Fts5SegIter	file:
nPoslist	.\ext\fts5\fts5_index.c	/^  int nPoslist;$/;"	m	struct:Fts5DoclistIter	file:
nPrefix	.\ext\fts3\fts3Int.h	/^    int nPrefix;                  \/* Prefix length (0 for main terms index) *\/$/;"	m	struct:Fts3Table::Fts3Index
nPrefix	.\ext\fts5\fts5Int.h	/^  int nPrefix;                    \/* Number of prefix indexes *\/$/;"	m	struct:Fts5Config
nPrefix	.\ext\misc\nextchar.c	/^  int nPrefix;                      \/* Size of zPrefix in bytes *\/$/;"	m	struct:nextCharContext	file:
nProgress	.\ext\rbu\sqlite3rbu.c	/^  i64 nProgress;$/;"	m	struct:RbuState	file:
nProgress	.\ext\rbu\sqlite3rbu.c	/^  int nProgress;                  \/* Rows processed for all objects *\/$/;"	m	struct:sqlite3rbu	file:
nProgressOps	.\src\sqliteInt.h	/^  unsigned nProgressOps;        \/* Number of opcodes for progress callback *\/$/;"	m	struct:sqlite3
nQueryLoop	.\src\sqliteInt.h	/^  u32 nQueryLoop;      \/* Est number of iterations of a query (10*log2(N)) *\/$/;"	m	struct:Parse
nRangeReg	.\src\sqliteInt.h	/^  int nRangeReg;       \/* Size of the temporary register block *\/$/;"	m	struct:Parse
nRankArg	.\ext\fts5\fts5_main.c	/^  int nRankArg;                   \/* Number of trailing arguments for rank() *\/$/;"	m	struct:Fts5Cursor	file:
nRead	.\ext\fts5\fts5_index.c	/^  int nRead;                      \/* Total number of blocks read *\/$/;"	m	struct:Fts5Index	file:
nRead	.\src\pager.c	/^  int nRead;                  \/* Database pages read *\/$/;"	m	struct:Pager	file:
nReaders	.\src\os_win.c	/^  int nReaders;       \/* Number of reader locks obtained *\/$/;"	m	struct:winceLock	file:
nReal	.\src\test_multiplex.c	/^  int nReal;                       \/* Number of chunks *\/$/;"	m	struct:multiplexGroup	file:
nRec	.\src\pager.c	/^  int nRec;                   \/* Pages journalled since last j-header written *\/$/;"	m	struct:Pager	file:
nRecValid	.\src\whereInt.h	/^  int nRecValid;            \/* Number of valid fields currently in pRec *\/$/;"	m	struct:WhereLoopBuilder
nRecyclable	.\src\pcache1.c	/^  unsigned int nRecyclable;           \/* Number of pages in the LRU list *\/$/;"	m	struct:PCache1	file:
nRef	.\ext\fts5\fts5_index.c	/^  int nRef;                       \/* Object reference count *\/$/;"	m	struct:Fts5Structure	file:
nRef	.\ext\misc\vfslog.c	/^  int nRef;                       \/* Number of references to this object *\/$/;"	m	struct:VLogLog	file:
nRef	.\ext\rtree\rtree.c	/^  int nRef;                   \/* Number of references to this node *\/$/;"	m	struct:RtreeNode	file:
nRef	.\src\btreeInt.h	/^  int nRef;             \/* Number of references to this structure *\/$/;"	m	struct:BtShared
nRef	.\src\mutex_unix.c	/^  volatile int nRef;         \/* Number of entrances *\/$/;"	m	struct:sqlite3_mutex	file:
nRef	.\src\mutex_w32.c	/^  volatile int nRef;         \/* Number of enterances *\/$/;"	m	struct:sqlite3_mutex	file:
nRef	.\src\os_unix.c	/^  int nRef;                       \/* Number of pointers to this structure *\/$/;"	m	struct:unixInodeInfo	file:
nRef	.\src\os_unix.c	/^  int nRef;                     \/* Number of references to this one *\/$/;"	m	struct:vxworksFileId	file:
nRef	.\src\os_unix.c	/^  int nRef;                  \/* Number of unixShm objects pointing to this *\/$/;"	m	struct:unixShmNode	file:
nRef	.\src\os_win.c	/^  int nRef;                  \/* Number of winShm objects pointing to this *\/$/;"	m	struct:winShmNode	file:
nRef	.\src\pcache.h	/^  i16 nRef;                      \/* Number of users of this page *\/$/;"	m	struct:PgHdr
nRef	.\src\sqliteInt.h	/^  int nRef;                 \/* Number of pointers to this structure *\/$/;"	m	struct:VTable
nRef	.\src\sqliteInt.h	/^  int nRef;            \/* Number of names resolved by this context *\/$/;"	m	struct:NameContext
nRef	.\src\sqliteInt.h	/^  int nRef;$/;"	m	struct:FuncDestructor
nRef	.\src\sqliteInt.h	/^  u16 nRef;            \/* Number of pointers to this Table *\/$/;"	m	struct:Table
nRef	.\src\sqliteInt.h	/^  u32 nRef;           \/* Number of references to this KeyInfo object *\/$/;"	m	struct:KeyInfo
nRef	.\src\test_onefile.c	/^  int nRef;                   \/* Number of pointers to this structure *\/$/;"	m	struct:fs_real_file	file:
nRef	.\src\test_quota.c	/^  int nRef;                       \/* Number of times this file is open *\/$/;"	m	struct:quotaFile	file:
nRef	.\test\fuzzcheck.c	/^  int nRef;               \/* Number of references to this file *\/$/;"	m	struct:VFile	file:
nRefInitMutex	.\src\sqliteInt.h	/^  int nRefInitMutex;                \/* Number of users of pInitMutex *\/$/;"	m	struct:Sqlite3Config
nRefSqlite3	.\src\test3.c	/^static int nRefSqlite3 = 0;$/;"	v	file:
nRefSum	.\src\pcache.c	/^  int nRefSum;                        \/* Sum of ref counts over all pages *\/$/;"	m	struct:PCache	file:
nRegion	.\src\os_unix.c	/^  u16 nRegion;               \/* Size of array apRegion *\/$/;"	m	struct:unixShmNode	file:
nRegion	.\src\os_win.c	/^  int nRegion;               \/* Size of array apRegion *\/$/;"	m	struct:winShmNode	file:
nRemaining	.\src\backup.c	/^  Pgno nRemaining;         \/* Number of pages left to copy *\/$/;"	m	struct:sqlite3_backup	file:
nRepeat	.\src\test_malloc.c	/^  int nRepeat;            \/* Number of times to repeat the failure *\/$/;"	m	struct:MemFault	file:
nReply	.\tool\rollback-test.c	/^static int nReply = 0;$/;"	v	file:
nResColumn	.\src\vdbeInt.h	/^  u16 nResColumn;         \/* Number of columns in one row of the result set *\/$/;"	m	struct:Vdbe
nReserve	.\src\pager.c	/^  i16 nReserve;               \/* Number of unused bytes at end of each page *\/$/;"	m	struct:Pager	file:
nReserve	.\src\pcache1.c	/^  int nReserve;                  \/* Try to keep nFreeSlot above this *\/$/;"	m	struct:PCacheGlobal	file:
nResult	.\test\speedtest1.c	/^  int nResult;               \/* Size of the current result *\/$/;"	m	struct:Global	file:
nRet	.\ext\fts5\fts5_test_mi.c	/^  int nRet;                       \/* Number of elements in aRet[] *\/$/;"	m	struct:Fts5MatchinfoCtx	file:
nRow	.\ext\misc\spellfix.c	/^  int nRow;                    \/* Number of rows of content *\/$/;"	m	struct:spellfix1_cursor	file:
nRow	.\ext\rbu\sqlite3rbu.c	/^  int nRow;$/;"	m	struct:RbuState	file:
nRow	.\src\analyze.c	/^  tRowcnt nRow;             \/* Number of rows in the entire table *\/$/;"	m	struct:Stat4Accum	file:
nRow	.\src\table.c	/^  u32 nRow;          \/* Number of rows in the result *\/$/;"	m	struct:TabResult	file:
nRow	.\src\whereInt.h	/^  LogEst nRow;          \/* Estimated number of rows generated by this path *\/$/;"	m	struct:WherePath
nRowAvg	.\ext\fts3\fts3Int.h	/^  int nRowAvg;                    \/* Average size of database rows, in pages *\/$/;"	m	struct:Fts3Cursor
nRowEst	.\ext\rtree\rtree.c	/^  i64 nRowEst;                \/* Estimated number of rows in this table *\/$/;"	m	struct:Rtree	file:
nRowEst0	.\src\sqliteInt.h	/^  tRowcnt nRowEst0;        \/* Non-logarithmic number of rows in the index *\/$/;"	m	struct:Index
nRowLogEst	.\src\sqliteInt.h	/^  LogEst nRowLogEst;   \/* Estimated rows in table - from sqlite_stat1 table *\/$/;"	m	struct:Table
nRowOut	.\src\whereInt.h	/^  LogEst nRowOut;           \/* Estimated number of output rows *\/$/;"	m	struct:WhereInfo
nRowPerTrans	.\tool\loadfts.c	/^  int nRowPerTrans;$/;"	m	struct:VisitContext	file:
nRowid	.\src\analyze.c	/^  u32 nRowid;                     \/* Sizeof aRowid[] *\/$/;"	m	struct:Stat4Sample	file:
nRowidOffset	.\ext\fts5\fts5_index.c	/^  int nRowidOffset;               \/* Allocated size of aRowidOffset[] array *\/$/;"	m	struct:Fts5SegIter	file:
nRun	.\ext\misc\spellfix.c	/^  int nRun;                  \/* Number of prior runs for the same zPattern *\/$/;"	m	struct:MatchQuery	file:
nSample	.\src\analyze.c	/^  int nSample;              \/* Current number of samples *\/$/;"	m	struct:Stat4Accum	file:
nSample	.\src\sqliteInt.h	/^  int nSample;             \/* Number of elements in aSample[] *\/$/;"	m	struct:Index
nSampleCol	.\src\sqliteInt.h	/^  int nSampleCol;          \/* Size of IndexSample.anEq[] and so on *\/$/;"	m	struct:Index
nSavepoint	.\src\pager.c	/^  int nSavepoint;             \/* Number of elements in aSavepoint[] *\/$/;"	m	struct:Pager	file:
nSavepoint	.\src\sqliteInt.h	/^  int nSavepoint;               \/* Number of non-transaction savepoints *\/$/;"	m	struct:sqlite3
nScan	.\src\vdbeInt.h	/^  int nScan;              \/* Entries in aScan[] *\/$/;"	m	struct:Vdbe
nScratch	.\src\sqliteInt.h	/^  int nScratch;                     \/* Number of scratch buffers *\/$/;"	m	struct:Sqlite3Config
nScratchFree	.\src\malloc.c	/^  u32 nScratchFree;$/;"	m	struct:Mem0Global	file:
nSdst	.\src\sqliteInt.h	/^  int nSdst;           \/* Number of registers allocated *\/$/;"	m	struct:SelectDest
nSearch	.\ext\misc\spellfix.c	/^  int nSearch;                 \/* Number of vocabulary items checked *\/$/;"	m	struct:spellfix1_cursor	file:
nSeg	.\ext\fts5\fts5_index.c	/^  int nSeg;                       \/* Size of aSeg[] array *\/$/;"	m	struct:Fts5IndexIter	file:
nSeg	.\ext\fts5\fts5_index.c	/^  int nSeg;                       \/* Total number of segments on level *\/$/;"	m	struct:Fts5StructureLevel	file:
nSegment	.\ext\fts3\fts3Int.h	/^  int nSegment;                   \/* Size of apSegment array *\/$/;"	m	struct:Fts3MultiSegReader
nSegment	.\ext\fts5\fts5_index.c	/^  int nSegment;                   \/* Total segments in this structure *\/$/;"	m	struct:Fts5Structure	file:
nSegment	.\src\wal.c	/^  int nSegment;                   \/* Number of entries in aSegment[] *\/$/;"	m	struct:WalIterator	file:
nSelect	.\src\sqliteInt.h	/^  int nSelect;         \/* Number of SELECT statements seen *\/$/;"	m	struct:Parse
nSelectIndent	.\src\sqliteInt.h	/^  int nSelectIndent;   \/* How far to indent SELECTTRACE() output *\/$/;"	m	struct:Parse
nSelectRow	.\src\sqliteInt.h	/^  u64 nSelectRow;        \/* Estimated number of result rows *\/$/;"	m	struct:Select
nServer	.\src\test7.c	/^  int nServer;             \/* Number of server threads running *\/$/;"	m	struct:Thread	file:
nSet	.\src\bitvec.c	/^  u32 nSet;       \/* Number of bits that are set - only valid for aHash$/;"	m	struct:Bitvec	file:
nSet	.\src\sqliteInt.h	/^  int nSet;            \/* Number of sets used so far *\/$/;"	m	struct:Parse
nShared	.\src\os_unix.c	/^  int nShared;                    \/* Number of SHARED locks held *\/$/;"	m	struct:unixInodeInfo	file:
nShm	.\ext\rbu\sqlite3rbu.c	/^  int nShm;                       \/* Number of entries in apShm[] array *\/$/;"	m	struct:rbu_file	file:
nSize	.\ext\fts3\fts3_write.c	/^  int nSize;                      \/* Size of allocation at aData *\/$/;"	m	struct:SegmentWriter	file:
nSize	.\ext\fts5\fts5_index.c	/^  int nSize;$/;"	m	struct:Fts5DoclistIter	file:
nSize	.\src\btreeInt.h	/^  u16 nSize;     \/* Size of the cell content on the main b-tree page *\/$/;"	m	struct:CellInfo
nSize	.\src\test_onefile.c	/^  int nSize;$/;"	m	struct:tmp_file	file:
nSkip	.\src\whereInt.h	/^  u16 nSkip;            \/* Number of NULL aLTerm[] entries *\/$/;"	m	struct:WhereLoop
nSlot	.\ext\fts5\fts5_hash.c	/^  int nSlot;                      \/* Size of aSlot[] array *\/$/;"	m	struct:Fts5Hash	file:
nSlot	.\src\pcache1.c	/^  int nSlot;                     \/* The number of pcache slots *\/$/;"	m	struct:PCacheGlobal	file:
nSlot	.\src\whereInt.h	/^  int nSlot;               \/* Number of entries in a[] *\/$/;"	m	struct:WhereClause
nSnippet	.\ext\fts1\fts1.c	/^  int nSnippet;   \/* strlen(zSnippet) *\/$/;"	m	struct:Snippet	file:
nSnippet	.\ext\fts2\fts2.c	/^  int nSnippet;   \/* strlen(zSnippet) *\/$/;"	m	struct:Snippet	file:
nSnippet	.\ext\fts3\fts3_snippet.c	/^  int nSnippet;                   \/* Requested snippet length (in tokens) *\/$/;"	m	struct:SnippetIter	file:
nSort	.\src\tclsqlite.c	/^  int nStep, nSort, nIndex;  \/* Statistics for most recent operation *\/$/;"	m	struct:SqliteDb	file:
nSortingColumn	.\src\sqliteInt.h	/^  int nSortingColumn;     \/* Number of columns in the sorting index *\/$/;"	m	struct:AggInfo
nSpace	.\ext\fts3\fts3_write.c	/^  int nSpace;$/;"	m	struct:PendingList	file:
nSpace	.\ext\fts5\fts5Int.h	/^  int nSpace;$/;"	m	struct:Fts5Buffer
nSql	.\src\tclsqlite.c	/^  int nSql;                \/* chars in zSql[] *\/$/;"	m	struct:SqlPreparedStmt	file:
nSql	.\test\fuzzcheck.c	/^  int nSql;                        \/* Number of SQL scripts *\/$/;"	m	struct:GlobalVars	file:
nSrc	.\src\sqliteInt.h	/^  int nSrc;        \/* Number of tables or subqueries in the FROM clause *\/$/;"	m	struct:SrcList
nStack	.\tool\offsets.c	/^  int nStack;           \/* Depth of stack *\/$/;"	m	struct:GState	file:
nStat	.\ext\fts3\fts3_aux.c	/^  int nStat;                      \/* Size of aStat[] array *\/$/;"	m	struct:Fts3auxCursor	file:
nState	.\ext\misc\regexp.c	/^  unsigned nState;            \/* Number of current states *\/$/;"	m	struct:ReStateSet	file:
nState	.\ext\misc\regexp.c	/^  unsigned nState;            \/* Number of entries in aOp[] and aArg[] *\/$/;"	m	struct:ReCompiled	file:
nStatement	.\src\sqliteInt.h	/^  int nStatement;               \/* Number of nested statement-transactions  *\/$/;"	m	struct:sqlite3
nStem	.\ext\misc\fuzzer.c	/^  int nStem;                 \/* Number of stems allocated *\/$/;"	m	struct:fuzzer_cursor	file:
nStep	.\ext\rbu\sqlite3rbu.c	/^  int nStep;                      \/* Rows processed for current object *\/$/;"	m	struct:sqlite3rbu	file:
nStep	.\src\tclsqlite.c	/^  int nStep, nSort, nIndex;  \/* Statistics for most recent operation *\/$/;"	m	struct:SqliteDb	file:
nStmt	.\src\tclsqlite.c	/^  int nStmt;                 \/* Number of statements in stmtList *\/$/;"	m	struct:SqliteDb	file:
nStmtDefCons	.\src\vdbeInt.h	/^  i64 nStmtDefCons;       \/* Number of def. constraints when stmt started *\/$/;"	m	struct:Vdbe
nStmtDefImmCons	.\src\vdbeInt.h	/^  i64 nStmtDefImmCons;    \/* Number of def. imm constraints when stmt started *\/$/;"	m	struct:Vdbe
nStop	.\ext\fts3\fts3_aux.c	/^  int nStop;                      \/* Byte-length of string zStop *\/$/;"	m	struct:Fts3auxCursor	file:
nSub	.\src\vdbeaux.c	/^  int nSub;                  \/* Number of entries in apSub *\/$/;"	m	struct:VdbeOpIter	file:
nSubRec	.\src\pager.c	/^  u32 nSubRec;                \/* Number of records written to sub-journal *\/$/;"	m	struct:Pager	file:
nSubst	.\ext\misc\spellfix.c	/^  int nSubst;              \/* Number of substitution cost entries *\/$/;"	m	struct:EditDist3From	file:
nSuffix	.\ext\fts5\fts5_tokenize.c	/^  int nSuffix;$/;"	m	struct:PorterRule	file:
nSync	.\src\test_journal.c	/^  int nSync;               \/* Number of times journal file has been synced *\/$/;"	m	struct:jt_file	file:
nTab	.\src\sqliteInt.h	/^  int nTab;            \/* Number of previously allocated VDBE cursors *\/$/;"	m	struct:Parse
nTableLock	.\src\sqliteInt.h	/^  int nTableLock;        \/* Number of locks in aTableLock *\/$/;"	m	struct:Parse
nTask	.\src\vdbesort.c	/^  u8 nTask;                       \/* Size of aTask[] array *\/$/;"	m	struct:VdbeSorter	file:
nTblCol	.\ext\rbu\sqlite3rbu.c	/^  int nTblCol;                    \/* Size of azTblCol[] array *\/$/;"	m	struct:RbuObjIter	file:
nTempReg	.\src\sqliteInt.h	/^  u8 nTempReg;         \/* Number of temporary registers in aTempReg[] *\/$/;"	m	struct:Parse
nTerm	.\ext\fts1\fts1.c	/^  int nTerm;         \/* Number of bytes in pTerm[] *\/$/;"	m	struct:QueryTerm	file:
nTerm	.\ext\fts2\fts2.c	/^  int nTerm;         \/* Number of bytes in pTerm[] *\/$/;"	m	struct:QueryTerm	file:
nTerm	.\ext\fts2\fts2.c	/^  int nTerm;$/;"	m	struct:TermData	file:
nTerm	.\ext\fts3\fts3Int.h	/^  int nTerm;                      \/* Size of zTerm in bytes *\/$/;"	m	struct:Fts3MultiSegReader
nTerm	.\ext\fts3\fts3Int.h	/^  int nTerm;$/;"	m	struct:Fts3SegFilter
nTerm	.\ext\fts3\fts3_write.c	/^  int nTerm;                      \/* Number of bytes in current term *\/$/;"	m	struct:Fts3SegReader	file:
nTerm	.\ext\fts3\fts3_write.c	/^  int nTerm;                      \/* Number of bytes in zTerm *\/$/;"	m	struct:SegmentNode	file:
nTerm	.\ext\fts3\fts3_write.c	/^  int nTerm;                      \/* Number of bytes in zTerm *\/$/;"	m	struct:SegmentWriter	file:
nTerm	.\ext\fts5\fts5_expr.c	/^  int nTerm;                      \/* Number of entries in aTerm[] *\/$/;"	m	struct:Fts5ExprPhrase	file:
nTerm	.\ext\fts5\fts5_main.c	/^  int nTerm;                      \/* Size of phrase in terms *\/$/;"	m	struct:Fts5MatchPhrase	file:
nTerm	.\src\whereInt.h	/^  int nTerm;               \/* Number of terms *\/$/;"	m	struct:WhereClause
nTermAlloc	.\ext\fts3\fts3_write.c	/^  int nTermAlloc;                 \/* Allocated size of zTerm buffer *\/$/;"	m	struct:Fts3SegReader	file:
nTermDistinct	.\ext\fts2\fts2.c	/^  int nTermDistinct;$/;"	m	struct:LeafWriter	file:
nTerms	.\ext\fts1\fts1.c	/^  int nTerms;           \/* Number of terms in the query *\/$/;"	m	struct:Query	file:
nTerms	.\ext\fts1\fulltext.c	/^  int nTerms;$/;"	m	struct:Query	file:
nTerms	.\ext\fts2\fts2.c	/^  int nTerms;           \/* Number of terms in the query *\/$/;"	m	struct:Query	file:
nTest	.\mptest\mptest.c	/^  int nTest;             \/* Number of --match operators *\/$/;"	m	struct:Global	file:
nTest	.\test\threadtest4.c	/^  int nTest;                  \/* Number of tests run by this thread *\/$/;"	m	struct:WorkerInfo	file:
nText	.\test\threadtest3.c	/^  int nText;                      \/* Size of array at aText[] *\/$/;"	m	struct:Sqlite	file:
nThis	.\src\expr.c	/^  int nThis;       \/* Number of references to columns in pSrcList *\/$/;"	m	struct:SrcCount	file:
nTitle	.\src\mem2.c	/^  int nTitle;        \/* Bytes of zTitle to save.  Includes '\\0' and padding *\/$/;"	m	struct:__anon10	file:
nTitle	.\src\mem2.c	/^  u8 nTitle;                          \/* Bytes of title; includes '\\0' *\/$/;"	m	struct:MemBlockHdr	file:
nTknAct	.\tool\lemon.c	/^  int nTknAct, nNtAct;     \/* Number of actions on terminals and nonterminals *\/$/;"	m	struct:state	file:
nTo	.\ext\misc\amatch.c	/^  amatch_len nFrom, nTo;   \/* Length of the zFrom and zTo strings *\/$/;"	m	struct:amatch_rule	file:
nTo	.\ext\misc\fuzzer.c	/^  fuzzer_len nFrom, nTo;      \/* Length of the zFrom and zTo strings *\/$/;"	m	struct:fuzzer_rule	file:
nTo	.\ext\misc\spellfix.c	/^  u8 nTo;                   \/* Number of bytes in aTo *\/$/;"	m	struct:EditDist3Cost	file:
nToken	.\ext\fts3\fts3Int.h	/^  int nToken;                \/* Number of tokens in the phrase *\/$/;"	m	struct:Fts3Phrase
nToken	.\ext\fts3\fts3_snippet.c	/^  int nToken;                     \/* Number of tokens in phrase *\/$/;"	m	struct:SnippetPhrase	file:
nToken	.\ext\fts3\fts3_snippet.c	/^  int nToken;                     \/* Number of tokens seen so far *\/$/;"	m	struct:LoadDoclistCtx	file:
nToken	.\ext\fts3\fts3_test.c	/^  int nToken;                     \/* Length of token in bytes *\/$/;"	m	struct:NearDocument	file:
nToken	.\ext\fts3\fts3_test.c	/^  int nToken;                     \/* Number of tokens in this phrase *\/$/;"	m	struct:NearPhrase	file:
nToken	.\ext\fts3\fts3_tokenize_vtab.c	/^  int nToken;                     \/* Size of zToken in bytes *\/$/;"	m	struct:Fts3tokCursor	file:
nTokenAllocated	.\ext\fts1\fts1_tokenizer1.c	/^  int nTokenAllocated;         \/* space allocated to zToken buffer *\/$/;"	m	struct:simple_tokenizer_cursor	file:
nTokenAllocated	.\ext\fts1\simple_tokenizer.c	/^  int nTokenAllocated;         \/* space allocated to zToken buffer *\/$/;"	m	struct:simple_tokenizer_cursor	file:
nTokenAllocated	.\ext\fts2\fts2_tokenizer1.c	/^  int nTokenAllocated;         \/* space allocated to zToken buffer *\/$/;"	m	struct:simple_tokenizer_cursor	file:
nTokenAllocated	.\ext\fts3\fts3_tokenizer1.c	/^  int nTokenAllocated;         \/* space allocated to zToken buffer *\/$/;"	m	struct:simple_tokenizer_cursor	file:
nTokenBytes	.\ext\fts1\simple_tokenizer.c	/^  int nTokenBytes;             \/* actual size of current token *\/$/;"	m	struct:simple_tokenizer_cursor	file:
nTotalChange	.\src\sqliteInt.h	/^  int nTotalChange;             \/* Value returned by sqlite3_total_changes() *\/$/;"	m	struct:sqlite3
nTotalRow	.\ext\fts5\fts5_storage.c	/^  i64 nTotalRow;                  \/* Total number of rows in FTS table *\/$/;"	m	struct:Fts5Storage	file:
nTransaction	.\src\btreeInt.h	/^  int nTransaction;     \/* Number of open transactions (read + write) *\/$/;"	m	struct:BtShared
nTransaction	.\src\tclsqlite.c	/^  int nTransaction;          \/* Number of nested [transaction] methods *\/$/;"	m	struct:SqliteDb	file:
nTree	.\src\vdbesort.c	/^  int nTree;                 \/* Used size of aTree\/aReadr (power of 2) *\/$/;"	m	struct:MergeEngine	file:
nUnused	.\src\dbstat.c	/^  int nUnused;                    \/* Number of unused bytes on page *\/$/;"	m	struct:StatPage	file:
nUnused	.\src\dbstat.c	/^  int nUnused;                    \/* Value of 'unused' column *\/$/;"	m	struct:StatCursor	file:
nUsed	.\ext\misc\eval.c	/^  sqlite3_int64 nUsed;   \/* Number of bytes of z[] actually used *\/$/;"	m	struct:EvalResult	file:
nUsed	.\ext\misc\json1.c	/^  u64 nUsed;               \/* Bytes of zBuf[] currently used *\/$/;"	m	struct:JsonString	file:
nUsed	.\ext\misc\nextchar.c	/^  int nUsed;                        \/* Space used in aResult *\/$/;"	m	struct:nextCharContext	file:
nUsed	.\ext\misc\percentile.c	/^  unsigned nUsed;      \/* Number of slots actually used in a[] *\/$/;"	m	struct:Percentile	file:
nUsed	.\src\sqliteInt.h	/^  int nUsed;               \/* Number of arguments used so far *\/$/;"	m	struct:PrintfArguments
nUsed	.\src\test1.c	/^  int nUsed;   \/* Space used *\/$/;"	m	struct:dstr	file:
nUsed	.\tool\fuzzershell.c	/^  sqlite3_int64 nUsed;   \/* Number of bytes of z[] actually used *\/$/;"	m	struct:EvalResult	file:
nUsed	.\tool\sqldiff.c	/^  int nUsed;      \/* Bytes actually used in z[] *\/$/;"	m	struct:Str	file:
nVDestroy	.\src\sqliteInt.h	/^  int nVDestroy;                \/* Number of active OP_VDestroy operations *\/$/;"	m	struct:sqlite3
nVTrans	.\src\sqliteInt.h	/^  int nVTrans;                  \/* Allocated size of aVTrans *\/$/;"	m	struct:sqlite3
nVal	.\src\vdbesort.c	/^  int nVal;                       \/* Size of the record in bytes *\/$/;"	m	struct:SorterRecord	file:
nVar	.\src\sqliteInt.h	/^  int nVar;                 \/* Number of '?' variables seen in the SQL so far *\/$/;"	m	struct:Parse
nVar	.\src\vdbeInt.h	/^  ynVar nVar;             \/* Number of entries in aVar[] *\/$/;"	m	struct:Vdbe
nVdbeActive	.\src\sqliteInt.h	/^  int nVdbeActive;              \/* Number of VDBEs currently running *\/$/;"	m	struct:sqlite3
nVdbeExec	.\src\sqliteInt.h	/^  int nVdbeExec;                \/* Number of nested calls to VdbeExec() *\/$/;"	m	struct:sqlite3
nVdbeRead	.\src\sqliteInt.h	/^  int nVdbeRead;                \/* Number of active VDBEs that read or write *\/$/;"	m	struct:sqlite3
nVdbeWrite	.\src\sqliteInt.h	/^  int nVdbeWrite;               \/* Number of active VDBEs that read and write *\/$/;"	m	struct:sqlite3
nVfs	.\src\test1.c	/^static int nVfs = 0;$/;"	v	file:
nVtabLock	.\src\sqliteInt.h	/^  int nVtabLock;            \/* Number of virtual tables to lock *\/$/;"	m	struct:Parse
nWiData	.\src\wal.c	/^  int nWiData;               \/* Size of array apWiData *\/$/;"	m	struct:Wal	file:
nWord	.\ext\misc\amatch.c	/^  int nWord;                 \/* Number of amatch_word objects *\/$/;"	m	struct:amatch_cursor	file:
nWork	.\ext\fts3\fts3_write.c	/^  int nWork;                      \/* Number of leaf pages flushed *\/$/;"	m	struct:IncrmergeWriter	file:
nWorkUnit	.\ext\fts5\fts5_index.c	/^  int nWorkUnit;                  \/* Leaf pages in a "unit" of work *\/$/;"	m	struct:Fts5Index	file:
nWorker	.\src\vdbesort.c	1017;"	d	file:
nWorker	.\src\vdbesort.c	941;"	d	file:
nWorker	.\test\threadtest4.c	/^  int nWorker;                \/* Total number of workers *\/$/;"	m	struct:WorkerInfo	file:
nWriteCounter	.\ext\fts5\fts5_index.c	/^  u64 nWriteCounter;              \/* Total leaves written to level 0 *\/$/;"	m	struct:Fts5Structure	file:
nXField	.\src\sqliteInt.h	/^  u16 nXField;        \/* Number of columns beyond the key columns *\/$/;"	m	struct:KeyInfo
nZero	.\src\vdbeInt.h	/^    int nZero;          \/* Used when bit MEM_Zero is set in flags *\/$/;"	m	union:Mem::MemValue
nactiontab	.\tool\lemon.c	/^  int nactiontab;          \/* Number of entries in the yy_action[] table *\/$/;"	m	struct:lemon	file:
name	.\tool\lemon.c	/^  char *name;              \/* Name of the generated parser *\/$/;"	m	struct:lemon	file:
name	.\tool\lemon.c	/^  const char *name;        \/* Name of the symbol *\/$/;"	m	struct:symbol	file:
nameInUsingClause	.\src\resolve.c	/^static int nameInUsingClause(IdList *pUsing, const char *zCol){$/;"	f	file:
name_to_enc	.\src\test5.c	/^static u8 name_to_enc(Tcl_Interp *interp, Tcl_Obj *pObj){$/;"	f	file:
namelistFree	.\tool\sqldiff.c	/^static void namelistFree(char **az){$/;"	f	file:
nappend	.\ext\fts1\fts1.c	/^static void nappend(StringBuffer *sb, const char *zFrom, int nFrom){$/;"	f	file:
nappend	.\ext\fts2\fts2.c	/^static void nappend(StringBuffer *sb, const char *zFrom, int nFrom){$/;"	f	file:
ncFlags	.\src\sqliteInt.h	/^  u16 ncFlags;         \/* Zero or more NC_* flags defined below *\/$/;"	m	struct:NameContext
nconflict	.\tool\lemon.c	/^  int nconflict;           \/* Number of parsing conflicts *\/$/;"	m	struct:lemon	file:
nearlyFull	.\src\malloc.c	/^  int nearlyFull;$/;"	m	struct:Mem0Global	file:
nearset	.\ext\fts5\test\fts5_common.tcl	/^proc nearset {aCol args} {$/;"	p
needCsvQuote	.\src\shell.c	/^static const char needCsvQuote[] = {$/;"	v	file:
needFree	.\src\whereInt.h	/^      u8 needFree;           \/* True if sqlite3_free(idxStr) is needed *\/$/;"	m	struct:WhereLoop::__anon28::__anon30
nested	.\src\sqliteInt.h	/^  u8 nested;           \/* Number of nested calls to the parser\/code generator *\/$/;"	m	struct:Parse
neverCorrupt	.\src\sqliteInt.h	/^  int neverCorrupt;                 \/* Database is always well-formed *\/$/;"	m	struct:Sqlite3Config
newDatabase	.\src\btree.c	/^static int newDatabase(BtShared *pBt){$/;"	f	file:
newRowid	.\ext\rtree\rtree.c	/^static int newRowid(Rtree *pRtree, i64 *piRowid){$/;"	f	file:
newTnum	.\src\sqliteInt.h	/^    int newTnum;                \/* Rootpage of table being initialized *\/$/;"	m	struct:sqlite3::sqlite3InitInfo
newconfig	.\tool\lemon.c	/^PRIVATE struct config *newconfig(){$/;"	f
newmask	.\src\sqliteInt.h	/^  u32 newmask;         \/* Mask of new.* columns referenced *\/$/;"	m	struct:Parse
next	.\ext\fts1\ft_hash.h	/^  HashElem *next, *prev;   \/* Next and previous elements in the table *\/$/;"	m	struct:HashElem
next	.\ext\fts1\fts1_hash.h	/^  fts1HashElem *next, *prev; \/* Next and previous elements in the table *\/$/;"	m	struct:fts1HashElem
next	.\ext\fts2\fts2.c	/^  struct InteriorBlock *next;$/;"	m	struct:InteriorBlock	typeref:struct:InteriorBlock::InteriorBlock	file:
next	.\ext\fts2\fts2_hash.h	/^  fts2HashElem *next, *prev; \/* Next and previous elements in the table *\/$/;"	m	struct:fts2HashElem
next	.\ext\fts3\fts3_hash.h	/^  Fts3HashElem *next, *prev; \/* Next and previous elements in the table *\/$/;"	m	struct:Fts3HashElem
next	.\src\hash.h	/^  HashElem *next, *prev;       \/* Next and previous elements in the table *\/$/;"	m	struct:HashElem
next	.\src\mem3.c	/^      u32 next;       \/* Index in mem3.aPool[] of next free chunk *\/$/;"	m	struct:Mem3Block::__anon11::__anon13	file:
next	.\src\mem5.c	/^  int next;       \/* Index of next free chunk *\/$/;"	m	struct:Mem5Link	file:
next	.\tool\lemon.c	/^  struct action *next;     \/* Next action for this state *\/$/;"	m	struct:action	typeref:struct:action::action	file:
next	.\tool\lemon.c	/^  struct config *next;     \/* Next configuration in the state *\/$/;"	m	struct:config	typeref:struct:config::config	file:
next	.\tool\lemon.c	/^  struct plink *next;      \/* The next propagate link *\/$/;"	m	struct:plink	typeref:struct:plink::plink	file:
next	.\tool\lemon.c	/^  struct rule *next;       \/* Next rule in the global list *\/$/;"	m	struct:rule	typeref:struct:rule::rule	file:
next	.\tool\lemon.c	/^  struct s_x1node *next;   \/* Next entry with the same hash *\/$/;"	m	struct:s_x1node	typeref:struct:s_x1node::s_x1node	file:
next	.\tool\lemon.c	/^  struct s_x2node *next;   \/* Next entry with the same hash *\/$/;"	m	struct:s_x2node	typeref:struct:s_x2node::s_x2node	file:
next	.\tool\lemon.c	/^  struct s_x3node *next;   \/* Next entry with the same hash *\/$/;"	m	struct:s_x3node	typeref:struct:s_x3node::s_x3node	file:
next	.\tool\lemon.c	/^  struct s_x4node *next;   \/* Next entry with the same hash *\/$/;"	m	struct:s_x4node	typeref:struct:s_x4node::s_x4node	file:
next2	.\src\test_tclvar.c	/^static int next2(Tcl_Interp *interp, tclvar_cursor *pCur, Tcl_Obj *pObj){$/;"	f	file:
nextAutovac	.\src\sqliteInt.h	/^  signed char nextAutovac;      \/* Autovac setting after VACUUM if >=0 *\/$/;"	m	struct:sqlite3
nextCharAppend	.\ext\misc\nextchar.c	/^static void nextCharAppend(nextCharContext *p, unsigned c){$/;"	f	file:
nextCharContext	.\ext\misc\nextchar.c	/^struct nextCharContext {$/;"	s	file:
nextCharContext	.\ext\misc\nextchar.c	/^typedef struct nextCharContext nextCharContext;$/;"	t	typeref:struct:nextCharContext	file:
nextCharFunc	.\ext\misc\nextchar.c	/^static void nextCharFunc($/;"	f	file:
nextColumn	.\ext\fts1\fts1.c	/^  int nextColumn;       \/* Next word parsed must be in this column *\/$/;"	m	struct:Query	file:
nextColumn	.\ext\fts2\fts2.c	/^  int nextColumn;       \/* Next word parsed must be in this column *\/$/;"	m	struct:Query	file:
nextDocid	.\ext\fts1\fts1.c	/^static sqlite_int64 nextDocid(DocListReader *pIn){$/;"	f	file:
nextIsOr	.\ext\fts1\fts1.c	/^  int nextIsOr;         \/* Set the isOr flag on the next inserted term *\/$/;"	m	struct:Query	file:
nextIsOr	.\ext\fts2\fts2.c	/^  int nextIsOr;         \/* Set the isOr flag on the next inserted term *\/$/;"	m	struct:Query	file:
nextPagesize	.\src\sqliteInt.h	/^  int nextPagesize;             \/* Pagesize after VACUUM if >0 *\/$/;"	m	struct:sqlite3
nextPtr	.\autoconf\tea\win\nmakehlp.c	/^    struct list_item_t *nextPtr;$/;"	m	struct:list_item_t	typeref:struct:list_item_t::list_item_t	file:
nextShmId	.\src\os_unix.c	/^  u8 nextShmId;              \/* Next available unixShm.id value *\/$/;"	m	struct:unixShmNode	file:
nextShmId	.\src\os_win.c	/^  u8 nextShmId;              \/* Next available winShm.id value *\/$/;"	m	struct:winShmNode	file:
next_stmt	.\src\sqlite3ext.h	/^  sqlite3_stmt *(*next_stmt)(sqlite3*,sqlite3_stmt*);$/;"	m	struct:sqlite3_api_routines
nextlhs	.\tool\lemon.c	/^  struct rule *nextlhs;    \/* Next rule with the same LHS *\/$/;"	m	struct:rule	typeref:struct:rule::rule	file:
nfsUnlock	.\src\os_unix.c	/^static int nfsUnlock(sqlite3_file *id, int eFileLock){$/;"	f	file:
nm_match_count	.\ext\fts3\fts3_test.c	/^static int nm_match_count($/;"	f	file:
nm_near_chain	.\ext\fts3\fts3_test.c	/^static int nm_near_chain($/;"	f	file:
nm_phrase_match	.\ext\fts3\fts3_test.c	/^static int nm_phrase_match($/;"	f	file:
nn	.\ext\fts5\fts5_index.c	/^  int nn;                         \/* Size of record in bytes *\/$/;"	m	struct:Fts5Data	file:
noCase	.\src\func.c	/^  u8 noCase;$/;"	m	struct:compareInfo	file:
noLock	.\src\pager.c	/^  u8 noLock;                  \/* Do not lock (except in WAL mode) *\/$/;"	m	struct:Pager	file:
noPayload	.\src\btreeInt.h	/^  u8 noPayload;        \/* True if internal intKey page (thus w\/o data) *\/$/;"	m	struct:MemPage
noSkipScan	.\src\sqliteInt.h	/^  unsigned noSkipScan:1;   \/* Do not try to use skip-scan if true *\/$/;"	m	struct:Index
noSync	.\src\pager.c	/^  u8 noSync;                  \/* Do not sync the journal if true *\/$/;"	m	struct:Pager	file:
no_errors	.\tool\build-all-msvc.bat	/^:no_errors$/;"	l
nocaseCollatingFunc	.\src\main.c	/^static int nocaseCollatingFunc($/;"	f	file:
nodeAcquire	.\ext\rtree\rtree.c	/^static int nodeAcquire($/;"	f	file:
nodeDeleteCell	.\ext\rtree\rtree.c	/^static void nodeDeleteCell(Rtree *pRtree, RtreeNode *pNode, int iCell){$/;"	f	file:
nodeGetCell	.\ext\rtree\rtree.c	/^static void nodeGetCell($/;"	f	file:
nodeGetCoord	.\ext\rtree\rtree.c	/^static void nodeGetCoord($/;"	f	file:
nodeGetRowid	.\ext\rtree\rtree.c	/^static i64 nodeGetRowid($/;"	f	file:
nodeHash	.\ext\rtree\rtree.c	/^static int nodeHash(i64 iNode){$/;"	f	file:
nodeHashDelete	.\ext\rtree\rtree.c	/^static void nodeHashDelete(Rtree *pRtree, RtreeNode *pNode){$/;"	f	file:
nodeHashInsert	.\ext\rtree\rtree.c	/^static void nodeHashInsert(Rtree *pRtree, RtreeNode *pNode){$/;"	f	file:
nodeHashLookup	.\ext\rtree\rtree.c	/^static RtreeNode *nodeHashLookup(Rtree *pRtree, i64 iNode){$/;"	f	file:
nodeInsertCell	.\ext\rtree\rtree.c	/^static int nodeInsertCell($/;"	f	file:
nodeNew	.\ext\rtree\rtree.c	/^static RtreeNode *nodeNew(Rtree *pRtree, RtreeNode *pParent){$/;"	f	file:
nodeOverwriteCell	.\ext\rtree\rtree.c	/^static void nodeOverwriteCell($/;"	f	file:
nodeParentIndex	.\ext\rtree\rtree.c	/^static int nodeParentIndex(Rtree *pRtree, RtreeNode *pNode, int *piIndex){$/;"	f	file:
nodeReaderInit	.\ext\fts3\fts3_write.c	/^static int nodeReaderInit(NodeReader *p, const char *aNode, int nNode){$/;"	f	file:
nodeReaderNext	.\ext\fts3\fts3_write.c	/^static int nodeReaderNext(NodeReader *p){$/;"	f	file:
nodeReaderRelease	.\ext\fts3\fts3_write.c	/^static void nodeReaderRelease(NodeReader *p){$/;"	f	file:
nodeReference	.\ext\rtree\rtree.c	/^static void nodeReference(RtreeNode *p){$/;"	f	file:
nodeRelease	.\ext\rtree\rtree.c	/^static int nodeRelease(Rtree *pRtree, RtreeNode *pNode){$/;"	f	file:
nodeRowidIndex	.\ext\rtree\rtree.c	/^static int nodeRowidIndex($/;"	f	file:
nodeWrite	.\ext\rtree\rtree.c	/^static int nodeWrite(Rtree *pRtree, RtreeNode *pNode){$/;"	f	file:
nodeZero	.\ext\rtree\rtree.c	/^static void nodeZero(Rtree *pRtree, RtreeNode *p){$/;"	f	file:
node_bbox	.\ext\rtree\viewrtree.tcl	/^proc node_bbox {data} {$/;"	p
nolinenosflag	.\tool\lemon.c	/^  int nolinenosflag;       \/* True if #line statements should not be printed *\/$/;"	m	struct:lemon	file:
nolockCheckReservedLock	.\src\os_unix.c	/^static int nolockCheckReservedLock(sqlite3_file *NotUsed, int *pResOut){$/;"	f	file:
nolockClose	.\src\os_unix.c	/^static int nolockClose(sqlite3_file *id) {$/;"	f	file:
nolockLock	.\src\os_unix.c	/^static int nolockLock(sqlite3_file *NotUsed, int NotUsed2){$/;"	f	file:
nolockUnlock	.\src\os_unix.c	/^static int nolockUnlock(sqlite3_file *NotUsed, int NotUsed2){$/;"	f	file:
nondeterministicFunction	.\src\test1.c	/^static void nondeterministicFunction($/;"	f	file:
noopFunc	.\src\func.c	465;"	d	file:
noopMutexAlloc	.\src\mutex_noop.c	/^static sqlite3_mutex *noopMutexAlloc(int id){ $/;"	f	file:
noopMutexEnd	.\src\mutex_noop.c	/^static int noopMutexEnd(void){ return SQLITE_OK; }$/;"	f	file:
noopMutexEnter	.\src\mutex_noop.c	/^static void noopMutexEnter(sqlite3_mutex *p){ UNUSED_PARAMETER(p); return; }$/;"	f	file:
noopMutexFree	.\src\mutex_noop.c	/^static void noopMutexFree(sqlite3_mutex *p){ UNUSED_PARAMETER(p); return; }$/;"	f	file:
noopMutexInit	.\src\mutex_noop.c	/^static int noopMutexInit(void){ return SQLITE_OK; }$/;"	f	file:
noopMutexLeave	.\src\mutex_noop.c	/^static void noopMutexLeave(sqlite3_mutex *p){ UNUSED_PARAMETER(p); return; }$/;"	f	file:
noopMutexTry	.\src\mutex_noop.c	/^static int noopMutexTry(sqlite3_mutex *p){$/;"	f	file:
normalMode	.\src\shell.c	/^  SavedModeInfo normalMode;\/* Holds the mode just before .explain ON *\/$/;"	m	struct:ShellState	file:
notIndexed	.\src\sqliteInt.h	/^      unsigned notIndexed :1;    \/* True if there is a NOT INDEXED clause *\/$/;"	m	struct:SrcList::SrcList_item::__anon19
notNull	.\src\sqliteInt.h	/^  u8 notNull;      \/* An OE_ code for handling a NOT NULL constraint *\/$/;"	m	struct:Column
notReady	.\src\whereInt.h	/^  Bitmask notReady;          \/* FROM entries not usable at this level *\/$/;"	m	struct:WhereLevel
notUsed1	.\src\sqliteInt.h	/^    double notUsed1;            \/* Spacer *\/$/;"	m	union:sqlite3::__anon14
notValid	.\src\resolve.c	/^static void notValid($/;"	f	file:
nowValue	.\src\status.c	/^  sqlite3_int64 nowValue[10];         \/* Current value *\/$/;"	m	struct:sqlite3StatType	file:
nrhs	.\src\lempar.c	/^  unsigned char nrhs;     \/* Number of right-hand side symbols in the rule *\/$/;"	m	struct:__anon9	file:
nrhs	.\tool\lemon.c	/^  int nrhs;                  \/* Number of right-hand side symbols seen *\/$/;"	m	struct:pstate	file:
nrhs	.\tool\lemon.c	/^  int nrhs;                \/* Number of RHS symbols *\/$/;"	m	struct:rule	file:
nrhs	.\tool\lempar.c	/^  unsigned char nrhs;     \/* Number of right-hand side symbols in the rule *\/$/;"	m	struct:__anon35	file:
nrule	.\tool\lemon.c	/^  int nrule;               \/* Number of rules *\/$/;"	m	struct:lemon	file:
nstate	.\tool\lemon.c	/^  int nstate;              \/* Number of states *\/$/;"	m	struct:lemon	file:
nsubsym	.\tool\lemon.c	/^  int nsubsym;             \/* Number of constituent symbols in the MULTI *\/$/;"	m	struct:symbol	file:
nsymbol	.\tool\lemon.c	/^  int nsymbol;             \/* Number of terminal and nonterminal symbols *\/$/;"	m	struct:lemon	file:
nterminal	.\tool\lemon.c	/^  int nterminal;           \/* Number of terminal symbols *\/$/;"	m	struct:lemon	file:
nullRow	.\src\vdbeInt.h	/^  u8 nullRow;           \/* True if pointing to a row with no data *\/$/;"	m	struct:VdbeCursor
nullRule	.\ext\misc\fuzzer.c	/^  fuzzer_rule nullRule;      \/* Null rule used first *\/$/;"	m	struct:fuzzer_cursor	file:
nullValue	.\src\shell.c	/^  char nullValue[20];    \/* The text to print when a NULL comes back from$/;"	m	struct:ShellState	file:
nullifFunc	.\src\func.c	/^static void nullifFunc($/;"	f	file:
numberOfCachePages	.\src\pcache.c	/^static int numberOfCachePages(PCache *p){$/;"	f	file:
number_name	.\tool\mkspeedsql.tcl	/^proc number_name {n} {$/;"	p
number_name	.\tool\speedtest.tcl	/^proc number_name {n} {$/;"	p
number_name	.\tool\speedtest2.tcl	/^proc number_name {n} {$/;"	p
numericType	.\src\vdbe.c	/^static u16 numericType(Mem *pMem){$/;"	f	file:
nxstate	.\tool\lemon.c	/^  int nxstate;             \/* nstate with tail degenerate states removed *\/$/;"	m	struct:lemon	file:
nzVar	.\src\sqliteInt.h	/^  int nzVar;                \/* Number of available slots in azVar[] *\/$/;"	m	struct:Parse
nzVar	.\src\vdbeInt.h	/^  ynVar nzVar;            \/* Number of entries in azVar[] *\/$/;"	m	struct:Vdbe
objiter	.\ext\rbu\sqlite3rbu.c	/^  RbuObjIter objiter;             \/* Iterator for skipping through tbl\/idx *\/$/;"	m	struct:sqlite3rbu	file:
offset	.\src\os_unix.c	/^  unsigned long long offset;        \/* offset to first byte to lock *\/$/;"	m	struct:ByteRangeLockPB2	file:
offset	.\tool\mkkeywordhash.c	/^  int offset;          \/* Offset to start of name string *\/$/;"	m	struct:Keyword	file:
offsetof	.\src\sqliteInt.h	536;"	d
ofst2byte	.\tool\offsets.c	/^static int ofst2byte(GState *p, int ofst){$/;"	f	file:
ofst4byte	.\tool\offsets.c	/^static int ofst4byte(GState *p, int ofst){$/;"	f	file:
ofstError	.\tool\offsets.c	/^static void ofstError(GState *p, const char *zFormat, ...){$/;"	f	file:
ofstInFile	.\tool\offsets.c	/^static int ofstInFile(GState *p, int ofst){$/;"	f	file:
ofstPopPage	.\tool\offsets.c	/^static void ofstPopPage(GState *p){$/;"	f	file:
ofstPushPage	.\tool\offsets.c	/^static void ofstPushPage(GState *p, int pgno){$/;"	f	file:
ofstRootAndColumn	.\tool\offsets.c	/^static void ofstRootAndColumn($/;"	f	file:
ofstSerialSize	.\tool\offsets.c	/^static int ofstSerialSize(int scode){$/;"	f	file:
ofstTrace	.\tool\offsets.c	/^static void ofstTrace(GState *p, const char *zFormat, ...){$/;"	f	file:
ofstVarint	.\tool\offsets.c	/^static sqlite3_int64 ofstVarint(GState *p, int *pOfst){$/;"	f	file:
ofstWalkInteriorPage	.\tool\offsets.c	/^static void ofstWalkInteriorPage(GState *p){$/;"	f	file:
ofstWalkLeafPage	.\tool\offsets.c	/^static void ofstWalkLeafPage(GState *p){$/;"	f	file:
ofstWalkPage	.\tool\offsets.c	/^static void ofstWalkPage(GState *p, int pgno){$/;"	f	file:
ok	.\src\test1.c	/^  int ok;             \/* Finished ok *\/$/;"	m	struct:win32FileLocker	file:
okConstFactor	.\src\sqliteInt.h	/^  u8 okConstFactor;    \/* OK to factor out constants *\/$/;"	m	struct:Parse
oldLockingContext	.\src\os_unix.c	/^  void *oldLockingContext;     \/* Original lockingcontext to restore on close *\/$/;"	m	struct:proxyLockingContext	file:
oldmask	.\src\sqliteInt.h	/^  u32 oldmask;         \/* Mask of old.* columns referenced *\/$/;"	m	struct:Parse
omitMask	.\src\whereInt.h	/^      u16 omitMask;          \/* Terms that may be omitted *\/$/;"	m	struct:WhereLoop::__anon28::__anon30
omit_test	.\test\tester.tcl	/^proc omit_test {name reason {append 1}} {$/;"	p
onError	.\src\sqliteInt.h	/^  u8 onError;              \/* OE_Abort, OE_Ignore, OE_Replace, or OE_None *\/$/;"	m	struct:Index
onErrorText	.\src\trigger.c	/^static const char *onErrorText(int onError){$/;"	f	file:
one	.\test\randexpr1.tcl	/^proc one {args} {$/;"	p
one_input_line	.\src\shell.c	/^static char *one_input_line(FILE *in, char *zPrior, int isContinuation){$/;"	f	file:
oom	.\ext\misc\json1.c	/^  u8 oom;            \/* Set to true if out of memory *\/$/;"	m	struct:JsonParse	file:
oomErr	.\ext\misc\amatch.c	/^  int oomErr;                \/* True following an OOM error *\/$/;"	m	struct:amatch_cursor	file:
oomFault	.\tool\fuzzershell.c	/^static void oomFault(void){$/;"	f	file:
oomMalloc	.\tool\fuzzershell.c	/^static void *oomMalloc(int nByte){$/;"	f	file:
oomRealloc	.\tool\fuzzershell.c	/^static void *oomRealloc(void *pOld, int nByte){$/;"	f	file:
oom_injectstart	.\test\malloc_common.tcl	/^proc oom_injectstart {nRepeat iFail} {$/;"	p
oom_injectstop	.\test\malloc_common.tcl	/^proc oom_injectstop {} {$/;"	p
op	.\ext\async\sqlite3async.c	/^  int op;                      \/* One of ASYNC_xxx etc. *\/$/;"	m	struct:AsyncWrite	file:
op	.\ext\rtree\rtree.c	/^  int op;                         \/* Constraining operation *\/$/;"	m	struct:RtreeConstraint	file:
op	.\src\sqliteInt.h	/^  u8 op;                  \/* One of TK_DELETE, TK_UPDATE, TK_INSERT         *\/$/;"	m	struct:Trigger
op	.\src\sqliteInt.h	/^  u8 op;                 \/* One of: TK_UNION TK_ALL TK_INTERSECT TK_EXCEPT *\/$/;"	m	struct:Select
op	.\src\sqliteInt.h	/^  u8 op;                 \/* Operation performed by this node *\/$/;"	m	struct:Expr
op	.\src\sqliteInt.h	/^  u8 op;               \/* One of TK_DELETE, TK_UPDATE, TK_INSERT, TK_SELECT *\/$/;"	m	struct:TriggerStep
op	.\src\test_server.c	/^  int op;                      \/* Opcode for the message *\/$/;"	m	struct:SqlMessage	file:
op	.\src\whereInt.h	/^  u8 op, p3, p5;        \/* Opcode, P3 & P5 of the opcode that ends the loop *\/$/;"	m	struct:WhereLevel
op	.\src\whereInt.h	/^  u8 op;                   \/* Split operator.  TK_AND or TK_OR *\/$/;"	m	struct:WhereClause
op	.\tool\lemon.c	/^static struct s_options *op;$/;"	v	typeref:struct:s_options	file:
op2	.\src\sqliteInt.h	/^  u8 op2;                \/* TK_REGISTER: original value of Expr.op$/;"	m	struct:Expr
opIterNext	.\src\vdbeaux.c	/^static Op *opIterNext(VdbeOpIter *p){$/;"	f	file:
opMask	.\src\whereInt.h	/^  u32 opMask;                \/* Acceptable operators *\/$/;"	m	struct:WhereScan
opPrecedence	.\ext\fts3\fts3_expr.c	/^static int opPrecedence(Fts3Expr *p){$/;"	f	file:
opcode	.\src\vdbe.h	/^  u8 opcode;          \/* What operation to perform *\/$/;"	m	struct:VdbeOp
opcode	.\src\vdbe.h	/^  u8 opcode;          \/* What operation to perform *\/$/;"	m	struct:VdbeOpList
open	.\src\sqlite3ext.h	/^  int  (*open)(const char*,sqlite3**);$/;"	m	struct:sqlite3_api_routines
open16	.\src\sqlite3ext.h	/^  int  (*open16)(const void*,sqlite3**);$/;"	m	struct:sqlite3_api_routines
openDatabase	.\src\main.c	/^static int openDatabase($/;"	f	file:
openDatabase	.\tool\showdb.c	/^static sqlite3 *openDatabase(const char *zPrg, const char *zName){$/;"	f	file:
openDb	.\tool\rollback-test.c	/^static sqlite3 *openDb(const char *zFilename){$/;"	f	file:
openDirectory	.\src\os_unix.c	/^static int openDirectory(const char *zFilename, int *pFd){$/;"	f	file:
openFlags	.\ext\rbu\sqlite3rbu.c	/^  int openFlags;                  \/* Flags this file was opened with *\/$/;"	m	struct:rbu_file	file:
openFlags	.\src\btreeInt.h	/^  u8 openFlags;         \/* Flags to sqlite3BtreeOpen() *\/$/;"	m	struct:BtShared
openFlags	.\src\os_unix.c	/^  int openFlags;                      \/* The flags specified at open() *\/$/;"	m	struct:unixFile	file:
openFlags	.\src\sqliteInt.h	/^  unsigned int openFlags;       \/* Flags passed to sqlite3_vfs.xOpen() *\/$/;"	m	struct:sqlite3
openStatTable	.\src\analyze.c	/^static void openStatTable($/;"	f	file:
openSubJournal	.\src\pager.c	/^static int openSubJournal(Pager *pPager){$/;"	f	file:
openTransaction	.\src\test_journal.c	/^static int openTransaction(jt_file *pMain, jt_file *pJournal){$/;"	f	file:
open_db	.\src\shell.c	/^static void open_db(ShellState *p, int keepAlive){$/;"	f	file:
open_v2	.\src\sqlite3ext.h	/^  int (*open_v2)(const char*,sqlite3**,int,const char*);$/;"	m	struct:sqlite3_api_routines
opendb	.\test\threadtest3.c	41;"	d	file:
opendb_x	.\test\threadtest3.c	/^static void opendb_x($/;"	f	file:
operatorMask	.\src\whereexpr.c	/^static u16 operatorMask(int op){$/;"	f	file:
opflags	.\src\vdbe.h	/^  u8 opflags;         \/* Mask of the OPFLG_* flags in opcodes.h *\/$/;"	m	struct:VdbeOp
opnum	.\src\test4.c	/^  int opnum;             \/* Operation number *\/$/;"	m	struct:Thread	file:
opnum	.\src\test7.c	/^  volatile int opnum;      \/* Operation number *\/$/;"	m	struct:Thread	file:
optLeavesReaderAtEnd	.\ext\fts2\fts2.c	/^static int optLeavesReaderAtEnd(OptLeavesReader *pReader){$/;"	f	file:
optLeavesReaderCmp	.\ext\fts2\fts2.c	/^static int optLeavesReaderCmp(OptLeavesReader *lr1, OptLeavesReader *lr2){$/;"	f	file:
optLeavesReaderData	.\ext\fts2\fts2.c	/^static const char *optLeavesReaderData(OptLeavesReader *pReader){$/;"	f	file:
optLeavesReaderDataBytes	.\ext\fts2\fts2.c	/^static int optLeavesReaderDataBytes(OptLeavesReader *pReader){$/;"	f	file:
optLeavesReaderReorder	.\ext\fts2\fts2.c	/^static void optLeavesReaderReorder(OptLeavesReader *pLr, int nLr){$/;"	f	file:
optLeavesReaderStep	.\ext\fts2\fts2.c	/^static int optLeavesReaderStep(fulltext_vtab *v, OptLeavesReader *pReader){$/;"	f	file:
optLeavesReaderTerm	.\ext\fts2\fts2.c	/^static const char *optLeavesReaderTerm(OptLeavesReader *pReader){$/;"	f	file:
optLeavesReaderTermBytes	.\ext\fts2\fts2.c	/^static int optLeavesReaderTermBytes(OptLeavesReader *pReader){$/;"	f	file:
optLeavesReaderTermCmp	.\ext\fts2\fts2.c	/^static int optLeavesReaderTermCmp(OptLeavesReader *lr1, OptLeavesReader *lr2){$/;"	f	file:
optimalReserve	.\src\btreeInt.h	/^  u8 optimalReserve;    \/* Desired amount of reserved space per page *\/$/;"	m	struct:BtShared
optimization_control	.\src\test1.c	/^static int optimization_control($/;"	f	file:
optimizeFunc	.\ext\fts2\fts2.c	/^static void optimizeFunc(sqlite3_context *pContext,$/;"	f	file:
optimizeInternal	.\ext\fts2\fts2.c	/^static int optimizeInternal(fulltext_vtab *v,$/;"	f	file:
option_type	.\tool\lemon.c	/^enum option_type { OPT_FLAG=1,  OPT_INT,  OPT_DBL,  OPT_STR,$/;"	g	file:
orconf	.\src\sqliteInt.h	/^  int orconf;             \/* Default ON CONFLICT policy *\/$/;"	m	struct:TriggerPrg
orconf	.\src\sqliteInt.h	/^  u8 orconf;           \/* OE_Rollback etc. *\/$/;"	m	struct:TriggerStep
orderedDLReaderCmp	.\ext\fts2\fts2.c	/^static int orderedDLReaderCmp(OrderedDLReader *r1, OrderedDLReader *r2){$/;"	f	file:
orderedDLReaderReorder	.\ext\fts2\fts2.c	/^static void orderedDLReaderReorder(OrderedDLReader *p, int n){$/;"	f	file:
orig_access	.\src\test_syscall.c	150;"	d	file:
orig_close	.\src\test_syscall.c	149;"	d	file:
orig_fallocate	.\src\test_syscall.c	165;"	d	file:
orig_fchmod	.\src\test_syscall.c	164;"	d	file:
orig_fcntl	.\src\test_syscall.c	155;"	d	file:
orig_fstat	.\src\test_syscall.c	153;"	d	file:
orig_ftruncate	.\src\test_syscall.c	154;"	d	file:
orig_getcwd	.\src\test_syscall.c	151;"	d	file:
orig_getpagesize	.\src\test_syscall.c	/^  sqlite3_syscall_ptr orig_getpagesize;$/;"	m	struct:TestSyscallGlobal	file:
orig_mmap	.\src\test_syscall.c	166;"	d	file:
orig_mremap	.\src\test_syscall.c	167;"	d	file:
orig_open	.\src\test_syscall.c	148;"	d	file:
orig_pread	.\src\test_syscall.c	157;"	d	file:
orig_pread64	.\src\test_syscall.c	158;"	d	file:
orig_pwrite	.\src\test_syscall.c	160;"	d	file:
orig_pwrite64	.\src\test_syscall.c	162;"	d	file:
orig_read	.\src\test_syscall.c	156;"	d	file:
orig_stat	.\src\test_syscall.c	152;"	d	file:
orig_write	.\src\test_syscall.c	159;"	d	file:
orphanTrigger	.\src\sqliteInt.h	/^    u8 orphanTrigger;           \/* Last statement is orphaned TEMP trigger *\/$/;"	m	struct:sqlite3::sqlite3InitInfo
osAccess	.\src\os_unix.c	362;"	d	file:
osAreFileApisANSI	.\src\os_win.c	435;"	d	file:
osAreFileApisANSI	.\src\os_win.c	456;"	d	file:
osCharLowerW	.\src\os_win.c	465;"	d	file:
osCharUpperW	.\src\os_win.c	473;"	d	file:
osClose	.\src\os_unix.c	359;"	d	file:
osCloseHandle	.\src\os_win.c	477;"	d	file:
osCreateEventExW	.\src\os_win.c	943;"	d	file:
osCreateFile2	.\src\os_win.c	997;"	d	file:
osCreateFileA	.\src\os_win.c	485;"	d	file:
osCreateFileMappingA	.\src\os_win.c	504;"	d	file:
osCreateFileMappingFromApp	.\src\os_win.c	1052;"	d	file:
osCreateFileMappingW	.\src\os_win.c	514;"	d	file:
osCreateFileW	.\src\os_win.c	494;"	d	file:
osCreateMutexW	.\src\os_win.c	523;"	d	file:
osDeleteFileA	.\src\os_win.c	532;"	d	file:
osDeleteFileW	.\src\os_win.c	540;"	d	file:
osFallocate	.\src\os_unix.c	434;"	d	file:
osFchmod	.\src\os_unix.c	427;"	d	file:
osFchown	.\src\os_unix.c	449;"	d	file:
osFcntl	.\src\os_unix.c	388;"	d	file:
osFcntl	.\src\os_unix.c	718;"	d	file:
osFcntl	.\src\os_unix.c	719;"	d	file:
osFileTimeToLocalFileTime	.\src\os_win.c	548;"	d	file:
osFileTimeToSystemTime	.\src\os_win.c	557;"	d	file:
osFlushFileBuffers	.\src\os_win.c	562;"	d	file:
osFlushViewOfFile	.\src\os_win.c	1094;"	d	file:
osFormatMessageA	.\src\os_win.c	570;"	d	file:
osFormatMessageW	.\src\os_win.c	579;"	d	file:
osFreeLibrary	.\src\os_win.c	588;"	d	file:
osFstat	.\src\os_unix.c	378;"	d	file:
osFtruncate	.\src\os_unix.c	385;"	d	file:
osGetCurrentProcessId	.\src\os_win.c	592;"	d	file:
osGetDiskFreeSpaceA	.\src\os_win.c	600;"	d	file:
osGetDiskFreeSpaceW	.\src\os_win.c	609;"	d	file:
osGetFileAttributesA	.\src\os_win.c	618;"	d	file:
osGetFileAttributesExW	.\src\os_win.c	634;"	d	file:
osGetFileAttributesW	.\src\os_win.c	626;"	d	file:
osGetFileInformationByHandleEx	.\src\os_win.c	979;"	d	file:
osGetFileSize	.\src\os_win.c	643;"	d	file:
osGetFullPathNameA	.\src\os_win.c	651;"	d	file:
osGetFullPathNameW	.\src\os_win.c	660;"	d	file:
osGetLastError	.\src\os_win.c	665;"	d	file:
osGetNativeSystemInfo	.\src\os_win.c	1023;"	d	file:
osGetProcAddressA	.\src\os_win.c	680;"	d	file:
osGetProcessHeap	.\src\os_win.c	1044;"	d	file:
osGetSystemInfo	.\src\os_win.c	689;"	d	file:
osGetSystemTime	.\src\os_win.c	693;"	d	file:
osGetSystemTimeAsFileTime	.\src\os_win.c	701;"	d	file:
osGetTempPathA	.\src\os_win.c	710;"	d	file:
osGetTempPathW	.\src\os_win.c	718;"	d	file:
osGetTickCount	.\src\os_win.c	726;"	d	file:
osGetTickCount64	.\src\os_win.c	1015;"	d	file:
osGetVersionExA	.\src\os_win.c	735;"	d	file:
osGetVersionExW	.\src\os_win.c	745;"	d	file:
osGetcwd	.\src\os_unix.c	365;"	d	file:
osGetpagesize	.\src\os_unix.c	465;"	d	file:
osGetpid	.\src\os_unix.c	154;"	d	file:
osHeapAlloc	.\src\os_win.c	750;"	d	file:
osHeapCompact	.\src\os_win.c	799;"	d	file:
osHeapCreate	.\src\os_win.c	759;"	d	file:
osHeapDestroy	.\src\os_win.c	768;"	d	file:
osHeapFree	.\src\os_win.c	772;"	d	file:
osHeapReAlloc	.\src\os_win.c	776;"	d	file:
osHeapSize	.\src\os_win.c	781;"	d	file:
osHeapValidate	.\src\os_win.c	790;"	d	file:
osInterlockedCompareExchange	.\src\os_win.c	1063;"	d	file:
osIsNT	.\src\os_win.c	1351;"	d	file:
osIsNT	.\src\os_win.c	1353;"	d	file:
osIsNT	.\src\os_win.c	1355;"	d	file:
osIsNT	.\src\os_win.c	1357;"	d	file:
osLoadLibraryA	.\src\os_win.c	807;"	d	file:
osLoadLibraryW	.\src\os_win.c	816;"	d	file:
osLoadPackagedLibrary	.\src\os_win.c	1006;"	d	file:
osLocalFree	.\src\os_win.c	824;"	d	file:
osLocaltime	.\src\date.c	/^static int osLocaltime(time_t *t, struct tm *pTm){$/;"	f	file:
osLockFile	.\src\os_win.c	833;"	d	file:
osLockFileEx	.\src\os_win.c	844;"	d	file:
osMapViewOfFile	.\src\os_win.c	855;"	d	file:
osMapViewOfFileFromApp	.\src\os_win.c	988;"	d	file:
osMkdir	.\src\os_unix.c	443;"	d	file:
osMmap	.\src\os_unix.c	453;"	d	file:
osMremap	.\src\os_unix.c	463;"	d	file:
osMultiByteToWideChar	.\src\os_win.c	860;"	d	file:
osMunmap	.\src\os_unix.c	456;"	d	file:
osOpen	.\src\os_unix.c	356;"	d	file:
osOpenDirectory	.\src\os_unix.c	440;"	d	file:
osOutputDebugStringA	.\src\os_win.c	1032;"	d	file:
osOutputDebugStringW	.\src\os_win.c	1040;"	d	file:
osPread	.\src\os_unix.c	398;"	d	file:
osPread64	.\src\os_unix.c	405;"	d	file:
osPwrite	.\src\os_unix.c	415;"	d	file:
osPwrite64	.\src\os_unix.c	423;"	d	file:
osQueryPerformanceCounter	.\src\os_win.c	865;"	d	file:
osRead	.\src\os_unix.c	391;"	d	file:
osReadFile	.\src\os_win.c	870;"	d	file:
osRmdir	.\src\os_unix.c	446;"	d	file:
osSetEndOfFile	.\src\os_win.c	875;"	d	file:
osSetFilePointer	.\src\os_win.c	883;"	d	file:
osSetFilePointerEx	.\src\os_win.c	970;"	d	file:
osSleep	.\src\os_win.c	892;"	d	file:
osStat	.\src\os_unix.c	368;"	d	file:
osSystemTimeToFileTime	.\src\os_win.c	896;"	d	file:
osUnlink	.\src\os_unix.c	437;"	d	file:
osUnlockFile	.\src\os_win.c	906;"	d	file:
osUnlockFileEx	.\src\os_win.c	916;"	d	file:
osUnmapViewOfFile	.\src\os_win.c	925;"	d	file:
osUuidCreate	.\src\os_win.c	1077;"	d	file:
osUuidCreateSequential	.\src\os_win.c	1085;"	d	file:
osWaitForSingleObject	.\src\os_win.c	952;"	d	file:
osWaitForSingleObjectEx	.\src\os_win.c	961;"	d	file:
osWideCharToMultiByte	.\src\os_win.c	929;"	d	file:
osWrite	.\src\os_unix.c	408;"	d	file:
osWriteFile	.\src\os_win.c	934;"	d	file:
otherError	.\ext\misc\nextchar.c	/^  int otherError;                   \/* True for any other failure *\/$/;"	m	struct:nextCharContext	file:
out	.\ext\misc\vfslog.c	/^  FILE *out;                      \/* Write information here *\/$/;"	m	struct:VLogLog	file:
out	.\src\shell.c	/^  FILE *out;             \/* Write results here *\/$/;"	m	struct:ShellState	file:
out2Prerelease	.\src\vdbe.c	/^static Mem *out2Prerelease(Vdbe *p, VdbeOp *pOp){$/;"	f	file:
outCount	.\src\shell.c	/^  int outCount;          \/* Revert to stdout when reaching zero *\/$/;"	m	struct:ShellState	file:
out_of_memory	.\tool\showdb.c	/^static void out_of_memory(void){$/;"	f	file:
out_of_memory	.\tool\showjournal.c	/^static void out_of_memory(void){$/;"	f	file:
out_of_memory	.\tool\showwal.c	/^static void out_of_memory(void){$/;"	f	file:
outfile	.\src\shell.c	/^  char outfile[FILENAME_MAX]; \/* Filename for *out *\/$/;"	m	struct:ShellState	file:
outname	.\tool\lemon.c	/^  char *outname;           \/* Name of the current output file *\/$/;"	m	struct:lemon	file:
output	.\ext\fts5\extract_api_docs.tcl	/^  proc output {text} {$/;"	p
output1	.\test\tester.tcl	/^proc output1 {args} {$/;"	p
output2	.\test\tester.tcl	/^proc output2 {args} {$/;"	p
output2_if_no_verbose	.\test\tester.tcl	/^proc output2_if_no_verbose {args} {$/;"	p
output_c_string	.\src\shell.c	/^static void output_c_string(FILE *out, const char *z){$/;"	f	file:
output_csv	.\src\shell.c	/^static void output_csv(ShellState *p, const char *z, int bSep){$/;"	f	file:
output_file_close	.\src\shell.c	/^static void output_file_close(FILE *f){$/;"	f	file:
output_file_open	.\src\shell.c	/^static FILE *output_file_open(const char *zFile){$/;"	f	file:
output_hex_blob	.\src\shell.c	/^static void output_hex_blob(FILE *out, const void *pBlob, int nBlob){$/;"	f	file:
output_html_string	.\src\shell.c	/^static void output_html_string(FILE *out, const char *z){$/;"	f	file:
output_quoted_string	.\src\shell.c	/^static void output_quoted_string(FILE *out, const char *z){$/;"	f	file:
output_reset	.\src\shell.c	/^static void output_reset(ShellState *p){$/;"	f	file:
overflow	.\src\func.c	/^  u8 overflow;      \/* True if integer overflow seen *\/$/;"	m	struct:SumCtx	file:
overflow	.\tool\lemon.c	/^  char *overflow;          \/* Code to execute on a stack overflow *\/$/;"	m	struct:lemon	file:
overload_function	.\src\sqlite3ext.h	/^  int (*overload_function)(sqlite3*, const char *zFuncName, int nArg);$/;"	m	struct:sqlite3_api_routines
overloadedGlobFunction	.\src\test8.c	/^static void overloadedGlobFunction($/;"	f	file:
owner	.\src\mutex_unix.c	/^  volatile pthread_t owner;  \/* Thread that is within this mutex *\/$/;"	m	struct:sqlite3_mutex	file:
owner	.\src\mutex_w32.c	/^  volatile DWORD owner;      \/* Thread holding this mutex *\/$/;"	m	struct:sqlite3_mutex	file:
p	.\ext\fts1\fts1.c	/^  char *p;            \/* Pointer to next unread byte in the doclist *\/$/;"	m	struct:DocListReader	file:
p	.\ext\fts1\fulltext.c	/^  char *p;$/;"	m	struct:DocListReader	file:
p	.\ext\fts5\fts5Int.h	/^  const char *p;                  \/* Token text (not NULL terminated) *\/$/;"	m	struct:Fts5Token
p	.\ext\fts5\fts5Int.h	/^  u8 *p;$/;"	m	struct:Fts5Buffer
p	.\ext\fts5\fts5_index.c	/^  u8 *p;                          \/* Pointer to buffer containing record *\/$/;"	m	struct:Fts5Data	file:
p	.\src\sqliteInt.h	/^  void *p;          \/* Pointer to sampled record *\/$/;"	m	struct:IndexSample
p	.\src\test_multiplex.c	/^    sqlite3_file *p;                  \/* Handle for the chunk *\/$/;"	m	struct:multiplexGroup::multiplexReal	file:
p	.\src\vdbe.h	/^    void *p;               \/* Generic pointer *\/$/;"	m	union:VdbeOp::p4union
p1	.\src\vdbe.h	/^  int p1;             \/* First operand *\/$/;"	m	struct:VdbeOp
p1	.\src\vdbe.h	/^  signed char p1;     \/* First operand *\/$/;"	m	struct:VdbeOpList
p1	.\src\whereInt.h	/^  int p1, p2;           \/* Operands of the opcode used to ends the loop *\/$/;"	m	struct:WhereLevel
p2	.\src\vdbe.h	/^  int p2;             \/* Second parameter (often the jump destination) *\/$/;"	m	struct:VdbeOp
p2	.\src\vdbe.h	/^  signed char p2;     \/* Second parameter (often the jump destination) *\/$/;"	m	struct:VdbeOpList
p2	.\src\whereInt.h	/^  int p1, p2;           \/* Operands of the opcode used to ends the loop *\/$/;"	m	struct:WhereLevel
p3	.\src\vdbe.h	/^  int p3;             \/* The third parameter *\/$/;"	m	struct:VdbeOp
p3	.\src\vdbe.h	/^  signed char p3;     \/* Third parameter *\/$/;"	m	struct:VdbeOpList
p3	.\src\whereInt.h	/^  u8 op, p3, p5;        \/* Opcode, P3 & P5 of the opcode that ends the loop *\/$/;"	m	struct:WhereLevel
p4	.\src\vdbe.h	/^  } p4;$/;"	m	struct:VdbeOp	typeref:union:VdbeOp::p4union
p4type	.\src\vdbe.h	/^  signed char p4type; \/* One of the P4_xxx constants for p4 *\/$/;"	m	struct:VdbeOp
p4union	.\src\vdbe.h	/^  union p4union {     \/* fourth parameter *\/$/;"	u	struct:VdbeOp
p5	.\src\vdbe.h	/^  u8 p5;              \/* Fifth parameter is an unsigned character *\/$/;"	m	struct:VdbeOp
p5	.\src\whereInt.h	/^  u8 op, p3, p5;        \/* Opcode, P3 & P5 of the opcode that ends the loop *\/$/;"	m	struct:WhereLevel
pAfter	.\ext\misc\amatch.c	/^  amatch_avl *pAfter;   \/* Other elements greater than zKey *\/$/;"	m	struct:amatch_avl	file:
pAfter	.\ext\misc\closure.c	/^  closure_avl *pAfter;  \/* Other elements greater than id *\/$/;"	m	struct:closure_avl	file:
pAggInfo	.\src\sqliteInt.h	/^  AggInfo *pAggInfo;     \/* Used by TK_AGG_COLUMN and TK_AGG_FUNCTION *\/$/;"	m	struct:Expr
pAggInfo	.\src\sqliteInt.h	/^  AggInfo *pAggInfo;   \/* Information about aggregates at this level *\/$/;"	m	struct:NameContext
pAinc	.\src\sqliteInt.h	/^  AutoincInfo *pAinc;  \/* Information about AUTOINCREMENT counters *\/$/;"	m	struct:Parse
pAllCur	.\ext\misc\vtshim.c	/^  vtshim_cursor *pAllCur;  \/* List of all cursors *\/$/;"	m	struct:vtshim_vtab	file:
pAllVtab	.\ext\misc\vtshim.c	/^  vtshim_vtab *pAllVtab;        \/* List of all vtshim_vtab objects *\/$/;"	m	struct:vtshim_aux	file:
pAllWords	.\ext\misc\amatch.c	/^  amatch_word *pAllWords;    \/* List of all amatch_word objects *\/$/;"	m	struct:amatch_cursor	file:
pAndInfo	.\src\whereInt.h	/^    WhereAndInfo *pAndInfo; \/* Extra information if (eOperator& WO_AND)!=0 *\/$/;"	m	union:WhereTerm::__anon31
pApi	.\ext\fts5\fts5_aux.c	/^  const Fts5ExtensionApi *pApi;   \/* API offered by current FTS version *\/$/;"	m	struct:CInstIter	file:
pApi	.\ext\fts5\fts5_tcl.c	/^  const Fts5ExtensionApi *pApi;$/;"	m	struct:F5tApi	file:
pArg	.\src\sqliteInt.h	/^  void *pArg;                \/* First arg to busy callback *\/$/;"	m	struct:BusyHandler
pArg	.\src\test_quota.c	/^  void *pArg;                    \/* Third argument to the xCallback() *\/$/;"	m	struct:quotaGroup	file:
pArg	.\test\threadtest3.c	/^  void* pArg;                     \/* Pointer argument passed by caller *\/$/;"	m	struct:Thread	file:
pArray	.\src\tclsqlite.c	/^  Tcl_Obj *pArray;                \/* Name of array variable *\/$/;"	m	struct:DbEvalContext	file:
pAuthArg	.\src\sqliteInt.h	/^  void *pAuthArg;               \/* 1st argument to the access auth function *\/$/;"	m	struct:sqlite3
pAux	.\ext\fts5\fts5_main.c	/^  Fts5Auxiliary *pAux;            \/* Currently executing extension function *\/$/;"	m	struct:Fts5Cursor	file:
pAux	.\ext\fts5\fts5_main.c	/^  Fts5Auxiliary *pAux;            \/* Extension to which this belongs *\/$/;"	m	struct:Fts5Auxdata	file:
pAux	.\ext\fts5\fts5_main.c	/^  Fts5Auxiliary *pAux;            \/* First in list of all aux. functions *\/$/;"	m	struct:Fts5Global	file:
pAux	.\ext\misc\vtshim.c	/^  vtshim_aux *pAux;        \/* Pointer to vtshim_aux object *\/$/;"	m	struct:vtshim_vtab	file:
pAux	.\src\sqliteInt.h	/^  void *pAux;                          \/* pAux passed to create_module() *\/$/;"	m	struct:Module
pAux	.\src\vdbeInt.h	/^  void *pAux;                     \/* Aux data pointer *\/$/;"	m	struct:AuxData
pAuxData	.\src\vdbeInt.h	/^  AuxData *pAuxData;      \/* Linked list of auxdata allocations *\/$/;"	m	struct:Vdbe
pAuxdata	.\ext\fts5\fts5_main.c	/^  Fts5Auxdata *pAuxdata;          \/* First in linked list of saved aux-data *\/$/;"	m	struct:Fts5Cursor	file:
pBackup	.\src\pager.c	/^  sqlite3_backup *pBackup;    \/* Pointer to list of ongoing backup processes *\/$/;"	m	struct:Pager	file:
pBaseRead	.\ext\async\sqlite3async.c	/^  sqlite3_file *pBaseRead;   \/* Read handle to the underlying Os file *\/$/;"	m	struct:AsyncFileData	file:
pBaseWrite	.\ext\async\sqlite3async.c	/^  sqlite3_file *pBaseWrite;  \/* Write handle to the underlying Os file *\/$/;"	m	struct:AsyncFileData	file:
pBefore	.\ext\misc\amatch.c	/^  amatch_avl *pBefore;  \/* Other elements less than zKey *\/$/;"	m	struct:amatch_avl	file:
pBefore	.\ext\misc\closure.c	/^  closure_avl *pBefore; \/* Other elements less than id *\/$/;"	m	struct:closure_avl	file:
pBlob	.\ext\fts3\fts3_write.c	/^  sqlite3_blob *pBlob;            \/* If not NULL, blob handle to read node *\/$/;"	m	struct:Fts3SegReader	file:
pBlob	.\src\tclsqlite.c	/^  sqlite3_blob *pBlob;      \/* sqlite3 blob handle *\/$/;"	m	struct:IncrblobChannel	file:
pBlockingConnection	.\src\sqliteInt.h	/^  sqlite3 *pBlockingConnection; \/* Connection that caused SQLITE_LOCKED *\/$/;"	m	struct:sqlite3
pBt	.\src\btreeInt.h	/^  BtShared *pBt;            \/* The BtShared this cursor points to *\/$/;"	m	struct:BtCursor
pBt	.\src\btreeInt.h	/^  BtShared *pBt;       \/* Pointer to BtShared that this page is part of *\/$/;"	m	struct:MemPage
pBt	.\src\btreeInt.h	/^  BtShared *pBt;     \/* Sharable content of this btree *\/$/;"	m	struct:Btree
pBt	.\src\btreeInt.h	/^  BtShared *pBt;    \/* The tree being checked out *\/$/;"	m	struct:IntegrityCk
pBt	.\src\sqliteInt.h	/^  Btree *pBt;          \/* The B*Tree structure for this database file *\/$/;"	m	struct:Db
pBt	.\src\vdbeInt.h	/^  Btree *pBt;           \/* Separate file holding temporary table *\/$/;"	m	struct:VdbeCursor
pBtree	.\src\btreeInt.h	/^  Btree *pBtree;            \/* The Btree to which this cursor belongs *\/$/;"	m	struct:BtCursor
pBtree	.\src\btreeInt.h	/^  Btree *pBtree;        \/* Btree handle holding this lock *\/$/;"	m	struct:BtLock
pBuf	.\ext\fts5\fts5_index.c	/^  Fts5Buffer *pBuf;               \/* Append to this buffer *\/$/;"	m	struct:PoslistCallbackCtx	file:
pBuffer	.\src\test_vfs.c	/^  TestvfsBuffer *pBuffer;         \/* List of shared buffers *\/$/;"	m	struct:Testvfs	file:
pBulk	.\src\pcache1.c	/^  void *pBulk;                        \/* Bulk memory used by pcache-local *\/$/;"	m	struct:PCache1	file:
pBusyArg	.\src\test_superlock.c	/^  void *pBusyArg;                 \/* First arg to pass to xBusy *\/$/;"	m	struct:SuperlockBusy	file:
pBusyHandlerArg	.\src\pager.c	/^  void *pBusyHandlerArg;      \/* Context argument for xBusyHandler *\/$/;"	m	struct:Pager	file:
pCache	.\src\pcache.c	/^  sqlite3_pcache *pCache;             \/* Pluggable cache module *\/$/;"	m	struct:PCache	file:
pCache	.\src\pcache.h	/^  PCache *pCache;                \/* Cache that owns this page *\/$/;"	m	struct:PgHdr
pCache	.\src\pcache1.c	/^  PCache1 *pCache;               \/* Cache that currently owns this page *\/$/;"	m	struct:PgHdr1	file:
pCache	.\test\threadtest3.c	/^  Statement *pCache;              \/* Linked list of cached statements *\/$/;"	m	struct:Sqlite	file:
pCheck	.\src\sqliteInt.h	/^  ExprList *pCheck;    \/* All CHECK constraints *\/$/;"	m	struct:Table
pChild	.\ext\misc\vtshim.c	/^  sqlite3_vtab *pChild;    \/* Child virtual table *\/$/;"	m	struct:vtshim_vtab	file:
pChild	.\ext\misc\vtshim.c	/^  sqlite3_vtab_cursor *pChild; \/* Cursor generated by the managed subclass *\/$/;"	m	struct:vtshim_cursor	file:
pChildAux	.\ext\misc\vtshim.c	/^  void *pChildAux;              \/* pAux for child virtual tables *\/$/;"	m	struct:vtshim_aux	file:
pChunk	.\src\memjournal.c	/^  FileChunk *pChunk;              \/* Specific chunk into which cursor points *\/$/;"	m	struct:FilePoint	file:
pChunk	.\src\rowset.c	/^  struct RowSetChunk *pChunk;    \/* List of all chunk allocations *\/$/;"	m	struct:RowSet	typeref:struct:RowSet::RowSetChunk	file:
pClosure	.\ext\misc\closure.c	/^  closure_avl *pClosure;     \/* The complete closure tree *\/$/;"	m	struct:closure_cursor	file:
pCmp	.\src\test1.c	/^  Tcl_Obj *pCmp;$/;"	m	struct:TestCollationX	file:
pCodec	.\src\pager.c	/^  void *pCodec;               \/* First argument to xCodec... methods *\/$/;"	m	struct:Pager	file:
pColl	.\src\vdbe.h	/^    CollSeq *pColl;        \/* Used when p4type is P4_COLLSEQ *\/$/;"	m	union:VdbeOp::p4union
pCollNeededArg	.\src\sqliteInt.h	/^  void *pCollNeededArg;$/;"	m	struct:sqlite3
pCollate	.\src\tclsqlite.c	/^  SqlCollate *pCollate;      \/* List of SQL collation functions *\/$/;"	m	struct:SqliteDb	file:
pCollateNeeded	.\src\tclsqlite.c	/^  Tcl_Obj *pCollateNeeded;   \/* Collation needed script *\/$/;"	m	struct:SqliteDb	file:
pCollector	.\ext\fts2\fts2.c	/^  DLCollector *pCollector;$/;"	m	struct:TermData	file:
pCols	.\src\sqliteInt.h	/^    ExprList *pCols;                \/* List of explicit column names, or NULL *\/$/;"	m	struct:With::Cte
pColset	.\ext\fts5\fts5_expr.c	/^  Fts5Colset *pColset;            \/* Columns to search (NULL -> all columns) *\/$/;"	m	struct:Fts5ExprNearset	file:
pColset	.\ext\fts5\fts5_index.c	/^  Fts5Colset *pColset;            \/* Restrict matches to this column *\/$/;"	m	struct:PoslistCallbackCtx	file:
pColumnList	.\src\test_schema.c	/^  sqlite3_stmt *pColumnList;$/;"	m	struct:schema_cursor	file:
pColumns	.\src\sqliteInt.h	/^  IdList *pColumns;       \/* If this is an UPDATE OF <column-list> trigger,$/;"	m	struct:Trigger
pCommitArg	.\src\sqliteInt.h	/^  void *pCommitArg;                 \/* Argument to xCommitCallback() *\/   $/;"	m	struct:sqlite3
pConfig	.\ext\fts5\fts5_expr.c	/^  Fts5Config *pConfig;$/;"	m	struct:Fts5Parse	file:
pConfig	.\ext\fts5\fts5_index.c	/^  Fts5Config *pConfig;            \/* Virtual table configuration *\/$/;"	m	struct:Fts5Index	file:
pConfig	.\ext\fts5\fts5_main.c	/^  Fts5Config *pConfig;            \/* Virtual table configuration *\/$/;"	m	struct:Fts5Table	file:
pConfig	.\ext\fts5\fts5_storage.c	/^  Fts5Config *pConfig;$/;"	m	struct:Fts5IntegrityCtx	file:
pConfig	.\ext\fts5\fts5_storage.c	/^  Fts5Config *pConfig;$/;"	m	struct:Fts5Storage	file:
pConfig3	.\ext\misc\spellfix.c	/^  EditDist3Config *pConfig3;       \/* Edit-distance cost coefficients *\/$/;"	m	struct:MatchQuery	file:
pConfig3	.\ext\misc\spellfix.c	/^  EditDist3Config *pConfig3; \/* Parsed edit distance costs *\/$/;"	m	struct:spellfix1_vtab	file:
pConstExpr	.\src\sqliteInt.h	/^  ExprList *pConstExpr;\/* Constant expressions *\/$/;"	m	struct:Parse
pContent	.\src\test_intarray.c	/^  sqlite3_intarray *pContent;   \/* Content of the integer array *\/$/;"	m	struct:intarray_vtab	file:
pContext	.\ext\fts5\fts5_tcl.c	/^  F5tTokenizerContext *pContext;$/;"	m	struct:F5tTokenizerInstance	file:
pContext	.\ext\fts5\fts5_tcl.c	/^  F5tTokenizerContext *pContext;$/;"	m	struct:F5tTokenizerModule	file:
pContext	.\ext\rtree\rtree.c	/^  void *pContext;$/;"	m	struct:RtreeGeomCallback	file:
pContext	.\ext\rtree\sqlite3rtree.h	/^  void *pContext;                   \/* pContext from when function registered *\/$/;"	m	struct:sqlite3_rtree_query_info
pContext	.\ext\rtree\sqlite3rtree.h	/^  void *pContext;                 \/* Copy of pContext passed to s_r_g_c() *\/$/;"	m	struct:sqlite3_rtree_geometry
pCost	.\ext\misc\amatch.c	/^  amatch_avl *pCost;         \/* amatch_word objects keyed by iCost *\/$/;"	m	struct:amatch_cursor	file:
pCost	.\ext\misc\spellfix.c	/^  EditDist3Cost *pCost;  \/* Costs *\/$/;"	m	struct:EditDist3Lang	file:
pCovidx	.\src\whereInt.h	/^    Index *pCovidx;       \/* Possible covering index for WHERE_MULTI_OR *\/$/;"	m	union:WhereLevel::__anon26
pCsr	.\ext\fts3\fts3_snippet.c	/^  Fts3Cursor *pCsr;               \/* Cursor snippet is being generated from *\/$/;"	m	struct:SnippetIter	file:
pCsr	.\ext\fts3\fts3_snippet.c	/^  Fts3Cursor *pCsr;               \/* FTS3 Cursor *\/$/;"	m	struct:LoadDoclistCtx	file:
pCsr	.\ext\fts3\fts3_snippet.c	/^  Fts3Cursor *pCsr;$/;"	m	struct:TermOffsetCtx	file:
pCsr	.\ext\fts3\fts3_tokenize_vtab.c	/^  sqlite3_tokenizer_cursor *pCsr; \/* Cursor to iterate through zInput *\/$/;"	m	struct:Fts3tokCursor	file:
pCsr	.\ext\fts5\fts5_main.c	/^  Fts5Cursor *pCsr;               \/* First in list of all open cursors *\/$/;"	m	struct:Fts5Global	file:
pCsr	.\src\vdbeblob.c	/^  BtCursor *pCsr;         \/* Cursor pointing at blob row *\/$/;"	m	struct:Incrblob	file:
pCtx	.\ext\fts3\fts3_expr.c	/^  sqlite3_context *pCtx;              \/* Write error message here *\/$/;"	m	struct:ParseContext	file:
pCtx	.\ext\fts5\fts5_tcl.c	/^  void *pCtx;$/;"	m	struct:F5tTokenizerContext	file:
pCtx	.\ext\fts5\fts5_tokenize.c	/^  void *pCtx;$/;"	m	struct:PorterContext	file:
pCtx	.\ext\misc\json1.c	/^  sqlite3_context *pCtx;   \/* Function context - put error messages here *\/$/;"	m	struct:JsonString	file:
pCtx	.\src\vdbe.h	/^    sqlite3_context *pCtx; \/* Used when p4type is P4_FUNCCTX *\/$/;"	m	union:VdbeOp::p4union
pCur	.\ext\misc\spellfix.c	/^  spellfix1_cursor *pCur;          \/* The cursor being queried *\/$/;"	m	struct:MatchQuery	file:
pCurrent	.\ext\fts1\simple_tokenizer.c	/^  const char *pCurrent;        \/* current position in pInput *\/$/;"	m	struct:simple_tokenizer_cursor	file:
pCurrent	.\ext\misc\amatch.c	/^  amatch_word *pCurrent;     \/* Most recent solution *\/$/;"	m	struct:amatch_cursor	file:
pCurrent	.\ext\misc\closure.c	/^  closure_avl *pCurrent;     \/* Current element of output *\/$/;"	m	struct:closure_cursor	file:
pCurrent	.\src\os_unix.c	/^  sqlite3_syscall_ptr pCurrent; \/* Current value of the system call *\/$/;"	m	struct:unix_syscall	file:
pCurrent	.\src\os_win.c	/^  sqlite3_syscall_ptr pCurrent; \/* Current value of the system call *\/$/;"	m	struct:win_syscall	file:
pCursor	.\ext\fts3\fts3_snippet.c	/^  Fts3Cursor *pCursor;            \/* FTS3 Cursor *\/$/;"	m	struct:MatchInfo	file:
pCursor	.\src\btreeInt.h	/^  BtCursor *pCursor;    \/* A list of all open cursors *\/$/;"	m	struct:BtShared
pCursor	.\src\vdbeInt.h	/^  BtCursor *pCursor;    \/* The cursor structure of the backend *\/$/;"	m	struct:VdbeCursor
pData	.\ext\async\sqlite3async.c	/^  AsyncFileData *pData;$/;"	m	struct:AsyncFile	file:
pData	.\ext\fts1\fts1.c	/^  char *pData;$/;"	m	struct:DocList	file:
pData	.\ext\fts1\fulltext.c	/^  char *pData;$/;"	m	struct:DocList	file:
pData	.\ext\fts2\fts2.c	/^  char *pData;          \/* Pointer to malloc'ed buffer. *\/$/;"	m	struct:DataBuffer	file:
pData	.\ext\fts2\fts2.c	/^  const char *pData;        \/* data for current term. *\/$/;"	m	struct:LeafReader	file:
pData	.\ext\fts2\fts2.c	/^  const char *pData;$/;"	m	struct:DLReader	file:
pData	.\ext\fts2\fts2.c	/^  const char *pData;$/;"	m	struct:InteriorReader	file:
pData	.\ext\fts2\fts2.c	/^  const char *pData;$/;"	m	struct:PLReader	file:
pData	.\ext\fts5\fts5_index.c	/^  Fts5Data *pData;              \/* Data for current page of this level *\/$/;"	m	struct:Fts5DlidxLvl	file:
pData	.\src\pcache.h	/^  void *pData;                   \/* Page data *\/$/;"	m	struct:PgHdr
pDb	.\src\tclsqlite.c	/^  SqliteDb *pDb;                  \/* Database handle *\/$/;"	m	struct:DbEvalContext	file:
pDb	.\src\tclsqlite.c	/^  SqliteDb *pDb;            \/* Associated database connection *\/$/;"	m	struct:IncrblobChannel	file:
pDb	.\src\tclsqlite.c	/^  SqliteDb *pDb;        \/* Database connection that owns this function *\/$/;"	m	struct:SqlFunc	file:
pDb	.\src\test_server.c	/^  sqlite3 *pDb;                \/* The SQLite connection *\/$/;"	m	struct:SqlMessage	file:
pDb	.\tool\showdb.c	/^  sqlite3 *pDb;                   \/* Database handle that owns pFd *\/$/;"	m	struct:GlobalData	file:
pDbFd	.\src\wal.c	/^  sqlite3_file *pDbFd;       \/* File handle for the database file *\/$/;"	m	struct:Wal	file:
pDbList	.\src\test_schema.c	/^  sqlite3_stmt *pDbList;$/;"	m	struct:schema_cursor	file:
pDbPage	.\src\btreeInt.h	/^  DbPage *pDbPage;     \/* Pager page handle *\/$/;"	m	struct:MemPage
pDef	.\src\vdbeInt.h	/^    FuncDef *pDef;      \/* Used only when flags==MEM_Agg *\/$/;"	m	union:Mem::MemValue
pDefault	.\src\os_unix.c	/^  sqlite3_syscall_ptr pDefault; \/* Default value *\/$/;"	m	struct:unix_syscall	file:
pDefault	.\src\os_win.c	/^  sqlite3_syscall_ptr pDefault; \/* Default value *\/$/;"	m	struct:win_syscall	file:
pDeferred	.\ext\fts3\fts3Int.h	/^  Fts3DeferredToken *pDeferred;   \/* Deferred search tokens, if any *\/$/;"	m	struct:Fts3Cursor
pDeferred	.\ext\fts3\fts3Int.h	/^  Fts3DeferredToken *pDeferred;   \/* Deferred token object for this token *\/$/;"	m	struct:Fts3PhraseToken
pDel	.\src\test1.c	/^  Tcl_Obj *pDel;$/;"	m	struct:TestCollationX	file:
pDelFrame	.\src\vdbeInt.h	/^  VdbeFrame *pDelFrame;   \/* List of frame objects to free on VM reset *\/$/;"	m	struct:Vdbe
pDelete	.\ext\rbu\sqlite3rbu.c	/^  sqlite3_stmt *pDelete;          \/* Statement for DELETE ops *\/$/;"	m	struct:RbuObjIter	file:
pDeleteNode	.\ext\rtree\rtree.c	/^  sqlite3_stmt *pDeleteNode;$/;"	m	struct:Rtree	file:
pDeleteParent	.\ext\rtree\rtree.c	/^  sqlite3_stmt *pDeleteParent;$/;"	m	struct:Rtree	file:
pDeleteRowid	.\ext\rtree\rtree.c	/^  sqlite3_stmt *pDeleteRowid;$/;"	m	struct:Rtree	file:
pDeleted	.\ext\rtree\rtree.c	/^  RtreeNode *pDeleted;$/;"	m	struct:Rtree	file:
pDeleter	.\ext\fts5\fts5_index.c	/^  sqlite3_stmt *pDeleter;         \/* "DELETE FROM %_data ... id>=? AND id<=?" *\/$/;"	m	struct:Fts5Index	file:
pDest	.\src\backup.c	/^  Btree *pDest;            \/* Destination b-tree file *\/$/;"	m	struct:sqlite3_backup	file:
pDestDb	.\src\backup.c	/^  sqlite3* pDestDb;        \/* Destination database handle *\/$/;"	m	struct:sqlite3_backup	file:
pDestroy	.\src\test1.c	/^  Tcl_Obj *pDestroy;              \/* Destructor script *\/$/;"	m	struct:CreateFunctionV2	file:
pDestructor	.\src\sqliteInt.h	/^  FuncDestructor *pDestructor;   \/* Reference counted destructor function *\/$/;"	m	struct:FuncDef
pDflt	.\src\sqliteInt.h	/^  Expr *pDflt;     \/* Default value of this column *\/$/;"	m	struct:Column
pDfltColl	.\src\sqliteInt.h	/^  CollSeq *pDfltColl;           \/* The default collating sequence (BINARY) *\/$/;"	m	struct:sqlite3
pDfltReduce	.\tool\lemon.c	/^  struct rule *pDfltReduce;\/* The default REDUCE rule. *\/$/;"	m	struct:state	typeref:struct:state::rule	file:
pDfltTok	.\ext\fts5\fts5_main.c	/^  Fts5TokenizerModule *pDfltTok;  \/* Default tokenizer module *\/$/;"	m	struct:Fts5Global	file:
pDirty	.\src\pcache.c	/^  PgHdr *pDirty, *pDirtyTail;         \/* List of dirty pages in LRU order *\/$/;"	m	struct:PCache	file:
pDirty	.\src\pcache.h	/^  PgHdr *pDirty;                 \/* Transient list of dirty pages *\/$/;"	m	struct:PgHdr
pDirtyNext	.\src\pcache.h	/^  PgHdr *pDirtyNext;             \/* Next element in list of dirty pages *\/$/;"	m	struct:PgHdr
pDirtyPrev	.\src\pcache.h	/^  PgHdr *pDirtyPrev;             \/* Previous element in list of dirty pages *\/$/;"	m	struct:PgHdr
pDirtyTail	.\src\pcache.c	/^  PgHdr *pDirty, *pDirtyTail;         \/* List of dirty pages in LRU order *\/$/;"	m	struct:PCache	file:
pDisconnect	.\src\sqliteInt.h	/^  VTable *pDisconnect;    \/* Disconnect these in next sqlite3_prepare() *\/$/;"	m	struct:sqlite3
pDlidx	.\ext\fts5\fts5_index.c	/^  Fts5DlidxIter *pDlidx;          \/* If there is a doclist-index *\/$/;"	m	struct:Fts5SegIter	file:
pDoclist	.\ext\fts1\fts1.c	/^  DocList *pDoclist;  \/* The document list we are stepping through *\/$/;"	m	struct:DocListReader	file:
pDoclist	.\ext\fts1\fulltext.c	/^  DocList *pDoclist;$/;"	m	struct:DocListReader	file:
pDone	.\ext\misc\fuzzer.c	/^  fuzzer_stem *pDone;        \/* Stems already processed to completion *\/$/;"	m	struct:fuzzer_cursor	file:
pDummy	.\src\test_pcache.c	/^  void *pDummy;             \/* Dummy allocation to simulate failures *\/$/;"	m	struct:testpcacheGlobalType	file:
pEList	.\src\sqliteInt.h	/^  ExprList *pEList;      \/* The fields of the result *\/$/;"	m	struct:Select
pEList	.\src\sqliteInt.h	/^  ExprList *pEList;    \/* Optional list of result-set columns *\/$/;"	m	struct:NameContext
pEnd	.\src\pcache1.c	/^  void *pStart, *pEnd;           \/* Bounds of global page cache memory *\/$/;"	m	struct:PCacheGlobal	file:
pEnd	.\src\sqliteInt.h	/^  void *pEnd;             \/* First byte past end of available space *\/$/;"	m	struct:Lookaside
pEntry	.\src\rowset.c	/^  struct RowSetEntry *pEntry;    \/* List of entries using pRight *\/$/;"	m	struct:RowSet	typeref:struct:RowSet::RowSetEntry	file:
pEpoTab	.\src\sqliteInt.h	/^  Table *pEpoTab;                      \/* Eponymous table for this module *\/$/;"	m	struct:Module
pErr	.\src\sqliteInt.h	/^  sqlite3_value *pErr;          \/* Most recent error message *\/$/;"	m	struct:sqlite3
pErrLog	.\mptest\mptest.c	/^  FILE *pErrLog;         \/* Where to write errors *\/$/;"	m	struct:Global	file:
pExpr	.\ext\fts3\fts3Int.h	/^  Fts3Expr *pExpr;                \/* Parsed MATCH query string *\/$/;"	m	struct:Fts3Cursor
pExpr	.\ext\fts3\fts3_snippet.c	/^  Fts3Expr *pExpr;                \/* Pointer to phrase expression *\/$/;"	m	struct:LcsIterator	file:
pExpr	.\ext\fts5\fts5_expr.c	/^  Fts5ExprNode *pExpr;            \/* Result of a successful parse *\/$/;"	m	struct:Fts5Parse	file:
pExpr	.\ext\fts5\fts5_main.c	/^  Fts5Expr *pExpr;                \/* Expression for MATCH queries *\/$/;"	m	struct:Fts5Cursor	file:
pExpr	.\src\sqliteInt.h	/^    Expr *pExpr;             \/* Expression encoding the function *\/$/;"	m	struct:AggInfo::AggInfo_func
pExpr	.\src\sqliteInt.h	/^    Expr *pExpr;             \/* The original expression *\/$/;"	m	struct:AggInfo::AggInfo_col
pExpr	.\src\sqliteInt.h	/^    Expr *pExpr;            \/* The list of expressions *\/$/;"	m	struct:ExprList::ExprList_item
pExpr	.\src\sqliteInt.h	/^  Expr *pExpr;          \/* The expression parse tree *\/$/;"	m	struct:ExprSpan
pExpr	.\src\whereInt.h	/^  Expr *pExpr;            \/* Pointer to the subexpression that is this term *\/$/;"	m	struct:WhereTerm
pExprList	.\src\sqliteInt.h	/^  ExprList *pExprList; \/* SET clause for UPDATE. *\/$/;"	m	struct:TriggerStep
pExtra	.\src\pcache.h	/^  void *pExtra;                  \/* Extra content *\/$/;"	m	struct:PgHdr
pFKey	.\src\sqliteInt.h	/^  FKey *pFKey;         \/* Linked list of all foreign keys in this table *\/$/;"	m	struct:Table
pFd	.\src\test_osinst.c	/^  sqlite3_file *pFd;              \/* File descriptor open on vfslog file *\/$/;"	m	struct:VfslogVtab	file:
pFd	.\src\test_vfs.c	/^  TestvfsFd *pFd;                 \/* File data *\/$/;"	m	struct:TestvfsFile	file:
pFd	.\src\vdbesort.c	/^  sqlite3_file *pFd;              \/* File handle *\/$/;"	m	struct:SorterFile	file:
pFd	.\src\vdbesort.c	/^  sqlite3_file *pFd;              \/* File handle to write to *\/$/;"	m	struct:PmaWriter	file:
pFd	.\src\vdbesort.c	/^  sqlite3_file *pFd;          \/* File handle we are reading from *\/$/;"	m	struct:PmaReader	file:
pFd	.\src\wal.c	/^  sqlite3_file *pFd;           \/* The WAL file to which we write *\/$/;"	m	struct:WalWriter	file:
pFd	.\tool\showdb.c	/^  sqlite3_file *pFd;              \/* File descriptor for non-raw mode *\/$/;"	m	struct:GlobalData	file:
pFile	.\ext\async\sqlite3async.c	/^  sqlite3_file *pFile;$/;"	m	struct:AsyncLock	file:
pFile	.\src\test6.c	/^  CrashFile *pFile;            \/* File this write() applies to *\/$/;"	m	struct:WriteBuffer	file:
pFile	.\src\test_onefile.c	/^  sqlite3_file *pFile;$/;"	m	struct:fs_real_file	file:
pFile	.\src\test_quota.c	/^  quotaFile *pFile;               \/* The underlying file *\/$/;"	m	struct:quotaConn	file:
pFile	.\src\test_quota.c	/^  quotaFile *pFile;       \/* The file record in the quota system *\/$/;"	m	struct:quota_FILE	file:
pFile	.\src\test_vfs.c	/^  TestvfsFd *pFile;               \/* List of open handles *\/$/;"	m	struct:TestvfsBuffer	file:
pFileData	.\ext\async\sqlite3async.c	/^  AsyncFileData *pFileData;    \/* File to write data to or sync *\/$/;"	m	struct:AsyncWrite	file:
pFileList	.\src\test_onefile.c	/^  fs_real_file *pFileList;$/;"	m	struct:fs_vfs_t	file:
pFiles	.\src\test_quota.c	/^  quotaFile *pFiles;             \/* Files within this group *\/$/;"	m	struct:quotaGroup	file:
pFiller	.\src\vdbeInt.h	/^  void *pFiller;      \/* So that sizeof(Mem) is a multiple of 8 *\/$/;"	m	struct:Mem
pFilter	.\ext\fts3\fts3Int.h	/^  Fts3SegFilter *pFilter;         \/* Pointer to filter object *\/$/;"	m	struct:Fts3MultiSegReader
pFinal	.\src\test1.c	/^  Tcl_Obj *pFinal;                \/* Script for agg. finalization invocation *\/$/;"	m	struct:CreateFunctionV2	file:
pFirst	.\ext\misc\closure.c	/^  closure_avl *pFirst;       \/* Oldest node on the queue *\/$/;"	m	struct:closure_queue	file:
pFirst	.\src\mem2.c	/^  struct MemBlockHdr *pFirst;$/;"	m	struct:__anon10	typeref:struct:__anon10::MemBlockHdr	file:
pFirst	.\src\memjournal.c	/^  FileChunk *pFirst;              \/* Head of in-memory chunk-list *\/$/;"	m	struct:MemJournal	file:
pFirst	.\src\os_unix.c	/^  unixShm *pFirst;           \/* All unixShm objects pointing to this *\/$/;"	m	struct:unixShmNode	file:
pFirst	.\src\os_win.c	/^  winShm *pFirst;            \/* All winShm objects pointing to this *\/$/;"	m	struct:winShmNode	file:
pFirstDb	.\test\fuzzcheck.c	/^  Blob *pFirstDb;                  \/* Content of first template database *\/$/;"	m	struct:GlobalVars	file:
pFirstSql	.\test\fuzzcheck.c	/^  Blob *pFirstSql;                 \/* First SQL script *\/$/;"	m	struct:GlobalVars	file:
pForest	.\src\rowset.c	/^  struct RowSetEntry *pForest;   \/* List of binary trees of entries *\/$/;"	m	struct:RowSet	typeref:struct:RowSet::RowSetEntry	file:
pFrame	.\src\vdbeInt.h	/^    VdbeFrame *pFrame;  \/* Used when flags==MEM_Frame *\/$/;"	m	union:Mem::MemValue
pFrame	.\src\vdbeInt.h	/^  VdbeFrame *pFrame;      \/* Parent frame *\/$/;"	m	struct:Vdbe
pFree	.\src\pcache1.c	/^  PgFreeslot *pFree;             \/* Free page blocks *\/$/;"	m	struct:PCacheGlobal	file:
pFree	.\src\pcache1.c	/^  PgHdr1 *pFree;                      \/* List of unused pcache-local pages *\/$/;"	m	struct:PCache1	file:
pFree	.\src\sqliteInt.h	/^  LookasideSlot *pFree;   \/* List of available buffers *\/$/;"	m	struct:Lookaside
pFree	.\src\test_wsd.c	/^  u8 *pFree;$/;"	m	struct:ProcessLocalStorage	file:
pFree	.\src\vdbeInt.h	/^  void *pFree;            \/* Free this when deleting the vdbe *\/$/;"	m	struct:Vdbe
pFresh	.\src\rowset.c	/^  struct RowSetEntry *pFresh;    \/* Source of new entry objects *\/$/;"	m	struct:RowSet	typeref:struct:RowSet::RowSetEntry	file:
pFrom	.\src\sqliteInt.h	/^  Table *pFrom;     \/* Table containing the REFERENCES clause (aka: Child) *\/$/;"	m	struct:FKey
pFts	.\ext\fts1\fts1.c	/^  fulltext_vtab *pFts;  \/* The full text index *\/$/;"	m	struct:Query	file:
pFts	.\ext\fts2\fts2.c	/^  fulltext_vtab *pFts;  \/* The full text index *\/$/;"	m	struct:Query	file:
pFts	.\ext\fts5\fts5_aux.c	/^  Fts5Context *pFts;              \/* First arg to pass to pApi functions *\/$/;"	m	struct:CInstIter	file:
pFts	.\ext\fts5\fts5_tcl.c	/^  Fts5Context *pFts;$/;"	m	struct:F5tApi	file:
pFts3Tab	.\ext\fts3\fts3_aux.c	/^  Fts3Table *pFts3Tab;$/;"	m	struct:Fts3auxTable	file:
pFts3Tab	.\ext\fts3\fts3_term.c	/^  Fts3Table *pFts3Tab;$/;"	m	struct:Fts3termTable	file:
pFullScan	.\ext\misc\spellfix.c	/^  sqlite3_stmt *pFullScan;     \/* Shadow query for a full table scan *\/$/;"	m	struct:spellfix1_cursor	file:
pFulltextStatements	.\ext\fts1\fts1.c	/^  sqlite3_stmt *pFulltextStatements[MAX_STMT];$/;"	m	struct:fulltext_vtab	file:
pFulltextStatements	.\ext\fts1\fulltext.c	/^  sqlite3_stmt *pFulltextStatements[MAX_STMT];$/;"	m	struct:fulltext_vtab	file:
pFulltextStatements	.\ext\fts2\fts2.c	/^  sqlite3_stmt *pFulltextStatements[MAX_STMT];$/;"	m	struct:fulltext_vtab	file:
pFunc	.\src\sqliteInt.h	/^    FuncDef *pFunc;          \/* The aggregate function implementation *\/$/;"	m	struct:AggInfo::AggInfo_func
pFunc	.\src\tclsqlite.c	/^  SqlFunc *pFunc;            \/* List of SQL functions *\/$/;"	m	struct:SqliteDb	file:
pFunc	.\src\test1.c	/^  Tcl_Obj *pFunc;                 \/* Script for function invocation *\/$/;"	m	struct:CreateFunctionV2	file:
pFunc	.\src\vdbe.h	/^    FuncDef *pFunc;        \/* Used when p4type is P4_FUNCDEF *\/$/;"	m	union:VdbeOp::p4union
pFunc	.\src\vdbeInt.h	/^  FuncDef *pFunc;         \/* Pointer to function information *\/$/;"	m	struct:sqlite3_context
pFuncArg	.\src\sqliteInt.h	/^      ExprList *pFuncArg;  \/* Arguments to table-valued-function *\/$/;"	m	union:SrcList::SrcList_item::__anon20
pGlobal	.\ext\fts5\fts5_main.c	/^  Fts5Global *pGlobal;            \/* Global (connection wide) data *\/$/;"	m	struct:Fts5Table	file:
pGlobal	.\ext\fts5\fts5_main.c	/^  Fts5Global *pGlobal;            \/* Global context for this function *\/$/;"	m	struct:Fts5Auxiliary	file:
pGlobal	.\ext\fts5\fts5_vocab.c	/^  Fts5Global *pGlobal;            \/* FTS5 global object for this database *\/$/;"	m	struct:Fts5VocabTable	file:
pGlobal	.\src\test_wsd.c	/^static ProcessLocalStorage *pGlobal = 0;$/;"	v	file:
pGroup	.\src\pcache1.c	/^  PGroup *pGroup;                     \/* PGroup this cache belongs to *\/$/;"	m	struct:PCache1	file:
pGroup	.\src\test_multiplex.c	/^  multiplexGroup *pGroup;         \/* The underlying group of files *\/$/;"	m	struct:multiplexConn	file:
pGroup	.\src\test_quota.c	/^  quotaGroup *pGroup;             \/* Quota group to which this file belongs *\/$/;"	m	struct:quotaFile	file:
pGroup	.\src\test_quota.c	/^  quotaGroup *pGroup;$/;"	m	struct:__anon24	file:
pGroupBy	.\src\sqliteInt.h	/^  ExprList *pGroupBy;     \/* The group by clause *\/$/;"	m	struct:AggInfo
pGroupBy	.\src\sqliteInt.h	/^  ExprList *pGroupBy;    \/* The GROUP BY clause *\/$/;"	m	struct:Select
pGroups	.\src\test_multiplex.c	/^  multiplexGroup *pGroups;$/;"	m	struct:__anon23	file:
pHasContent	.\src\btreeInt.h	/^  Bitvec *pHasContent;  \/* Set of pages moved to free-list this transaction *\/$/;"	m	struct:BtShared
pHash	.\ext\fts5\fts5_index.c	/^  Fts5Hash *pHash;                \/* Hash table for in-memory data *\/$/;"	m	struct:Fts5Index	file:
pHash	.\ext\misc\fuzzer.c	/^  fuzzer_stem *pHash;        \/* Next stem with same hash on zBasis *\/$/;"	m	struct:fuzzer_stem	file:
pHash	.\src\sqliteInt.h	/^  FuncDef *pHash;      \/* Next with a different name but the same hash *\/$/;"	m	struct:FuncDef
pHashNext	.\ext\fts5\fts5_hash.c	/^  Fts5HashEntry *pHashNext;       \/* Next hash entry with same hash-key *\/$/;"	m	struct:Fts5HashEntry	file:
pHaving	.\src\sqliteInt.h	/^  Expr *pHaving;         \/* The HAVING clause *\/$/;"	m	struct:Select
pHead	.\ext\fts3\fts3_snippet.c	/^  char *pHead;                    \/* Position list data following iHead *\/$/;"	m	struct:SnippetPhrase	file:
pHeap	.\src\sqliteInt.h	/^  void *pHeap;                      \/* Heap storage space *\/$/;"	m	struct:Sqlite3Config
pI64	.\src\vdbe.h	/^    i64 *pI64;             \/* Used when p4type is P4_INT64 *\/$/;"	m	union:VdbeOp::p4union
pIBIndex	.\src\sqliteInt.h	/^    Index *pIBIndex;  \/* Index structure corresponding to u1.zIndexedBy *\/$/;"	m	struct:SrcList::SrcList_item
pId	.\src\os_unix.c	/^  struct vxworksFileId *pId;          \/* Unique file ID *\/$/;"	m	struct:unixFile	typeref:struct:unixFile::vxworksFileId	file:
pId	.\src\os_unix.c	/^  struct vxworksFileId *pId;  \/* Unique file ID for vxworks. *\/$/;"	m	struct:unixFileId	typeref:struct:unixFileId::vxworksFileId	file:
pIdList	.\src\sqliteInt.h	/^  IdList *pIdList;     \/* Column names for INSERT *\/$/;"	m	struct:TriggerStep
pIdx	.\ext\fts5\fts5_index.c	/^  Fts5Index *pIdx;$/;"	m	struct:Fts5FlushCtx	file:
pIdx	.\src\vdbemem.c	/^  Index *pIdx;$/;"	m	struct:ValueNewStat4Ctx	file:
pIdxDeleter	.\ext\fts5\fts5_index.c	/^  sqlite3_stmt *pIdxDeleter;      \/* "DELETE FROM %_idx WHERE segid=? *\/$/;"	m	struct:Fts5Index	file:
pIdxExpr	.\src\whereInt.h	/^  Expr *pIdxExpr;            \/* Search for this index expression *\/$/;"	m	struct:WhereScan
pIdxIter	.\ext\rbu\sqlite3rbu.c	/^  sqlite3_stmt *pIdxIter;         \/* Index iterator *\/$/;"	m	struct:RbuObjIter	file:
pIdxSelect	.\ext\fts5\fts5_index.c	/^  sqlite3_stmt *pIdxSelect;$/;"	m	struct:Fts5Index	file:
pIdxWriter	.\ext\fts5\fts5_index.c	/^  sqlite3_stmt *pIdxWriter;       \/* "INSERT ... %_idx VALUES(?,?,?,?)" *\/$/;"	m	struct:Fts5Index	file:
pIn	.\src\threads.c	/^  void *pIn;                     \/* Argument to the thread *\/$/;"	m	struct:SQLiteThread	file:
pIn	.\src\threads.c	/^  void *pIn;               \/* Argument to xTask *\/$/;"	m	struct:SQLiteThread	file:
pInJournal	.\src\pager.c	/^  Bitvec *pInJournal;         \/* One bit for each page in the database file *\/$/;"	m	struct:Pager	file:
pInSavepoint	.\src\pager.c	/^  Bitvec *pInSavepoint;        \/* Set of pages in this savepoint *\/$/;"	m	struct:PagerSavepoint	file:
pIncr	.\src\vdbesort.c	/^  IncrMerger *pIncr;          \/* Incremental merger *\/$/;"	m	struct:PmaReader	file:
pIncrblob	.\src\tclsqlite.c	/^  IncrblobChannel *pIncrblob;\/* Linked list of open incrblob channels *\/$/;"	m	struct:SqliteDb	file:
pIndex	.\ext\fts5\fts5_expr.c	/^  Fts5Index *pIndex;$/;"	m	struct:Fts5Expr	file:
pIndex	.\ext\fts5\fts5_index.c	/^  Fts5Index *pIndex;              \/* Index that owns this iterator *\/$/;"	m	struct:Fts5IndexIter	file:
pIndex	.\ext\fts5\fts5_main.c	/^  Fts5Index *pIndex;              \/* Full-text index *\/$/;"	m	struct:Fts5Table	file:
pIndex	.\ext\fts5\fts5_storage.c	/^  Fts5Index *pIndex;$/;"	m	struct:Fts5Storage	file:
pIndex	.\ext\fts5\fts5_vocab.c	/^  Fts5Index *pIndex;              \/* Associated FTS5 index *\/$/;"	m	struct:Fts5VocabCursor	file:
pIndex	.\src\sqliteInt.h	/^  Index *pIndex;       \/* List of SQL indexes on this table. *\/$/;"	m	struct:Table
pIndex	.\src\whereInt.h	/^      Index *pIndex;         \/* Index used, or NULL *\/$/;"	m	struct:WhereLoop::__anon28::__anon29
pInfo	.\ext\rtree\rtree.c	/^  sqlite3_rtree_query_info *pInfo;  \/* xGeom and xQueryFunc argument *\/$/;"	m	struct:RtreeConstraint	file:
pInfo	.\src\test_vfstrace.c	/^  vfstrace_info *pInfo;     \/* The trace-VFS to which this file belongs *\/$/;"	m	struct:vfstrace_file	file:
pInitMutex	.\src\sqliteInt.h	/^  sqlite3_mutex *pInitMutex;        \/* Mutex used by sqlite3_initialize() *\/$/;"	m	struct:Sqlite3Config
pInode	.\src\os_unix.c	/^  unixInodeInfo *pInode;              \/* Info about locks on this inode *\/$/;"	m	struct:unixFile	file:
pInode	.\src\os_unix.c	/^  unixInodeInfo *pInode;     \/* unixInodeInfo that owns this SHM node *\/$/;"	m	struct:unixShmNode	file:
pInput	.\ext\fts1\fts1_tokenizer1.c	/^  const char *pInput;          \/* input we are tokenizing *\/$/;"	m	struct:simple_tokenizer_cursor	file:
pInput	.\ext\fts1\simple_tokenizer.c	/^  const char *pInput;          \/* input we are tokenizing *\/$/;"	m	struct:simple_tokenizer_cursor	file:
pInput	.\ext\fts2\fts2_tokenizer1.c	/^  const char *pInput;          \/* input we are tokenizing *\/$/;"	m	struct:simple_tokenizer_cursor	file:
pInput	.\ext\fts3\fts3_tokenizer1.c	/^  const char *pInput;          \/* input we are tokenizing *\/$/;"	m	struct:simple_tokenizer_cursor	file:
pInsert	.\ext\rbu\sqlite3rbu.c	/^  sqlite3_stmt *pInsert;          \/* Statement for INSERT operations *\/$/;"	m	struct:RbuObjIter	file:
pInsert	.\tool\loadfts.c	/^  sqlite3_stmt *pInsert;          \/* INSERT INTO fts VALUES(readtext(:1)) *\/$/;"	m	struct:VisitContext	file:
pInterp	.\src\test1.c	/^  Tcl_Interp *pInterp;$/;"	m	struct:LogCallback	file:
pIter	.\ext\fts2\fts2_icu.c	/^  UBreakIterator *pIter;      \/* ICU break-iterator object *\/$/;"	m	struct:IcuCursor	file:
pIter	.\ext\fts3\fts3_icu.c	/^  UBreakIterator *pIter;      \/* ICU break-iterator object *\/$/;"	m	struct:IcuCursor	file:
pIter	.\ext\fts5\fts5_expr.c	/^  Fts5IndexIter *pIter;           \/* Iterator for this term *\/$/;"	m	struct:Fts5ExprTerm	file:
pIter	.\ext\fts5\fts5_vocab.c	/^  Fts5IndexIter *pIter;           \/* Term\/rowid iterator object *\/$/;"	m	struct:Fts5VocabCursor	file:
pKey	.\ext\fts1\ft_hash.h	/^  void *pKey; int nKey;    \/* Key associated with this element *\/$/;"	m	struct:HashElem
pKey	.\ext\fts1\fts1_hash.h	/^  void *pKey; int nKey;      \/* Key associated with this element *\/$/;"	m	struct:fts1HashElem
pKey	.\ext\fts2\fts2_hash.h	/^  void *pKey; int nKey;      \/* Key associated with this element *\/$/;"	m	struct:fts2HashElem
pKey	.\ext\fts3\fts3_hash.h	/^  void *pKey; int nKey;      \/* Key associated with this element *\/$/;"	m	struct:Fts3HashElem
pKey	.\src\btreeInt.h	/^  void *pKey;               \/* Saved key that was cursor last known position *\/$/;"	m	struct:BtCursor
pKey	.\src\hash.h	/^  const char *pKey;            \/* Key associated with this element *\/$/;"	m	struct:HashElem
pKey	.\src\test_wsd.c	/^  void *pKey;$/;"	m	struct:ProcessLocalVar	file:
pKeyInfo	.\src\btreeInt.h	/^  struct KeyInfo *pKeyInfo; \/* Argument passed to comparison function *\/$/;"	m	struct:BtCursor	typeref:struct:BtCursor::KeyInfo
pKeyInfo	.\src\sqliteInt.h	/^  KeyInfo *pKeyInfo;  \/* Collation and sort-order information *\/$/;"	m	struct:UnpackedRecord
pKeyInfo	.\src\vdbe.h	/^    KeyInfo *pKeyInfo;     \/* Used when p4type is P4_KEYINFO *\/$/;"	m	union:VdbeOp::p4union
pKeyInfo	.\src\vdbeInt.h	/^  KeyInfo *pKeyInfo;    \/* Info about index keys needed by index cursors *\/$/;"	m	struct:VdbeCursor
pKeyInfo	.\src\vdbesort.c	/^  KeyInfo *pKeyInfo;              \/* How to compare records *\/$/;"	m	struct:VdbeSorter	file:
pLang	.\ext\misc\spellfix.c	/^  const EditDist3Lang *pLang;      \/* The selected language coefficients *\/$/;"	m	struct:MatchQuery	file:
pLast	.\ext\misc\closure.c	/^  closure_avl *pLast;        \/* Youngest node on the queue *\/$/;"	m	struct:closure_queue	file:
pLast	.\src\mem2.c	/^  struct MemBlockHdr *pLast;$/;"	m	struct:__anon10	typeref:struct:__anon10::MemBlockHdr	file:
pLast	.\src\rowset.c	/^  struct RowSetEntry *pLast;     \/* Last entry on the pEntry list *\/$/;"	m	struct:RowSet	typeref:struct:RowSet::RowSetEntry	file:
pLast	.\src\sqliteInt.h	/^  TriggerStep *pLast;  \/* Last element in link-list. Valid for 1st elem only *\/$/;"	m	struct:TriggerStep
pLeaf	.\ext\fts5\fts5_index.c	/^  Fts5Data *pLeaf;                \/* Current leaf data *\/$/;"	m	struct:Fts5SegIter	file:
pLeafSelectStmts	.\ext\fts2\fts2.c	/^  sqlite3_stmt *pLeafSelectStmts[MERGE_COUNT];$/;"	m	struct:fulltext_vtab	file:
pLeft	.\ext\fts3\fts3Int.h	/^  Fts3Expr *pLeft;           \/* Left operand *\/$/;"	m	struct:Fts3Expr
pLeft	.\src\rowset.c	/^  struct RowSetEntry *pLeft;    \/* Left subtree (smaller entries) *\/$/;"	m	struct:RowSetEntry	typeref:struct:RowSetEntry::RowSetEntry	file:
pLeft	.\src\sqliteInt.h	/^  Expr *pLeft;           \/* Left subnode *\/$/;"	m	struct:Expr
pLeftmost	.\ext\fts3\fts3_write.c	/^  SegmentNode *pLeftmost;         \/* Pointer to left-most node of this depth *\/$/;"	m	struct:SegmentNode	file:
pLimit	.\src\sqliteInt.h	/^  Expr *pLimit;          \/* LIMIT expression. NULL means not used. *\/$/;"	m	struct:Select
pList	.\ext\async\sqlite3async.c	/^  AsyncFileLock *pList;$/;"	m	struct:AsyncLock	file:
pList	.\ext\fts3\fts3.c	/^  char *pList;$/;"	m	struct:TokenDoclist	file:
pList	.\ext\fts3\fts3Int.h	/^  char *pList;                   \/* Pointer to position list following iDocid *\/$/;"	m	struct:Fts3Doclist
pList	.\ext\fts3\fts3_snippet.c	/^  char *pList;                    \/* Pointer to start of phrase position list *\/$/;"	m	struct:SnippetPhrase	file:
pList	.\ext\fts3\fts3_snippet.c	/^  char *pList;                    \/* Position-list *\/$/;"	m	struct:TermOffset	file:
pList	.\ext\fts3\fts3_write.c	/^  PendingList *pList;             \/* Doclist is assembled here *\/$/;"	m	struct:Fts3DeferredToken	file:
pList	.\ext\misc\closure.c	/^  closure_avl *pList;   \/* A linked list of nodes *\/$/;"	m	struct:closure_avl	file:
pList	.\src\sqliteInt.h	/^    ExprList *pList;     \/* op = IN, EXISTS, SELECT, CASE, FUNCTION, BETWEEN *\/$/;"	m	union:Expr::__anon16
pList	.\src\test_journal.c	/^  jt_file *pList;                \/* List of all open files *\/$/;"	m	struct:JtGlobal	file:
pList	.\src\vdbesort.c	/^  SorterRecord *pList;            \/* Linked list of records *\/$/;"	m	struct:SorterList	file:
pList1	.\src\test_tclvar.c	/^  Tcl_Obj *pList1;     \/* Result of [info vars ?pattern?] *\/$/;"	m	struct:tclvar_cursor	file:
pList2	.\src\test_tclvar.c	/^  Tcl_Obj *pList2;     \/* Result of [array names [lindex $pList1 $i1]] *\/$/;"	m	struct:tclvar_cursor	file:
pLock	.\ext\async\sqlite3async.c	/^  AsyncLock *pLock;            \/* Linked list of all AsyncLock structures *\/$/;"	m	struct:TestAsyncStaticData	file:
pLock	.\ext\async\sqlite3async.c	/^  AsyncLock *pLock;          \/* AsyncLock object for this file system entry *\/$/;"	m	struct:AsyncFileData	file:
pLock	.\src\btreeInt.h	/^  BtLock *pLock;        \/* List of locks held on this shared-btree struct *\/$/;"	m	struct:BtShared
pLog	.\ext\misc\vfslog.c	/^  VLogLog *pLog;                  \/* The log file for this file *\/$/;"	m	struct:VLogFile	file:
pLog	.\mptest\mptest.c	/^  FILE *pLog;            \/* Where to write log messages *\/$/;"	m	struct:Global	file:
pLog	.\src\shell.c	/^  FILE *pLog;            \/* Write log output here *\/$/;"	m	struct:ShellState	file:
pLog	.\src\test_osinst.c	/^  sqlite3_file *pLog;             \/* Log file handle *\/$/;"	m	struct:VfslogVfs	file:
pLogArg	.\src\sqliteInt.h	/^  void *pLogArg;                       \/* First argument to xLog() *\/$/;"	m	struct:Sqlite3Config
pLoops	.\src\whereInt.h	/^  WhereLoop *pLoops;        \/* List of all WhereLoop objects *\/$/;"	m	struct:WhereInfo
pLruNext	.\src\pcache1.c	/^  PgHdr1 *pLruNext;              \/* Next in LRU list of unpinned pages *\/$/;"	m	struct:PgHdr1	file:
pLruPrev	.\src\pcache1.c	/^  PgHdr1 *pLruPrev;              \/* Previous in LRU list of unpinned pages *\/$/;"	m	struct:PgHdr1	file:
pMIBuffer	.\ext\fts3\fts3Int.h	/^  MatchinfoBuffer *pMIBuffer;     \/* Buffer for matchinfo data *\/$/;"	m	struct:Fts3Cursor
pMain	.\ext\rbu\sqlite3rbu.c	/^  rbu_file *pMain;                \/* Linked list of main db files *\/$/;"	m	struct:rbu_vfs	file:
pMainNext	.\ext\rbu\sqlite3rbu.c	/^  rbu_file *pMainNext;            \/* Next MAIN_DB file *\/$/;"	m	struct:rbu_file	file:
pMap	.\src\os_win.c	/^    void *pMap;$/;"	m	struct:winShmNode::ShmRegion	file:
pMapRegion	.\src\os_unix.c	/^  void *pMapRegion;                   \/* Memory mapped region *\/$/;"	m	struct:unixFile	file:
pMapRegion	.\src\os_win.c	/^  void *pMapRegion;             \/* Area memory mapped *\/$/;"	m	struct:winFile	file:
pMatchStr3	.\ext\misc\spellfix.c	/^  EditDist3FromString *pMatchStr3; \/* Original unicode string *\/$/;"	m	struct:MatchQuery	file:
pMem	.\src\vdbe.h	/^    Mem *pMem;             \/* Used when p4type is P4_MEM *\/$/;"	m	union:VdbeOp::p4union
pMem	.\src\vdbeInt.h	/^  Mem *pMem;              \/* Memory cell used to store aggregate context *\/$/;"	m	struct:sqlite3_context
pMerger	.\src\vdbesort.c	/^  MergeEngine *pMerger;           \/* Merge engine thread reads data from *\/$/;"	m	struct:IncrMerger	file:
pMerger	.\src\vdbesort.c	/^  MergeEngine *pMerger;           \/* Or here, if bUseThreads==0 *\/$/;"	m	struct:VdbeSorter	file:
pMethod	.\ext\async\sqlite3async.c	/^  sqlite3_io_methods *pMethod;$/;"	m	struct:AsyncFile	file:
pMethod	.\src\journal.c	/^  sqlite3_io_methods *pMethod;    \/* I\/O methods on journal files *\/$/;"	m	struct:JournalFile	file:
pMethod	.\src\memjournal.c	/^  sqlite3_io_methods *pMethod;    \/* Parent class. MUST BE FIRST *\/$/;"	m	struct:MemJournal	file:
pMethod	.\src\os_unix.c	/^  sqlite3_io_methods const *pMethod;  \/* Always the first entry *\/$/;"	m	struct:unixFile	file:
pMethod	.\src\os_win.c	/^  const sqlite3_io_methods *pMethod; \/*** Must be first ***\/$/;"	m	struct:winFile	file:
pMethod	.\src\test6.c	/^  const sqlite3_io_methods *pMethod;   \/* Must be first *\/$/;"	m	struct:CrashFile	file:
pMmapFreelist	.\src\pager.c	/^  PgHdr *pMmapFreelist;       \/* List of free mmap page headers (pDirty) *\/$/;"	m	struct:Pager	file:
pMod	.\ext\fts3\fts3_tokenize_vtab.c	/^  const sqlite3_tokenizer_module *pMod;$/;"	m	struct:Fts3tokTable	file:
pMod	.\ext\misc\vtshim.c	/^  sqlite3_module *pMod;         \/* Methods for child virtual tables *\/$/;"	m	struct:vtshim_aux	file:
pMod	.\src\sqliteInt.h	/^  Module *pMod;             \/* Pointer to module implementation *\/$/;"	m	struct:VTable
pModule	.\ext\fts1\fts1_tokenizer.h	/^  const sqlite3_tokenizer_module *pModule;  \/* The module for this tokenizer *\/$/;"	m	struct:sqlite3_tokenizer
pModule	.\ext\fts1\tokenizer.h	/^  sqlite3_tokenizer_module *pModule;  \/* The module for this tokenizer *\/$/;"	m	struct:sqlite3_tokenizer
pModule	.\ext\fts2\fts2_tokenizer.h	/^  const sqlite3_tokenizer_module *pModule;  \/* The module for this tokenizer *\/$/;"	m	struct:sqlite3_tokenizer
pModule	.\ext\fts3\fts3_tokenizer.h	/^  const sqlite3_tokenizer_module *pModule;  \/* The module for this tokenizer *\/$/;"	m	struct:sqlite3_tokenizer
pModule	.\src\sqliteInt.h	/^  const sqlite3_module *pModule;       \/* Callback pointers *\/$/;"	m	struct:Module
pMutex	.\src\test_multiplex.c	/^  sqlite3_mutex *pMutex;$/;"	m	struct:__anon23	file:
pMutex	.\src\test_quota.c	/^  sqlite3_mutex *pMutex;$/;"	m	struct:__anon24	file:
pNC	.\src\sqliteInt.h	/^    NameContext *pNC;                          \/* Naming context *\/$/;"	m	union:Walker::__anon22
pName	.\src\sqliteInt.h	/^  const Token *pName; \/* Name of the container - used for error messages *\/$/;"	m	struct:DbFixer
pNear	.\ext\fts5\fts5_expr.c	/^  Fts5ExprNearset *pNear;         \/* For FTS5_STRING - cluster of phrases *\/$/;"	m	struct:Fts5ExprNode	file:
pNew	.\src\whereInt.h	/^  WhereLoop *pNew;          \/* Template WhereLoop *\/$/;"	m	struct:WhereLoopBuilder
pNewTable	.\src\sqliteInt.h	/^  Table *pNewTable;         \/* A table being constructed by CREATE TABLE *\/$/;"	m	struct:Parse
pNewTrigger	.\src\sqliteInt.h	/^  Trigger *pNewTrigger;     \/* Trigger under construct by a CREATE TRIGGER *\/$/;"	m	struct:Parse
pNext	.\ext\async\sqlite3async.c	/^  AsyncFileLock *pNext;$/;"	m	struct:AsyncFileLock	file:
pNext	.\ext\async\sqlite3async.c	/^  AsyncLock *pNext;           \/* Next in linked list headed by async.pLock *\/$/;"	m	struct:AsyncLock	file:
pNext	.\ext\async\sqlite3async.c	/^  AsyncWrite *pNext;  \/* Next write operation (to any file) *\/$/;"	m	struct:AsyncWrite	file:
pNext	.\ext\fts3\fts3_term.c	/^  char *pNext;$/;"	m	struct:Fts3termCursor	file:
pNext	.\ext\fts3\fts3_write.c	/^  Fts3DeferredToken *pNext;       \/* Next in list of deferred tokens *\/$/;"	m	struct:Fts3DeferredToken	file:
pNext	.\ext\fts5\fts5_main.c	/^  Fts5Auxdata *pNext;             \/* Next object in linked list *\/$/;"	m	struct:Fts5Auxdata	file:
pNext	.\ext\fts5\fts5_main.c	/^  Fts5Auxiliary *pNext;           \/* Next registered auxiliary function *\/$/;"	m	struct:Fts5Auxiliary	file:
pNext	.\ext\fts5\fts5_main.c	/^  Fts5Cursor *pNext;              \/* Next cursor in Fts5Cursor.pCsr list *\/$/;"	m	struct:Fts5Cursor	file:
pNext	.\ext\fts5\fts5_main.c	/^  Fts5TokenizerModule *pNext;     \/* Next registered tokenizer module *\/$/;"	m	struct:Fts5TokenizerModule	file:
pNext	.\ext\misc\amatch.c	/^  amatch_rule *pNext;      \/* Next rule in order of increasing rCost *\/$/;"	m	struct:amatch_rule	file:
pNext	.\ext\misc\amatch.c	/^  amatch_word *pNext;   \/* Next on a list of all amatch_words *\/$/;"	m	struct:amatch_word	file:
pNext	.\ext\misc\fuzzer.c	/^  fuzzer_rule *pNext;         \/* Next rule in order of increasing rCost *\/$/;"	m	struct:fuzzer_rule	file:
pNext	.\ext\misc\fuzzer.c	/^  fuzzer_stem *pNext;        \/* Next stem in rCost order *\/$/;"	m	struct:fuzzer_stem	file:
pNext	.\ext\misc\spellfix.c	/^  EditDist3Cost *pNext;     \/* Next cost element *\/$/;"	m	struct:EditDist3Cost	file:
pNext	.\ext\misc\vfslog.c	/^  VLogLog *pNext;                 \/* Next in a list of all active logs *\/$/;"	m	struct:VLogLog	file:
pNext	.\ext\misc\vtshim.c	/^  vtshim_cursor *pNext;        \/* Next on list of all cursors *\/$/;"	m	struct:vtshim_cursor	file:
pNext	.\ext\misc\vtshim.c	/^  vtshim_vtab *pNext;      \/* Next on list *\/$/;"	m	struct:vtshim_vtab	file:
pNext	.\ext\rbu\sqlite3rbu.c	/^  RbuUpdateStmt *pNext;$/;"	m	struct:RbuUpdateStmt	file:
pNext	.\ext\rtree\rtree.c	/^  RtreeNode *pNext;           \/* Next node in this hash collision chain *\/$/;"	m	struct:RtreeNode	file:
pNext	.\src\backup.c	/^  sqlite3_backup *pNext;   \/* Next backup associated with source pager *\/$/;"	m	struct:sqlite3_backup	file:
pNext	.\src\btreeInt.h	/^  BtCursor *pNext;          \/* Forms a linked list of all cursors *\/$/;"	m	struct:BtCursor
pNext	.\src\btreeInt.h	/^  BtLock *pNext;        \/* Next in BtShared.pLock list *\/$/;"	m	struct:BtLock
pNext	.\src\btreeInt.h	/^  BtShared *pNext;      \/* Next on a list of sharable BtShared structs *\/$/;"	m	struct:BtShared
pNext	.\src\btreeInt.h	/^  Btree *pNext;      \/* List of other sharable Btrees from the same db *\/$/;"	m	struct:Btree
pNext	.\src\malloc.c	/^  struct ScratchFreeslot *pNext;   \/* Next unused scratch buffer *\/$/;"	m	struct:ScratchFreeslot	typeref:struct:ScratchFreeslot::ScratchFreeslot	file:
pNext	.\src\mem2.c	/^  struct MemBlockHdr *pNext, *pPrev;  \/* Linked list of all unfreed memory *\/$/;"	m	struct:MemBlockHdr	typeref:struct:MemBlockHdr::MemBlockHdr	file:
pNext	.\src\memjournal.c	/^  FileChunk *pNext;               \/* Next chunk in the journal *\/$/;"	m	struct:FileChunk	file:
pNext	.\src\os_unix.c	/^  UnixUnusedFd *pNext;      \/* Next unused file descriptor on same file *\/$/;"	m	struct:UnixUnusedFd	file:
pNext	.\src\os_unix.c	/^  struct vxworksFileId *pNext;  \/* Next in a list of them all *\/$/;"	m	struct:vxworksFileId	typeref:struct:vxworksFileId::vxworksFileId	file:
pNext	.\src\os_unix.c	/^  unixInodeInfo *pNext;           \/* List of all unixInodeInfo objects *\/$/;"	m	struct:unixInodeInfo	file:
pNext	.\src\os_unix.c	/^  unixShm *pNext;            \/* Next unixShm with the same unixShmNode *\/$/;"	m	struct:unixShm	file:
pNext	.\src\os_win.c	/^  winShm *pNext;             \/* Next winShm with the same winShmNode *\/$/;"	m	struct:winShm	file:
pNext	.\src\os_win.c	/^  winShmNode *pNext;         \/* Next in list of all winShmNode objects *\/$/;"	m	struct:winShmNode	file:
pNext	.\src\pcache1.c	/^  PgFreeslot *pNext;  \/* Next free slot *\/$/;"	m	struct:PgFreeslot	file:
pNext	.\src\pcache1.c	/^  PgHdr1 *pNext;                 \/* Next in hash table chain *\/$/;"	m	struct:PgHdr1	file:
pNext	.\src\sqliteInt.h	/^  AutoincInfo *pNext;   \/* Next info block in a list of them all *\/$/;"	m	struct:AutoincInfo
pNext	.\src\sqliteInt.h	/^  FuncDef *pNext;      \/* Next function with same name *\/$/;"	m	struct:FuncDef
pNext	.\src\sqliteInt.h	/^  Index *pNext;            \/* The next index associated with the same table *\/$/;"	m	struct:Index
pNext	.\src\sqliteInt.h	/^  LookasideSlot *pNext;    \/* Next buffer in the list of free buffers *\/$/;"	m	struct:LookasideSlot
pNext	.\src\sqliteInt.h	/^  NameContext *pNext;  \/* Next outer name context.  NULL for outermost *\/$/;"	m	struct:NameContext
pNext	.\src\sqliteInt.h	/^  Savepoint *pNext;                   \/* Parent savepoint (if any) *\/$/;"	m	struct:Savepoint
pNext	.\src\sqliteInt.h	/^  Select *pNext;         \/* Next select to the left in a compound *\/$/;"	m	struct:Select
pNext	.\src\sqliteInt.h	/^  Trigger *pNext;         \/* Next trigger associated with the table *\/$/;"	m	struct:Trigger
pNext	.\src\sqliteInt.h	/^  TriggerPrg *pNext;      \/* Next entry in Parse.pTriggerPrg list *\/$/;"	m	struct:TriggerPrg
pNext	.\src\sqliteInt.h	/^  TriggerStep *pNext;  \/* Next in the link-list *\/$/;"	m	struct:TriggerStep
pNext	.\src\sqliteInt.h	/^  VTable *pNext;            \/* Next in linked list (see above) *\/$/;"	m	struct:VTable
pNext	.\src\tclsqlite.c	/^  IncrblobChannel *pNext;   \/* Linked list of all open incrblob channels *\/$/;"	m	struct:IncrblobChannel	file:
pNext	.\src\tclsqlite.c	/^  SqlCollate *pNext;    \/* Next function on the list of them all *\/$/;"	m	struct:SqlCollate	file:
pNext	.\src\tclsqlite.c	/^  SqlFunc *pNext;       \/* Next function on the list of them all *\/$/;"	m	struct:SqlFunc	file:
pNext	.\src\tclsqlite.c	/^  SqlPreparedStmt *pNext;  \/* Next in linked list *\/$/;"	m	struct:SqlPreparedStmt	file:
pNext	.\src\test6.c	/^  WriteBuffer *pNext;          \/* Next in CrashGlobal.pWriteList *\/$/;"	m	struct:WriteBuffer	file:
pNext	.\src\test_journal.c	/^  jt_file *pNext;          \/* All files are stored in a linked list *\/$/;"	m	struct:jt_file	file:
pNext	.\src\test_multiplex.c	/^  multiplexGroup *pNext, *pPrev;   \/* Doubly linked list of all group objects *\/$/;"	m	struct:multiplexGroup	file:
pNext	.\src\test_onefile.c	/^  fs_real_file *pNext;$/;"	m	struct:fs_real_file	file:
pNext	.\src\test_quota.c	/^  quotaFile *pNext, **ppPrev;     \/* Linked list of files in the same group *\/$/;"	m	struct:quotaFile	file:
pNext	.\src\test_quota.c	/^  quotaGroup *pNext, **ppPrev;   \/* Doubly linked list of all quota objects *\/$/;"	m	struct:quotaGroup	file:
pNext	.\src\test_server.c	/^  SqlMessage *pNext;           \/* Next message in the queue *\/$/;"	m	struct:SqlMessage	file:
pNext	.\src\test_vfs.c	/^  TestvfsBuffer *pNext;           \/* Next in linked list of all buffers *\/$/;"	m	struct:TestvfsBuffer	file:
pNext	.\src\test_vfs.c	/^  TestvfsFd *pNext;               \/* Next handle opened on the same file *\/$/;"	m	struct:TestvfsFd	file:
pNext	.\src\test_wsd.c	/^  ProcessLocalVar *pNext;$/;"	m	struct:ProcessLocalVar	file:
pNext	.\src\vdbe.h	/^  SubProgram *pNext;            \/* Next sub-program already visited *\/$/;"	m	struct:SubProgram
pNext	.\src\vdbeInt.h	/^  AuxData *pNext;                 \/* Next element in list *\/$/;"	m	struct:AuxData
pNext	.\src\vdbeInt.h	/^  Vdbe *pPrev,*pNext;     \/* Linked list of VDBEs with the same Vdbe.db *\/$/;"	m	struct:Vdbe
pNext	.\src\vdbesort.c	/^    SorterRecord *pNext;          \/* Pointer to next record in list *\/$/;"	m	union:SorterRecord::__anon25	file:
pNext	.\test\fuzzcheck.c	/^  Blob *pNext;            \/* Next in a list *\/$/;"	m	struct:Blob	file:
pNext	.\test\threadtest3.c	/^  Statement *pNext;               \/* Next statement in linked-list *\/$/;"	m	struct:Statement	file:
pNext	.\test\threadtest3.c	/^  Thread *pNext;                  \/* Next in this list of threads *\/$/;"	m	struct:Thread	file:
pNextBlocked	.\src\sqliteInt.h	/^  sqlite3 *pNextBlocked;        \/* Next in list of all blocked connections *\/$/;"	m	struct:sqlite3
pNextChunk	.\src\rowset.c	/^  struct RowSetChunk *pNextChunk;        \/* Next chunk on list of them all *\/$/;"	m	struct:RowSetChunk	typeref:struct:RowSetChunk::RowSetChunk	file:
pNextDocid	.\ext\fts3\fts3Int.h	/^  char *pNextDocid;              \/* Pointer to next docid *\/$/;"	m	struct:Fts3Doclist
pNextFrom	.\src\sqliteInt.h	/^  FKey *pNextFrom;  \/* Next FKey with the same in pFrom. Next parent of pFrom *\/$/;"	m	struct:FKey
pNextId	.\ext\fts3\fts3Int.h	/^  char *pNextId;                  \/* Pointer into the body of aDoclist *\/$/;"	m	struct:Fts3Cursor
pNextLeaf	.\ext\fts5\fts5_index.c	/^  Fts5Data *pNextLeaf;            \/* Leaf page (iLeafPgno+1) *\/$/;"	m	struct:Fts5SegIter	file:
pNextLoop	.\src\whereInt.h	/^  WhereLoop *pNextLoop; \/* Next WhereLoop object in the WhereClause *\/$/;"	m	struct:WhereLoop
pNextTo	.\src\sqliteInt.h	/^  FKey *pNextTo;    \/* Next with the same zTo. Next child of zTo. *\/$/;"	m	struct:FKey
pNextZombie	.\src\sqliteInt.h	/^  Table *pNextZombie;  \/* Next on the Parse.pZombieTab list *\/$/;"	m	struct:Table
pNode	.\ext\fts5\fts5_expr.c	/^  Fts5ExprNode *pNode;            \/* FTS5_STRING node this phrase is part of *\/$/;"	m	struct:Fts5ExprPhrase	file:
pObj	.\ext\fts5\fts5_tcl.c	/^  Tcl_Obj *pObj;$/;"	m	struct:F5tAuxData	file:
pObj	.\src\test1.c	/^  Tcl_Obj *pObj;$/;"	m	struct:LogCallback	file:
pOffset	.\src\sqliteInt.h	/^  Expr *pOffset;         \/* OFFSET expression. NULL means not used. *\/$/;"	m	struct:Select
pOffsetList	.\ext\fts3\fts3_write.c	/^  char *pOffsetList;$/;"	m	struct:Fts3SegReader	file:
pOldMethod	.\src\os_unix.c	/^  sqlite3_io_methods const *pOldMethod;     \/* Original I\/O methods for close *\/$/;"	m	struct:proxyLockingContext	file:
pOn	.\src\sqliteInt.h	/^    Expr *pOn;        \/* The ON clause of a join *\/$/;"	m	struct:SrcList::SrcList_item
pOrInfo	.\src\whereInt.h	/^    WhereOrInfo *pOrInfo;   \/* Extra information if (eOperator & WO_OR)!=0 *\/$/;"	m	union:WhereTerm::__anon31
pOrPoslist	.\ext\fts3\fts3Int.h	/^  char *pOrPoslist;$/;"	m	struct:Fts3Phrase
pOrSet	.\src\whereInt.h	/^  WhereOrSet *pOrSet;       \/* Record best loops here, if not NULL *\/$/;"	m	struct:WhereLoopBuilder
pOrderBy	.\src\select.c	/^  ExprList *pOrderBy;   \/* The ORDER BY (or GROUP BY clause) *\/$/;"	m	struct:SortCtx	file:
pOrderBy	.\src\sqliteInt.h	/^  ExprList *pOrderBy;    \/* The ORDER BY clause *\/$/;"	m	struct:Select
pOrderBy	.\src\sqliteInt.h	/^  ExprList *pOrderBy;  \/* Key columns for SRT_Queue and SRT_DistQueue *\/$/;"	m	struct:SelectDest
pOrderBy	.\src\whereInt.h	/^  ExprList *pOrderBy;       \/* ORDER BY clause *\/$/;"	m	struct:WhereLoopBuilder
pOrderBy	.\src\whereInt.h	/^  ExprList *pOrderBy;       \/* The ORDER BY clause or NULL *\/$/;"	m	struct:WhereInfo
pOrig	.\src\test6.c	/^  sqlite3_vfs *pOrig;                   \/* Wrapped vfs structure *\/$/;"	m	struct:crashAppData	file:
pOrigVfs	.\src\test_multiplex.c	/^  sqlite3_vfs *pOrigVfs;$/;"	m	struct:__anon23	file:
pOrigVfs	.\src\test_quota.c	/^  sqlite3_vfs *pOrigVfs;$/;"	m	struct:__anon24	file:
pOrigWC	.\src\whereInt.h	/^  WhereClause *pOrigWC;      \/* Original, innermost WhereClause *\/$/;"	m	struct:WhereScan
pOut	.\ext\fts1\fulltext.c	/^  DocList *pOut;$/;"	m	struct:DocListMerge	file:
pOut	.\ext\fts5\fts5_expr.c	/^  Fts5Buffer *pOut;               \/* Output poslist *\/$/;"	m	struct:Fts5NearTrimmer	file:
pOut	.\src\threads.c	/^  void *pOut;                    \/* Result returned by the thread *\/$/;"	m	struct:SQLiteThread	file:
pOut	.\src\vdbeInt.h	/^  Mem *pOut;              \/* The return value is stored here *\/$/;"	m	struct:sqlite3_context
pOutArg	.\src\test_vfstrace.c	/^  void *pOutArg;                      \/* First argument to xOut *\/$/;"	m	struct:vfstrace_info	file:
pOuter	.\src\sqliteInt.h	/^  With *pOuter;                   \/* Containing WITH clause, or NULL *\/$/;"	m	struct:With
pOuter	.\src\whereInt.h	/^  WhereClause *pOuter;     \/* Outer conjunction *\/$/;"	m	struct:WhereClause
pPCache	.\src\pager.c	/^  PCache *pPCache;            \/* Pointer to page cache object *\/$/;"	m	struct:Pager	file:
pPage	.\src\pcache.h	/^  sqlite3_pcache_page *pPage;    \/* Pcache object page handle *\/$/;"	m	struct:PgHdr
pPage	.\src\sqliteInt.h	/^  void *pPage;                      \/* Page cache memory *\/$/;"	m	struct:Sqlite3Config
pPage1	.\src\btreeInt.h	/^  MemPage *pPage1;      \/* First page of the database *\/$/;"	m	struct:BtShared
pPager	.\src\btreeInt.h	/^  Pager *pPager;        \/* The page cache *\/$/;"	m	struct:BtShared
pPager	.\src\btreeInt.h	/^  Pager *pPager;    \/* The associated pager.  Also accessible by pBt->pPager *\/$/;"	m	struct:IntegrityCk
pPager	.\src\pcache.h	/^  Pager *pPager;                 \/* The pager this page is part of *\/$/;"	m	struct:PgHdr
pParent	.\ext\fts3\fts3Int.h	/^  Fts3Expr *pParent;         \/* pParent->pLeft==this or pParent->pRight==this *\/$/;"	m	struct:Fts3Expr
pParent	.\ext\fts3\fts3_write.c	/^  SegmentNode *pParent;           \/* Parent node (or NULL for root node) *\/$/;"	m	struct:SegmentNode	file:
pParent	.\ext\rtree\rtree.c	/^  RtreeNode *pParent;         \/* Parent node *\/$/;"	m	struct:RtreeNode	file:
pParent	.\src\test_onefile.c	/^  sqlite3_vfs *pParent;$/;"	m	struct:fs_vfs_t	file:
pParent	.\src\test_vfs.c	/^  sqlite3_vfs *pParent;           \/* The VFS to use for file IO *\/$/;"	m	struct:Testvfs	file:
pParent	.\src\vdbeInt.h	/^  VdbeFrame *pParent;     \/* Parent of this frame, or NULL if parent is main *\/$/;"	m	struct:VdbeFrame
pParse	.\src\sqliteInt.h	/^  Parse *pParse;                            \/* Parser context.  *\/$/;"	m	struct:Walker
pParse	.\src\sqliteInt.h	/^  Parse *pParse;              \/* The Parse structure *\/$/;"	m	struct:AuthContext
pParse	.\src\sqliteInt.h	/^  Parse *pParse;       \/* The parser *\/$/;"	m	struct:NameContext
pParse	.\src\sqliteInt.h	/^  Parse *pParse;      \/* The parsing context.  Error messages written here *\/$/;"	m	struct:DbFixer
pParse	.\src\vdbeInt.h	/^  Parse *pParse;          \/* Parsing context used to create this Vdbe *\/$/;"	m	struct:Vdbe
pParse	.\src\vdbemem.c	/^  Parse *pParse;$/;"	m	struct:ValueNewStat4Ctx	file:
pParse	.\src\whereInt.h	/^  Parse *pParse;            \/* Parsing and code generating context *\/$/;"	m	struct:WhereInfo
pPartIdxWhere	.\src\sqliteInt.h	/^  Expr *pPartIdxWhere;     \/* WHERE clause for partial indices *\/$/;"	m	struct:Index
pPayload	.\src\btreeInt.h	/^  u8 *pPayload;  \/* Pointer to the start of payload *\/$/;"	m	struct:CellInfo
pPg	.\src\dbstat.c	/^  DbPage *pPg;$/;"	m	struct:StatPage	file:
pPhrase	.\ext\fts3\fts3.c	/^  Fts3Phrase *pPhrase;            \/* The phrase the token belongs to *\/$/;"	m	struct:Fts3TokenAndCost	file:
pPhrase	.\ext\fts3\fts3Int.h	/^  Fts3Phrase *pPhrase;       \/* Valid if eType==FTSQUERY_PHRASE *\/$/;"	m	struct:Fts3Expr
pPhrase	.\ext\fts5\fts5_expr.c	/^  Fts5ExprPhrase *pPhrase;$/;"	m	struct:TokenCtx	file:
pPoslist	.\ext\fts5\fts5_main.c	/^  Fts5Buffer *pPoslist;           \/* Pointer to current poslist *\/$/;"	m	struct:Fts5MatchPhrase	file:
pPreStmt	.\src\tclsqlite.c	/^  SqlPreparedStmt *pPreStmt;      \/* Current statement *\/$/;"	m	struct:DbEvalContext	file:
pPrev	.\src\btreeInt.h	/^  Btree *pPrev;      \/* Back pointer of the same list *\/$/;"	m	struct:Btree
pPrev	.\src\mem2.c	/^  struct MemBlockHdr *pNext, *pPrev;  \/* Linked list of all unfreed memory *\/$/;"	m	struct:MemBlockHdr	typeref:struct:MemBlockHdr::	file:
pPrev	.\src\os_unix.c	/^  unixInodeInfo *pPrev;           \/*    .... doubly linked *\/$/;"	m	struct:unixInodeInfo	file:
pPrev	.\src\tclsqlite.c	/^  IncrblobChannel *pPrev;   \/* Linked list of all open incrblob channels *\/$/;"	m	struct:IncrblobChannel	file:
pPrev	.\src\tclsqlite.c	/^  SqlPreparedStmt *pPrev;  \/* Previous on the list *\/$/;"	m	struct:SqlPreparedStmt	file:
pPrev	.\src\test_multiplex.c	/^  multiplexGroup *pNext, *pPrev;   \/* Doubly linked list of all group objects *\/$/;"	m	struct:multiplexGroup	file:
pPrev	.\src\test_server.c	/^  SqlMessage *pPrev;           \/* Previous message in the queue *\/$/;"	m	struct:SqlMessage	file:
pPrev	.\src\vdbeInt.h	/^  Vdbe *pPrev,*pNext;     \/* Linked list of VDBEs with the same Vdbe.db *\/$/;"	m	struct:Vdbe
pPrevTo	.\src\sqliteInt.h	/^  FKey *pPrevTo;    \/* Previous with the same zTo *\/$/;"	m	struct:FKey
pPrior	.\src\sqliteInt.h	/^  Select *pPrior;        \/* Prior select in a compound select statement *\/$/;"	m	struct:Select
pPrior	.\src\vtab.c	/^  VtabCtx *pPrior;    \/* Parent context (if any) *\/$/;"	m	struct:VtabCtx	file:
pProfileArg	.\src\sqliteInt.h	/^  void *pProfileArg;                        \/* Argument to profile function *\/$/;"	m	struct:sqlite3
pProgram	.\src\sqliteInt.h	/^  SubProgram *pProgram;   \/* Program implementing pTrigger\/orconf *\/$/;"	m	struct:TriggerPrg
pProgram	.\src\vdbe.h	/^    SubProgram *pProgram;  \/* Used when p4type is P4_SUBPROGRAM *\/$/;"	m	union:VdbeOp::p4union
pProgram	.\src\vdbeInt.h	/^  SubProgram *pProgram;   \/* Linked list of all sub-programs used by VM *\/$/;"	m	struct:Vdbe
pProgressArg	.\src\sqliteInt.h	/^  void *pProgressArg;           \/* Argument to the progress callback *\/$/;"	m	struct:sqlite3
pPtr	.\ext\fts5\fts5_main.c	/^  void *pPtr;                     \/* Pointer value *\/$/;"	m	struct:Fts5Auxdata	file:
pQueueFirst	.\ext\async\sqlite3async.c	/^  AsyncWrite *pQueueFirst;     \/* Next write operation to be processed *\/$/;"	m	struct:TestAsyncStaticData	file:
pQueueHead	.\src\test_server.c	/^  SqlMessage *pQueueHead;       \/* Head of the message queue *\/$/;"	m	struct:ServerState	file:
pQueueLast	.\ext\async\sqlite3async.c	/^  AsyncWrite *pQueueLast;      \/* Last write operation on the list *\/$/;"	m	struct:TestAsyncStaticData	file:
pQueueTail	.\src\test_server.c	/^  SqlMessage *pQueueTail;       \/* Tail of the message queue *\/$/;"	m	struct:ServerState	file:
pRank	.\ext\fts5\fts5_main.c	/^  Fts5Auxiliary *pRank;           \/* Rank callback (or NULL) *\/$/;"	m	struct:Fts5Cursor	file:
pRankArgStmt	.\ext\fts5\fts5_main.c	/^  sqlite3_stmt *pRankArgStmt;     \/* Origin of objects in apRankArg[] *\/$/;"	m	struct:Fts5Cursor	file:
pRbu	.\ext\rbu\sqlite3rbu.c	/^  sqlite3rbu *pRbu;               \/* Pointer to rbu object (rbu target only) *\/$/;"	m	struct:rbu_file	file:
pRbuUpdate	.\ext\rbu\sqlite3rbu.c	/^  RbuUpdateStmt *pRbuUpdate;$/;"	m	struct:RbuObjIter	file:
pRbuVfs	.\ext\rbu\sqlite3rbu.c	/^  rbu_vfs *pRbuVfs;               \/* Pointer to the rbu_vfs object *\/$/;"	m	struct:rbu_file	file:
pRead	.\ext\fts3\fts3_snippet.c	/^  char *pRead;                    \/* Cursor used to iterate through aDoclist *\/$/;"	m	struct:LcsIterator	file:
pReadNode	.\ext\rtree\rtree.c	/^  sqlite3_stmt *pReadNode;$/;"	m	struct:Rtree	file:
pReadParent	.\ext\rtree\rtree.c	/^  sqlite3_stmt *pReadParent;$/;"	m	struct:Rtree	file:
pReadRowid	.\ext\rtree\rtree.c	/^  sqlite3_stmt *pReadRowid;$/;"	m	struct:Rtree	file:
pReader	.\ext\fts2\fts2.c	/^  DLReader *pReader;$/;"	m	struct:OrderedDLReader	file:
pReader	.\ext\fts5\fts5_index.c	/^  sqlite3_blob *pReader;          \/* RO incr-blob open on %_data table *\/$/;"	m	struct:Fts5Index	file:
pReader	.\src\vdbesort.c	/^  PmaReader *pReader;             \/* Readr data from here after Rewind() *\/$/;"	m	struct:VdbeSorter	file:
pReal	.\ext\misc\vfslog.c	/^  sqlite3_file *pReal;            \/* Underlying file handle *\/$/;"	m	struct:VLogFile	file:
pReal	.\ext\rbu\sqlite3rbu.c	/^  sqlite3_file *pReal;            \/* Underlying file handle *\/$/;"	m	struct:rbu_file	file:
pReal	.\src\journal.c	/^  sqlite3_file *pReal;            \/* The "real" underlying file descriptor *\/$/;"	m	struct:JournalFile	file:
pReal	.\src\test_devsym.c	/^  sqlite3_file *pReal;$/;"	m	struct:devsym_file	file:
pReal	.\src\test_journal.c	/^  sqlite3_file *pReal;     \/* The file handle for the underlying vfs *\/$/;"	m	struct:jt_file	file:
pReal	.\src\test_mutex.c	/^  sqlite3_mutex *pReal;$/;"	m	struct:sqlite3_mutex	file:
pReal	.\src\test_onefile.c	/^  fs_real_file *pReal;$/;"	m	struct:fs_file	file:
pReal	.\src\test_osinst.c	/^  sqlite3_file *pReal;            \/* Underlying file handle *\/$/;"	m	struct:VfslogFile	file:
pReal	.\src\test_vfs.c	/^  sqlite3_file *pReal;            \/* The real, underlying file descriptor *\/$/;"	m	struct:TestvfsFd	file:
pReal	.\src\test_vfstrace.c	/^  sqlite3_file *pReal;      \/* The real underlying file *\/$/;"	m	struct:vfstrace_file	file:
pReal	.\src\vdbe.h	/^    double *pReal;         \/* Used when p4type is P4_REAL *\/$/;"	m	union:VdbeOp::p4union
pRealFile	.\src\test6.c	/^  sqlite3_file *pRealFile;             \/* Underlying "real" file handle *\/$/;"	m	struct:CrashFile	file:
pRealVfs	.\ext\rbu\sqlite3rbu.c	/^  sqlite3_vfs *pRealVfs;          \/* Underlying VFS *\/$/;"	m	struct:rbu_vfs	file:
pRec	.\src\whereInt.h	/^  UnpackedRecord *pRec;     \/* Probe for stat4 (if required) *\/$/;"	m	struct:WhereLoopBuilder
pRef	.\src\btree.c	/^  MemPage *pRef;          \/* Reference page *\/$/;"	m	struct:CellArray	file:
pReprepare	.\src\sqliteInt.h	/^  Vdbe *pReprepare;         \/* VM being reprepared (sqlite3Reprepare()) *\/$/;"	m	struct:Parse
pResult	.\src\threads.c	/^  void *pResult;           \/* Result of xTask *\/$/;"	m	struct:SQLiteThread	file:
pResultSet	.\src\vdbeInt.h	/^  Mem *pResultSet;        \/* Pointer to an array of results *\/$/;"	m	struct:Vdbe
pResultSet	.\src\whereInt.h	/^  ExprList *pResultSet;     \/* Result set. DISTINCT operates on these *\/$/;"	m	struct:WhereInfo
pRet	.\ext\fts5\fts5_tcl.c	/^  Tcl_Obj *pRet;$/;"	m	struct:F5tTokenizeCtx	file:
pRight	.\ext\fts3\fts3Int.h	/^  Fts3Expr *pRight;          \/* Right operand *\/$/;"	m	struct:Fts3Expr
pRight	.\ext\fts3\fts3_write.c	/^  SegmentNode *pRight;            \/* Pointer to right-sibling *\/$/;"	m	struct:SegmentNode	file:
pRight	.\src\rowset.c	/^  struct RowSetEntry *pRight;   \/* Right subtree (larger entries) or list *\/$/;"	m	struct:RowSetEntry	typeref:struct:RowSetEntry::RowSetEntry	file:
pRight	.\src\sqliteInt.h	/^  Expr *pRight;          \/* Right subnode *\/$/;"	m	struct:Expr
pRollbackArg	.\src\sqliteInt.h	/^  void *pRollbackArg;               \/* Argument to xRollbackCallback() *\/   $/;"	m	struct:sqlite3
pRollbackHook	.\src\tclsqlite.c	/^  Tcl_Obj *pRollbackHook;    \/* Rollback hook script (if any) *\/$/;"	m	struct:SqliteDb	file:
pRoot	.\ext\fts3\fts3.c	/^  Fts3Expr *pRoot;                \/* Root of NEAR\/AND cluster *\/$/;"	m	struct:Fts3TokenAndCost	file:
pRoot	.\ext\fts5\fts5_expr.c	/^  Fts5ExprNode *pRoot;$/;"	m	struct:Fts5Expr	file:
pRootVfs	.\src\test_vfstrace.c	/^  sqlite3_vfs *pRootVfs;              \/* The underlying real VFS *\/$/;"	m	struct:vfstrace_info	file:
pRowSet	.\src\vdbeInt.h	/^    RowSet *pRowSet;    \/* Used only when flags==MEM_RowSet *\/$/;"	m	union:Mem::MemValue
pRule	.\ext\misc\amatch.c	/^  amatch_rule *pRule;        \/* All active rules in this amatch *\/$/;"	m	struct:amatch_vtab	file:
pRule	.\ext\misc\fuzzer.c	/^  const fuzzer_rule *pRule;  \/* Current rule to apply *\/$/;"	m	struct:fuzzer_stem	file:
pRule	.\ext\misc\fuzzer.c	/^  fuzzer_rule *pRule;        \/* All active rules in this fuzzer *\/$/;"	m	struct:fuzzer_vtab	file:
pSavepoint	.\src\sqliteInt.h	/^  Savepoint *pSavepoint;        \/* List of active savepoints *\/$/;"	m	struct:sqlite3
pScan	.\ext\fts5\fts5_hash.c	/^  Fts5HashEntry *pScan;           \/* Current ordered scan item *\/$/;"	m	struct:Fts5Hash	file:
pScanNext	.\ext\fts5\fts5_hash.c	/^  Fts5HashEntry *pScanNext;       \/* Next entry in sorted order *\/$/;"	m	struct:Fts5HashEntry	file:
pSchema	.\src\btreeInt.h	/^  void *pSchema;        \/* Pointer to space allocated by sqlite3BtreeSchema() *\/$/;"	m	struct:BtShared
pSchema	.\src\sqliteInt.h	/^    Schema *pSchema;  \/* Schema to which this item is fixed *\/$/;"	m	struct:SrcList::SrcList_item
pSchema	.\src\sqliteInt.h	/^  Schema *pSchema;         \/* Schema containing this index *\/$/;"	m	struct:Index
pSchema	.\src\sqliteInt.h	/^  Schema *pSchema;        \/* Schema containing the trigger *\/$/;"	m	struct:Trigger
pSchema	.\src\sqliteInt.h	/^  Schema *pSchema;     \/* Pointer to database schema (possibly shared) *\/$/;"	m	struct:Db
pSchema	.\src\sqliteInt.h	/^  Schema *pSchema;     \/* Schema that contains this table *\/$/;"	m	struct:Table
pSchema	.\src\sqliteInt.h	/^  Schema *pSchema;    \/* Fix items to this schema *\/$/;"	m	struct:DbFixer
pScopyFrom	.\src\vdbeInt.h	/^  Mem *pScopyFrom;    \/* This Mem is a shallow copy of pScopyFrom *\/$/;"	m	struct:Mem
pScratch	.\src\sqliteInt.h	/^  void *pScratch;                   \/* Scratch memory *\/$/;"	m	struct:Sqlite3Config
pScratchEnd	.\src\malloc.c	/^  void *pScratchEnd;$/;"	m	struct:Mem0Global	file:
pScratchFree	.\src\malloc.c	/^  ScratchFreeslot *pScratchFree;$/;"	m	struct:Mem0Global	file:
pScript	.\ext\fts5\fts5_tcl.c	/^  Tcl_Obj *pScript;$/;"	m	struct:F5tFunction	file:
pScript	.\ext\fts5\fts5_tcl.c	/^  Tcl_Obj *pScript;$/;"	m	struct:F5tTokenizerInstance	file:
pScript	.\ext\fts5\fts5_tcl.c	/^  Tcl_Obj *pScript;$/;"	m	struct:F5tTokenizerModule	file:
pScript	.\src\tclsqlite.c	/^  Tcl_Obj *pScript;     \/* The Tcl_Obj representation of the script *\/$/;"	m	struct:SqlFunc	file:
pScript	.\src\test_quota.c	/^  Tcl_Obj *pScript;      \/* Script to be run *\/$/;"	m	struct:TclQuotaCallback	file:
pScript	.\src\test_superlock.c	/^  Tcl_Obj *pScript;$/;"	m	struct:InterpAndScript	file:
pScript	.\src\test_vfs.c	/^  Tcl_Obj *pScript;               \/* Script to execute *\/$/;"	m	struct:Testvfs	file:
pSeg	.\ext\fts5\fts5_index.c	/^  Fts5StructureSegment *pSeg;     \/* Segment to iterate through *\/$/;"	m	struct:Fts5SegIter	file:
pSegcsr	.\ext\fts3\fts3Int.h	/^  Fts3MultiSegReader *pSegcsr;    \/* Segment-reader for this token *\/$/;"	m	struct:Fts3PhraseToken
pSegments	.\ext\fts3\fts3Int.h	/^  sqlite3_blob *pSegments;        \/* Blob handle open on %_segments table *\/$/;"	m	struct:Fts3Table
pSelect	.\ext\rbu\sqlite3rbu.c	/^  sqlite3_stmt *pSelect;          \/* Source data *\/$/;"	m	struct:RbuObjIter	file:
pSelect	.\src\sqliteInt.h	/^    Select *pSelect;                \/* The definition of this CTE *\/$/;"	m	struct:With::Cte
pSelect	.\src\sqliteInt.h	/^    Select *pSelect;     \/* EP_xIsSelect and op = IN, EXISTS, SELECT *\/$/;"	m	union:Expr::__anon16
pSelect	.\src\sqliteInt.h	/^    Select *pSelect;  \/* A SELECT statement used in place of a table name *\/$/;"	m	struct:SrcList::SrcList_item
pSelect	.\src\sqliteInt.h	/^  Select *pSelect;     \/* NULL for tables.  Points to definition if a view. *\/$/;"	m	struct:Table
pSelect	.\src\sqliteInt.h	/^  Select *pSelect;     \/* SELECT statement or RHS of INSERT INTO SELECT ... *\/$/;"	m	struct:TriggerStep
pSem	.\src\os_unix.c	/^  sem_t *pSem;                    \/* Named POSIX semaphore *\/$/;"	m	struct:unixInodeInfo	file:
pSeqTab	.\src\sqliteInt.h	/^  Table *pSeqTab;      \/* The sqlite_sequence table used by AUTOINCREMENT *\/$/;"	m	struct:Schema
pShm	.\src\os_unix.c	/^  unixShm *pShm;                      \/* Shared memory segment information *\/$/;"	m	struct:unixFile	file:
pShm	.\src\os_win.c	/^  winShm *pShm;           \/* Instance of shared memory on this file *\/$/;"	m	struct:winFile	file:
pShm	.\src\test_vfs.c	/^  TestvfsBuffer *pShm;            \/* Shared memory buffer *\/$/;"	m	struct:TestvfsFd	file:
pShmId	.\src\test_vfs.c	/^  Tcl_Obj *pShmId;                \/* Shared memory id for Tcl callbacks *\/$/;"	m	struct:TestvfsFd	file:
pShmNode	.\src\os_unix.c	/^  unixShmNode *pShmNode;          \/* Shared memory associated with this inode *\/$/;"	m	struct:unixInodeInfo	file:
pShmNode	.\src\os_unix.c	/^  unixShmNode *pShmNode;     \/* The underlying unixShmNode object *\/$/;"	m	struct:unixShm	file:
pShmNode	.\src\os_win.c	/^  winShmNode *pShmNode;      \/* The underlying winShmNode object *\/$/;"	m	struct:winShm	file:
pSortCsr	.\ext\fts5\fts5_main.c	/^  Fts5Cursor *pSortCsr;           \/* Sort data from this cursor *\/$/;"	m	struct:Fts5Table	file:
pSorter	.\ext\fts5\fts5_main.c	/^  Fts5Sorter *pSorter;            \/* Sorter for "ORDER BY rank" queries *\/$/;"	m	struct:Fts5Cursor	file:
pSorter	.\src\vdbeInt.h	/^  VdbeSorter *pSorter;  \/* Sorter object for OP_SorterOpen cursors *\/$/;"	m	struct:VdbeCursor
pSorter	.\src\vdbesort.c	/^  VdbeSorter *pSorter;            \/* Sorter that owns this sub-task *\/$/;"	m	struct:SortSubtask	file:
pSql	.\src\tclsqlite.c	/^  Tcl_Obj *pSql;                  \/* Object holding string zSql *\/$/;"	m	struct:DbEvalContext	file:
pSqllogArg	.\src\sqliteInt.h	/^  void *pSqllogArg;$/;"	m	struct:Sqlite3Config
pSrc	.\src\backup.c	/^  Btree *pSrc;             \/* Source b-tree file *\/$/;"	m	struct:sqlite3_backup	file:
pSrc	.\src\expr.c	/^  SrcList *pSrc;   \/* One particular FROM clause in a nested query *\/$/;"	m	struct:SrcCount	file:
pSrc	.\src\sqliteInt.h	/^  SrcList *pSrc;         \/* The FROM clause *\/$/;"	m	struct:Select
pSrcCount	.\src\sqliteInt.h	/^    struct SrcCount *pSrcCount;                \/* Counting column references *\/$/;"	m	union:Walker::__anon22	typeref:struct:Walker::__anon22::SrcCount
pSrcDb	.\src\backup.c	/^  sqlite3* pSrcDb;         \/* Source database handle *\/$/;"	m	struct:sqlite3_backup	file:
pSrcList	.\src\sqliteInt.h	/^    SrcList *pSrcList;                         \/* FROM clause *\/$/;"	m	union:Walker::__anon22
pSrcList	.\src\sqliteInt.h	/^  SrcList *pSrcList;   \/* One or more tables used to resolve names *\/$/;"	m	struct:NameContext
pStart	.\src\pcache1.c	/^  void *pStart, *pEnd;           \/* Bounds of global page cache memory *\/$/;"	m	struct:PCacheGlobal	file:
pStart	.\src\sqliteInt.h	/^  void *pStart;           \/* First byte of available memory space *\/$/;"	m	struct:Lookaside
pStem	.\ext\misc\fuzzer.c	/^  fuzzer_stem *pStem;        \/* Stem with smallest rCostX *\/$/;"	m	struct:fuzzer_cursor	file:
pStep	.\src\test1.c	/^  Tcl_Obj *pStep;                 \/* Script for agg. step invocation *\/$/;"	m	struct:CreateFunctionV2	file:
pStmt	.\ext\fts1\fts1.c	/^  sqlite3_stmt *pStmt;             \/* Prepared statement in use by the cursor *\/$/;"	m	struct:fulltext_cursor	file:
pStmt	.\ext\fts1\fulltext.c	/^  sqlite3_stmt *pStmt;$/;"	m	struct:fulltext_cursor	file:
pStmt	.\ext\fts2\fts2.c	/^  sqlite3_stmt *pStmt;             \/* Prepared statement in use by the cursor *\/$/;"	m	struct:fulltext_cursor	file:
pStmt	.\ext\fts2\fts2.c	/^  sqlite3_stmt *pStmt;      \/* Statement we're streaming leaves from. *\/$/;"	m	struct:LeavesReader	file:
pStmt	.\ext\fts3\fts3Int.h	/^  sqlite3_stmt *pStmt;            \/* Prepared statement in use by the cursor *\/$/;"	m	struct:Fts3Cursor
pStmt	.\ext\fts5\fts5_main.c	/^  sqlite3_stmt *pStmt;            \/* Statement used to read %_content *\/$/;"	m	struct:Fts5Cursor	file:
pStmt	.\ext\fts5\fts5_main.c	/^  sqlite3_stmt *pStmt;$/;"	m	struct:Fts5Sorter	file:
pStmt	.\ext\fts5\fts5_vocab.c	/^  sqlite3_stmt *pStmt;            \/* Statement holding lock on pIndex *\/$/;"	m	struct:Fts5VocabCursor	file:
pStmt	.\ext\misc\nextchar.c	/^  sqlite3_stmt *pStmt;              \/* Prepared statement used to query *\/$/;"	m	struct:nextCharContext	file:
pStmt	.\ext\misc\spellfix.c	/^  sqlite3_stmt *pStmt;             \/* shadow table query statment *\/$/;"	m	struct:MatchQuery	file:
pStmt	.\src\dbstat.c	/^  sqlite3_stmt *pStmt;            \/* Iterates through set of root pages *\/$/;"	m	struct:StatCursor	file:
pStmt	.\src\shell.c	/^  sqlite3_stmt *pStmt;   \/* Current statement if any. *\/$/;"	m	struct:ShellState	file:
pStmt	.\src\tclsqlite.c	/^  sqlite3_stmt *pStmt;     \/* The prepared statement *\/$/;"	m	struct:SqlPreparedStmt	file:
pStmt	.\src\test4.c	/^  sqlite3_stmt *pStmt;     \/* Pending operation *\/$/;"	m	struct:Thread	file:
pStmt	.\src\test7.c	/^  sqlite3_stmt *pStmt;     \/* Pending operation *\/$/;"	m	struct:Thread	file:
pStmt	.\src\test8.c	/^  sqlite3_stmt *pStmt;$/;"	m	struct:echo_cursor	file:
pStmt	.\src\test_fs.c	/^  sqlite3_stmt *pStmt;$/;"	m	struct:fs_cursor	file:
pStmt	.\src\test_server.c	/^  sqlite3_stmt *pStmt;         \/* A specific statement *\/$/;"	m	struct:SqlMessage	file:
pStmt	.\src\vdbeblob.c	/^  sqlite3_stmt *pStmt;    \/* Statement holding cursor open *\/$/;"	m	struct:Incrblob	file:
pStmt	.\test\speedtest1.c	/^  sqlite3_stmt *pStmt;       \/* Current SQL statement *\/$/;"	m	struct:Global	file:
pStmt	.\test\threadtest3.c	/^  sqlite3_stmt *pStmt;            \/* Pre-compiled statement handle *\/$/;"	m	struct:Statement	file:
pStorage	.\ext\fts5\fts5_main.c	/^  Fts5Storage *pStorage;          \/* Document store *\/$/;"	m	struct:Fts5Table	file:
pStorage	.\ext\fts5\fts5_storage.c	/^  Fts5Storage *pStorage;$/;"	m	struct:Fts5InsertCtx	file:
pStress	.\src\pcache.c	/^  void *pStress;                      \/* Argument to xStress *\/$/;"	m	struct:PCache	file:
pStruct	.\ext\fts5\fts5_index.c	/^  Fts5Structure *pStruct;         \/* Database structure for this iterator *\/$/;"	m	struct:Fts5IndexIter	file:
pSynced	.\src\pcache.c	/^  PgHdr *pSynced;                     \/* Last synced page in dirty page list *\/$/;"	m	struct:PCache	file:
pSynonym	.\ext\fts5\fts5_expr.c	/^  Fts5ExprTerm *pSynonym;         \/* Pointer to first in list of synonyms *\/$/;"	m	struct:Fts5ExprTerm	file:
pTab	.\src\sqliteInt.h	/^    Table *pTab;             \/* Source table *\/$/;"	m	struct:AggInfo::AggInfo_col
pTab	.\src\sqliteInt.h	/^    Table *pTab;      \/* An SQL table corresponding to zName *\/$/;"	m	struct:SrcList::SrcList_item
pTab	.\src\sqliteInt.h	/^  Table *pTab;           \/* Table for TK_COLUMN expressions. *\/$/;"	m	struct:Expr
pTab	.\src\sqliteInt.h	/^  Table *pTab;          \/* Table this info block refers to *\/$/;"	m	struct:AutoincInfo
pTab	.\src\vtab.c	/^  Table *pTab;        \/* The Table object to which the virtual table belongs *\/$/;"	m	struct:VtabCtx	file:
pTabList	.\src\whereInt.h	/^  SrcList *pTabList;        \/* List of tables in the join *\/$/;"	m	struct:WhereInfo
pTabSchema	.\src\sqliteInt.h	/^  Schema *pTabSchema;     \/* Schema containing the table *\/$/;"	m	struct:Trigger
pTable	.\src\sqliteInt.h	/^  Table *pTable;           \/* The SQL table being indexed *\/$/;"	m	struct:Index
pTableList	.\src\test_schema.c	/^  sqlite3_stmt *pTableList;$/;"	m	struct:schema_cursor	file:
pTail	.\ext\fts3\fts3_snippet.c	/^  char *pTail;                    \/* Position list data following iTail *\/$/;"	m	struct:SnippetPhrase	file:
pTargetFd	.\ext\rbu\sqlite3rbu.c	/^  rbu_file *pTargetFd;            \/* File handle open on target db *\/$/;"	m	struct:sqlite3rbu	file:
pTask	.\src\vdbesort.c	/^  SortSubtask *pTask;             \/* Task that owns this merger *\/$/;"	m	struct:IncrMerger	file:
pTask	.\src\vdbesort.c	/^  SortSubtask *pTask;        \/* Used by this thread only *\/$/;"	m	struct:MergeEngine	file:
pTblIter	.\ext\rbu\sqlite3rbu.c	/^  sqlite3_stmt *pTblIter;         \/* Iterate through tables *\/$/;"	m	struct:RbuObjIter	file:
pTerm	.\ext\fts1\fts1.c	/^  char *pTerm;       \/* text of the term.  '\\000' terminated.  malloced *\/$/;"	m	struct:QueryTerm	file:
pTerm	.\ext\fts1\fulltext.c	/^  QueryTerm *pTerm;$/;"	m	struct:Query	file:
pTerm	.\ext\fts2\fts2.c	/^  char *pTerm;       \/* text of the term.  '\\000' terminated.  malloced *\/$/;"	m	struct:QueryTerm	file:
pTerm	.\ext\fts2\fts2.c	/^  const char *pTerm;$/;"	m	struct:TermData	file:
pTerms	.\ext\fts1\fts1.c	/^  QueryTerm *pTerms;    \/* Array of terms.  Space obtained from malloc() *\/$/;"	m	struct:Query	file:
pTerms	.\ext\fts2\fts2.c	/^  QueryTerm *pTerms;    \/* Array of terms.  Space obtained from malloc() *\/$/;"	m	struct:Query	file:
pTestCollateInterp	.\src\test1.c	/^static Tcl_Interp* pTestCollateInterp;$/;"	v	file:
pThread	.\src\vdbesort.c	/^  SQLiteThread *pThread;          \/* Background thread, if any *\/$/;"	m	struct:SortSubtask	file:
pThread	.\test\threadtest3.c	/^  Thread *pThread;                \/* Linked list of threads *\/$/;"	m	struct:Threadset	file:
pTimelimitVfs	.\test\threadtest3.c	/^static sqlite3_vfs *pTimelimitVfs = 0;$/;"	v	file:
pTmpInsert	.\ext\rbu\sqlite3rbu.c	/^  sqlite3_stmt *pTmpInsert;       \/* Insert into rbu_tmp_$zDataTbl *\/$/;"	m	struct:RbuObjIter	file:
pTmpSpace	.\src\btreeInt.h	/^  u8 *pTmpSpace;        \/* Temp space sufficient to hold a single cell *\/$/;"	m	struct:BtShared
pTmpSpace	.\src\pager.c	/^  char *pTmpSpace;            \/* Pager.pageSize bytes of space for tmp use *\/$/;"	m	struct:Pager	file:
pTok	.\ext\fts3\fts3_tokenize_vtab.c	/^  sqlite3_tokenizer *pTok;$/;"	m	struct:Fts3tokTable	file:
pTok	.\ext\fts5\fts5Int.h	/^  Fts5Tokenizer *pTok;$/;"	m	struct:Fts5Config
pTok	.\ext\fts5\fts5_main.c	/^  Fts5TokenizerModule *pTok;      \/* First in list of all tokenizer modules *\/$/;"	m	struct:Fts5Global	file:
pTokApi	.\ext\fts5\fts5Int.h	/^  fts5_tokenizer *pTokApi;$/;"	m	struct:Fts5Config
pToken	.\ext\fts1\fts1_tokenizer1.c	/^  char *pToken;                \/* storage for current token *\/$/;"	m	struct:simple_tokenizer_cursor	file:
pToken	.\ext\fts2\fts2_tokenizer1.c	/^  char *pToken;                \/* storage for current token *\/$/;"	m	struct:simple_tokenizer_cursor	file:
pToken	.\ext\fts3\fts3.c	/^  Fts3PhraseToken *pToken;        \/* The token itself *\/$/;"	m	struct:Fts3TokenAndCost	file:
pToken	.\ext\fts3\fts3_tokenizer1.c	/^  char *pToken;                \/* storage for current token *\/$/;"	m	struct:simple_tokenizer_cursor	file:
pToken	.\ext\fts3\fts3_write.c	/^  Fts3PhraseToken *pToken;        \/* Pointer to corresponding expr token *\/$/;"	m	struct:Fts3DeferredToken	file:
pTokenizer	.\ext\fts1\fts1.c	/^  sqlite3_tokenizer *pTokenizer;   \/* tokenizer for inserts and queries *\/$/;"	m	struct:fulltext_vtab	file:
pTokenizer	.\ext\fts1\fts1_tokenizer.h	/^  sqlite3_tokenizer *pTokenizer;       \/* Tokenizer for this cursor. *\/$/;"	m	struct:sqlite3_tokenizer_cursor
pTokenizer	.\ext\fts1\fulltext.c	/^  sqlite3_tokenizer *pTokenizer;   \/* tokenizer for inserts and queries *\/$/;"	m	struct:fulltext_vtab	file:
pTokenizer	.\ext\fts1\tokenizer.h	/^  sqlite3_tokenizer *pTokenizer;       \/* Tokenizer for this cursor. *\/$/;"	m	struct:sqlite3_tokenizer_cursor
pTokenizer	.\ext\fts2\fts2.c	/^  sqlite3_tokenizer *pTokenizer;   \/* tokenizer for inserts and queries *\/$/;"	m	struct:fulltext_vtab	file:
pTokenizer	.\ext\fts2\fts2_tokenizer.h	/^  sqlite3_tokenizer *pTokenizer;       \/* Tokenizer for this cursor. *\/$/;"	m	struct:sqlite3_tokenizer_cursor
pTokenizer	.\ext\fts3\fts3Int.h	/^  sqlite3_tokenizer *pTokenizer;  \/* tokenizer for inserts and queries *\/$/;"	m	struct:Fts3Table
pTokenizer	.\ext\fts3\fts3_expr.c	/^  sqlite3_tokenizer *pTokenizer;      \/* Tokenizer module *\/$/;"	m	struct:ParseContext	file:
pTokenizer	.\ext\fts3\fts3_tokenizer.h	/^  sqlite3_tokenizer *pTokenizer;       \/* Tokenizer for this cursor. *\/$/;"	m	struct:sqlite3_tokenizer_cursor
pTokenizer	.\ext\fts5\fts5_tokenize.c	/^  Fts5Tokenizer *pTokenizer;      \/* Parent tokenizer instance *\/$/;"	m	struct:PorterTokenizer	file:
pToplevel	.\src\sqliteInt.h	/^  Parse *pToplevel;    \/* Parse structure for main program (or NULL) *\/$/;"	m	struct:Parse
pTraceArg	.\src\sqliteInt.h	/^  void *pTraceArg;                          \/* Argument to the trace function *\/$/;"	m	struct:sqlite3
pTraceVfs	.\src\test_vfstrace.c	/^  sqlite3_vfs *pTraceVfs;             \/* Pointer back to the trace VFS *\/$/;"	m	struct:vfstrace_info	file:
pTree	.\ext\fts3\fts3_write.c	/^  SegmentNode *pTree;             \/* Pointer to interior tree structure *\/$/;"	m	struct:SegmentWriter	file:
pTrig	.\src\sqliteInt.h	/^  Trigger *pTrig;      \/* The trigger that this step is a part of *\/$/;"	m	struct:TriggerStep
pTrigger	.\src\delete.c	589;"	d	file:
pTrigger	.\src\insert.c	1052;"	d	file:
pTrigger	.\src\sqliteInt.h	/^  Trigger *pTrigger;      \/* Trigger this program was coded from *\/$/;"	m	struct:TriggerPrg
pTrigger	.\src\sqliteInt.h	/^  Trigger *pTrigger;   \/* List of triggers stored in pSchema *\/$/;"	m	struct:Table
pTrigger	.\src\update.c	680;"	d	file:
pTriggerPrg	.\src\sqliteInt.h	/^  TriggerPrg *pTriggerPrg;  \/* Linked list of coded triggers *\/$/;"	m	struct:Parse
pTriggerTab	.\src\sqliteInt.h	/^  Table *pTriggerTab;  \/* Table triggers are being coded for *\/$/;"	m	struct:Parse
pUnlockArg	.\src\sqliteInt.h	/^  void *pUnlockArg;                     \/* Argument to xUnlockNotify *\/$/;"	m	struct:sqlite3
pUnlockConnection	.\src\sqliteInt.h	/^  sqlite3 *pUnlockConnection;           \/* Connection to watch for unlock *\/$/;"	m	struct:sqlite3
pUnlockNotify	.\src\tclsqlite.c	/^  Tcl_Obj *pUnlockNotify;    \/* Unlock notify script (if any) *\/$/;"	m	struct:SqliteDb	file:
pUnpacked	.\src\vdbesort.c	/^  UnpackedRecord *pUnpacked;      \/* Space to unpack a record *\/$/;"	m	struct:SortSubtask	file:
pUnpacked	.\src\vdbesort.c	/^  UnpackedRecord *pUnpacked;      \/* Used by VdbeSorterCompare() *\/$/;"	m	struct:VdbeSorter	file:
pUnused	.\src\os_unix.c	/^  UnixUnusedFd *pUnused;              \/* Pre-allocated UnixUnusedFd *\/$/;"	m	struct:unixFile	file:
pUnused	.\src\os_unix.c	/^  UnixUnusedFd *pUnused;          \/* Unused file descriptors to close *\/$/;"	m	struct:unixInodeInfo	file:
pUp	.\ext\misc\amatch.c	/^  amatch_avl *pUp;      \/* Parent element *\/$/;"	m	struct:amatch_avl	file:
pUp	.\ext\misc\closure.c	/^  closure_avl *pUp;     \/* Parent element *\/$/;"	m	struct:closure_avl	file:
pUpdate	.\ext\rbu\sqlite3rbu.c	/^  sqlite3_stmt *pUpdate;          \/* Last update statement (or NULL) *\/$/;"	m	struct:RbuUpdateStmt	file:
pUpdateArg	.\src\sqliteInt.h	/^  void *pUpdateArg;$/;"	m	struct:sqlite3
pUpdateHook	.\src\tclsqlite.c	/^  Tcl_Obj *pUpdateHook;      \/* Update hook script (if any) *\/$/;"	m	struct:SqliteDb	file:
pUser	.\ext\rtree\sqlite3rtree.h	/^  void *pUser;                      \/* callback can use this, if desired *\/$/;"	m	struct:sqlite3_rtree_query_info
pUser	.\ext\rtree\sqlite3rtree.h	/^  void *pUser;                    \/* Callback implementation user data *\/$/;"	m	struct:sqlite3_rtree_geometry
pUser	.\src\sqliteInt.h	/^  void *pUser;          \/* First argument to xCmp() *\/$/;"	m	struct:CollSeq
pUserData	.\ext\fts5\fts5_main.c	/^  void *pUserData;                \/* User pointer passed to xCreate() *\/$/;"	m	struct:Fts5TokenizerModule	file:
pUserData	.\ext\fts5\fts5_main.c	/^  void *pUserData;                \/* User-data pointer *\/$/;"	m	struct:Fts5Auxiliary	file:
pUserData	.\src\sqliteInt.h	/^  void *pUserData;     \/* User data parameter *\/$/;"	m	struct:FuncDef
pUserData	.\src\sqliteInt.h	/^  void *pUserData;$/;"	m	struct:FuncDestructor
pUsing	.\src\sqliteInt.h	/^    IdList *pUsing;   \/* The USING clause of a join *\/$/;"	m	struct:SrcList::SrcList_item
pVCheck	.\ext\misc\amatch.c	/^  sqlite3_stmt *pVCheck;     \/* Query to check zVocabTab *\/$/;"	m	struct:amatch_vtab	file:
pVFile	.\test\fuzzcheck.c	/^  VFile *pVFile;          \/* The underlying file *\/$/;"	m	struct:VHandle	file:
pVTab	.\ext\misc\spellfix.c	/^  spellfix1_vtab *pVTab;       \/* The table to which this cursor belongs *\/$/;"	m	struct:spellfix1_cursor	file:
pVTable	.\src\sqliteInt.h	/^  VTable *pVTable;     \/* List of VTable objects. *\/$/;"	m	struct:Table
pVTable	.\src\vtab.c	/^  VTable *pVTable;    \/* The virtual table being constructed *\/$/;"	m	struct:VtabCtx	file:
pVdbe	.\src\sqliteInt.h	/^  Vdbe *pVdbe;         \/* An engine for executing database bytecode *\/$/;"	m	struct:Parse
pVdbe	.\src\sqliteInt.h	/^  struct Vdbe *pVdbe;           \/* List of active virtual machines *\/$/;"	m	struct:sqlite3	typeref:struct:sqlite3::Vdbe
pVdbe	.\src\vdbeInt.h	/^  Vdbe *pVdbe;            \/* The VM that owns this context *\/$/;"	m	struct:sqlite3_context
pVdbe	.\src\vdbeInt.h	/^  Vdbe *pVdbe;       \/* Attach the explanation to this Vdbe *\/$/;"	m	struct:Explain
pVdbeBranchArg	.\src\sqliteInt.h	/^  void *pVdbeBranchArg;                                     \/* 1st argument *\/$/;"	m	struct:Sqlite3Config
pVfs	.\ext\misc\vfslog.c	/^  sqlite3_vfs *pVfs;              \/* Parent VFS *\/$/;"	m	struct:VLogVfs	file:
pVfs	.\src\journal.c	/^  sqlite3_vfs *pVfs;              \/* The "real" underlying VFS *\/$/;"	m	struct:JournalFile	file:
pVfs	.\src\os_unix.c	/^  sqlite3_vfs *pVfs;                  \/* The VFS that created this unixFile *\/$/;"	m	struct:unixFile	file:
pVfs	.\src\os_win.c	/^  sqlite3_vfs *pVfs;      \/* The VFS used to open this file *\/$/;"	m	struct:winFile	file:
pVfs	.\src\pager.c	/^  sqlite3_vfs *pVfs;          \/* OS functions to use for IO *\/$/;"	m	struct:Pager	file:
pVfs	.\src\sqliteInt.h	/^  sqlite3_vfs *pVfs;            \/* OS Interface *\/$/;"	m	struct:sqlite3
pVfs	.\src\test_devsym.c	/^  sqlite3_vfs *pVfs;$/;"	m	struct:DevsymGlobal	file:
pVfs	.\src\test_journal.c	/^  sqlite3_vfs *pVfs;             \/* Parent VFS *\/$/;"	m	struct:JtGlobal	file:
pVfs	.\src\test_osinst.c	/^  sqlite3_vfs *pVfs;              \/* Parent VFS *\/$/;"	m	struct:VfslogVfs	file:
pVfs	.\src\test_vfs.c	/^  sqlite3_vfs *pVfs;              \/* The VFS *\/$/;"	m	struct:TestvfsFd	file:
pVfs	.\src\test_vfs.c	/^  sqlite3_vfs *pVfs;              \/* The testvfs registered with SQLite *\/$/;"	m	struct:Testvfs	file:
pVfs	.\src\wal.c	/^  sqlite3_vfs *pVfs;         \/* The VFS used to create pDbFd *\/$/;"	m	struct:Wal	file:
pVfslog	.\src\test_osinst.c	/^  sqlite3_vfs *pVfslog;           \/* Associated VsflogVfs object *\/$/;"	m	struct:VfslogFile	file:
pVtab	.\ext\misc\amatch.c	/^  amatch_vtab *pVtab;        \/* The virtual table this cursor belongs to *\/$/;"	m	struct:amatch_cursor	file:
pVtab	.\ext\misc\closure.c	/^  closure_vtab *pVtab;       \/* The virtual table this cursor belongs to *\/$/;"	m	struct:closure_cursor	file:
pVtab	.\ext\misc\fuzzer.c	/^  fuzzer_vtab *pVtab;        \/* The virtual table this cursor belongs to *\/$/;"	m	struct:fuzzer_cursor	file:
pVtab	.\src\sqliteInt.h	/^  sqlite3_vtab *pVtab;      \/* Pointer to vtab instance *\/$/;"	m	struct:VTable
pVtab	.\src\vdbe.h	/^    VTable *pVtab;         \/* Used when p4type is P4_VTAB *\/$/;"	m	union:VdbeOp::p4union
pVtabCtx	.\src\sqliteInt.h	/^  VtabCtx *pVtabCtx;            \/* Context for active vtab connect\/create *\/$/;"	m	struct:sqlite3
pVtabCursor	.\src\vdbeInt.h	/^  sqlite3_vtab_cursor *pVtabCursor;  \/* The cursor for a virtual table *\/$/;"	m	struct:VdbeCursor
pWC	.\src\whereInt.h	/^  WhereClause *pWC;          \/* WhereClause currently being scanned *\/$/;"	m	struct:WhereScan
pWC	.\src\whereInt.h	/^  WhereClause *pWC;         \/* WHERE clause terms *\/$/;"	m	struct:WhereLoopBuilder
pWC	.\src\whereInt.h	/^  WhereClause *pWC;       \/* The clause this term is part of *\/$/;"	m	struct:WhereTerm
pWInfo	.\src\whereInt.h	/^  WhereInfo *pWInfo;        \/* Information about this WHERE *\/$/;"	m	struct:WhereLoopBuilder
pWInfo	.\src\whereInt.h	/^  WhereInfo *pWInfo;       \/* WHERE clause processing context *\/$/;"	m	struct:WhereClause
pWLoop	.\src\whereInt.h	/^  struct WhereLoop *pWLoop;  \/* The selected WhereLoop object *\/$/;"	m	struct:WhereLevel	typeref:struct:WhereLevel::WhereLoop
pWal	.\src\pager.c	/^  Wal *pWal;                  \/* Write-ahead log used by "journal_mode=wal" *\/$/;"	m	struct:Pager	file:
pWal	.\src\wal.c	/^  Wal *pWal;                   \/* The complete WAL information *\/$/;"	m	struct:WalWriter	file:
pWalArg	.\src\sqliteInt.h	/^  void *pWalArg;$/;"	m	struct:sqlite3
pWalFd	.\ext\rbu\sqlite3rbu.c	/^  rbu_file *pWalFd;               \/* Wal file descriptor for this main db *\/$/;"	m	struct:rbu_file	file:
pWalFd	.\src\wal.c	/^  sqlite3_file *pWalFd;      \/* File handle for WAL file *\/$/;"	m	struct:Wal	file:
pWalHook	.\src\tclsqlite.c	/^  Tcl_Obj *pWalHook;         \/* WAL hook script (if any) *\/$/;"	m	struct:SqliteDb	file:
pWhen	.\src\sqliteInt.h	/^  Expr *pWhen;            \/* The WHEN clause of the expression (may be NULL) *\/$/;"	m	struct:Trigger
pWhere	.\src\sqliteInt.h	/^  Expr *pWhere;          \/* The WHERE clause *\/$/;"	m	struct:Select
pWhere	.\src\sqliteInt.h	/^  Expr *pWhere;        \/* The WHERE clause for DELETE or UPDATE steps *\/$/;"	m	struct:TriggerStep
pWith	.\src\sqliteInt.h	/^  With *pWith;              \/* Current WITH clause, or NULL *\/$/;"	m	struct:Parse
pWith	.\src\sqliteInt.h	/^  With *pWith;           \/* WITH clause attached to this select. Or NULL. *\/$/;"	m	struct:Select
pWord	.\ext\misc\amatch.c	/^  amatch_avl *pWord;         \/* amatch_word objects keyed by zWord *\/$/;"	m	struct:amatch_cursor	file:
pWord	.\ext\misc\amatch.c	/^  amatch_word *pWord;   \/* Points to the object being stored in the tree *\/$/;"	m	struct:amatch_avl	file:
pWrMutex	.\test\threadtest4.c	/^  pthread_mutex_t *pWrMutex;  \/* Hold this mutex while writing *\/$/;"	m	struct:WorkerInfo	file:
pWritable	.\src\test_journal.c	/^  Bitvec *pWritable;       \/* Bitvec of pages that may be written to the file *\/$/;"	m	struct:jt_file	file:
pWriteList	.\src\test6.c	/^  WriteBuffer *pWriteList;     \/* Head of write-list *\/$/;"	m	struct:CrashGlobal	file:
pWriteListEnd	.\src\test6.c	/^  WriteBuffer *pWriteListEnd;  \/* End of write-list *\/$/;"	m	struct:CrashGlobal	file:
pWriteNode	.\ext\rtree\rtree.c	/^  sqlite3_stmt *pWriteNode;$/;"	m	struct:Rtree	file:
pWriteParent	.\ext\rtree\rtree.c	/^  sqlite3_stmt *pWriteParent;$/;"	m	struct:Rtree	file:
pWriteRowid	.\ext\rtree\rtree.c	/^  sqlite3_stmt *pWriteRowid;$/;"	m	struct:Rtree	file:
pWriter	.\ext\fts5\fts5_index.c	/^  sqlite3_stmt *pWriter;          \/* "INSERT ... %_data VALUES(?,?)" *\/$/;"	m	struct:Fts5Index	file:
pWriter	.\src\btreeInt.h	/^  Btree *pWriter;       \/* Btree with currently open write transaction *\/$/;"	m	struct:BtShared
pZombieTab	.\src\sqliteInt.h	/^  Table *pZombieTab;        \/* List of Table objects to delete after code gen *\/$/;"	m	struct:Parse
padToSectorBoundary	.\src\wal.c	/^  u8 padToSectorBoundary;    \/* Pad transactions out to the next sector *\/$/;"	m	struct:Wal	file:
padding1	.\src\btreeInt.h	/^  void *padding1;           \/* Make object size a multiple of 16 *\/$/;"	m	struct:BtCursor
page	.\src\pcache1.c	/^  sqlite3_pcache_page page;      \/* Base class. Must be first. pBuf & pExtra *\/$/;"	m	struct:PgHdr1	file:
page	.\src\test_pcache.c	/^    sqlite3_pcache_page page;  \/* Base class *\/$/;"	m	struct:testpcache::testpcachePage	file:
pageFindSlot	.\src\btree.c	/^static u8 *pageFindSlot(MemPage *pPg, int nByte, int *pRc){$/;"	f	file:
pageFreeArray	.\src\btree.c	/^static int pageFreeArray($/;"	f	file:
pageHash	.\src\pcache.h	/^  u32 pageHash;                  \/* Hash of page content *\/$/;"	m	struct:PgHdr
pageInJournal	.\src\pager.c	/^static int pageInJournal(Pager *pPager, PgHdr *pPg){$/;"	f	file:
pageInsertArray	.\src\btree.c	/^static int pageInsertArray($/;"	f	file:
pageReinit	.\src\btree.c	/^static void pageReinit(DbPage *pData){$/;"	f	file:
pageSize	.\src\btreeInt.h	/^  u32 pageSize;         \/* Total number of bytes on a page *\/$/;"	m	struct:BtShared
pageSize	.\src\pager.c	/^  int pageSize;               \/* Number of bytes in a page *\/$/;"	m	struct:Pager	file:
pageSize	.\tool\showjournal.c	/^static int pageSize = 1024;$/;"	v	file:
page_get	.\src\test2.c	/^static int page_get($/;"	f	file:
page_info	.\tool\fragck.tcl	/^proc page_info {csr up} {$/;"	p
page_lookup	.\src\test2.c	/^static int page_lookup($/;"	f	file:
page_number	.\src\test2.c	/^static int page_number($/;"	f	file:
page_read	.\src\test2.c	/^static int page_read($/;"	f	file:
page_unref	.\src\test2.c	/^static int page_unref($/;"	f	file:
page_usage_btree	.\tool\showdb.c	/^static void page_usage_btree($/;"	f	file:
page_usage_cell	.\tool\showdb.c	/^static void page_usage_cell($/;"	f	file:
page_usage_freelist	.\tool\showdb.c	/^static void page_usage_freelist(int pgno){$/;"	f	file:
page_usage_msg	.\tool\showdb.c	/^static void page_usage_msg(int pgno, const char *zFormat, ...){$/;"	f	file:
page_usage_ptrmap	.\tool\showdb.c	/^static void page_usage_ptrmap(unsigned char *a){$/;"	f	file:
page_usage_report	.\tool\showdb.c	/^static void page_usage_report(const char *zPrg, const char *zDbName){$/;"	f	file:
page_write	.\src\test2.c	/^static int page_write($/;"	f	file:
pagerAcquireMapPage	.\src\pager.c	/^static int pagerAcquireMapPage($/;"	f	file:
pagerAddPageToRollbackJournal	.\src\pager.c	/^static SQLITE_NOINLINE int pagerAddPageToRollbackJournal(PgHdr *pPg){$/;"	f	file:
pagerBeginReadTransaction	.\src\pager.c	/^static int pagerBeginReadTransaction(Pager *pPager){$/;"	f	file:
pagerBeginReadTransaction	.\src\pager.c	826;"	d	file:
pagerExclusiveLock	.\src\pager.c	/^static int pagerExclusiveLock(Pager *pPager){$/;"	f	file:
pagerFixMaplimit	.\src\pager.c	/^static void pagerFixMaplimit(Pager *pPager){$/;"	f	file:
pagerFreeMapHdrs	.\src\pager.c	/^static void pagerFreeMapHdrs(Pager *pPager){$/;"	f	file:
pagerLockDb	.\src\pager.c	/^static int pagerLockDb(Pager *pPager, int eLock){$/;"	f	file:
pagerOpenSavepoint	.\src\pager.c	/^static SQLITE_NOINLINE int pagerOpenSavepoint(Pager *pPager, int nSavepoint){$/;"	f	file:
pagerOpenWal	.\src\pager.c	/^static int pagerOpenWal(Pager *pPager){$/;"	f	file:
pagerOpenWalIfPresent	.\src\pager.c	/^static int pagerOpenWalIfPresent(Pager *pPager){$/;"	f	file:
pagerOpenWalIfPresent	.\src\pager.c	825;"	d	file:
pagerOpentemp	.\src\pager.c	/^static int pagerOpentemp($/;"	f	file:
pagerPagecount	.\src\pager.c	/^static int pagerPagecount(Pager *pPager, Pgno *pnPage){$/;"	f	file:
pagerPlaybackSavepoint	.\src\pager.c	/^static int pagerPlaybackSavepoint(Pager *pPager, PagerSavepoint *pSavepoint){$/;"	f	file:
pagerReleaseMapPage	.\src\pager.c	/^static void pagerReleaseMapPage(PgHdr *pPg){$/;"	f	file:
pagerReportSize	.\src\pager.c	/^static void pagerReportSize(Pager *pPager){$/;"	f	file:
pagerReportSize	.\src\pager.c	2116;"	d	file:
pagerRollbackWal	.\src\pager.c	/^static int pagerRollbackWal(Pager *pPager){$/;"	f	file:
pagerRollbackWal	.\src\pager.c	823;"	d	file:
pagerStress	.\src\pager.c	/^static int pagerStress(void *p, PgHdr *pPg){$/;"	f	file:
pagerSyncHotJournal	.\src\pager.c	/^static int pagerSyncHotJournal(Pager *pPager){$/;"	f	file:
pagerUndoCallback	.\src\pager.c	/^static int pagerUndoCallback(void *pCtx, Pgno iPg){$/;"	f	file:
pagerUnlockAndRollback	.\src\pager.c	/^static void pagerUnlockAndRollback(Pager *pPager){$/;"	f	file:
pagerUnlockDb	.\src\pager.c	/^static int pagerUnlockDb(Pager *pPager, int eLock){$/;"	f	file:
pagerUnlockIfUnused	.\src\pager.c	/^static void pagerUnlockIfUnused(Pager *pPager){$/;"	f	file:
pagerUseWal	.\src\pager.c	/^static int pagerUseWal(Pager *pPager){$/;"	f	file:
pagerUseWal	.\src\pager.c	822;"	d	file:
pagerWalFrames	.\src\pager.c	/^static int pagerWalFrames($/;"	f	file:
pagerWalFrames	.\src\pager.c	824;"	d	file:
pagerWriteLargeSector	.\src\pager.c	/^static SQLITE_NOINLINE int pagerWriteLargeSector(PgHdr *pPg){$/;"	f	file:
pager_cksum	.\src\pager.c	/^static u32 pager_cksum(Pager *pPager, const u8 *aData){$/;"	f	file:
pager_close	.\src\test2.c	/^static int pager_close($/;"	f	file:
pager_commit	.\src\test2.c	/^static int pager_commit($/;"	f	file:
pager_datahash	.\src\pager.c	/^static u32 pager_datahash(int nByte, unsigned char *pData){$/;"	f	file:
pager_datahash	.\src\pager.c	1210;"	d	file:
pager_delmaster	.\src\pager.c	/^static int pager_delmaster(Pager *pPager, const char *zMaster){$/;"	f	file:
pager_end_transaction	.\src\pager.c	/^static int pager_end_transaction(Pager *pPager, int hasMaster, int bCommit){$/;"	f	file:
pager_error	.\src\pager.c	/^static int pager_error(Pager *pPager, int rc){$/;"	f	file:
pager_incr_changecounter	.\src\pager.c	/^static int pager_incr_changecounter(Pager *pPager, int isDirectMode){$/;"	f	file:
pager_open	.\src\test2.c	/^static int pager_open($/;"	f	file:
pager_open_journal	.\src\pager.c	/^static int pager_open_journal(Pager *pPager){$/;"	f	file:
pager_pagecount	.\src\test2.c	/^static int pager_pagecount($/;"	f	file:
pager_pagehash	.\src\pager.c	/^static u32 pager_pagehash(PgHdr *pPage){$/;"	f	file:
pager_pagehash	.\src\pager.c	1211;"	d	file:
pager_playback	.\src\pager.c	/^static int pager_playback(Pager *pPager, int isHot){$/;"	f	file:
pager_playback_one_page	.\src\pager.c	/^static int pager_playback_one_page($/;"	f	file:
pager_reset	.\src\pager.c	/^static void pager_reset(Pager *pPager){$/;"	f	file:
pager_rollback	.\src\test2.c	/^static int pager_rollback($/;"	f	file:
pager_set_pagehash	.\src\pager.c	/^static void pager_set_pagehash(PgHdr *pPage){$/;"	f	file:
pager_set_pagehash	.\src\pager.c	1212;"	d	file:
pager_stats	.\src\test2.c	/^static int pager_stats($/;"	f	file:
pager_stmt_begin	.\src\test2.c	/^static int pager_stmt_begin($/;"	f	file:
pager_stmt_commit	.\src\test2.c	/^static int pager_stmt_commit($/;"	f	file:
pager_stmt_rollback	.\src\test2.c	/^static int pager_stmt_rollback($/;"	f	file:
pager_test_reiniter	.\src\test2.c	/^static void pager_test_reiniter(DbPage *pNotUsed){$/;"	f	file:
pager_truncate	.\src\pager.c	/^static int pager_truncate(Pager *pPager, Pgno nPage){$/;"	f	file:
pager_truncate	.\src\test2.c	/^static int pager_truncate($/;"	f	file:
pager_unlock	.\src\pager.c	/^static void pager_unlock(Pager *pPager){$/;"	f	file:
pager_wait_on_lock	.\src\pager.c	/^static int pager_wait_on_lock(Pager *pPager, int locktype){$/;"	f	file:
pager_write	.\src\pager.c	/^static int pager_write(PgHdr *pPg){$/;"	f	file:
pager_write_changecounter	.\src\pager.c	/^static void pager_write_changecounter(PgHdr *pPg){$/;"	f	file:
pager_write_pagelist	.\src\pager.c	/^static int pager_write_pagelist(Pager *pPager, PgHdr *pList){$/;"	f	file:
pagesize	.\tool\showdb.c	/^  int pagesize;                   \/* Size of a database page *\/$/;"	m	struct:GlobalData	file:
pagesize	.\tool\showwal.c	/^static int pagesize = 1024;     \/* Size of a database page *\/$/;"	v	file:
parent	.\src\test_thread.c	/^  Tcl_ThreadId parent;     \/* Thread id of parent thread *\/$/;"	m	struct:SqlThread	file:
parentWrite	.\ext\rtree\rtree.c	/^static int parentWrite(Rtree *pRtree, sqlite3_int64 iNode, sqlite3_int64 iPar){$/;"	f	file:
parentWriter	.\ext\fts2\fts2.c	/^  InteriorWriter parentWriter;    \/* if we overflow *\/$/;"	m	struct:LeafWriter	file:
parentWriter	.\ext\fts2\fts2.c	/^  struct InteriorWriter *parentWriter;$/;"	m	struct:InteriorWriter	typeref:struct:InteriorWriter::InteriorWriter	file:
parseDateOrTime	.\src\date.c	/^static int parseDateOrTime($/;"	f	file:
parseHhMmSs	.\src\date.c	/^static int parseHhMmSs(const char *zDate, DateTime *p){$/;"	f	file:
parseModifier	.\src\date.c	/^static int parseModifier(sqlite3_context *pCtx, const char *zMod, DateTime *p){$/;"	f	file:
parseQuery	.\ext\fts1\fts1.c	/^static int parseQuery($/;"	f	file:
parseQuery	.\ext\fts2\fts2.c	/^static int parseQuery($/;"	f	file:
parseSpec	.\ext\fts1\fts1.c	/^static int parseSpec(TableSpec *pSpec, int argc, const char *const*argv,$/;"	f	file:
parseSpec	.\ext\fts2\fts2.c	/^static int parseSpec(TableSpec *pSpec, int argc, const char *const*argv,$/;"	f	file:
parseTimezone	.\src\date.c	/^static int parseTimezone(const char *zDate, DateTime *p){$/;"	f	file:
parseYyyyMmDd	.\src\date.c	/^static int parseYyyyMmDd(const char *zDate, DateTime *p){$/;"	f	file:
parse_client_id	.\src\test7.c	/^static int parse_client_id(Tcl_Interp *interp, const char *zArg){$/;"	f	file:
parse_query	.\ext\fts1\fulltext.c	/^static int parse_query(fulltext_vtab *v, const char *zQuery, Query *pQuery){$/;"	f	file:
parse_thread_id	.\src\test4.c	/^static int parse_thread_id(Tcl_Interp *interp, const char *zArg){$/;"	f	file:
parseonetoken	.\tool\lemon.c	/^static void parseonetoken(struct pstate *psp)$/;"	f	file:
pathsearch	.\tool\lemon.c	/^PRIVATE char *pathsearch(char *argv0, char *name, int modemask)$/;"	f
patternCompare	.\src\func.c	/^static int patternCompare($/;"	f	file:
payloadSize	.\src\vdbeInt.h	/^  u32 payloadSize;      \/* Total number of bytes in the record *\/$/;"	m	struct:VdbeCursor
pc	.\src\vdbeInt.h	/^  int pc;                 \/* Program Counter in parent (calling) frame *\/$/;"	m	struct:VdbeFrame
pc	.\src\vdbeInt.h	/^  int pc;                 \/* The program counter *\/$/;"	m	struct:Vdbe
pcache	.\src\test_init.c	/^  sqlite3_pcache_methods2 pcache;$/;"	m	struct:Wrapped	file:
pcache1	.\src\pcache1.c	216;"	d	file:
pcache1Alloc	.\src\pcache1.c	/^static void *pcache1Alloc(int nByte){$/;"	f	file:
pcache1AllocPage	.\src\pcache1.c	/^static PgHdr1 *pcache1AllocPage(PCache1 *pCache, int benignMalloc){$/;"	f	file:
pcache1Cachesize	.\src\pcache1.c	/^static void pcache1Cachesize(sqlite3_pcache *p, int nMax){$/;"	f	file:
pcache1Create	.\src\pcache1.c	/^static sqlite3_pcache *pcache1Create(int szPage, int szExtra, int bPurgeable){$/;"	f	file:
pcache1Destroy	.\src\pcache1.c	/^static void pcache1Destroy(sqlite3_pcache *p){$/;"	f	file:
pcache1EnforceMaxPage	.\src\pcache1.c	/^static void pcache1EnforceMaxPage(PCache1 *pCache){$/;"	f	file:
pcache1EnterMutex	.\src\pcache1.c	222;"	d	file:
pcache1EnterMutex	.\src\pcache1.c	226;"	d	file:
pcache1Fetch	.\src\pcache1.c	/^static sqlite3_pcache_page *pcache1Fetch($/;"	f	file:
pcache1FetchNoMutex	.\src\pcache1.c	/^static PgHdr1 *pcache1FetchNoMutex($/;"	f	file:
pcache1FetchStage2	.\src\pcache1.c	/^static SQLITE_NOINLINE PgHdr1 *pcache1FetchStage2($/;"	f	file:
pcache1FetchWithMutex	.\src\pcache1.c	/^static PgHdr1 *pcache1FetchWithMutex($/;"	f	file:
pcache1Free	.\src\pcache1.c	/^static void pcache1Free(void *p){$/;"	f	file:
pcache1FreePage	.\src\pcache1.c	/^static void pcache1FreePage(PgHdr1 *p){$/;"	f	file:
pcache1Init	.\src\pcache1.c	/^static int pcache1Init(void *NotUsed){$/;"	f	file:
pcache1InitBulk	.\src\pcache1.c	/^static int pcache1InitBulk(PCache1 *pCache){$/;"	f	file:
pcache1LeaveMutex	.\src\pcache1.c	223;"	d	file:
pcache1LeaveMutex	.\src\pcache1.c	227;"	d	file:
pcache1MemSize	.\src\pcache1.c	/^static int pcache1MemSize(void *p){$/;"	f	file:
pcache1Pagecount	.\src\pcache1.c	/^static int pcache1Pagecount(sqlite3_pcache *p){$/;"	f	file:
pcache1PinPage	.\src\pcache1.c	/^static PgHdr1 *pcache1PinPage(PgHdr1 *pPage){$/;"	f	file:
pcache1Rekey	.\src\pcache1.c	/^static void pcache1Rekey($/;"	f	file:
pcache1RemoveFromHash	.\src\pcache1.c	/^static void pcache1RemoveFromHash(PgHdr1 *pPage, int freeFlag){$/;"	f	file:
pcache1ResizeHash	.\src\pcache1.c	/^static void pcache1ResizeHash(PCache1 *p){$/;"	f	file:
pcache1Shrink	.\src\pcache1.c	/^static void pcache1Shrink(sqlite3_pcache *p){$/;"	f	file:
pcache1Shutdown	.\src\pcache1.c	/^static void pcache1Shutdown(void *NotUsed){$/;"	f	file:
pcache1Truncate	.\src\pcache1.c	/^static void pcache1Truncate(sqlite3_pcache *p, unsigned int iLimit){$/;"	f	file:
pcache1TruncateUnsafe	.\src\pcache1.c	/^static void pcache1TruncateUnsafe($/;"	f	file:
pcache1UnderMemoryPressure	.\src\pcache1.c	/^static int pcache1UnderMemoryPressure(PCache1 *pCache){$/;"	f	file:
pcache1Unpin	.\src\pcache1.c	/^static void pcache1Unpin($/;"	f	file:
pcache1_g	.\src\pcache1.c	/^} pcache1_g;$/;"	v	typeref:struct:PCacheGlobal	file:
pcache2	.\src\sqliteInt.h	/^  sqlite3_pcache_methods2 pcache2;  \/* Low-level page-cache interface *\/$/;"	m	struct:Sqlite3Config
pcacheFetchFinishWithInit	.\src\pcache.c	/^static SQLITE_NOINLINE PgHdr *pcacheFetchFinishWithInit($/;"	f	file:
pcacheManageDirtyList	.\src\pcache.c	/^static void pcacheManageDirtyList(PgHdr *pPage, u8 addRemove){$/;"	f	file:
pcacheMergeDirtyList	.\src\pcache.c	/^static PgHdr *pcacheMergeDirtyList(PgHdr *pA, PgHdr *pB){$/;"	f	file:
pcacheSortDirtyList	.\src\pcache.c	/^static PgHdr *pcacheSortDirtyList(PgHdr *pIn){$/;"	f	file:
pcacheUnpin	.\src\pcache.c	/^static void pcacheUnpin(PgHdr *p){$/;"	f	file:
pcache_fail	.\src\test_init.c	/^  int pcache_fail;             \/* True to fail pcache subsystem inialization *\/$/;"	m	struct:Wrapped	file:
pcache_init	.\src\test_init.c	/^  int pcache_init;             \/* True if pcache subsystem is initalized *\/$/;"	m	struct:Wrapped	file:
pclose	.\src\shell.c	110;"	d	file:
pclose	.\src\shell.c	111;"	d	file:
peekDocid	.\ext\fts1\fts1.c	/^static sqlite_int64 peekDocid(DocListReader *pReader){$/;"	f	file:
peekDocid	.\ext\fts1\fulltext.c	/^static sqlite_int64 peekDocid(DocListReader *pReader){$/;"	f	file:
pendingTerms	.\ext\fts2\fts2.c	/^  fts2Hash pendingTerms;$/;"	m	struct:fulltext_vtab	file:
perLine	.\tool\showdb.c	/^  int perLine;                    \/* HEX elements to print per line *\/$/;"	m	struct:GlobalData	file:
perLine	.\tool\showwal.c	/^static int perLine = 16;        \/* HEX elements to print per line *\/$/;"	v	file:
percent	.\tool\spaceanal.tcl	/^proc percent {num denom {of {}}} {$/;"	p
percentFinal	.\ext\misc\percentile.c	/^static void percentFinal(sqlite3_context *pCtx){$/;"	f	file:
percentStep	.\ext\misc\percentile.c	/^static void percentStep(sqlite3_context *pCtx, int argc, sqlite3_value **argv){$/;"	f	file:
permutation	.\test\tester.tcl	/^proc permutation {} {$/;"	p
pgidx	.\ext\fts5\fts5_index.c	/^  Fts5Buffer pgidx;               \/* Buffer containing page-index *\/$/;"	m	struct:Fts5PageWriter	file:
pgno	.\ext\fts5\fts5_index.c	/^  int pgno;                       \/* Page number for this page *\/$/;"	m	struct:Fts5DlidxWriter	file:
pgno	.\ext\fts5\fts5_index.c	/^  int pgno;                       \/* Page number for this page *\/$/;"	m	struct:Fts5PageWriter	file:
pgno	.\src\btreeInt.h	/^  Pgno pgno;           \/* Page number for this page *\/$/;"	m	struct:MemPage
pgno	.\src\pcache.h	/^  Pgno pgno;                     \/* Page number for this page *\/$/;"	m	struct:PgHdr
pgno	.\tool\offsets.c	/^  int pgno;             \/* Current page number *\/$/;"	m	struct:GState	file:
pgnoFirst	.\ext\fts5\fts5_index.c	/^  int pgnoFirst;                  \/* First leaf page number in segment *\/$/;"	m	struct:Fts5StructureSegment	file:
pgnoLast	.\ext\fts5\fts5_index.c	/^  int pgnoLast;                   \/* Last leaf page number in segment *\/$/;"	m	struct:Fts5StructureSegment	file:
pgnoRoot	.\src\btreeInt.h	/^  Pgno pgnoRoot;            \/* The root page of this tree *\/$/;"	m	struct:BtCursor
pgnoRoot	.\src\vdbeInt.h	/^  Pgno pgnoRoot;        \/* Root page of the open btree cursor *\/$/;"	m	struct:VdbeCursor
pgsz	.\ext\fts5\fts5Int.h	/^  int pgsz;                       \/* Approximate page size used in %_data *\/$/;"	m	struct:Fts5Config
pgsz	.\ext\rbu\sqlite3rbu.c	/^  int pgsz;$/;"	m	struct:sqlite3rbu	file:
pgsz	.\src\test_syscall.c	/^  int pgsz;$/;"	m	struct:TestSyscallGlobal	file:
pgsz	.\src\test_vfs.c	/^  int pgsz;                       \/* Page size *\/$/;"	m	struct:TestvfsBuffer	file:
pgsz	.\src\vdbesort.c	/^  int pgsz;                       \/* Main database page size *\/$/;"	m	struct:VdbeSorter	file:
phoneticHash	.\ext\misc\spellfix.c	/^static unsigned char *phoneticHash(const unsigned char *zIn, int nIn){$/;"	f	file:
phoneticHashSqlFunc	.\ext\misc\spellfix.c	/^static void phoneticHashSqlFunc($/;"	f	file:
pipe	.\autoconf\tea\win\nmakehlp.c	/^    HANDLE pipe;$/;"	m	struct:__anon1	file:
pipeinfo	.\autoconf\tea\win\nmakehlp.c	/^} pipeinfo;$/;"	t	typeref:struct:__anon1	file:
plink	.\tool\lemon.c	/^struct plink {$/;"	s	file:
plink_freelist	.\tool\lemon.c	/^static struct plink *plink_freelist = 0;$/;"	v	typeref:struct:plink	file:
plrAtEnd	.\ext\fts2\fts2.c	/^static int plrAtEnd(PLReader *pReader){$/;"	f	file:
plrColumn	.\ext\fts2\fts2.c	/^static int plrColumn(PLReader *pReader){$/;"	f	file:
plrDestroy	.\ext\fts2\fts2.c	/^static void plrDestroy(PLReader *pReader){$/;"	f	file:
plrEndOffset	.\ext\fts2\fts2.c	/^static int plrEndOffset(PLReader *pReader){$/;"	f	file:
plrInit	.\ext\fts2\fts2.c	/^static void plrInit(PLReader *pReader, DLReader *pDLReader){$/;"	f	file:
plrPosition	.\ext\fts2\fts2.c	/^static int plrPosition(PLReader *pReader){$/;"	f	file:
plrStartOffset	.\ext\fts2\fts2.c	/^static int plrStartOffset(PLReader *pReader){$/;"	f	file:
plrStep	.\ext\fts2\fts2.c	/^static void plrStep(PLReader *pReader){$/;"	f	file:
plw	.\ext\fts2\fts2.c	/^  PLWriter plw;$/;"	m	struct:DLCollector	file:
plwAdd	.\ext\fts2\fts2.c	/^static void plwAdd(PLWriter *pWriter, int iColumn, int iPos,$/;"	f	file:
plwCopy	.\ext\fts2\fts2.c	/^static void plwCopy(PLWriter *pWriter, PLReader *pReader){$/;"	f	file:
plwDestroy	.\ext\fts2\fts2.c	/^static void plwDestroy(PLWriter *pWriter){$/;"	f	file:
plwInit	.\ext\fts2\fts2.c	/^static void plwInit(PLWriter *pWriter, DLWriter *dlw, sqlite_int64 iDocid){$/;"	f	file:
plwTerminate	.\ext\fts2\fts2.c	/^static void plwTerminate(PLWriter *pWriter){$/;"	f	file:
pnByte	.\ext\fts5\fts5_hash.c	/^  int *pnByte;                    \/* Pointer to bytes counter *\/$/;"	m	struct:Fts5Hash	file:
pnBytesFreed	.\src\sqliteInt.h	/^  int *pnBytesFreed;            \/* If not NULL, increment this in DbFree() *\/$/;"	m	struct:sqlite3
pointerToText	.\src\test_malloc.c	/^static void pointerToText(void *p, char *z){$/;"	f	file:
popen	.\src\shell.c	108;"	d	file:
popen	.\src\shell.c	109;"	d	file:
populateCellCache	.\src\btree.c	/^static void populateCellCache(CellArray *p, int idx, int N){$/;"	f	file:
porterClose	.\ext\fts1\fts1_porter.c	/^static int porterClose(sqlite3_tokenizer_cursor *pCursor){$/;"	f	file:
porterClose	.\ext\fts2\fts2_porter.c	/^static int porterClose(sqlite3_tokenizer_cursor *pCursor){$/;"	f	file:
porterClose	.\ext\fts3\fts3_porter.c	/^static int porterClose(sqlite3_tokenizer_cursor *pCursor){$/;"	f	file:
porterCreate	.\ext\fts1\fts1_porter.c	/^static int porterCreate($/;"	f	file:
porterCreate	.\ext\fts2\fts2_porter.c	/^static int porterCreate($/;"	f	file:
porterCreate	.\ext\fts3\fts3_porter.c	/^static int porterCreate($/;"	f	file:
porterDestroy	.\ext\fts1\fts1_porter.c	/^static int porterDestroy(sqlite3_tokenizer *pTokenizer){$/;"	f	file:
porterDestroy	.\ext\fts2\fts2_porter.c	/^static int porterDestroy(sqlite3_tokenizer *pTokenizer){$/;"	f	file:
porterDestroy	.\ext\fts3\fts3_porter.c	/^static int porterDestroy(sqlite3_tokenizer *pTokenizer){$/;"	f	file:
porterIdChar	.\ext\fts2\fts2_porter.c	/^static const char porterIdChar[] = {$/;"	v	file:
porterIdChar	.\ext\fts3\fts3_porter.c	/^static const char porterIdChar[] = {$/;"	v	file:
porterNext	.\ext\fts1\fts1_porter.c	/^static int porterNext($/;"	f	file:
porterNext	.\ext\fts2\fts2_porter.c	/^static int porterNext($/;"	f	file:
porterNext	.\ext\fts3\fts3_porter.c	/^static int porterNext($/;"	f	file:
porterOpen	.\ext\fts1\fts1_porter.c	/^static int porterOpen($/;"	f	file:
porterOpen	.\ext\fts2\fts2_porter.c	/^static int porterOpen($/;"	f	file:
porterOpen	.\ext\fts3\fts3_porter.c	/^static int porterOpen($/;"	f	file:
porterTokenizerModule	.\ext\fts1\fts1_porter.c	/^static const sqlite3_tokenizer_module porterTokenizerModule = {$/;"	v	file:
porterTokenizerModule	.\ext\fts1\fts1_porter.c	/^static const sqlite3_tokenizer_module porterTokenizerModule;$/;"	v	file:
porterTokenizerModule	.\ext\fts2\fts2_porter.c	/^static const sqlite3_tokenizer_module porterTokenizerModule = {$/;"	v	file:
porterTokenizerModule	.\ext\fts2\fts2_porter.c	/^static const sqlite3_tokenizer_module porterTokenizerModule;$/;"	v	file:
porterTokenizerModule	.\ext\fts3\fts3_porter.c	/^static const sqlite3_tokenizer_module porterTokenizerModule = {$/;"	v	file:
porter_stemmer	.\ext\fts1\fts1_porter.c	/^static void porter_stemmer(const char *zIn, int nIn, char *zOut, int *pnOut){$/;"	f	file:
porter_stemmer	.\ext\fts2\fts2_porter.c	/^static void porter_stemmer(const char *zIn, int nIn, char *zOut, int *pnOut){$/;"	f	file:
porter_stemmer	.\ext\fts3\fts3_porter.c	/^static void porter_stemmer(const char *zIn, int nIn, char *zOut, int *pnOut){$/;"	f	file:
porter_tokenizer	.\ext\fts1\fts1_porter.c	/^typedef struct porter_tokenizer {$/;"	s	file:
porter_tokenizer	.\ext\fts1\fts1_porter.c	/^} porter_tokenizer;$/;"	t	typeref:struct:porter_tokenizer	file:
porter_tokenizer	.\ext\fts2\fts2_porter.c	/^typedef struct porter_tokenizer {$/;"	s	file:
porter_tokenizer	.\ext\fts2\fts2_porter.c	/^} porter_tokenizer;$/;"	t	typeref:struct:porter_tokenizer	file:
porter_tokenizer	.\ext\fts3\fts3_porter.c	/^typedef struct porter_tokenizer {$/;"	s	file:
porter_tokenizer	.\ext\fts3\fts3_porter.c	/^} porter_tokenizer;$/;"	t	typeref:struct:porter_tokenizer	file:
porter_tokenizer_cursor	.\ext\fts1\fts1_porter.c	/^typedef struct porter_tokenizer_cursor {$/;"	s	file:
porter_tokenizer_cursor	.\ext\fts1\fts1_porter.c	/^} porter_tokenizer_cursor;$/;"	t	typeref:struct:porter_tokenizer_cursor	file:
porter_tokenizer_cursor	.\ext\fts2\fts2_porter.c	/^typedef struct porter_tokenizer_cursor {$/;"	s	file:
porter_tokenizer_cursor	.\ext\fts2\fts2_porter.c	/^} porter_tokenizer_cursor;$/;"	t	typeref:struct:porter_tokenizer_cursor	file:
porter_tokenizer_cursor	.\ext\fts3\fts3_porter.c	/^typedef struct porter_tokenizer_cursor {$/;"	s	file:
porter_tokenizer_cursor	.\ext\fts3\fts3_porter.c	/^} porter_tokenizer_cursor;$/;"	t	typeref:struct:porter_tokenizer_cursor	file:
posListCmp	.\ext\fts2\fts2.c	/^static int posListCmp(PLReader *pLeft, PLReader *pRight){$/;"	f	file:
posListPhraseMerge	.\ext\fts2\fts2.c	/^static void posListPhraseMerge(DLReader *pLeft, DLReader *pRight,$/;"	f	file:
posListUnion	.\ext\fts2\fts2.c	/^static void posListUnion(DLReader *pLeft, DLReader *pRight, DLWriter *pOut){$/;"	f	file:
posixFchown	.\src\os_unix.c	/^static int posixFchown(int fd, uid_t uid, gid_t gid){$/;"	f	file:
posixOpen	.\src\os_unix.c	/^static int posixOpen(const char *zFile, int flags, int mode){$/;"	f	file:
posixUnlock	.\src\os_unix.c	/^static int posixUnlock(sqlite3_file *id, int eFileLock, int handleNFSUnlock){$/;"	f	file:
poslist	.\ext\fts5\fts5_expr.c	/^  Fts5Buffer poslist;             \/* Current position list *\/$/;"	m	struct:Fts5ExprPhrase	file:
poslist	.\ext\fts5\fts5_index.c	/^  Fts5Buffer poslist;             \/* Buffer containing current poslist *\/$/;"	m	struct:Fts5IndexIter	file:
postToParent	.\src\test_thread.c	/^static void postToParent(SqlThread *p, Tcl_Obj *pScript){$/;"	f	file:
ppNextElem	.\ext\fts3\fts3_write.c	/^  Fts3HashElem **ppNextElem;$/;"	m	struct:Fts3SegReader	file:
ppPrev	.\ext\misc\vfslog.c	/^  VLogLog **ppPrev;               \/* Pointer to this in the list *\/$/;"	m	struct:VLogLog	file:
ppPrev	.\ext\misc\vtshim.c	/^  vtshim_cursor **ppPrev;      \/* Previous on list of all cursors *\/$/;"	m	struct:vtshim_cursor	file:
ppPrev	.\ext\misc\vtshim.c	/^  vtshim_vtab **ppPrev;    \/* Previous on list *\/$/;"	m	struct:vtshim_vtab	file:
ppPrev	.\src\test_quota.c	/^  quotaFile *pNext, **ppPrev;     \/* Linked list of files in the same group *\/$/;"	m	struct:quotaFile	file:
ppPrev	.\src\test_quota.c	/^  quotaGroup *pNext, **ppPrev;   \/* Doubly linked list of all quota objects *\/$/;"	m	struct:quotaGroup	file:
ppRec	.\src\vdbemem.c	/^  UnpackedRecord **ppRec;$/;"	m	struct:ValueNewStat4Ctx	file:
ppThis	.\src\test_onefile.c	/^  fs_real_file **ppThis;$/;"	m	struct:fs_real_file	file:
prec	.\tool\lemon.c	/^  int prec;                \/* Precedence if defined (-1 otherwise) *\/$/;"	m	struct:symbol	file:
preccounter	.\tool\lemon.c	/^  int preccounter;           \/* Assign this precedence to decl arguments *\/$/;"	m	struct:pstate	file:
precsym	.\tool\lemon.c	/^  struct symbol *precsym;  \/* Precedence symbol for this rule *\/$/;"	m	struct:rule	typeref:struct:rule::symbol	file:
prefix	.\src\printf.c	/^  etByte prefix;           \/* Offset into aPrefix[] of the prefix string *\/$/;"	m	struct:et_info	file:
prefix	.\tool\mkkeywordhash.c	/^  int prefix;          \/* Number of characters in prefix *\/$/;"	m	struct:Keyword	file:
prepStack	.\src\test1.c	/^static void prepStack(void){$/;"	f	file:
prepTime	.\tool\speedtest16.c	/^static sqlite_uint64 prepTime = 0;$/;"	v	file:
prepTime	.\tool\speedtest8.c	/^static sqlite_uint64 prepTime = 0;$/;"	v	file:
prep_sql	.\test\threadtest4.c	/^static sqlite3_stmt *prep_sql(sqlite3 *db, const char *zFormat, ...){$/;"	f	file:
prepare	.\ext\fts3\tool\fts3view.c	/^static sqlite3_stmt *prepare(sqlite3 *db, const char *zFormat, ...){$/;"	f	file:
prepare	.\src\sqlite3ext.h	/^  int  (*prepare)(sqlite3*,const char*,int,sqlite3_stmt**,const char**);$/;"	m	struct:sqlite3_api_routines
prepare16	.\src\sqlite3ext.h	/^  int  (*prepare16)(sqlite3*,const void*,int,sqlite3_stmt**,const void**);$/;"	m	struct:sqlite3_api_routines
prepare16_v2	.\src\sqlite3ext.h	/^  int (*prepare16_v2)(sqlite3*,const void*,int,sqlite3_stmt**,const void**);$/;"	m	struct:sqlite3_api_routines
prepareAndCollectError	.\ext\rbu\sqlite3rbu.c	/^static int prepareAndCollectError($/;"	f	file:
prepareAndRun	.\tool\speedtest16.c	/^static void prepareAndRun(sqlite3 *db, const char *zSql){$/;"	f	file:
prepareAndRun	.\tool\speedtest8.c	/^static void prepareAndRun(sqlite3 *db, const char *zSql, int bQuiet){$/;"	f	file:
prepareAndRun	.\tool\speedtest8inst1.c	/^static void prepareAndRun(sqlite3_vfs *pInstVfs, sqlite3 *db, const char *zSql){$/;"	f	file:
prepareFreeAndCollectError	.\ext\rbu\sqlite3rbu.c	/^static int prepareFreeAndCollectError($/;"	f	file:
prepareSql	.\mptest\mptest.c	/^static sqlite3_stmt *prepareSql(const char *zFormat, ...){$/;"	f	file:
prepareToGetSegment	.\ext\fts3\tool\fts3view.c	/^static sqlite3_stmt *prepareToGetSegment($/;"	f	file:
prepare_v2	.\src\sqlite3ext.h	/^  int (*prepare_v2)(sqlite3*,const char*,int,sqlite3_stmt**,const char**);$/;"	m	struct:sqlite3_api_routines
preprocess_input	.\tool\lemon.c	/^static void preprocess_input(char *z){$/;"	f	file:
prereq	.\src\whereInt.h	/^  Bitmask prereq;       \/* Bitmask of other loops that must run first *\/$/;"	m	struct:WhereLoop
prereq	.\src\whereInt.h	/^  Bitmask prereq;     \/* Prerequisites *\/$/;"	m	struct:WhereOrCost
prereqAll	.\src\whereInt.h	/^  Bitmask prereqAll;      \/* Bitmask of tables referenced by pExpr *\/$/;"	m	struct:WhereTerm
prereqRight	.\src\whereInt.h	/^  Bitmask prereqRight;    \/* Bitmask of tables used by pExpr->pRight *\/$/;"	m	struct:WhereTerm
presql	.\test\tester.tcl	/^proc presql {} {$/;"	p
prev	.\ext\fts1\ft_hash.h	/^  HashElem *next, *prev;   \/* Next and previous elements in the table *\/$/;"	m	struct:HashElem
prev	.\ext\fts1\fts1_hash.h	/^  fts1HashElem *next, *prev; \/* Next and previous elements in the table *\/$/;"	m	struct:fts1HashElem
prev	.\ext\fts2\fts2_hash.h	/^  fts2HashElem *next, *prev; \/* Next and previous elements in the table *\/$/;"	m	struct:fts2HashElem
prev	.\ext\fts3\fts3_hash.h	/^  Fts3HashElem *next, *prev; \/* Next and previous elements in the table *\/$/;"	m	struct:Fts3HashElem
prev	.\src\hash.h	/^  HashElem *next, *prev;       \/* Next and previous elements in the table *\/$/;"	m	struct:HashElem
prev	.\src\mem3.c	/^      u32 prev;       \/* Index in mem3.aPool[] of previous free chunk *\/$/;"	m	struct:Mem3Block::__anon11::__anon13	file:
prev	.\src\mem5.c	/^  int prev;       \/* Index of previous free chunk *\/$/;"	m	struct:Mem5Link	file:
prevSize	.\src\mem3.c	/^      u32 prevSize;   \/* Size of previous chunk in Mem3Block elements *\/$/;"	m	struct:Mem3Block::__anon11::__anon12	file:
prevrule	.\tool\lemon.c	/^  struct rule *prevrule;     \/* Previous rule parsed *\/$/;"	m	struct:pstate	typeref:struct:pstate::rule	file:
primitives	.\ext\async\sqlite3async.c	/^} primitives = { 0 };$/;"	v	typeref:struct:AsyncPrimitives	file:
primitives	.\ext\async\sqlite3async.c	/^} primitives = {$/;"	v	typeref:struct:AsyncPrimitives	file:
printBlob	.\ext\fts3\tool\fts3view.c	/^static void printBlob($/;"	f	file:
printBold	.\src\shell.c	/^static void printBold(const char *zText){$/;"	f	file:
printBytes	.\tool\showdb.c	/^static void printBytes($/;"	f	file:
printDoclist	.\ext\fts1\fts1.c	/^static void printDoclist(DocList *p){$/;"	f	file:
printExplainQueryPlan	.\src\test1.c	/^int printExplainQueryPlan(sqlite3_stmt *pStmt){$/;"	f
printQuoted	.\tool\sqldiff.c	/^static void printQuoted(FILE *out, sqlite3_value *X){$/;"	f	file:
printResult	.\test\wordcount.c	/^static int printResult(void *NotUsed, int nArg, char **azArg, char **azNm){$/;"	f	file:
printSql	.\test\speedtest1.c	/^static void printSql(const char *zSql){$/;"	f	file:
printTreeLine	.\ext\fts3\tool\fts3view.c	/^static void printTreeLine(sqlite3_int64 iLower, sqlite3_int64 iUpper){$/;"	f	file:
printWithPrefix	.\mptest\mptest.c	/^static void printWithPrefix(FILE *pOut, const char *zPrefix, const char *zMsg){$/;"	f	file:
print_and_free_err	.\test\threadtest3.c	/^static void print_and_free_err(Error *p){$/;"	f	file:
print_byte_range	.\tool\showdb.c	/^static unsigned char *print_byte_range($/;"	f	file:
print_byte_range	.\tool\showwal.c	/^static void print_byte_range($/;"	f	file:
print_db_header	.\tool\showdb.c	/^static void print_db_header(void){$/;"	f	file:
print_decode_line	.\tool\showdb.c	/^static void print_decode_line($/;"	f	file:
print_decode_line	.\tool\showjournal.c	/^static unsigned print_decode_line($/;"	f	file:
print_decode_line	.\tool\showwal.c	/^static void print_decode_line($/;"	f	file:
print_err	.\test\threadtest3.c	/^static void print_err(Error *p){$/;"	f	file:
print_fileheader	.\ext\fts3\unicode\mkunicode.tcl	/^proc print_fileheader {} {$/;"	p
print_fold	.\ext\fts3\unicode\mkunicode.tcl	/^proc print_fold {zFunc} {$/;"	p
print_fold_test	.\ext\fts3\unicode\mkunicode.tcl	/^proc print_fold_test {zFunc mappings} {$/;"	p
print_frame	.\tool\showwal.c	/^static void print_frame(int iFrame){$/;"	f	file:
print_isalnum	.\ext\fts3\unicode\mkunicode.tcl	/^proc print_isalnum {zFunc lRange} {$/;"	p
print_isdiacritic	.\ext\fts3\unicode\mkunicode.tcl	/^proc print_isdiacritic {zFunc map} {$/;"	p
print_oneline_frame	.\tool\showwal.c	/^static void print_oneline_frame(int iFrame, Cksum *pCksum){$/;"	f	file:
print_page	.\tool\showdb.c	/^static void print_page(int iPg){$/;"	f	file:
print_page	.\tool\showjournal.c	/^static void print_page(int iOfst){$/;"	f	file:
print_pager_state	.\src\pager.c	/^static char *print_pager_state(Pager *p){$/;"	f	file:
print_rd	.\ext\fts3\unicode\mkunicode.tcl	/^proc print_rd {map} {$/;"	p
print_stack_union	.\tool\lemon.c	/^void print_stack_union($/;"	f
print_test_isalnum	.\ext\fts3\unicode\mkunicode.tcl	/^proc print_test_isalnum {zFunc lRange} {$/;"	p
print_test_main	.\ext\fts3\unicode\mkunicode.tcl	/^proc print_test_main {} {$/;"	p
print_wal_header	.\tool\showwal.c	/^static void print_wal_header(Cksum *pCksum){$/;"	f	file:
printfFunc	.\src\func.c	/^static void printfFunc($/;"	f	file:
prngSeed	.\src\test_pcache.c	/^  unsigned prngSeed;        \/* Seed for the PRNG *\/$/;"	m	struct:testpcacheGlobalType	file:
processDevSymArgs	.\src\test6.c	/^static int processDevSymArgs($/;"	f	file:
process_input	.\src\shell.c	/^static int process_input(ShellState *p, FILE *in){$/;"	f	file:
process_options	.\test\releasetest.tcl	/^proc process_options {argv} {$/;"	p
process_options	.\tool\omittest.tcl	/^proc process_options {argv} {$/;"	p
process_sqliterc	.\src\shell.c	/^static void process_sqliterc($/;"	f	file:
profile	.\src\sqlite3ext.h	/^  void * (*profile)(sqlite3*,void(*)(void*,const char*,sqlite_uint64),void*);$/;"	m	struct:sqlite3_api_routines
progressHandler	.\test\fuzzcheck.c	/^static int progressHandler(void *pVdbeLimitFlag){$/;"	f	file:
progress_handler	.\src\sqlite3ext.h	/^  void  (*progress_handler)(sqlite3*,int,int(*)(void*),void*);$/;"	m	struct:sqlite3_api_routines
proxyBreakConchLock	.\src\os_unix.c	/^static int proxyBreakConchLock(unixFile *pFile, uuid_t myHostID){$/;"	f	file:
proxyCheckReservedLock	.\src\os_unix.c	/^static int proxyCheckReservedLock(sqlite3_file *id, int *pResOut) {$/;"	f	file:
proxyClose	.\src\os_unix.c	/^static int proxyClose(sqlite3_file *id) {$/;"	f	file:
proxyConchLock	.\src\os_unix.c	/^static int proxyConchLock(unixFile *pFile, uuid_t myHostID, int lockType){$/;"	f	file:
proxyCreateConchPathname	.\src\os_unix.c	/^static int proxyCreateConchPathname(char *dbPath, char **pConchPath){$/;"	f	file:
proxyCreateLockPath	.\src\os_unix.c	/^static int proxyCreateLockPath(const char *lockPath){$/;"	f	file:
proxyCreateUnixFile	.\src\os_unix.c	/^static int proxyCreateUnixFile($/;"	f	file:
proxyFileControl	.\src\os_unix.c	/^static int proxyFileControl(sqlite3_file *id, int op, void *pArg){$/;"	f	file:
proxyGetDbPathForUnixFile	.\src\os_unix.c	/^static int proxyGetDbPathForUnixFile(unixFile *pFile, char *dbPath){$/;"	f	file:
proxyGetHostID	.\src\os_unix.c	/^static int proxyGetHostID(unsigned char *pHostID, int *pError){$/;"	f	file:
proxyGetLockPath	.\src\os_unix.c	/^static int proxyGetLockPath(const char *dbPath, char *lPath, size_t maxLen){$/;"	f	file:
proxyLock	.\src\os_unix.c	/^static int proxyLock(sqlite3_file *id, int eFileLock) {$/;"	f	file:
proxyLockingContext	.\src\os_unix.c	/^struct proxyLockingContext {$/;"	s	file:
proxyLockingContext	.\src\os_unix.c	/^typedef struct proxyLockingContext proxyLockingContext;$/;"	t	typeref:struct:proxyLockingContext	file:
proxyReleaseConch	.\src\os_unix.c	/^static int proxyReleaseConch(unixFile *pFile){$/;"	f	file:
proxyTakeConch	.\src\os_unix.c	/^static int proxyTakeConch(unixFile *pFile){$/;"	f	file:
proxyTransformUnixFile	.\src\os_unix.c	/^static int proxyTransformUnixFile(unixFile *pFile, const char *path) {$/;"	f	file:
proxyUnlock	.\src\os_unix.c	/^static int proxyUnlock(sqlite3_file *id, int eFileLock) {$/;"	f	file:
pseudoTableReg	.\src\vdbeInt.h	/^  int pseudoTableReg;   \/* Register holding pseudotable content. *\/$/;"	m	struct:VdbeCursor
pstate	.\tool\lemon.c	/^struct pstate {$/;"	s	file:
pthreadMutexAlloc	.\src\mutex_unix.c	/^static sqlite3_mutex *pthreadMutexAlloc(int iType){$/;"	f	file:
pthreadMutexEnd	.\src\mutex_unix.c	/^static int pthreadMutexEnd(void){ return SQLITE_OK; }$/;"	f	file:
pthreadMutexEnter	.\src\mutex_unix.c	/^static void pthreadMutexEnter(sqlite3_mutex *p){$/;"	f	file:
pthreadMutexFree	.\src\mutex_unix.c	/^static void pthreadMutexFree(sqlite3_mutex *p){$/;"	f	file:
pthreadMutexHeld	.\src\mutex_unix.c	/^static int pthreadMutexHeld(sqlite3_mutex *p){$/;"	f	file:
pthreadMutexInit	.\src\mutex_unix.c	/^static int pthreadMutexInit(void){ return SQLITE_OK; }$/;"	f	file:
pthreadMutexLeave	.\src\mutex_unix.c	/^static void pthreadMutexLeave(sqlite3_mutex *p){$/;"	f	file:
pthreadMutexNotheld	.\src\mutex_unix.c	/^static int pthreadMutexNotheld(sqlite3_mutex *p){$/;"	f	file:
pthreadMutexTry	.\src\mutex_unix.c	/^static int pthreadMutexTry(sqlite3_mutex *p){$/;"	f	file:
ptrChngFunction	.\src\test1.c	/^static void ptrChngFunction($/;"	f	file:
ptrToText	.\src\test_blob.c	/^static char *ptrToText(void *p){$/;"	f	file:
ptrmapGet	.\src\btree.c	/^static int ptrmapGet(BtShared *pBt, Pgno key, u8 *pEType, Pgno *pPgno){$/;"	f	file:
ptrmapGet	.\src\btree.c	980;"	d	file:
ptrmapPageno	.\src\btree.c	/^static Pgno ptrmapPageno(BtShared *pBt, Pgno pgno){$/;"	f	file:
ptrmapPut	.\src\btree.c	/^static void ptrmapPut(BtShared *pBt, Pgno key, u8 eType, Pgno parent, int *pRC){$/;"	f	file:
ptrmapPut	.\src\btree.c	979;"	d	file:
ptrmapPutOvflPtr	.\src\btree.c	/^static void ptrmapPutOvflPtr(MemPage *pPage, u8 *pCell, int *pRC){$/;"	f	file:
ptrmapPutOvflPtr	.\src\btree.c	981;"	d	file:
ptrmap_coverage_report	.\tool\showdb.c	/^static void ptrmap_coverage_report(const char *zDbName){$/;"	f	file:
pushDownWhereTerms	.\src\select.c	/^static int pushDownWhereTerms($/;"	f	file:
pushOntoSorter	.\src\select.c	/^static void pushOntoSorter($/;"	f	file:
put2byte	.\src\btreeInt.h	692;"	d
put32bits	.\src\pager.c	1069;"	d	file:
put32bits	.\src\test_osinst.c	/^static void put32bits(unsigned char *p, unsigned int v){$/;"	f	file:
put4byte	.\src\btreeInt.h	694;"	d
putInt	.\tool\sqldiff.c	/^static void putInt(unsigned int v, char **pz){$/;"	f	file:
putValue	.\tool\sqldiff.c	/^static void putValue(FILE *out, sqlite3_value *pVal){$/;"	f	file:
putVarint	.\ext\fts1\fts1.c	/^static int putVarint(char *p, sqlite_int64 v){$/;"	f	file:
putVarint	.\ext\fts1\fulltext.c	/^static int putVarint(char *p, sqlite_int64 v){$/;"	f	file:
putVarint	.\ext\fts2\fts2.c	/^static int putVarint(char *p, sqlite_int64 v){$/;"	f	file:
putVarint	.\src\sqliteInt.h	3585;"	d
putVarint	.\tool\varint.c	/^static int putVarint(unsigned char *p, u64 v){$/;"	f	file:
putVarint32	.\src\sqliteInt.h	3581;"	d
putVarint64	.\src\util.c	/^static int SQLITE_NOINLINE putVarint64(unsigned char *p, u64 v){$/;"	f	file:
put_item	.\tool\mkopts.tcl	/^proc put_item x {$/;"	p
puts	.\test\tester.tcl	/^proc puts {args} { uplevel puts_override $args }$/;"	p
putsVarint	.\tool\sqldiff.c	/^static void putsVarint(FILE *out, sqlite3_uint64 v){$/;"	f	file:
puts_override	.\test\tester.tcl	/^proc puts_override {args} {$/;"	p
pzErrMsg	.\src\sqliteInt.h	/^  char **pzErrMsg;    \/* Error message stored here *\/$/;"	m	struct:__anon21
pzErrmsg	.\ext\fts5\fts5Int.h	/^  char **pzErrmsg;$/;"	m	struct:Fts5Config
pzNeededCollation	.\src\test1.c	/^static char *pzNeededCollation = zNeededCollation;$/;"	v	file:
q	.\ext\fts1\fts1.c	/^  Query q;                         \/* Parsed query string *\/$/;"	m	struct:fulltext_cursor	file:
q	.\ext\fts2\fts2.c	/^  Query q;                         \/* Parsed query string *\/$/;"	m	struct:fulltext_cursor	file:
queryAdd	.\ext\fts1\fts1.c	/^static void queryAdd(Query *q, const char *pTerm, int nTerm){$/;"	f	file:
queryAdd	.\ext\fts2\fts2.c	/^static void queryAdd(Query *q, const char *pTerm, int nTerm){$/;"	f	file:
queryClear	.\ext\fts1\fts1.c	/^static void queryClear(Query *q){$/;"	f	file:
queryClear	.\ext\fts2\fts2.c	/^static void queryClear(Query *q){$/;"	f	file:
queryFts2Tokenizer	.\ext\fts2\fts2_tokenizer.c	/^int queryFts2Tokenizer($/;"	f	file:
querySharedCacheTableLock	.\src\btree.c	/^static int querySharedCacheTableLock(Btree *p, Pgno iTab, u8 eLock){$/;"	f	file:
querySharedCacheTableLock	.\src\btree.c	107;"	d	file:
queryTestTokenizer	.\ext\fts3\fts3_expr.c	/^static int queryTestTokenizer($/;"	f	file:
queryTokenizer	.\ext\fts3\fts3_tokenizer.c	/^int queryTokenizer($/;"	f	file:
query_add	.\ext\fts1\fulltext.c	/^static void query_add(Query *q, int is_phrase, const char *zTerm){$/;"	f	file:
query_free	.\ext\fts1\fulltext.c	/^static void query_free(Query *q){$/;"	f	file:
query_merge	.\ext\fts1\fulltext.c	/^static int query_merge(fulltext_vtab *v, sqlite3_stmt **pSelect,$/;"	f	file:
queueMutex	.\src\test_server.c	/^  pthread_mutex_t queueMutex;   \/* Hold this mutex to access the msg queue *\/$/;"	m	struct:ServerState	file:
queuePull	.\ext\misc\closure.c	/^static closure_avl *queuePull(closure_queue *pQueue){$/;"	f	file:
queuePush	.\ext\misc\closure.c	/^static void queuePush(closure_queue *pQueue, closure_avl *pNode){$/;"	f	file:
quotaCheckReservedLock	.\src\test_quota.c	/^static int quotaCheckReservedLock(sqlite3_file *pConn, int *pResOut){$/;"	f	file:
quotaClose	.\src\test_quota.c	/^static int quotaClose(sqlite3_file *pConn){$/;"	f	file:
quotaConn	.\src\test_quota.c	/^struct quotaConn {$/;"	s	file:
quotaConn	.\src\test_quota.c	/^typedef struct quotaConn quotaConn;$/;"	t	typeref:struct:quotaConn	file:
quotaDelete	.\src\test_quota.c	/^static int quotaDelete($/;"	f	file:
quotaDeviceCharacteristics	.\src\test_quota.c	/^static int quotaDeviceCharacteristics(sqlite3_file *pConn){$/;"	f	file:
quotaEnter	.\src\test_quota.c	/^static void quotaEnter(void){ sqlite3_mutex_enter(gQuota.pMutex); }$/;"	f	file:
quotaFile	.\src\test_quota.c	/^struct quotaFile {$/;"	s	file:
quotaFile	.\src\test_quota.c	/^typedef struct quotaFile quotaFile;$/;"	t	typeref:struct:quotaFile	file:
quotaFileControl	.\src\test_quota.c	/^static int quotaFileControl(sqlite3_file *pConn, int op, void *pArg){$/;"	f	file:
quotaFileSize	.\src\test_quota.c	/^static int quotaFileSize(sqlite3_file *pConn, sqlite3_int64 *pSize){$/;"	f	file:
quotaFindFile	.\src\test_quota.c	/^static quotaFile *quotaFindFile($/;"	f	file:
quotaGroup	.\src\test_quota.c	/^struct quotaGroup {$/;"	s	file:
quotaGroup	.\src\test_quota.c	/^typedef struct quotaGroup quotaGroup;$/;"	t	typeref:struct:quotaGroup	file:
quotaGroupDeref	.\src\test_quota.c	/^static void quotaGroupDeref(quotaGroup *pGroup){$/;"	f	file:
quotaGroupFind	.\src\test_quota.c	/^static quotaGroup *quotaGroupFind(const char *zFilename){$/;"	f	file:
quotaGroupOpenFileCount	.\src\test_quota.c	/^static int quotaGroupOpenFileCount(quotaGroup *pGroup){$/;"	f	file:
quotaLeave	.\src\test_quota.c	/^static void quotaLeave(void){ sqlite3_mutex_leave(gQuota.pMutex); }$/;"	f	file:
quotaLock	.\src\test_quota.c	/^static int quotaLock(sqlite3_file *pConn, int lock){$/;"	f	file:
quotaOpen	.\src\test_quota.c	/^static int quotaOpen($/;"	f	file:
quotaRead	.\src\test_quota.c	/^static int quotaRead($/;"	f	file:
quotaRemoveAllFiles	.\src\test_quota.c	/^static void quotaRemoveAllFiles(quotaGroup *pGroup){$/;"	f	file:
quotaRemoveFile	.\src\test_quota.c	/^static void quotaRemoveFile(quotaFile *pFile){$/;"	f	file:
quotaSectorSize	.\src\test_quota.c	/^static int quotaSectorSize(sqlite3_file *pConn){$/;"	f	file:
quotaShmBarrier	.\src\test_quota.c	/^static void quotaShmBarrier(sqlite3_file *pConn){$/;"	f	file:
quotaShmLock	.\src\test_quota.c	/^static int quotaShmLock($/;"	f	file:
quotaShmMap	.\src\test_quota.c	/^static int quotaShmMap($/;"	f	file:
quotaShmUnmap	.\src\test_quota.c	/^static int quotaShmUnmap(sqlite3_file *pConn, int deleteFlag){$/;"	f	file:
quotaStrglob	.\src\test_quota.c	/^static int quotaStrglob(const char *zGlob, const char *z){$/;"	f	file:
quotaSubOpen	.\src\test_quota.c	/^static sqlite3_file *quotaSubOpen(sqlite3_file *pConn){$/;"	f	file:
quotaSync	.\src\test_quota.c	/^static int quotaSync(sqlite3_file *pConn, int flags){$/;"	f	file:
quotaTruncate	.\src\test_quota.c	/^static int quotaTruncate(sqlite3_file *pConn, sqlite3_int64 size){$/;"	f	file:
quotaUnlock	.\src\test_quota.c	/^static int quotaUnlock(sqlite3_file *pConn, int lock){$/;"	f	file:
quotaWrite	.\src\test_quota.c	/^static int quotaWrite($/;"	f	file:
quota_FILE	.\src\test_quota.c	/^struct quota_FILE {$/;"	s	file:
quota_FILE	.\src\test_quota.h	/^typedef struct quota_FILE quota_FILE;$/;"	t	typeref:struct:quota_FILE
quota_mbcs_free	.\src\test_quota.c	/^static void quota_mbcs_free(char *zOld){$/;"	f	file:
quota_utf8_to_mbcs	.\src\test_quota.c	/^static char *quota_utf8_to_mbcs(const char *zUtf8){$/;"	f	file:
quote	.\tool\spaceanal.tcl	/^proc quote {txt} {$/;"	p
quoteFunc	.\src\func.c	/^static void quoteFunc(sqlite3_context *context, int argc, sqlite3_value **argv){$/;"	f	file:
r	.\src\vdbeInt.h	/^    double r;           \/* Real value used when MEM_Real is set in flags *\/$/;"	m	union:Mem::MemValue
r1	.\src\sqliteInt.h	/^  int r1;             \/* Value to return if (lhs > rhs) *\/$/;"	m	struct:UnpackedRecord
r2	.\src\sqliteInt.h	/^  int r2;             \/* Value to return if (rhs < lhs) *\/$/;"	m	struct:UnpackedRecord
rBaseCost	.\ext\misc\fuzzer.c	/^  fuzzer_cost rBaseCost;     \/* Base cost of getting to zBasis *\/$/;"	m	struct:fuzzer_stem	file:
rCost	.\ext\misc\amatch.c	/^  amatch_cost rCost;       \/* Cost of this transformation *\/$/;"	m	struct:amatch_rule	file:
rCost	.\ext\misc\amatch.c	/^  amatch_cost rCost;    \/* Cost of the match so far *\/$/;"	m	struct:amatch_word	file:
rCost	.\ext\misc\fuzzer.c	/^  fuzzer_cost rCost;          \/* Cost of this transformation *\/$/;"	m	struct:fuzzer_rule	file:
rCost	.\src\whereInt.h	/^  LogEst rCost;         \/* Total cost of this path *\/$/;"	m	struct:WherePath
rCostX	.\ext\misc\fuzzer.c	/^  fuzzer_cost rCostX;        \/* Precomputed rBaseCost + pRule->rCost *\/$/;"	m	struct:fuzzer_stem	file:
rDel	.\ext\misc\amatch.c	/^  amatch_cost rDel;          \/* Generic deletion cost  ? -> '' *\/$/;"	m	struct:amatch_vtab	file:
rIns	.\ext\misc\amatch.c	/^  amatch_cost rIns;          \/* Generic insertion cost  '' -> ? *\/$/;"	m	struct:amatch_vtab	file:
rLimit	.\ext\misc\amatch.c	/^  amatch_cost rLimit;        \/* Maximum cost of any term *\/$/;"	m	struct:amatch_cursor	file:
rLimit	.\ext\misc\fuzzer.c	/^  fuzzer_cost rLimit;        \/* Maximum cost of any term *\/$/;"	m	struct:fuzzer_cursor	file:
rParentScore	.\ext\rtree\sqlite3rtree.h	/^  sqlite3_rtree_dbl rParentScore;   \/* Score of parent node *\/$/;"	m	struct:sqlite3_rtree_query_info
rPct	.\ext\misc\percentile.c	/^  double rPct;         \/* 1.0 more than the value for P *\/$/;"	m	struct:Percentile	file:
rRun	.\src\whereInt.h	/^  LogEst rRun;          \/* Cost of running each loop *\/$/;"	m	struct:WhereLoop
rRun	.\src\whereInt.h	/^  LogEst rRun;        \/* Cost of running this subquery *\/$/;"	m	struct:WhereOrCost
rScore	.\ext\rtree\rtree.c	/^  RtreeDValue rScore;    \/* The score for this node.  Smallest goes first. *\/$/;"	m	struct:RtreeSearchPoint	file:
rScore	.\ext\rtree\sqlite3rtree.h	/^  sqlite3_rtree_dbl rScore;         \/* OUT: Write the score here *\/$/;"	m	struct:sqlite3_rtree_query_info
rSetup	.\src\whereInt.h	/^  LogEst rSetup;        \/* One-time setup cost (ex: create transient index) *\/$/;"	m	struct:WhereLoop
rSub	.\ext\misc\amatch.c	/^  amatch_cost rSub;          \/* Generic substitution cost ? -> ? *\/$/;"	m	struct:amatch_vtab	file:
rSum	.\src\func.c	/^  double rSum;      \/* Floating point sum *\/$/;"	m	struct:SumCtx	file:
rUnsorted	.\src\whereInt.h	/^  LogEst rUnsorted;     \/* Total cost of this path ignoring sorting costs *\/$/;"	m	struct:WherePath
rValue	.\ext\rtree\rtree.c	/^    RtreeDValue rValue;             \/* Constraint value. *\/$/;"	m	union:RtreeConstraint::__anon6	file:
radius	.\src\test_rtree.c	/^  double radius;$/;"	m	struct:Circle	file:
randStr	.\src\test_func.c	/^static void randStr(sqlite3_context *context, int argc, sqlite3_value **argv){$/;"	f	file:
randomBlob	.\src\func.c	/^static void randomBlob($/;"	f	file:
randomFill	.\src\mem2.c	/^static void randomFill(char *pBuf, int nByte){$/;"	f	file:
randomFunc	.\src\func.c	/^static void randomFunc($/;"	f	file:
randomFunc	.\test\speedtest1.c	/^static void randomFunc($/;"	f	file:
randomness	.\src\sqlite3ext.h	/^  void (*randomness)(int,void*);$/;"	m	struct:sqlite3_api_routines
randomnessPid	.\src\os_unix.c	/^static pid_t randomnessPid = 0;$/;"	v	file:
rbuAllocateIterArrays	.\ext\rbu\sqlite3rbu.c	/^static void rbuAllocateIterArrays(sqlite3rbu *p, RbuObjIter *pIter, int nCol){$/;"	f	file:
rbuBadControlError	.\ext\rbu\sqlite3rbu.c	/^static void rbuBadControlError(sqlite3rbu *p){$/;"	f	file:
rbuCaptureDbWrite	.\ext\rbu\sqlite3rbu.c	/^static int rbuCaptureDbWrite(sqlite3rbu *pRbu, i64 iOff){$/;"	f	file:
rbuCaptureWalRead	.\ext\rbu\sqlite3rbu.c	/^static int rbuCaptureWalRead(sqlite3rbu *pRbu, i64 iOff, int iAmt){$/;"	f	file:
rbuCheckpointFrame	.\ext\rbu\sqlite3rbu.c	/^static void rbuCheckpointFrame(sqlite3rbu *p, RbuFrame *pFrame){$/;"	f	file:
rbuCreateImposterTable	.\ext\rbu\sqlite3rbu.c	/^static void rbuCreateImposterTable(sqlite3rbu *p, RbuObjIter *pIter){$/;"	f	file:
rbuCreateImposterTable2	.\ext\rbu\sqlite3rbu.c	/^static void rbuCreateImposterTable2(sqlite3rbu *p, RbuObjIter *pIter){$/;"	f	file:
rbuCreateVfs	.\ext\rbu\sqlite3rbu.c	/^static void rbuCreateVfs(sqlite3rbu *p){$/;"	f	file:
rbuDeleteOalFile	.\ext\rbu\sqlite3rbu.c	/^static void rbuDeleteOalFile(sqlite3rbu *p){$/;"	f	file:
rbuDeleteVfs	.\ext\rbu\sqlite3rbu.c	/^static void rbuDeleteVfs(sqlite3rbu *p){$/;"	f	file:
rbuDeltaApply	.\ext\rbu\sqlite3rbu.c	/^static int rbuDeltaApply($/;"	f	file:
rbuDeltaChecksum	.\ext\rbu\sqlite3rbu.c	/^static unsigned int rbuDeltaChecksum(const char *zIn, size_t N){$/;"	f	file:
rbuDeltaCreate	.\tool\sqldiff.c	/^static int rbuDeltaCreate($/;"	f	file:
rbuDeltaGetInt	.\ext\rbu\sqlite3rbu.c	/^static unsigned int rbuDeltaGetInt(const char **pz, int *pLen){$/;"	f	file:
rbuDeltaOutputSize	.\ext\rbu\sqlite3rbu.c	/^static int rbuDeltaOutputSize(const char *zDelta, int lenDelta){$/;"	f	file:
rbuEditErrmsg	.\ext\rbu\sqlite3rbu.c	/^static void rbuEditErrmsg(sqlite3rbu *p){$/;"	f	file:
rbuFileSuffix3	.\ext\rbu\sqlite3rbu.c	/^static void rbuFileSuffix3(const char *zBase, char *z){$/;"	f	file:
rbuFinalize	.\ext\rbu\sqlite3rbu.c	/^static void rbuFinalize(sqlite3rbu *p, sqlite3_stmt *pStmt){$/;"	f	file:
rbuFindMaindb	.\ext\rbu\sqlite3rbu.c	/^static rbu_file *rbuFindMaindb(rbu_vfs *pRbuVfs, const char *zWal){$/;"	f	file:
rbuFossilDeltaFunc	.\ext\rbu\sqlite3rbu.c	/^static void rbuFossilDeltaFunc($/;"	f	file:
rbuFreeState	.\ext\rbu\sqlite3rbu.c	/^static void rbuFreeState(RbuState *p){$/;"	f	file:
rbuGetU32	.\ext\rbu\sqlite3rbu.c	/^static u32 rbuGetU32(u8 *aBuf){$/;"	f	file:
rbuGetUpdateStmt	.\ext\rbu\sqlite3rbu.c	/^static int rbuGetUpdateStmt($/;"	f	file:
rbuIncrSchemaCookie	.\ext\rbu\sqlite3rbu.c	/^static void rbuIncrSchemaCookie(sqlite3rbu *p){$/;"	f	file:
rbuLoadState	.\ext\rbu\sqlite3rbu.c	/^static RbuState *rbuLoadState(sqlite3rbu *p){$/;"	f	file:
rbuLockDatabase	.\ext\rbu\sqlite3rbu.c	/^static void rbuLockDatabase(sqlite3rbu *p){$/;"	f	file:
rbuMPrintf	.\ext\rbu\sqlite3rbu.c	/^static char *rbuMPrintf(sqlite3rbu *p, const char *zFmt, ...){$/;"	f	file:
rbuMPrintfExec	.\ext\rbu\sqlite3rbu.c	/^static int rbuMPrintfExec(sqlite3rbu *p, sqlite3 *db, const char *zFmt, ...){$/;"	f	file:
rbuMalloc	.\ext\rbu\sqlite3rbu.c	/^static void *rbuMalloc(sqlite3rbu *p, int nByte){$/;"	f	file:
rbuMoveOalFile	.\ext\rbu\sqlite3rbu.c	/^static void rbuMoveOalFile(sqlite3rbu *p){$/;"	f	file:
rbuObjIterCacheIndexedCols	.\ext\rbu\sqlite3rbu.c	/^static void rbuObjIterCacheIndexedCols(sqlite3rbu *p, RbuObjIter *pIter){$/;"	f	file:
rbuObjIterCacheTableInfo	.\ext\rbu\sqlite3rbu.c	/^static int rbuObjIterCacheTableInfo(sqlite3rbu *p, RbuObjIter *pIter){$/;"	f	file:
rbuObjIterClearStatements	.\ext\rbu\sqlite3rbu.c	/^static void rbuObjIterClearStatements(RbuObjIter *pIter){$/;"	f	file:
rbuObjIterFinalize	.\ext\rbu\sqlite3rbu.c	/^static void rbuObjIterFinalize(RbuObjIter *pIter){$/;"	f	file:
rbuObjIterFirst	.\ext\rbu\sqlite3rbu.c	/^static int rbuObjIterFirst(sqlite3rbu *p, RbuObjIter *pIter){$/;"	f	file:
rbuObjIterFreeCols	.\ext\rbu\sqlite3rbu.c	/^static void rbuObjIterFreeCols(RbuObjIter *pIter){$/;"	f	file:
rbuObjIterGetBindlist	.\ext\rbu\sqlite3rbu.c	/^static char *rbuObjIterGetBindlist(sqlite3rbu *p, int nBind){$/;"	f	file:
rbuObjIterGetCollist	.\ext\rbu\sqlite3rbu.c	/^static char *rbuObjIterGetCollist($/;"	f	file:
rbuObjIterGetIndexCols	.\ext\rbu\sqlite3rbu.c	/^static char *rbuObjIterGetIndexCols($/;"	f	file:
rbuObjIterGetOldlist	.\ext\rbu\sqlite3rbu.c	/^static char *rbuObjIterGetOldlist($/;"	f	file:
rbuObjIterGetSetlist	.\ext\rbu\sqlite3rbu.c	/^static char *rbuObjIterGetSetlist($/;"	f	file:
rbuObjIterGetWhere	.\ext\rbu\sqlite3rbu.c	/^static char *rbuObjIterGetWhere($/;"	f	file:
rbuObjIterNext	.\ext\rbu\sqlite3rbu.c	/^static int rbuObjIterNext(sqlite3rbu *p, RbuObjIter *pIter){$/;"	f	file:
rbuObjIterPrepareAll	.\ext\rbu\sqlite3rbu.c	/^static int rbuObjIterPrepareAll($/;"	f	file:
rbuObjIterPrepareTmpInsert	.\ext\rbu\sqlite3rbu.c	/^static void rbuObjIterPrepareTmpInsert($/;"	f	file:
rbuOpenDatabase	.\ext\rbu\sqlite3rbu.c	/^static void rbuOpenDatabase(sqlite3rbu *p){$/;"	f	file:
rbuOpenDbhandle	.\ext\rbu\sqlite3rbu.c	/^static sqlite3 *rbuOpenDbhandle(sqlite3rbu *p, const char *zName){$/;"	f	file:
rbuSaveState	.\ext\rbu\sqlite3rbu.c	/^static void rbuSaveState(sqlite3rbu *p, int eStage){$/;"	f	file:
rbuSetupCheckpoint	.\ext\rbu\sqlite3rbu.c	/^static void rbuSetupCheckpoint(sqlite3rbu *p, RbuState *pState){$/;"	f	file:
rbuSetupOal	.\ext\rbu\sqlite3rbu.c	/^static void rbuSetupOal(sqlite3rbu *p, RbuState *pState){$/;"	f	file:
rbuShmChecksum	.\ext\rbu\sqlite3rbu.c	/^static i64 rbuShmChecksum(sqlite3rbu *p){$/;"	f	file:
rbuStep	.\ext\rbu\sqlite3rbu.c	/^static int rbuStep(sqlite3rbu *p){$/;"	f	file:
rbuStepType	.\ext\rbu\sqlite3rbu.c	/^static int rbuStepType(sqlite3rbu *p, const char **pzMask){$/;"	f	file:
rbuStrCompare	.\ext\rbu\sqlite3rbu.c	/^static int rbuStrCompare(const char *z1, const char *z2){$/;"	f	file:
rbuStrndup	.\ext\rbu\sqlite3rbu.c	/^static char *rbuStrndup(const char *zStr, int *pRc){$/;"	f	file:
rbuTableType	.\ext\rbu\sqlite3rbu.c	/^static void rbuTableType($/;"	f	file:
rbuTargetNameFunc	.\ext\rbu\sqlite3rbu.c	/^static void rbuTargetNameFunc($/;"	f	file:
rbuTmpInsertFunc	.\ext\rbu\sqlite3rbu.c	/^static void rbuTmpInsertFunc($/;"	f	file:
rbuUnlockShm	.\ext\rbu\sqlite3rbu.c	/^static void rbuUnlockShm(rbu_file *p){$/;"	f	file:
rbuVfsAccess	.\ext\rbu\sqlite3rbu.c	/^static int rbuVfsAccess($/;"	f	file:
rbuVfsCheckReservedLock	.\ext\rbu\sqlite3rbu.c	/^static int rbuVfsCheckReservedLock(sqlite3_file *pFile, int *pResOut){$/;"	f	file:
rbuVfsClose	.\ext\rbu\sqlite3rbu.c	/^static int rbuVfsClose(sqlite3_file *pFile){$/;"	f	file:
rbuVfsCurrentTime	.\ext\rbu\sqlite3rbu.c	/^static int rbuVfsCurrentTime(sqlite3_vfs *pVfs, double *pTimeOut){$/;"	f	file:
rbuVfsDelete	.\ext\rbu\sqlite3rbu.c	/^static int rbuVfsDelete(sqlite3_vfs *pVfs, const char *zPath, int dirSync){$/;"	f	file:
rbuVfsDeviceCharacteristics	.\ext\rbu\sqlite3rbu.c	/^static int rbuVfsDeviceCharacteristics(sqlite3_file *pFile){$/;"	f	file:
rbuVfsDlClose	.\ext\rbu\sqlite3rbu.c	/^static void rbuVfsDlClose(sqlite3_vfs *pVfs, void *pHandle){$/;"	f	file:
rbuVfsDlError	.\ext\rbu\sqlite3rbu.c	/^static void rbuVfsDlError(sqlite3_vfs *pVfs, int nByte, char *zErrMsg){$/;"	f	file:
rbuVfsDlOpen	.\ext\rbu\sqlite3rbu.c	/^static void *rbuVfsDlOpen(sqlite3_vfs *pVfs, const char *zPath){$/;"	f	file:
rbuVfsDlSym	.\ext\rbu\sqlite3rbu.c	/^static void (*rbuVfsDlSym($/;"	f	file:
rbuVfsFileControl	.\ext\rbu\sqlite3rbu.c	/^static int rbuVfsFileControl(sqlite3_file *pFile, int op, void *pArg){$/;"	f	file:
rbuVfsFileSize	.\ext\rbu\sqlite3rbu.c	/^static int rbuVfsFileSize(sqlite3_file *pFile, sqlite_int64 *pSize){$/;"	f	file:
rbuVfsFullPathname	.\ext\rbu\sqlite3rbu.c	/^static int rbuVfsFullPathname($/;"	f	file:
rbuVfsGetLastError	.\ext\rbu\sqlite3rbu.c	/^static int rbuVfsGetLastError(sqlite3_vfs *pVfs, int a, char *b){$/;"	f	file:
rbuVfsLock	.\ext\rbu\sqlite3rbu.c	/^static int rbuVfsLock(sqlite3_file *pFile, int eLock){$/;"	f	file:
rbuVfsOpen	.\ext\rbu\sqlite3rbu.c	/^static int rbuVfsOpen($/;"	f	file:
rbuVfsRandomness	.\ext\rbu\sqlite3rbu.c	/^static int rbuVfsRandomness(sqlite3_vfs *pVfs, int nByte, char *zBufOut){$/;"	f	file:
rbuVfsRead	.\ext\rbu\sqlite3rbu.c	/^static int rbuVfsRead($/;"	f	file:
rbuVfsSectorSize	.\ext\rbu\sqlite3rbu.c	/^static int rbuVfsSectorSize(sqlite3_file *pFile){$/;"	f	file:
rbuVfsShmBarrier	.\ext\rbu\sqlite3rbu.c	/^static void rbuVfsShmBarrier(sqlite3_file *pFile){$/;"	f	file:
rbuVfsShmLock	.\ext\rbu\sqlite3rbu.c	/^static int rbuVfsShmLock(sqlite3_file *pFile, int ofst, int n, int flags){$/;"	f	file:
rbuVfsShmMap	.\ext\rbu\sqlite3rbu.c	/^static int rbuVfsShmMap($/;"	f	file:
rbuVfsShmUnmap	.\ext\rbu\sqlite3rbu.c	/^static int rbuVfsShmUnmap(sqlite3_file *pFile, int delFlag){$/;"	f	file:
rbuVfsSleep	.\ext\rbu\sqlite3rbu.c	/^static int rbuVfsSleep(sqlite3_vfs *pVfs, int nMicro){$/;"	f	file:
rbuVfsSync	.\ext\rbu\sqlite3rbu.c	/^static int rbuVfsSync(sqlite3_file *pFile, int flags){$/;"	f	file:
rbuVfsTruncate	.\ext\rbu\sqlite3rbu.c	/^static int rbuVfsTruncate(sqlite3_file *pFile, sqlite_int64 size){$/;"	f	file:
rbuVfsUnlock	.\ext\rbu\sqlite3rbu.c	/^static int rbuVfsUnlock(sqlite3_file *pFile, int eLock){$/;"	f	file:
rbuVfsWrite	.\ext\rbu\sqlite3rbu.c	/^static int rbuVfsWrite($/;"	f	file:
rbuWinUtf8ToUnicode	.\ext\rbu\sqlite3rbu.c	/^static LPWSTR rbuWinUtf8ToUnicode(const char *zFilename){$/;"	f	file:
rbuWithoutRowidPK	.\ext\rbu\sqlite3rbu.c	/^static char *rbuWithoutRowidPK(sqlite3rbu *p, RbuObjIter *pIter){$/;"	f	file:
rbu_file	.\ext\rbu\sqlite3rbu.c	/^struct rbu_file {$/;"	s	file:
rbu_file	.\ext\rbu\sqlite3rbu.c	/^typedef struct rbu_file rbu_file;$/;"	t	typeref:struct:rbu_file	file:
rbu_vfs	.\ext\rbu\sqlite3rbu.c	/^struct rbu_vfs {$/;"	s	file:
rbu_vfs	.\ext\rbu\sqlite3rbu.c	/^typedef struct rbu_vfs rbu_vfs;$/;"	t	typeref:struct:rbu_vfs	file:
rbudiff_one_table	.\tool\sqldiff.c	/^static void rbudiff_one_table(const char *zTab, FILE *out){$/;"	f	file:
rc	.\ext\fts5\fts5_expr.c	/^  int rc;$/;"	m	struct:Fts5Parse	file:
rc	.\ext\fts5\fts5_expr.c	/^  int rc;$/;"	m	struct:TokenCtx	file:
rc	.\ext\fts5\fts5_index.c	/^  int rc;                         \/* Current error code *\/$/;"	m	struct:Fts5Index	file:
rc	.\ext\misc\spellfix.c	/^  int rc;                          \/* Error code *\/$/;"	m	struct:MatchQuery	file:
rc	.\ext\rbu\sqlite3rbu.c	/^  int rc;                         \/* Value returned by last rbu_step() call *\/$/;"	m	struct:sqlite3rbu	file:
rc	.\src\backup.c	/^  int rc;                  \/* Backup process error code *\/$/;"	m	struct:sqlite3_backup	file:
rc	.\src\sqliteInt.h	/^  int rc;              \/* Return code from execution *\/$/;"	m	struct:Parse
rc	.\src\sqliteInt.h	/^  int rc;             \/* Result code stored here *\/$/;"	m	struct:__anon21
rc	.\src\table.c	/^  int rc;            \/* Return code from sqlite3_exec() *\/$/;"	m	struct:TabResult	file:
rc	.\src\tclsqlite.c	/^  int rc;                    \/* Return code of most recent sqlite3_exec() *\/$/;"	m	struct:SqliteDb	file:
rc	.\src\test4.c	/^  int rc;               \/* operation return code *\/$/;"	m	struct:Thread	file:
rc	.\src\test7.c	/^  int rc;                  \/* operation return code *\/$/;"	m	struct:Thread	file:
rc	.\src\vdbeInt.h	/^  int rc;                 \/* Value to return *\/$/;"	m	struct:Vdbe
rc	.\test\threadtest3.c	/^  int rc;$/;"	m	struct:Error	file:
rcApp	.\src\vdbeInt.h	/^  int rcApp;              \/* errcode set by sqlite3_result_error_code() *\/$/;"	m	struct:Vdbe
rd_load_unicodedata_text	.\ext\fts3\unicode\parseunicode.tcl	/^proc rd_load_unicodedata_text {zName} {$/;"	p
rePeek	.\ext\misc\regexp.c	/^static unsigned char rePeek(ReCompiled *p){$/;"	f	file:
re_add_state	.\ext\misc\regexp.c	/^static void re_add_state(ReStateSet *pSet, int newState){$/;"	f	file:
re_append	.\ext\misc\regexp.c	/^static int re_append(ReCompiled *p, int op, int arg){$/;"	f	file:
re_compile	.\ext\misc\regexp.c	/^const char *re_compile(ReCompiled **ppRe, const char *zIn, int noCase){$/;"	f
re_compile	.\ext\misc\regexp.c	70;"	d	file:
re_copy	.\ext\misc\regexp.c	/^static void re_copy(ReCompiled *p, int iStart, int N){$/;"	f	file:
re_digit_char	.\ext\misc\regexp.c	/^static int re_digit_char(int c){$/;"	f	file:
re_esc_char	.\ext\misc\regexp.c	/^static unsigned re_esc_char(ReCompiled *p){$/;"	f	file:
re_free	.\ext\misc\regexp.c	/^void re_free(ReCompiled *pRe){$/;"	f
re_free	.\ext\misc\regexp.c	71;"	d	file:
re_hex	.\ext\misc\regexp.c	/^static int re_hex(int c, int *pV){$/;"	f	file:
re_insert	.\ext\misc\regexp.c	/^static int re_insert(ReCompiled *p, int iBefore, int op, int arg){$/;"	f	file:
re_match	.\ext\misc\regexp.c	/^static int re_match(ReCompiled *pRe, const unsigned char *zIn, int nIn){$/;"	f	file:
re_match	.\ext\misc\regexp.c	69;"	d	file:
re_next_char	.\ext\misc\regexp.c	/^static unsigned re_next_char(ReInput *p){$/;"	f	file:
re_next_char_nocase	.\ext\misc\regexp.c	/^static unsigned re_next_char_nocase(ReInput *p){$/;"	f	file:
re_resize	.\ext\misc\regexp.c	/^static int re_resize(ReCompiled *p, int N){$/;"	f	file:
re_space_char	.\ext\misc\regexp.c	/^static int re_space_char(int c){$/;"	f	file:
re_sql_func	.\ext\misc\regexp.c	/^static void re_sql_func($/;"	f	file:
re_subcompile_re	.\ext\misc\regexp.c	/^static const char *re_subcompile_re(ReCompiled *p){$/;"	f	file:
re_subcompile_string	.\ext\misc\regexp.c	/^static const char *re_subcompile_string(ReCompiled *p){$/;"	f	file:
re_word_char	.\ext\misc\regexp.c	/^static int re_word_char(int c){$/;"	f	file:
read32bits	.\src\pager.c	/^static int read32bits(sqlite3_file *fd, i64 offset, u32 *pRes){$/;"	f	file:
readCoord	.\ext\rtree\rtree.c	/^static void readCoord(u8 *p, RtreeCoord *pCoord){$/;"	f	file:
readDbPage	.\src\pager.c	/^static int readDbPage(PgHdr *pPg, u32 iFrame){$/;"	f	file:
readDocid	.\ext\fts1\fts1.c	/^static sqlite_int64 readDocid(DocListReader *pReader){$/;"	f	file:
readDocid	.\ext\fts1\fulltext.c	/^static sqlite_int64 readDocid(DocListReader *pReader){$/;"	f	file:
readFile	.\mptest\mptest.c	/^static char *readFile(const char *zFilename){$/;"	f	file:
readFile	.\tool\mkvsix.tcl	/^proc readFile { fileName } {$/;"	p
readInt16	.\ext\rtree\rtree.c	/^static int readInt16(u8 *p){$/;"	f	file:
readInt64	.\ext\rtree\rtree.c	/^static i64 readInt64(u8 *p){$/;"	f	file:
readJournalFile	.\src\test_journal.c	/^static int readJournalFile(jt_file *p, jt_file *pMain){$/;"	f	file:
readJournalHdr	.\src\pager.c	/^static int readJournalHdr($/;"	f	file:
readLock	.\src\wal.c	/^  i16 readLock;              \/* Which read lock is being held.  -1 for none *\/$/;"	m	struct:Wal	file:
readMasterJournal	.\src\pager.c	/^static int readMasterJournal(sqlite3_file *pJrnl, char *zMaster, u32 nMaster){$/;"	f	file:
readOnly	.\src\pager.c	/^  u8 readOnly;                \/* True for a read-only database *\/$/;"	m	struct:Pager	file:
readOnly	.\src\vdbeInt.h	/^  bft readOnly:1;         \/* True for statements that do not write *\/$/;"	m	struct:Vdbe
readOnly	.\src\wal.c	/^  u8 readOnly;               \/* WAL_RDWR, WAL_RDONLY, or WAL_SHM_RDONLY *\/$/;"	m	struct:Wal	file:
readPosition	.\ext\fts1\fts1.c	/^static int readPosition(DocListReader *pReader, int *iColumn){$/;"	f	file:
readPosition	.\ext\fts1\fulltext.c	/^static int readPosition(DocListReader *pReader){$/;"	f	file:
readScriptFile	.\tool\speedtest8inst1.c	/^static char *readScriptFile(const char *zFile, int *pnScript){$/;"	f	file:
readUtf8	.\ext\misc\nextchar.c	/^static int readUtf8(const unsigned char *z, unsigned *pOut){$/;"	f	file:
read_content	.\tool\showjournal.c	/^static unsigned char *read_content(int N, int iOfst){$/;"	f	file:
read_fts3varint	.\src\test_hexio.c	/^static int read_fts3varint($/;"	f	file:
reader	.\ext\fts2\fts2.c	/^  DLReader reader;                 \/* Result reader if result not empty *\/$/;"	m	struct:fulltext_cursor	file:
reader	.\ext\fts2\fts2.c	/^  LeavesReader reader;$/;"	m	struct:OptLeavesReader	file:
reader	.\ext\fts5\fts5_expr.c	/^  Fts5LookaheadReader reader;     \/* Input iterator *\/$/;"	m	struct:Fts5NearTrimmer	file:
readerAtEnd	.\ext\fts1\fulltext.c	/^static int readerAtEnd(DocListReader *pReader){$/;"	f	file:
readerInit	.\ext\fts1\fts1.c	/^static void readerInit(DocListReader *r, DocList *pDoclist){$/;"	f	file:
readerInit	.\ext\fts1\fulltext.c	/^static void readerInit(DocListReader *r, DocList *pDoclist){$/;"	f	file:
readfile	.\ext\fts5\tool\fts5txt2db.tcl	/^proc readfile {file} {$/;"	p
readfile	.\ext\fts5\tool\mkfts5c.tcl	/^proc readfile {zFile} {$/;"	p
readfileFunc	.\ext\misc\fileio.c	/^static void readfileFunc($/;"	f	file:
readfileFunc	.\src\shell.c	/^static void readfileFunc($/;"	f	file:
readfileFunc	.\test\fuzzcheck.c	/^static void readfileFunc($/;"	f	file:
readfileFunc	.\tool\loadfts.c	/^static void readfileFunc($/;"	f	file:
readpoint	.\src\memjournal.c	/^  FilePoint readpoint;            \/* Pointer to the end of the last xRead() *\/$/;"	m	struct:MemJournal	file:
readsTable	.\src\insert.c	/^static int readsTable(Parse *p, int iDb, Table *pTab){$/;"	f	file:
real2hex	.\src\test_func.c	/^static void real2hex($/;"	f	file:
realTime	.\test\wordcount.c	/^static sqlite3_int64 realTime(void){$/;"	f	file:
realloc	.\src\sqlite3ext.h	/^  void *(*realloc)(void*,int);$/;"	m	struct:sqlite3_api_routines
realloc64	.\src\sqlite3ext.h	/^  void *(*realloc64)(void*,sqlite3_uint64);$/;"	m	struct:sqlite3_api_routines
realnum_normalize	.\test\tester.tcl	/^proc realnum_normalize {r} {$/;"	p
rebuildPage	.\src\btree.c	/^static int rebuildPage($/;"	f	file:
rebuild_database	.\test\fuzzcheck.c	/^static void rebuild_database(sqlite3 *db){$/;"	f	file:
recordFunc	.\src\vdbemem.c	/^static void recordFunc($/;"	f	file:
record_one	.\tool\mkpragmatab.tcl	/^proc record_one {} {$/;"	p
refill-xy	.\test\show_speedtest1_rtree.tcl	/^proc refill-xy {} {$/;"	p
refill-xz	.\test\show_speedtest1_rtree.tcl	/^proc refill-xz {} {$/;"	p
refill-yz	.\test\show_speedtest1_rtree.tcl	/^proc refill-yz {} {$/;"	p
reformatVfs	.\test\fuzzcheck.c	/^static void reformatVfs(void){$/;"	f	file:
regCtr	.\src\sqliteInt.h	/^  int regCtr;           \/* Memory register holding the rowid counter *\/$/;"	m	struct:AutoincInfo
regResult	.\src\sqliteInt.h	/^    int regResult;    \/* Registers holding results of a co-routine *\/$/;"	m	struct:SrcList::SrcList_item
regReturn	.\src\select.c	/^  int regReturn;        \/* Register holding block-output return address *\/$/;"	m	struct:SortCtx	file:
regReturn	.\src\sqliteInt.h	/^    int regReturn;    \/* Register holding return address of addrFillSub *\/$/;"	m	struct:SrcList::SrcList_item
regRoot	.\src\sqliteInt.h	/^  int regRoot;         \/* Register holding root page number for new objects *\/$/;"	m	struct:Parse
regRowid	.\src\sqliteInt.h	/^  int regRowid;        \/* Register holding rowid of CREATE TABLE entry *\/$/;"	m	struct:Parse
registerTestFunctions	.\src\test_func.c	/^static int registerTestFunctions(sqlite3 *db){$/;"	f	file:
registerTokenizer	.\ext\fts2\fts2_tokenizer.c	/^int registerTokenizer($/;"	f	file:
registerTokenizer	.\ext\fts3\fts3_tokenizer.c	/^int registerTokenizer($/;"	f	file:
registerTrace	.\src\vdbe.c	/^static void registerTrace(int iReg, Mem *p){$/;"	f	file:
register_circle_geom	.\src\test_rtree.c	/^static int register_circle_geom($/;"	f	file:
register_cube_geom	.\src\test_rtree.c	/^static int register_cube_geom($/;"	f	file:
register_demovfs	.\src\test_demovfs.c	/^static int register_demovfs($/;"	f	file:
register_echo_module	.\src\test8.c	/^static int register_echo_module($/;"	f	file:
register_fs_module	.\src\test_fs.c	/^static int register_fs_module($/;"	f	file:
register_schema_module	.\src\test_schema.c	/^static int register_schema_module($/;"	f	file:
register_tclvar_module	.\src\test_tclvar.c	/^static int register_tclvar_module($/;"	f	file:
rehash	.\ext\fts1\ft_hash.c	/^static void rehash(Hash *pH, int new_size){$/;"	f	file:
rehash	.\ext\fts1\fts1_hash.c	/^static void rehash(fts1Hash *pH, int new_size){$/;"	f	file:
rehash	.\ext\fts2\fts2_hash.c	/^static void rehash(fts2Hash *pH, int new_size){$/;"	f	file:
rehash	.\src\hash.c	/^static int rehash(Hash *pH, unsigned int new_size){$/;"	f	file:
reindexDatabases	.\src\build.c	/^static void reindexDatabases(Parse *pParse, char const *zColl){$/;"	f	file:
reindexTable	.\src\build.c	/^static void reindexTable(Parse *pParse, Table *pTab, char const *zColl){$/;"	f	file:
reinsertNodeContent	.\ext\rtree\rtree.c	/^static int reinsertNodeContent(Rtree *pRtree, RtreeNode *pNode){$/;"	f	file:
releaseAllSavepoints	.\src\pager.c	/^static void releaseAllSavepoints(Pager *pPager){$/;"	f	file:
releaseInodeInfo	.\src\os_unix.c	/^static void releaseInodeInfo(unixFile *pFile){$/;"	f	file:
releaseMemArray	.\src\vdbeaux.c	/^static void releaseMemArray(Mem *p, int N){$/;"	f	file:
releasePage	.\src\btree.c	/^static void releasePage(MemPage *pPage){$/;"	f	file:
releasePageNotNull	.\src\btree.c	/^static void releasePageNotNull(MemPage *pPage){$/;"	f	file:
release_memory	.\src\sqlite3ext.h	/^  int (*release_memory)(int);$/;"	m	struct:sqlite3_api_routines
reloadTableSchema	.\src\alter.c	/^static void reloadTableSchema(Parse *pParse, Table *pTab, const char *zName){$/;"	f	file:
relocatePage	.\src\btree.c	/^static int relocatePage($/;"	f	file:
removeElementGivenHash	.\ext\fts1\ft_hash.c	/^static void removeElementGivenHash($/;"	f	file:
removeElementGivenHash	.\ext\fts1\fts1_hash.c	/^static void removeElementGivenHash($/;"	f	file:
removeElementGivenHash	.\ext\fts2\fts2_hash.c	/^static void removeElementGivenHash($/;"	f	file:
removeElementGivenHash	.\src\hash.c	/^static void removeElementGivenHash($/;"	f	file:
removeFromBlockedList	.\src\notify.c	/^static void removeFromBlockedList(sqlite3 *db){$/;"	f	file:
removeFromSharingList	.\src\btree.c	/^static int removeFromSharingList(BtShared *pBt){$/;"	f	file:
removeNode	.\ext\rtree\rtree.c	/^static int removeNode(Rtree *pRtree, RtreeNode *pNode, int iHeight){$/;"	f	file:
remove_diacritic	.\ext\fts3\fts3_unicode2.c	/^static int remove_diacritic(int c){$/;"	f	file:
renameParentFunc	.\src\alter.c	/^static void renameParentFunc($/;"	f	file:
renameTableFunc	.\src\alter.c	/^static void renameTableFunc($/;"	f	file:
renameTriggerFunc	.\src\alter.c	/^static void renameTriggerFunc($/;"	f	file:
renderLogMsg	.\src\printf.c	/^static void renderLogMsg(int iErrCode, const char *zFormat, va_list ap){$/;"	f	file:
replaceFileNameTokens	.\tool\mkvsix.tcl	/^proc replaceFileNameTokens { fileName name buildName platformName } {$/;"	p
replaceFunc	.\src\func.c	/^static void replaceFunc($/;"	f	file:
report_default_vfs	.\ext\rbu\rbu.c	/^void report_default_vfs(){$/;"	f
report_rbu_vfs	.\ext\rbu\rbu.c	/^void report_rbu_vfs(sqlite3rbu *pRbu){$/;"	f
reserved	.\src\os_unix.c	/^  int reserved;$/;"	m	struct:afpLockingContext	file:
reset	.\src\sqlite3ext.h	/^  int  (*reset)(sqlite3_stmt*pStmt);$/;"	m	struct:sqlite3_api_routines
resetAccumulator	.\src\select.c	/^static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo){$/;"	f	file:
resetAndCollectError	.\ext\rbu\sqlite3rbu.c	/^static int resetAndCollectError(sqlite3_stmt *pStmt, char **pzErrmsg){$/;"	f	file:
resetAutoExtObjCmd	.\src\test_autoext.c	/^static int resetAutoExtObjCmd($/;"	f	file:
reset_auto_extension	.\src\sqlite3ext.h	/^  void (*reset_auto_extension)(void);$/;"	m	struct:sqlite3_api_routines
reset_db	.\test\tester.tcl	/^proc reset_db {} {$/;"	p
reset_prng_state	.\src\test1.c	/^static int reset_prng_state($/;"	f	file:
resizeIndexObject	.\src\build.c	/^static int resizeIndexObject(sqlite3 *db, Index *pIdx, int N){$/;"	f	file:
resize_canvas_to_fit	.\test\show_speedtest1_rtree.tcl	/^proc resize_canvas_to_fit {} {$/;"	p
resolveAlias	.\src\resolve.c	/^static void resolveAlias($/;"	f	file:
resolveAsName	.\src\resolve.c	/^static int resolveAsName($/;"	f	file:
resolveAttachExpr	.\src\attach.c	/^static int resolveAttachExpr(NameContext *pName, Expr *pExpr)$/;"	f	file:
resolveCompoundOrderBy	.\src\resolve.c	/^static int resolveCompoundOrderBy($/;"	f	file:
resolveExprStep	.\src\resolve.c	/^static int resolveExprStep(Walker *pWalker, Expr *pExpr){$/;"	f	file:
resolveOrderByTermToExprList	.\src\resolve.c	/^static int resolveOrderByTermToExprList($/;"	f	file:
resolveOrderGroupBy	.\src\resolve.c	/^static int resolveOrderGroupBy($/;"	f	file:
resolveOutOfRangeError	.\src\resolve.c	/^static void resolveOutOfRangeError($/;"	f	file:
resolveP2Values	.\src\vdbeaux.c	/^static void resolveP2Values(Vdbe *p, int *pMaxFuncArgs){$/;"	f	file:
resolveSelectStep	.\src\resolve.c	/^static int resolveSelectStep(Walker *pWalker, Select *p){$/;"	f	file:
resolve_backslashes	.\src\shell.c	/^static void resolve_backslashes(char *z){$/;"	f	file:
resolve_conflict	.\tool\lemon.c	/^static int resolve_conflict($/;"	f	file:
restoreCursorPosition	.\src\btree.c	808;"	d	file:
restore_prng_state	.\src\test1.c	/^static int restore_prng_state($/;"	f	file:
result	.\ext\fts1\fts1.c	/^  DocListReader result;  \/* used when iCursorType == QUERY_FULLTEXT *\/ $/;"	m	struct:fulltext_cursor	file:
result	.\ext\fts1\fulltext.c	/^  DocListReader result;$/;"	m	struct:fulltext_cursor	file:
result	.\ext\fts2\fts2.c	/^  DataBuffer result;               \/* Doclist results from fulltextQuery *\/$/;"	m	struct:fulltext_cursor	file:
result_blob	.\src\sqlite3ext.h	/^  void  (*result_blob)(sqlite3_context*,const void*,int,void(*)(void*));$/;"	m	struct:sqlite3_api_routines
result_blob64	.\src\sqlite3ext.h	/^  void (*result_blob64)(sqlite3_context*,const void*,sqlite3_uint64,$/;"	m	struct:sqlite3_api_routines
result_double	.\src\sqlite3ext.h	/^  void  (*result_double)(sqlite3_context*,double);$/;"	m	struct:sqlite3_api_routines
result_error	.\src\sqlite3ext.h	/^  void  (*result_error)(sqlite3_context*,const char*,int);$/;"	m	struct:sqlite3_api_routines
result_error16	.\src\sqlite3ext.h	/^  void  (*result_error16)(sqlite3_context*,const void*,int);$/;"	m	struct:sqlite3_api_routines
result_error_code	.\src\sqlite3ext.h	/^  void (*result_error_code)(sqlite3_context*,int);$/;"	m	struct:sqlite3_api_routines
result_error_nomem	.\src\sqlite3ext.h	/^  void (*result_error_nomem)(sqlite3_context*);$/;"	m	struct:sqlite3_api_routines
result_error_toobig	.\src\sqlite3ext.h	/^  void (*result_error_toobig)(sqlite3_context*);$/;"	m	struct:sqlite3_api_routines
result_int	.\src\sqlite3ext.h	/^  void  (*result_int)(sqlite3_context*,int);$/;"	m	struct:sqlite3_api_routines
result_int64	.\src\sqlite3ext.h	/^  void  (*result_int64)(sqlite3_context*,sqlite_int64);$/;"	m	struct:sqlite3_api_routines
result_null	.\src\sqlite3ext.h	/^  void  (*result_null)(sqlite3_context*);$/;"	m	struct:sqlite3_api_routines
result_subtype	.\src\sqlite3ext.h	/^  void (*result_subtype)(sqlite3_context*,unsigned int);$/;"	m	struct:sqlite3_api_routines
result_text	.\src\sqlite3ext.h	/^  void  (*result_text)(sqlite3_context*,const char*,int,void(*)(void*));$/;"	m	struct:sqlite3_api_routines
result_text16	.\src\sqlite3ext.h	/^  void  (*result_text16)(sqlite3_context*,const void*,int,void(*)(void*));$/;"	m	struct:sqlite3_api_routines
result_text16be	.\src\sqlite3ext.h	/^  void  (*result_text16be)(sqlite3_context*,const void*,int,void(*)(void*));$/;"	m	struct:sqlite3_api_routines
result_text16le	.\src\sqlite3ext.h	/^  void  (*result_text16le)(sqlite3_context*,const void*,int,void(*)(void*));$/;"	m	struct:sqlite3_api_routines
result_text64	.\src\sqlite3ext.h	/^  void (*result_text64)(sqlite3_context*,const char*,sqlite3_uint64,$/;"	m	struct:sqlite3_api_routines
result_value	.\src\sqlite3ext.h	/^  void  (*result_value)(sqlite3_context*,sqlite3_value*);$/;"	m	struct:sqlite3_api_routines
result_zeroblob	.\src\sqlite3ext.h	/^  void (*result_zeroblob)(sqlite3_context*,int);$/;"	m	struct:sqlite3_api_routines
result_zeroblob64	.\src\sqlite3ext.h	/^  int (*result_zeroblob64)(sqlite3_context*,sqlite3_uint64);$/;"	m	struct:sqlite3_api_routines
retRangeStart	.\src\os_unix.c	/^  unsigned long long retRangeStart; \/* nbr of 1st byte locked if successful *\/$/;"	m	struct:ByteRangeLockPB2	file:
returnSingleInt	.\src\pragma.c	/^static void returnSingleInt(Vdbe *v, const char *zLabel, i64 value){$/;"	f	file:
returnSingleText	.\src\pragma.c	/^static void returnSingleText($/;"	f	file:
reusable	.\src\sqliteInt.h	/^    unsigned reusable :1;   \/* Constant expression is reusable *\/$/;"	m	struct:ExprList::ExprList_item
revLoop	.\src\whereInt.h	/^  Bitmask revLoop;      \/* aLoop[]s that should be reversed for ORDER BY *\/$/;"	m	struct:WherePath
revMask	.\src\whereInt.h	/^  Bitmask revMask;          \/* Mask of ORDER BY terms that need reversing *\/$/;"	m	struct:WhereInfo
reverse	.\test\boundary1.tcl	/^proc reverse {inlist} {$/;"	p
reverse	.\test\boundary2.tcl	/^proc reverse {inlist} {$/;"	p
reverse	.\test\boundary3.tcl	/^proc reverse {inlist} {$/;"	p
reverse	.\test\boundary4.tcl	/^proc reverse {inlist} {$/;"	p
rhs	.\tool\lemon.c	/^  struct symbol **rhs;     \/* The RHS symbols *\/$/;"	m	struct:rule	typeref:struct:rule::symbol	file:
rhs	.\tool\lemon.c	/^  struct symbol *rhs[MAXRHS];  \/* RHS symbols *\/$/;"	m	struct:pstate	typeref:struct:pstate::symbol	file:
rhsalias	.\tool\lemon.c	/^  const char **rhsalias;   \/* An alias for each RHS symbol (NULL if none) *\/$/;"	m	struct:rule	file:
robust_close	.\src\os_unix.c	/^static void robust_close(unixFile *pFile, int h, int lineno){$/;"	f	file:
robust_flock	.\src\os_unix.c	/^static int robust_flock(int fd, int op){$/;"	f	file:
robust_flock	.\src\os_unix.c	2262;"	d	file:
robust_ftruncate	.\src\os_unix.c	/^static int robust_ftruncate(int h, sqlite3_int64 sz){$/;"	f	file:
robust_open	.\src\os_unix.c	/^static int robust_open(const char *z, int f, mode_t m){$/;"	f	file:
rollback_hook	.\src\sqlite3ext.h	/^  void * (*rollback_hook)(sqlite3*,void(*)(void*),void*);$/;"	m	struct:sqlite3_api_routines
rootData	.\ext\fts2\fts2.c	/^  DataBuffer rootData;      \/* root data for inline. *\/$/;"	m	struct:LeavesReader	file:
rootOnly	.\ext\fts3\fts3_write.c	/^  u8 rootOnly;                    \/* True for a root-only reader *\/$/;"	m	struct:Fts3SegReader	file:
rot13	.\ext\misc\rot13.c	/^static unsigned char rot13(unsigned char c){$/;"	f	file:
rot13CollFunc	.\ext\misc\rot13.c	/^static int rot13CollFunc($/;"	f	file:
rot13func	.\ext\misc\rot13.c	/^static void rot13func($/;"	f	file:
roundFunc	.\src\func.c	/^static void roundFunc(sqlite3_context *context, int argc, sqlite3_value **argv){$/;"	f	file:
roundup_allones	.\test\speedtest1.c	/^unsigned roundup_allones(unsigned limit){$/;"	f
rowSeparator	.\src\shell.c	/^  char rowSeparator[20]; \/* Row separator character for MODE_Ascii *\/$/;"	m	struct:ShellState	file:
rowSetEntryAlloc	.\src\rowset.c	/^static struct RowSetEntry *rowSetEntryAlloc(RowSet *p){$/;"	f	file:
rowSetEntryMerge	.\src\rowset.c	/^static struct RowSetEntry *rowSetEntryMerge($/;"	f	file:
rowSetEntrySort	.\src\rowset.c	/^static struct RowSetEntry *rowSetEntrySort(struct RowSetEntry *pIn){$/;"	f	file:
rowSetListToTree	.\src\rowset.c	/^static struct RowSetEntry *rowSetListToTree(struct RowSetEntry *pList){$/;"	f	file:
rowSetNDeepTree	.\src\rowset.c	/^static struct RowSetEntry *rowSetNDeepTree($/;"	f	file:
rowSetToList	.\src\rowset.c	/^static void rowSetToList(RowSet *p){$/;"	f	file:
rowSetTreeToList	.\src\rowset.c	/^static void rowSetTreeToList($/;"	f	file:
rowid	.\ext\fts5\fts5_vocab.c	/^  i64 rowid;                      \/* This table's current rowid value *\/$/;"	m	struct:Fts5VocabCursor	file:
rowid	.\src\test_schema.c	/^  int rowid;$/;"	m	struct:schema_cursor	file:
rowidWrite	.\ext\rtree\rtree.c	/^static int rowidWrite(Rtree *pRtree, sqlite3_int64 iRowid, sqlite3_int64 iNode){$/;"	f	file:
rp	.\tool\lemon.c	/^    struct rule *rp;       \/* The rule, if a reduce *\/$/;"	m	union:action::__anon34	typeref:struct:action::__anon34::rule	file:
rp	.\tool\lemon.c	/^  struct rule *rp;         \/* The rule upon which the configuration is based *\/$/;"	m	struct:config	typeref:struct:config::rule	file:
rsFlags	.\src\rowset.c	/^  u16 rsFlags;                   \/* Various flags *\/$/;"	m	struct:RowSet	file:
rtreeBestIndex	.\ext\rtree\rtree.c	/^static int rtreeBestIndex(sqlite3_vtab *tab, sqlite3_index_info *pIdxInfo){$/;"	f	file:
rtreeCallbackConstraint	.\ext\rtree\rtree.c	/^static int rtreeCallbackConstraint($/;"	f	file:
rtreeClose	.\ext\rtree\rtree.c	/^static int rtreeClose(sqlite3_vtab_cursor *cur){$/;"	f	file:
rtreeColumn	.\ext\rtree\rtree.c	/^static int rtreeColumn(sqlite3_vtab_cursor *cur, sqlite3_context *ctx, int i){$/;"	f	file:
rtreeConnect	.\ext\rtree\rtree.c	/^static int rtreeConnect($/;"	f	file:
rtreeCreate	.\ext\rtree\rtree.c	/^static int rtreeCreate($/;"	f	file:
rtreeDeleteRowid	.\ext\rtree\rtree.c	/^static int rtreeDeleteRowid(Rtree *pRtree, sqlite3_int64 iDelete){$/;"	f	file:
rtreeDestroy	.\ext\rtree\rtree.c	/^static int rtreeDestroy(sqlite3_vtab *pVtab){$/;"	f	file:
rtreeDisconnect	.\ext\rtree\rtree.c	/^static int rtreeDisconnect(sqlite3_vtab *pVtab){$/;"	f	file:
rtreeEnqueue	.\ext\rtree\rtree.c	/^static RtreeSearchPoint *rtreeEnqueue($/;"	f	file:
rtreeEof	.\ext\rtree\rtree.c	/^static int rtreeEof(sqlite3_vtab_cursor *cur){$/;"	f	file:
rtreeFilter	.\ext\rtree\rtree.c	/^static int rtreeFilter($/;"	f	file:
rtreeFreeCallback	.\ext\rtree\rtree.c	/^static void rtreeFreeCallback(void *p){$/;"	f	file:
rtreeInit	.\ext\rtree\rtree.c	/^static int rtreeInit($/;"	f	file:
rtreeInsertCell	.\ext\rtree\rtree.c	/^static int rtreeInsertCell($/;"	f	file:
rtreeLeafConstraint	.\ext\rtree\rtree.c	/^static void rtreeLeafConstraint($/;"	f	file:
rtreeMatchArgFree	.\ext\rtree\rtree.c	/^static void rtreeMatchArgFree(void *pArg){$/;"	f	file:
rtreeModule	.\ext\rtree\rtree.c	/^static sqlite3_module rtreeModule = {$/;"	v	file:
rtreeNext	.\ext\rtree\rtree.c	/^static int rtreeNext(sqlite3_vtab_cursor *pVtabCursor){$/;"	f	file:
rtreeNodeOfFirstSearchPoint	.\ext\rtree\rtree.c	/^static RtreeNode *rtreeNodeOfFirstSearchPoint(RtreeCursor *pCur, int *pRC){$/;"	f	file:
rtreeNonleafConstraint	.\ext\rtree\rtree.c	/^static void rtreeNonleafConstraint($/;"	f	file:
rtreeOpen	.\ext\rtree\rtree.c	/^static int rtreeOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor){$/;"	f	file:
rtreeQueryStat1	.\ext\rtree\rtree.c	/^static int rtreeQueryStat1(sqlite3 *db, Rtree *pRtree){$/;"	f	file:
rtreeReference	.\ext\rtree\rtree.c	/^static void rtreeReference(Rtree *pRtree){$/;"	f	file:
rtreeRelease	.\ext\rtree\rtree.c	/^static void rtreeRelease(Rtree *pRtree){$/;"	f	file:
rtreeRename	.\ext\rtree\rtree.c	/^static int rtreeRename(sqlite3_vtab *pVtab, const char *zNewName){$/;"	f	file:
rtreeRowid	.\ext\rtree\rtree.c	/^static int rtreeRowid(sqlite3_vtab_cursor *pVtabCursor, sqlite_int64 *pRowid){$/;"	f	file:
rtreeSearchPointCompare	.\ext\rtree\rtree.c	/^static int rtreeSearchPointCompare($/;"	f	file:
rtreeSearchPointFirst	.\ext\rtree\rtree.c	/^static RtreeSearchPoint *rtreeSearchPointFirst(RtreeCursor *pCur){$/;"	f	file:
rtreeSearchPointNew	.\ext\rtree\rtree.c	/^static RtreeSearchPoint *rtreeSearchPointNew($/;"	f	file:
rtreeSearchPointPop	.\ext\rtree\rtree.c	/^static void rtreeSearchPointPop(RtreeCursor *p){$/;"	f	file:
rtreeSearchPointSwap	.\ext\rtree\rtree.c	/^static void rtreeSearchPointSwap(RtreeCursor *p, int i, int j){$/;"	f	file:
rtreeSqlInit	.\ext\rtree\rtree.c	/^static int rtreeSqlInit($/;"	f	file:
rtreeStepToLeaf	.\ext\rtree\rtree.c	/^static int rtreeStepToLeaf(RtreeCursor *pCur){$/;"	f	file:
rtreeUpdate	.\ext\rtree\rtree.c	/^static int rtreeUpdate($/;"	f	file:
rtreeValueDown	.\ext\rtree\rtree.c	/^static RtreeValue rtreeValueDown(sqlite3_value *v){$/;"	f	file:
rtreeValueUp	.\ext\rtree\rtree.c	/^static RtreeValue rtreeValueUp(sqlite3_value *v){$/;"	f	file:
rtree_check	.\ext\rtree\rtree_util.tcl	/^proc rtree_check {db zTab} {$/;"	p
rtree_depth	.\ext\rtree\rtree_util.tcl	/^proc rtree_depth {db zTab} {$/;"	p
rtree_dump	.\ext\rtree\rtree_util.tcl	/^proc rtree_dump {db zTab} {$/;"	p
rtree_mincells	.\ext\rtree\rtree_util.tcl	/^proc rtree_mincells {db zTab} {$/;"	p
rtree_ndim	.\ext\rtree\rtree_util.tcl	/^proc rtree_ndim {db zTab} {$/;"	p
rtree_node	.\ext\rtree\rtree_util.tcl	/^proc rtree_node {db zTab iNode {iPrec 6}} {$/;"	p
rtree_node_check	.\ext\rtree\rtree_util.tcl	/^proc rtree_node_check {db zTab iNode iDepth} {$/;"	p
rtree_nodedepth	.\ext\rtree\rtree_util.tcl	/^proc rtree_nodedepth {db zTab iNode} {$/;"	p
rtree_nodetreedump	.\ext\rtree\rtree_util.tcl	/^proc rtree_nodetreedump {db zTab zIndent iDepth iNode} {$/;"	p
rtree_treedump	.\ext\rtree\rtree_util.tcl	/^proc rtree_treedump {db zTab} {$/;"	p
rtreedepth	.\ext\rtree\rtree.c	/^static void rtreedepth(sqlite3_context *ctx, int nArg, sqlite3_value **apArg){$/;"	f	file:
rtreenode	.\ext\rtree\rtree.c	/^static void rtreenode(sqlite3_context *ctx, int nArg, sqlite3_value **apArg){$/;"	f	file:
ru_stime	.\src\shell.c	/^  struct timeval ru_stime; \/* system CPU time used *\/$/;"	m	struct:rusage	typeref:struct:rusage::timeval	file:
ru_utime	.\src\shell.c	/^  struct timeval ru_utime; \/* user CPU time used *\/$/;"	m	struct:rusage	typeref:struct:rusage::timeval	file:
rule	.\tool\lemon.c	/^  struct rule *rule;       \/* Linked list of rules of this (if an NT) *\/$/;"	m	struct:symbol	typeref:struct:symbol::rule	file:
rule	.\tool\lemon.c	/^  struct rule *rule;       \/* List of all rules *\/$/;"	m	struct:lemon	typeref:struct:lemon::rule	file:
rule	.\tool\lemon.c	/^struct rule {$/;"	s	file:
ruleline	.\tool\lemon.c	/^  int ruleline;            \/* Line number for the rule *\/$/;"	m	struct:rule	file:
runAsObjProc	.\src\test1.c	/^static int runAsObjProc($/;"	f	file:
runOnlyOnce	.\src\vdbeInt.h	/^  bft runOnlyOnce:1;      \/* Automatically expire on reset *\/$/;"	m	struct:Vdbe
runScript	.\mptest\mptest.c	/^static void runScript($/;"	f	file:
runSql	.\ext\fts3\tool\fts3view.c	/^static int runSql(sqlite3 *db, const char *zFormat, ...){$/;"	f	file:
runSql	.\mptest\mptest.c	/^static void runSql(const char *zFormat, ...){$/;"	f	file:
runSql	.\test\fuzzcheck.c	/^static void runSql(sqlite3 *db, const char *zSql, unsigned  runFlags){$/;"	f	file:
runSql	.\tool\rollback-test.c	/^static void runSql(sqlite3 *db, const char *zSql){$/;"	f	file:
runTime	.\tool\speedtest16.c	/^static sqlite_uint64 runTime = 0;$/;"	v	file:
runTime	.\tool\speedtest8.c	/^static sqlite_uint64 runTime = 0;$/;"	v	file:
run_ioerr_prep	.\test\tester.tcl	/^proc run_ioerr_prep {} {$/;"	p
run_quick_test	.\tool\omittest.tcl	/^proc run_quick_test {dir omit_symbol_list} {$/;"	p
run_rbu	.\ext\rbu\rbu_common.tcl	/^proc run_rbu {target rbu} {$/;"	p
run_schema_dump_query	.\src\shell.c	/^static int run_schema_dump_query($/;"	f	file:
run_sql	.\test\threadtest4.c	/^static void run_sql(WorkerInfo *p, const char *zFormat, ...){$/;"	f	file:
run_table_dump_query	.\src\shell.c	/^static int run_table_dump_query($/;"	f	file:
run_test_suite	.\test\releasetest.tcl	/^proc run_test_suite {name testtarget config} {$/;"	p
run_thread_tests	.\test\thread_common.tcl	/^proc run_thread_tests {{print_warning 0}} {$/;"	p
runtest	.\tool\speedtest.tcl	/^proc runtest {title} {$/;"	p
runtest	.\tool\speedtest2.tcl	/^proc runtest {title} {$/;"	p
runtimeError	.\tool\sqldiff.c	/^static void runtimeError(const char *zFormat, ...){$/;"	f	file:
rusage	.\src\shell.c	/^struct rusage {$/;"	s	file:
s	.\ext\fts1\fts1.c	/^  char *s;      \/* Content of the string *\/$/;"	m	struct:StringBuffer	file:
s	.\src\date.c	/^  double s;          \/* Seconds *\/$/;"	m	struct:DateTime	file:
s	.\src\random.c	/^  unsigned char s[256];          \/* State variables *\/$/;"	m	struct:sqlite3PrngType	file:
s0	.\tool\showwal.c	/^  unsigned s0, s1;     \/* Current checksum value *\/$/;"	m	struct:Cksum	file:
s1	.\tool\showwal.c	/^  unsigned s0, s1;     \/* Current checksum value *\/$/;"	m	struct:Cksum	file:
sArg	.\src\sqliteInt.h	/^  Token sArg;               \/* Complete text of a module argument *\/$/;"	m	struct:Parse
sBegin	.\src\shell.c	/^static struct rusage sBegin;  \/* CPU time at start *\/$/;"	v	typeref:struct:rusage	file:
sColMap	.\src\sqliteInt.h	/^  struct sColMap {      \/* Mapping of columns in pFrom to columns in zTo *\/$/;"	s	struct:FKey
sCost	.\ext\misc\amatch.c	/^  amatch_avl sCost;     \/* Linkage of this node into the cost tree *\/$/;"	m	struct:amatch_word	file:
sDb	.\src\test3.c	/^static sqlite3 sDb;$/;"	v	file:
sFts5Api	.\ext\fts5\fts5_main.c	/^static const Fts5ExtensionApi sFts5Api = {$/;"	v	file:
sIn	.\ext\misc\regexp.c	/^  ReInput sIn;                \/* Regular expression text *\/$/;"	m	struct:ReCompiled	file:
sIoMethodsV1	.\src\test_multiplex.c	/^  sqlite3_io_methods sIoMethodsV1;$/;"	m	struct:__anon23	file:
sIoMethodsV1	.\src\test_quota.c	/^  sqlite3_io_methods sIoMethodsV1;$/;"	m	struct:__anon24	file:
sIoMethodsV2	.\src\test_multiplex.c	/^  sqlite3_io_methods sIoMethodsV2;$/;"	m	struct:__anon23	file:
sIoMethodsV2	.\src\test_quota.c	/^  sqlite3_io_methods sIoMethodsV2;$/;"	m	struct:__anon24	file:
sLastToken	.\src\sqliteInt.h	/^  Token sLastToken;         \/* The last token parsed *\/$/;"	m	struct:Parse
sMaskSet	.\src\whereInt.h	/^  WhereMaskSet sMaskSet;    \/* Map cursor numbers to bitmasks *\/$/;"	m	struct:WhereInfo
sNameToken	.\src\sqliteInt.h	/^  Token sNameToken;         \/* Token with unqualified schema object name *\/$/;"	m	struct:Parse
sOomMem	.\tool\fuzzershell.c	/^  sqlite3_mem_methods sOomMem;     \/* Memory methods with OOM simulator *\/$/;"	m	struct:GlobalVars	file:
sOrigMem	.\tool\fuzzershell.c	/^  sqlite3_mem_methods sOrigMem;    \/* Original memory methods *\/$/;"	m	struct:GlobalVars	file:
sParse	.\ext\misc\json1.c	/^  JsonParse sParse;          \/* Parse of the input JSON *\/$/;"	m	struct:JsonEachCursor	file:
sPoint	.\ext\rtree\rtree.c	/^  RtreeSearchPoint sPoint;          \/* Cached next search point *\/$/;"	m	struct:RtreeCursor	file:
sPragmaNames	.\src\pragma.h	/^static const struct sPragmaNames {$/;"	s
sSelf	.\ext\misc\vtshim.c	/^  sqlite3_module sSelf;         \/* Methods used by this shim *\/$/;"	m	struct:vtshim_aux	file:
sThisVfs	.\src\test_multiplex.c	/^  sqlite3_vfs sThisVfs;$/;"	m	struct:__anon23	file:
sThisVfs	.\src\test_quota.c	/^  sqlite3_vfs sThisVfs;$/;"	m	struct:__anon24	file:
sWC	.\src\whereInt.h	/^  WhereClause sWC;          \/* Decomposition of the WHERE clause *\/$/;"	m	struct:WhereInfo
sWord	.\ext\misc\amatch.c	/^  amatch_avl sWord;     \/* Linkage of this node into the word tree *\/$/;"	m	struct:amatch_word	file:
s_options	.\tool\lemon.c	/^struct s_options {$/;"	s	file:
s_x1	.\tool\lemon.c	/^struct s_x1 {$/;"	s	file:
s_x1node	.\tool\lemon.c	/^typedef struct s_x1node {$/;"	s	file:
s_x2	.\tool\lemon.c	/^struct s_x2 {$/;"	s	file:
s_x2node	.\tool\lemon.c	/^typedef struct s_x2node {$/;"	s	file:
s_x3	.\tool\lemon.c	/^struct s_x3 {$/;"	s	file:
s_x3node	.\tool\lemon.c	/^typedef struct s_x3node {$/;"	s	file:
s_x4	.\tool\lemon.c	/^struct s_x4 {$/;"	s	file:
s_x4node	.\tool\lemon.c	/^typedef struct s_x4node {$/;"	s	file:
safeId	.\tool\sqldiff.c	/^static char *safeId(const char *zId){$/;"	f	file:
safeToUseEvalObjv	.\src\tclsqlite.c	/^static int safeToUseEvalObjv(Tcl_Interp *interp, Tcl_Obj *pCmd){$/;"	f	file:
safe_isalnum	.\ext\fts1\fts1.c	/^static int safe_isalnum(char c){$/;"	f	file:
safe_isalnum	.\ext\fts2\fts2.c	/^static int safe_isalnum(char c){$/;"	f	file:
safe_isalnum	.\ext\misc\json1.c	49;"	d	file:
safe_isdigit	.\ext\misc\json1.c	48;"	d	file:
safe_isspace	.\ext\fts1\fts1.c	/^static int safe_isspace(char c){$/;"	f	file:
safe_isspace	.\ext\fts2\fts2.c	/^static int safe_isspace(char c){$/;"	f	file:
safe_isspace	.\ext\misc\json1.c	80;"	d	file:
safe_malloc	.\test\threadtest4.c	/^static void *safe_malloc(int sz){$/;"	f	file:
safe_realloc	.\test\fuzzcheck.c	/^static void *safe_realloc(void *pOld, int szNew){$/;"	f	file:
safe_strcmp	.\mptest\mptest.c	/^static int safe_strcmp(const char *a, const char *b){$/;"	f	file:
safe_tolower	.\ext\fts1\fts1.c	/^static int safe_tolower(char c){$/;"	f	file:
safe_tolower	.\ext\fts2\fts2.c	/^static int safe_tolower(char c){$/;"	f	file:
safety_level	.\src\sqliteInt.h	/^  u8 safety_level;     \/* How aggressive at syncing data to disk *\/$/;"	m	struct:Db
sameValue	.\ext\misc\percentile.c	/^static int sameValue(double a, double b){$/;"	f	file:
same_symbol	.\tool\lemon.c	/^int same_symbol(struct symbol *a, struct symbol *b)$/;"	f
sampleClear	.\src\analyze.c	/^static void sampleClear(sqlite3 *db, Stat4Sample *p){$/;"	f	file:
sampleCopy	.\src\analyze.c	/^static void sampleCopy(Stat4Accum *p, Stat4Sample *pTo, Stat4Sample *pFrom){$/;"	f	file:
sampleInsert	.\src\analyze.c	/^static void sampleInsert(Stat4Accum *p, Stat4Sample *pNew, int nEqZero){$/;"	f	file:
sampleIsBetter	.\src\analyze.c	/^static int sampleIsBetter($/;"	f	file:
sampleIsBetterPost	.\src\analyze.c	/^static int sampleIsBetterPost($/;"	f	file:
samplePushPrevious	.\src\analyze.c	/^static void samplePushPrevious(Stat4Accum *p, int iChng){$/;"	f	file:
sampleSetRowid	.\src\analyze.c	/^static void sampleSetRowid(sqlite3 *db, Stat4Sample *p, int n, const u8 *pData){$/;"	f	file:
sampleSetRowidInt64	.\src\analyze.c	/^static void sampleSetRowidInt64(sqlite3 *db, Stat4Sample *p, i64 iRowid){$/;"	f	file:
saveAllCursors	.\src\btree.c	/^static int saveAllCursors(BtShared *pBt, Pgno iRoot, BtCursor *pExcept){$/;"	f	file:
saveCursorKey	.\src\btree.c	/^static int saveCursorKey(BtCursor *pCur){$/;"	f	file:
saveCursorPosition	.\src\btree.c	/^static int saveCursorPosition(BtCursor *pCur){$/;"	f	file:
saveCursorsOnList	.\src\btree.c	/^static int SQLITE_NOINLINE saveCursorsOnList($/;"	f	file:
save_err_msg	.\src\shell.c	/^static char *save_err_msg($/;"	f	file:
save_prng_state	.\src\test1.c	/^static int save_prng_state($/;"	f	file:
savedNQueryLoop	.\src\whereInt.h	/^  int savedNQueryLoop;      \/* pParse->nQueryLoop outside the WHERE loop *\/$/;"	m	struct:WhereInfo
saved_cnt	.\src\pager.c	/^static int saved_cnt;$/;"	v	file:
savepoint_opt	.\src\parse.y	/^savepoint_opt ::= .$/;"	l
savepoint_opt	.\src\parse.y	/^savepoint_opt ::= SAVEPOINT.$/;"	l
scalarFunc	.\ext\fts2\fts2_tokenizer.c	/^static void scalarFunc($/;"	f	file:
scalarFunc	.\ext\fts3\fts3_tokenizer.c	/^static void scalarFunc($/;"	f	file:
scanstatsOn	.\src\shell.c	/^  int scanstatsOn;       \/* True to display scan stats before each finalize *\/$/;"	m	struct:ShellState	file:
scenario	.\tool\soak1.tcl	/^proc scenario {id title pattern} {$/;"	p
schemaBestIndex	.\src\test_schema.c	/^static int schemaBestIndex(sqlite3_vtab *tab, sqlite3_index_info *pIdxInfo){$/;"	f	file:
schemaClose	.\src\test_schema.c	/^static int schemaClose(sqlite3_vtab_cursor *cur){$/;"	f	file:
schemaColumn	.\src\test_schema.c	/^static int schemaColumn(sqlite3_vtab_cursor *cur, sqlite3_context *ctx, int i){$/;"	f	file:
schemaCreate	.\src\test_schema.c	/^static int schemaCreate($/;"	f	file:
schemaDestroy	.\src\test_schema.c	/^static int schemaDestroy(sqlite3_vtab *pVtab){$/;"	f	file:
schemaEof	.\src\test_schema.c	/^static int schemaEof(sqlite3_vtab_cursor *cur){$/;"	f	file:
schemaFilter	.\src\test_schema.c	/^static int schemaFilter($/;"	f	file:
schemaFlags	.\src\sqliteInt.h	/^  u16 schemaFlags;     \/* Flags associated with this schema *\/$/;"	m	struct:Schema
schemaIsValid	.\src\prepare.c	/^static void schemaIsValid(Parse *pParse){$/;"	f	file:
schemaModule	.\src\test_schema.c	/^static sqlite3_module schemaModule = {$/;"	v	file:
schemaNext	.\src\test_schema.c	/^static int schemaNext(sqlite3_vtab_cursor *cur){$/;"	f	file:
schemaOpen	.\src\test_schema.c	/^static int schemaOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor){$/;"	f	file:
schemaRowid	.\src\test_schema.c	/^static int schemaRowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid){$/;"	f	file:
schema_cookie	.\src\sqliteInt.h	/^  int schema_cookie;   \/* Database schema version number for this file *\/$/;"	m	struct:Schema
schema_cursor	.\src\test_schema.c	/^struct schema_cursor {$/;"	s	file:
schema_cursor	.\src\test_schema.c	/^typedef struct schema_cursor schema_cursor;$/;"	t	typeref:struct:schema_cursor	file:
schema_vtab	.\src\test_schema.c	/^struct schema_vtab {$/;"	s	file:
schema_vtab	.\src\test_schema.c	/^typedef struct schema_vtab schema_vtab;$/;"	t	typeref:struct:schema_vtab	file:
scramble	.\test\boundary1.tcl	/^proc scramble {inlist} {$/;"	p
scramble	.\test\boundary2.tcl	/^proc scramble {inlist} {$/;"	p
scramble	.\test\boundary3.tcl	/^proc scramble {inlist} {$/;"	p
scramble	.\test\boundary4.tcl	/^proc scramble {inlist} {$/;"	p
scratchAllocOut	.\src\malloc.c	/^static int scratchAllocOut = 0;$/;"	v	file:
scriptCodeSqlFunc	.\ext\misc\spellfix.c	/^static void scriptCodeSqlFunc($/;"	f	file:
searchWith	.\src\select.c	/^static struct Cte *searchWith($/;"	f	file:
section_comment	.\ext\fts2\mkfts2amal.tcl	/^proc section_comment {text} {$/;"	p
section_comment	.\ext\fts3\mkfts3amal.tcl	/^proc section_comment {text} {$/;"	p
section_comment	.\tool\mksqlite3c-noext.tcl	/^proc section_comment {text} {$/;"	p
section_comment	.\tool\mksqlite3c.tcl	/^proc section_comment {text} {$/;"	p
section_comment	.\tool\mksqlite3internalh.tcl	/^proc section_comment {text} {$/;"	p
sectorSize	.\src\os_unix.c	/^  int sectorSize;                     \/* Device sector size *\/$/;"	m	struct:unixFile	file:
sectorSize	.\src\pager.c	/^  u32 sectorSize;             \/* Assumed sector size during rollback *\/$/;"	m	struct:Pager	file:
sectorSize	.\tool\showjournal.c	/^static int sectorSize = 512;$/;"	v	file:
seekAndRead	.\src\os_unix.c	/^static int seekAndRead(unixFile *id, sqlite3_int64 offset, void *pBuf, int cnt){$/;"	f	file:
seekAndWrite	.\src\os_unix.c	/^static int seekAndWrite(unixFile *id, i64 offset, const void *pBuf, int cnt){$/;"	f	file:
seekAndWriteFd	.\src\os_unix.c	/^static int seekAndWriteFd($/;"	f	file:
seekOp	.\src\vdbeInt.h	/^  u8 seekOp;            \/* Most recent seek operation on this cursor *\/$/;"	m	struct:VdbeCursor
seekResult	.\src\vdbeInt.h	/^  int seekResult;       \/* Result of previous sqlite3BtreeMoveto() *\/$/;"	m	struct:VdbeCursor
seenInterrupt	.\src\shell.c	/^static volatile int seenInterrupt = 0;$/;"	v	file:
segdirNextIndex	.\ext\fts2\fts2.c	/^static int segdirNextIndex(fulltext_vtab *v, int iLevel, int *pidx){$/;"	f	file:
segdir_count	.\ext\fts2\fts2.c	/^static int segdir_count(fulltext_vtab *v, int *pnSegments, int *piMaxLevel){$/;"	f	file:
segdir_delete	.\ext\fts2\fts2.c	/^static int segdir_delete(fulltext_vtab *v, int iLevel){$/;"	f	file:
segdir_delete_all	.\ext\fts2\fts2.c	/^static int segdir_delete_all(fulltext_vtab *v){$/;"	f	file:
segdir_max_index	.\ext\fts2\fts2.c	/^static int segdir_max_index(fulltext_vtab *v, int iLevel, int *pidx){$/;"	f	file:
segdir_set	.\ext\fts2\fts2.c	/^static int segdir_set(fulltext_vtab *v, int iLevel, int idx,$/;"	f	file:
segdir_span	.\ext\fts2\fts2.c	/^static int segdir_span(fulltext_vtab *v, int iLevel,$/;"	f	file:
segment	.\ext\fts2\fts2.c	/^  int segment;$/;"	m	struct:OptLeavesReader	file:
segmentMerge	.\ext\fts2\fts2.c	/^static int segmentMerge(fulltext_vtab *v, int iLevel){$/;"	f	file:
selFlags	.\src\sqliteInt.h	/^  u16 selFlags;          \/* Various SF_* values *\/$/;"	m	struct:Select
selectAddColumnTypeAndCollation	.\src\select.c	/^static void selectAddColumnTypeAndCollation($/;"	f	file:
selectAddSubqueryTypeInfo	.\src\select.c	/^static void selectAddSubqueryTypeInfo(Walker *pWalker, Select *p){$/;"	f	file:
selectExpander	.\src\select.c	/^static int selectExpander(Walker *pWalker, Select *p){$/;"	f	file:
selectInnerLoop	.\src\select.c	/^static void selectInnerLoop($/;"	f	file:
selectNodeIsConstant	.\src\expr.c	/^static int selectNodeIsConstant(Walker *pWalker, Select *NotUsed){$/;"	f	file:
selectOpName	.\src\select.c	/^static const char *selectOpName(int id){$/;"	f	file:
selectPopWith	.\src\select.c	/^static void selectPopWith(Walker *pWalker, Select *p){$/;"	f	file:
selectPopWith	.\src\select.c	4152;"	d	file:
select_doc	.\ext\fts3\fts3speed.tcl	/^proc select_doc {nTerm} {$/;"	p
select_term	.\ext\fts3\fts3speed.tcl	/^proc select_term {} {$/;"	p
semXCheckReservedLock	.\src\os_unix.c	/^static int semXCheckReservedLock(sqlite3_file *id, int *pResOut) {$/;"	f	file:
semXClose	.\src\os_unix.c	/^static int semXClose(sqlite3_file *id) {$/;"	f	file:
semXLock	.\src\os_unix.c	/^static int semXLock(sqlite3_file *id, int eFileLock) {$/;"	f	file:
semXUnlock	.\src\os_unix.c	/^static int semXUnlock(sqlite3_file *id, int eFileLock) {$/;"	f	file:
sendToServer	.\src\test_server.c	/^static void sendToServer(SqlMessage *pMsg){$/;"	f	file:
separateCache	.\src\pcache1.c	/^  int separateCache;             \/* Use a new PGroup for each PCache *\/$/;"	m	struct:PCacheGlobal	file:
seq	.\test\fuzzcheck.c	/^  int seq;                \/* Sequence number *\/$/;"	m	struct:Blob	file:
seqCount	.\src\vdbeInt.h	/^  i64 seqCount;         \/* Sequence counter *\/$/;"	m	struct:VdbeCursor
serialGet	.\src\vdbeaux.c	/^static u32 SQLITE_NOINLINE serialGet($/;"	f	file:
seriesBestIndex	.\ext\misc\series.c	/^static int seriesBestIndex($/;"	f	file:
seriesClose	.\ext\misc\series.c	/^static int seriesClose(sqlite3_vtab_cursor *cur){$/;"	f	file:
seriesColumn	.\ext\misc\series.c	/^static int seriesColumn($/;"	f	file:
seriesConnect	.\ext\misc\series.c	/^static int seriesConnect($/;"	f	file:
seriesDisconnect	.\ext\misc\series.c	/^static int seriesDisconnect(sqlite3_vtab *pVtab){$/;"	f	file:
seriesEof	.\ext\misc\series.c	/^static int seriesEof(sqlite3_vtab_cursor *cur){$/;"	f	file:
seriesFilter	.\ext\misc\series.c	/^static int seriesFilter($/;"	f	file:
seriesModule	.\ext\misc\series.c	/^static sqlite3_module seriesModule = {$/;"	v	file:
seriesNext	.\ext\misc\series.c	/^static int seriesNext(sqlite3_vtab_cursor *cur){$/;"	f	file:
seriesOpen	.\ext\misc\series.c	/^static int seriesOpen(sqlite3_vtab *p, sqlite3_vtab_cursor **ppCursor){$/;"	f	file:
seriesRowid	.\ext\misc\series.c	/^static int seriesRowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid){$/;"	f	file:
series_cursor	.\ext\misc\series.c	/^struct series_cursor {$/;"	s	file:
series_cursor	.\ext\misc\series.c	/^typedef struct series_cursor series_cursor;$/;"	t	typeref:struct:series_cursor	file:
serverHalt	.\src\test_server.c	/^  volatile int serverHalt;      \/* Server halts itself when true *\/$/;"	m	struct:ServerState	file:
serverMutex	.\src\test_server.c	/^  pthread_mutex_t serverMutex;  \/* Held by the server while it is running *\/$/;"	m	struct:ServerState	file:
serverWakeup	.\src\test_server.c	/^  pthread_cond_t serverWakeup;  \/* Signal this condvar to wake up the server *\/$/;"	m	struct:ServerState	file:
serverWrapper	.\src\test_server.c	/^static void *serverWrapper(void *pnDecr){$/;"	f	file:
setAlarm	.\test\fuzzcheck.c	/^static void setAlarm(int N){$/;"	f	file:
setAllColumnNames	.\src\pragma.c	/^static void setAllColumnNames($/;"	f	file:
setAllPagerFlags	.\src\pragma.c	/^static void setAllPagerFlags(sqlite3 *db){$/;"	f	file:
setAllPagerFlags	.\src\pragma.c	230;"	d	file:
setBinaryMode	.\src\shell.c	/^static void setBinaryMode(FILE *out){$/;"	f	file:
setBinaryMode	.\src\shell.c	155;"	d	file:
setChildPtrmaps	.\src\btree.c	/^static int setChildPtrmaps(MemPage *pPage){$/;"	f	file:
setChildPtrmaps	.\src\btree.c	3660;"	d	file:
setDateTimeToCurrent	.\src\date.c	/^static int setDateTimeToCurrent(sqlite3_context *context, DateTime *p){$/;"	f	file:
setDestPgsz	.\src\backup.c	/^static int setDestPgsz(sqlite3_backup *p){$/;"	f	file:
setEstimatedRows	.\ext\rtree\rtree.c	/^static void setEstimatedRows(sqlite3_index_info *pIdxInfo, i64 nRow){$/;"	f	file:
setJoinExpr	.\src\select.c	/^static void setJoinExpr(Expr *p, int iTable){$/;"	f	file:
setLikeOptFlag	.\src\func.c	/^static void setLikeOptFlag(sqlite3 *db, const char *zName, u8 flagVal){$/;"	f	file:
setMaster	.\src\pager.c	/^  u8 setMaster;               \/* True if a m-j name has been written to jrnl *\/$/;"	m	struct:Pager	file:
setOneColumnName	.\src\pragma.c	/^static void setOneColumnName(Vdbe *v, const char *z){$/;"	f	file:
setPageReferenced	.\src\btree.c	/^static void setPageReferenced(IntegrityCk *pCheck, Pgno iPg){$/;"	f	file:
setPendingFd	.\src\os_unix.c	/^static void setPendingFd(unixFile *pFile){$/;"	f	file:
setResultStrOrError	.\src\vdbeapi.c	/^static void setResultStrOrError($/;"	f	file:
setSectorSize	.\src\pager.c	/^static void setSectorSize(Pager *pPager){$/;"	f	file:
setSharedCacheTableLock	.\src\btree.c	/^static int setSharedCacheTableLock(Btree *p, Pgno iTable, u8 eLock){$/;"	f	file:
setSharedCacheTableLock	.\src\btree.c	108;"	d	file:
setStrAccumError	.\src\printf.c	/^static void setStrAccumError(StrAccum *p, u8 eError){$/;"	f	file:
setTestUnlockNotifyVars	.\src\tclsqlite.c	/^static void setTestUnlockNotifyVars(Tcl_Interp *interp, int iArg, int nArg){$/;"	f	file:
setTestUnlockNotifyVars	.\src\tclsqlite.c	670;"	d	file:
setTextMode	.\src\shell.c	/^static void setTextMode(FILE *out){$/;"	f	file:
setTextMode	.\src\shell.c	156;"	d	file:
set_authorizer	.\src\sqlite3ext.h	/^  int  (*set_authorizer)(sqlite3*,int(*)(void*,int,const char*,const char*,$/;"	m	struct:sqlite3_api_routines
set_auxdata	.\src\sqlite3ext.h	/^  void  (*set_auxdata)(sqlite3_context*,int,void*,void (*)(void*));$/;"	m	struct:sqlite3_api_routines
set_option_var	.\ext\rtree\viewrtree.tcl	/^proc set_option_var {args} {$/;"	p
set_options	.\src\test_config.c	/^static void set_options(Tcl_Interp *interp){$/;"	f	file:
set_table_name	.\src\shell.c	/^static void set_table_name(ShellState *p, const char *zName){$/;"	f	file:
set_test_counter	.\test\tester.tcl	/^  proc set_test_counter {counter args} {$/;"	p
set_vcvarsall_done	.\tool\build-all-msvc.bat	/^:set_vcvarsall_done$/;"	l
set_vcvarsall_phone	.\tool\build-all-msvc.bat	/^:set_vcvarsall_phone$/;"	l
setstoptime	.\test\threadtest3.c	59;"	d	file:
setstoptime_x	.\test\threadtest3.c	/^static void setstoptime_x($/;"	f	file:
setupLookaside	.\src\main.c	/^static int setupLookaside(sqlite3 *db, void *pBuf, int sz, int cnt){$/;"	f	file:
sharable	.\src\btreeInt.h	/^  u8 sharable;       \/* True if we can share pBt with another db *\/$/;"	m	struct:Btree
shared	.\src\os_win.c	/^  winceLock *shared;      \/* Global shared lock memory for the file  *\/$/;"	m	struct:winFile	file:
sharedByte	.\src\os_unix.c	/^  unsigned long long sharedByte;  \/* for AFP simulated shared lock *\/$/;"	m	struct:unixInodeInfo	file:
sharedCacheEnabled	.\src\sqliteInt.h	/^  int sharedCacheEnabled;           \/* true if shared-cache mode enabled *\/$/;"	m	struct:Sqlite3Config
sharedLockByte	.\src\os_win.c	/^  short sharedLockByte;   \/* Randomly chosen byte used as a shared lock *\/$/;"	m	struct:winFile	file:
sharedMask	.\src\os_unix.c	/^  u16 sharedMask;            \/* Mask of shared locks held *\/$/;"	m	struct:unixShm	file:
sharedMask	.\src\os_unix.c	/^  u8 sharedMask;             \/* Mask of shared locks held *\/$/;"	m	struct:unixShmNode	file:
sharedMask	.\src\os_win.c	/^  u16 sharedMask;            \/* Mask of shared locks held *\/$/;"	m	struct:winShm	file:
sharedlock	.\src\test_vfs.c	/^  u32 sharedlock;                 \/* Mask of shared locks *\/$/;"	m	struct:TestvfsFd	file:
shellDatabaseError	.\src\shell.c	/^static int shellDatabaseError(sqlite3 *db){$/;"	f	file:
shellFlgs	.\src\shell.c	/^  unsigned shellFlgs;    \/* Various flags *\/$/;"	m	struct:ShellState	file:
shellLog	.\src\shell.c	/^static void shellLog(void *pArg, int iErrCode, const char *zMsg){$/;"	f	file:
shellLog	.\tool\fuzzershell.c	/^static void shellLog(void *pNotUsed, int iErrCode, const char *zMsg){$/;"	f	file:
shellLogNoop	.\tool\fuzzershell.c	/^static void shellLogNoop(void *pNotUsed, int iErrCode, const char *zMsg){$/;"	f	file:
shellNomemError	.\src\shell.c	/^static int shellNomemError(void){$/;"	f	file:
shell_add_history	.\src\shell.c	76;"	d	file:
shell_add_history	.\src\shell.c	85;"	d	file:
shell_callback	.\src\shell.c	/^static int shell_callback($/;"	f	file:
shell_dbinfo_command	.\src\shell.c	/^static int shell_dbinfo_command(ShellState *p, int nArg, char **azArg){$/;"	f	file:
shell_exec	.\src\shell.c	/^static int shell_exec($/;"	f	file:
shell_read_history	.\src\shell.c	77;"	d	file:
shell_read_history	.\src\shell.c	86;"	d	file:
shell_read_history	.\src\shell.c	93;"	d	file:
shell_readline	.\src\shell.c	80;"	d	file:
shell_readline	.\src\shell.c	89;"	d	file:
shell_stifle_history	.\src\shell.c	79;"	d	file:
shell_stifle_history	.\src\shell.c	88;"	d	file:
shell_stifle_history	.\src\shell.c	95;"	d	file:
shell_write_history	.\src\shell.c	78;"	d	file:
shell_write_history	.\src\shell.c	87;"	d	file:
shell_write_history	.\src\shell.c	94;"	d	file:
shellstaticFunc	.\src\shell.c	/^static void shellstaticFunc($/;"	f	file:
shmerr_injectinstall	.\test\malloc_common.tcl	/^proc shmerr_injectinstall {} {$/;"	p
shmerr_injectstart	.\test\malloc_common.tcl	/^proc shmerr_injectstart {persist iFail} {$/;"	p
shmerr_injectstop	.\test\malloc_common.tcl	/^proc shmerr_injectstop {} {$/;"	p
shmerr_injectuninstall	.\test\malloc_common.tcl	/^proc shmerr_injectuninstall {} {$/;"	p
showDoclist	.\ext\fts3\tool\fts3view.c	/^static void showDoclist(sqlite3 *db, const char *zTab){$/;"	f	file:
showHeader	.\src\shell.c	/^  int showHeader;        \/* True to show column names in List or Column mode *\/$/;"	m	struct:ShellState	file:
showHeader	.\src\shell.c	/^  int showHeader;     \/* The ".header" setting prior to ".explain on" *\/$/;"	m	struct:SavedModeInfo	file:
showHelp	.\test\fuzzcheck.c	/^static void showHelp(void){$/;"	f	file:
showHelp	.\tool\fuzzershell.c	/^static void showHelp(void){$/;"	f	file:
showHelp	.\tool\loadfts.c	/^static void showHelp(const char *zArgv0){$/;"	f	file:
showHelp	.\tool\logest.c	/^static void showHelp(const char *zArgv0){$/;"	f	file:
showHelp	.\tool\sqldiff.c	/^static void showHelp(void){$/;"	f	file:
showLocksInRange	.\tool\showlocks.c	/^static int showLocksInRange(int fd, off_t lwr, off_t upr){$/;"	f	file:
showPrecedenceConflict	.\tool\lemon.c	/^static int showPrecedenceConflict = 0;$/;"	v	file:
showSchema	.\ext\fts3\tool\fts3view.c	/^static void showSchema(sqlite3 *db, const char *zTab){$/;"	f	file:
showSegdirMap	.\ext\fts3\tool\fts3view.c	/^static void showSegdirMap(sqlite3 *db, const char *zTab){$/;"	f	file:
showSegment	.\ext\fts3\tool\fts3view.c	/^static void showSegment(sqlite3 *db, const char *zTab){$/;"	f	file:
showSegmentStats	.\ext\fts3\tool\fts3view.c	/^static void showSegmentStats(sqlite3 *db, const char *zTab){$/;"	f	file:
showStat	.\ext\fts3\tool\fts3view.c	/^static void showStat(sqlite3 *db, const char *zTab){$/;"	f	file:
showVocabulary	.\ext\fts3\tool\fts3view.c	/^static void showVocabulary(sqlite3 *db, const char *zTab){$/;"	f	file:
show_memstats	.\test\tester.tcl	/^proc show_memstats {} {$/;"	p
sig	.\test\threadtest1.c	/^pthread_cond_t sig = PTHREAD_COND_INITIALIZER;$/;"	v
signed	.\src\parse.y	/^signed ::= minus_num.$/;"	l
signed	.\src\parse.y	/^signed ::= plus_num.$/;"	l
simpleClose	.\ext\fts1\fts1_tokenizer1.c	/^static int simpleClose(sqlite3_tokenizer_cursor *pCursor){$/;"	f	file:
simpleClose	.\ext\fts1\simple_tokenizer.c	/^static int simpleClose(sqlite3_tokenizer_cursor *pCursor){$/;"	f	file:
simpleClose	.\ext\fts2\fts2_tokenizer1.c	/^static int simpleClose(sqlite3_tokenizer_cursor *pCursor){$/;"	f	file:
simpleClose	.\ext\fts3\fts3_tokenizer1.c	/^static int simpleClose(sqlite3_tokenizer_cursor *pCursor){$/;"	f	file:
simpleCreate	.\ext\fts1\fts1_tokenizer1.c	/^static int simpleCreate($/;"	f	file:
simpleCreate	.\ext\fts1\simple_tokenizer.c	/^static int simpleCreate($/;"	f	file:
simpleCreate	.\ext\fts2\fts2_tokenizer1.c	/^static int simpleCreate($/;"	f	file:
simpleCreate	.\ext\fts3\fts3_tokenizer1.c	/^static int simpleCreate($/;"	f	file:
simpleDelim	.\ext\fts2\fts2_tokenizer1.c	/^static int simpleDelim(simple_tokenizer *t, unsigned char c){$/;"	f	file:
simpleDelim	.\ext\fts3\fts3_tokenizer1.c	/^static int simpleDelim(simple_tokenizer *t, unsigned char c){$/;"	f	file:
simpleDestroy	.\ext\fts1\fts1_tokenizer1.c	/^static int simpleDestroy(sqlite3_tokenizer *pTokenizer){$/;"	f	file:
simpleDestroy	.\ext\fts1\simple_tokenizer.c	/^static int simpleDestroy(sqlite3_tokenizer *pTokenizer){$/;"	f	file:
simpleDestroy	.\ext\fts2\fts2_tokenizer1.c	/^static int simpleDestroy(sqlite3_tokenizer *pTokenizer){$/;"	f	file:
simpleDestroy	.\ext\fts3\fts3_tokenizer1.c	/^static int simpleDestroy(sqlite3_tokenizer *pTokenizer){$/;"	f	file:
simpleNext	.\ext\fts1\fts1_tokenizer1.c	/^static int simpleNext($/;"	f	file:
simpleNext	.\ext\fts1\simple_tokenizer.c	/^static int simpleNext($/;"	f	file:
simpleNext	.\ext\fts2\fts2_tokenizer1.c	/^static int simpleNext($/;"	f	file:
simpleNext	.\ext\fts3\fts3_tokenizer1.c	/^static int simpleNext($/;"	f	file:
simpleOpen	.\ext\fts1\fts1_tokenizer1.c	/^static int simpleOpen($/;"	f	file:
simpleOpen	.\ext\fts1\simple_tokenizer.c	/^static int simpleOpen($/;"	f	file:
simpleOpen	.\ext\fts2\fts2_tokenizer1.c	/^static int simpleOpen($/;"	f	file:
simpleOpen	.\ext\fts3\fts3_tokenizer1.c	/^static int simpleOpen($/;"	f	file:
simpleTokenizerModule	.\ext\fts1\fts1_tokenizer1.c	/^static const sqlite3_tokenizer_module simpleTokenizerModule = {$/;"	v	file:
simpleTokenizerModule	.\ext\fts1\fts1_tokenizer1.c	/^static const sqlite3_tokenizer_module simpleTokenizerModule;$/;"	v	file:
simpleTokenizerModule	.\ext\fts1\simple_tokenizer.c	/^static sqlite3_tokenizer_module simpleTokenizerModule = {$/;"	v	file:
simpleTokenizerModule	.\ext\fts1\simple_tokenizer.c	/^static sqlite3_tokenizer_module simpleTokenizerModule;\/* forward declaration *\/$/;"	v	file:
simpleTokenizerModule	.\ext\fts2\fts2_tokenizer1.c	/^static const sqlite3_tokenizer_module simpleTokenizerModule = {$/;"	v	file:
simpleTokenizerModule	.\ext\fts2\fts2_tokenizer1.c	/^static const sqlite3_tokenizer_module simpleTokenizerModule;$/;"	v	file:
simpleTokenizerModule	.\ext\fts3\fts3_tokenizer1.c	/^static const sqlite3_tokenizer_module simpleTokenizerModule = {$/;"	v	file:
simple_tokenizer	.\ext\fts1\fts1_tokenizer1.c	/^typedef struct simple_tokenizer {$/;"	s	file:
simple_tokenizer	.\ext\fts1\fts1_tokenizer1.c	/^} simple_tokenizer;$/;"	t	typeref:struct:simple_tokenizer	file:
simple_tokenizer	.\ext\fts1\simple_tokenizer.c	/^typedef struct simple_tokenizer {$/;"	s	file:
simple_tokenizer	.\ext\fts1\simple_tokenizer.c	/^} simple_tokenizer;$/;"	t	typeref:struct:simple_tokenizer	file:
simple_tokenizer	.\ext\fts2\fts2_tokenizer1.c	/^typedef struct simple_tokenizer {$/;"	s	file:
simple_tokenizer	.\ext\fts2\fts2_tokenizer1.c	/^} simple_tokenizer;$/;"	t	typeref:struct:simple_tokenizer	file:
simple_tokenizer	.\ext\fts3\fts3_tokenizer1.c	/^typedef struct simple_tokenizer {$/;"	s	file:
simple_tokenizer	.\ext\fts3\fts3_tokenizer1.c	/^} simple_tokenizer;$/;"	t	typeref:struct:simple_tokenizer	file:
simple_tokenizer_cursor	.\ext\fts1\fts1_tokenizer1.c	/^typedef struct simple_tokenizer_cursor {$/;"	s	file:
simple_tokenizer_cursor	.\ext\fts1\fts1_tokenizer1.c	/^} simple_tokenizer_cursor;$/;"	t	typeref:struct:simple_tokenizer_cursor	file:
simple_tokenizer_cursor	.\ext\fts1\simple_tokenizer.c	/^typedef struct simple_tokenizer_cursor {$/;"	s	file:
simple_tokenizer_cursor	.\ext\fts1\simple_tokenizer.c	/^} simple_tokenizer_cursor;$/;"	t	typeref:struct:simple_tokenizer_cursor	file:
simple_tokenizer_cursor	.\ext\fts2\fts2_tokenizer1.c	/^typedef struct simple_tokenizer_cursor {$/;"	s	file:
simple_tokenizer_cursor	.\ext\fts2\fts2_tokenizer1.c	/^} simple_tokenizer_cursor;$/;"	t	typeref:struct:simple_tokenizer_cursor	file:
simple_tokenizer_cursor	.\ext\fts3\fts3_tokenizer1.c	/^typedef struct simple_tokenizer_cursor {$/;"	s	file:
simple_tokenizer_cursor	.\ext\fts3\fts3_tokenizer1.c	/^} simple_tokenizer_cursor;$/;"	t	typeref:struct:simple_tokenizer_cursor	file:
simulateVtabError	.\src\test8.c	/^static int simulateVtabError(echo_vtab *p, const char *zMethod){$/;"	f	file:
size	.\tool\lemon.c	/^  int size;               \/* The number of available slots. *\/$/;"	m	struct:s_x1	file:
size	.\tool\lemon.c	/^  int size;               \/* The number of available slots. *\/$/;"	m	struct:s_x2	file:
size	.\tool\lemon.c	/^  int size;               \/* The number of available slots. *\/$/;"	m	struct:s_x3	file:
size	.\tool\lemon.c	/^  int size;               \/* The number of available slots. *\/$/;"	m	struct:s_x4	file:
size	.\tool\lemon.c	/^static int size = 0;$/;"	v	file:
size4x	.\src\mem3.c	/^      u32 size4x;     \/* 4x the size of current chunk in Mem3Block elements *\/$/;"	m	struct:Mem3Block::__anon11::__anon12	file:
sjfd	.\src\pager.c	/^  sqlite3_file *sjfd;         \/* File descriptor for sub-journal *\/$/;"	m	struct:Pager	file:
skipDocument	.\ext\fts1\fts1.c	/^static void skipDocument(DocListReader *pReader){$/;"	f	file:
skipDocument	.\ext\fts1\fulltext.c	/^static void skipDocument(DocListReader *pReader){$/;"	f	file:
skipFlag	.\src\vdbeInt.h	/^  u8 skipFlag;            \/* Skip accumulator loading if true *\/$/;"	m	struct:sqlite3_context
skipNext	.\src\btreeInt.h	/^  int skipNext;    \/* Prev() is noop if negative. Next() is noop if positive.$/;"	m	struct:BtCursor
skipPositionList	.\ext\fts1\fts1.c	/^static void skipPositionList(DocListReader *pReader){$/;"	f	file:
skipPositionList	.\ext\fts1\fulltext.c	/^static void skipPositionList(DocListReader *pReader){$/;"	f	file:
skipToDocid	.\ext\fts1\fts1.c	/^static int skipToDocid(DocListReader *pReader, sqlite_int64 iDocid){$/;"	f	file:
slave_test_file	.\test\tester.tcl	/^proc slave_test_file {zFile} {$/;"	p
slave_test_script	.\test\tester.tcl	/^proc slave_test_script {script} {$/;"	p
sleep	.\src\sqlite3ext.h	/^  int (*sleep)(int);$/;"	m	struct:sqlite3_api_routines
sleepObj	.\src\os_win.c	/^static HANDLE sleepObj = NULL;$/;"	v	file:
snStatus	.\ext\fts1\fts1.c	/^    char snStatus;       \/* Status flag for use while constructing snippets *\/$/;"	m	struct:Snippet::snippetMatch	file:
snStatus	.\ext\fts2\fts2.c	/^    char snStatus;       \/* Status flag for use while constructing snippets *\/$/;"	m	struct:Snippet::snippetMatch	file:
snippet	.\ext\fts1\fts1.c	/^  Snippet snippet;                 \/* Cached snippet for the current row *\/$/;"	m	struct:fulltext_cursor	file:
snippet	.\ext\fts2\fts2.c	/^  Snippet snippet;                 \/* Cached snippet for the current row *\/$/;"	m	struct:fulltext_cursor	file:
snippetAllOffsets	.\ext\fts1\fts1.c	/^static void snippetAllOffsets(fulltext_cursor *p){$/;"	f	file:
snippetAllOffsets	.\ext\fts2\fts2.c	/^static void snippetAllOffsets(fulltext_cursor *p){$/;"	f	file:
snippetAppendMatch	.\ext\fts1\fts1.c	/^static void snippetAppendMatch($/;"	f	file:
snippetAppendMatch	.\ext\fts2\fts2.c	/^static void snippetAppendMatch($/;"	f	file:
snippetClear	.\ext\fts1\fts1.c	/^static void snippetClear(Snippet *p){$/;"	f	file:
snippetClear	.\ext\fts2\fts2.c	/^static void snippetClear(Snippet *p){$/;"	f	file:
snippetFunc	.\ext\fts1\fts1.c	/^static void snippetFunc($/;"	f	file:
snippetFunc	.\ext\fts2\fts2.c	/^static void snippetFunc($/;"	f	file:
snippetMatch	.\ext\fts1\fts1.c	/^  struct snippetMatch { \/* One entry for each matching term *\/$/;"	s	struct:Snippet	file:
snippetMatch	.\ext\fts2\fts2.c	/^  struct snippetMatch { \/* One entry for each matching term *\/$/;"	s	struct:Snippet	file:
snippetOffsetText	.\ext\fts1\fts1.c	/^static void snippetOffsetText(Snippet *p){$/;"	f	file:
snippetOffsetText	.\ext\fts2\fts2.c	/^static void snippetOffsetText(Snippet *p){$/;"	f	file:
snippetOffsetsFunc	.\ext\fts1\fts1.c	/^static void snippetOffsetsFunc($/;"	f	file:
snippetOffsetsFunc	.\ext\fts2\fts2.c	/^static void snippetOffsetsFunc($/;"	f	file:
snippetOffsetsOfColumn	.\ext\fts1\fts1.c	/^static void snippetOffsetsOfColumn($/;"	f	file:
snippetOffsetsOfColumn	.\ext\fts2\fts2.c	/^static void snippetOffsetsOfColumn($/;"	f	file:
snippetText	.\ext\fts1\fts1.c	/^static void snippetText($/;"	f	file:
snippetText	.\ext\fts2\fts2.c	/^static void snippetText($/;"	f	file:
snprintf	.\autoconf\tea\win\nmakehlp.c	38;"	d	file:
snprintf	.\src\sqlite3ext.h	/^  char * (*snprintf)(int,char*,const char*,...);$/;"	m	struct:sqlite3_api_routines
soft_heap_limit	.\src\sqlite3ext.h	/^  void (*soft_heap_limit)(int);$/;"	m	struct:sqlite3_api_routines
soft_heap_limit64	.\src\sqlite3ext.h	/^  sqlite3_int64 (*soft_heap_limit64)(sqlite3_int64);$/;"	m	struct:sqlite3_api_routines
sort	.\test\boundary1.tcl	/^proc sort {inlist} {$/;"	p
sort	.\test\boundary2.tcl	/^proc sort {inlist} {$/;"	p
sort	.\test\boundary3.tcl	/^proc sort {inlist} {$/;"	p
sort	.\test\boundary4.tcl	/^proc sort {inlist} {$/;"	p
sortFlags	.\src\select.c	/^  u8 sortFlags;         \/* Zero or more SORTFLAG_* bits *\/$/;"	m	struct:SortCtx	file:
sortOrder	.\src\sqliteInt.h	/^    u8 sortOrder;           \/* 1 for DESC or 0 for ASC *\/$/;"	m	struct:ExprList::ExprList_item
sort_cb	.\ext\fts5\mkportersteps.tcl	/^proc sort_cb {lhs rhs} {$/;"	p
sort_poslist	.\ext\fts5\test\fts5_common.tcl	/^proc sort_poslist {L} {$/;"	p
sorted	.\src\whereInt.h	/^  u8 sorted;                \/* True if really sorted (not just grouped) *\/$/;"	m	struct:WhereInfo
sorted	.\tool\lemon.c	/^  struct state **sorted;   \/* Table of states sorted by state number *\/$/;"	m	struct:lemon	typeref:struct:lemon::state	file:
sorter_test_fakeheap	.\src\test1.c	/^static int sorter_test_fakeheap($/;"	f	file:
sorter_test_sort4_helper	.\src\test1.c	/^static int sorter_test_sort4_helper($/;"	f	file:
sortingIdx	.\src\sqliteInt.h	/^  int sortingIdx;         \/* Cursor number of the sorting index *\/$/;"	m	struct:AggInfo
sortingIdxPTab	.\src\sqliteInt.h	/^  int sortingIdxPTab;     \/* Cursor number of pseudo-table *\/$/;"	m	struct:AggInfo
soundexFunc	.\src\func.c	/^static void soundexFunc($/;"	f	file:
sourceid	.\src\sqlite3ext.h	/^  const char *(*sourceid)(void);$/;"	m	struct:sqlite3_api_routines
sourceidFunc	.\src\func.c	/^static void sourceidFunc($/;"	f	file:
sp	.\tool\lemon.c	/^  struct symbol *sp;       \/* The look-ahead symbol *\/$/;"	m	struct:action	typeref:struct:action::symbol	file:
speed_trial	.\test\tester.tcl	/^proc speed_trial {name numstmt units sql} {$/;"	p
speed_trial_init	.\test\tester.tcl	/^proc speed_trial_init {name} {$/;"	p
speed_trial_summary	.\test\tester.tcl	/^proc speed_trial_summary {name} {$/;"	p
speed_trial_tcl	.\test\tester.tcl	/^proc speed_trial_tcl {name numstmt units script} {$/;"	p
speedtest1_begin_test	.\test\speedtest1.c	/^void speedtest1_begin_test(int iTestNum, const char *zTestName, ...){$/;"	f
speedtest1_end_test	.\test\speedtest1.c	/^void speedtest1_end_test(void){$/;"	f
speedtest1_exec	.\test\speedtest1.c	/^void speedtest1_exec(const char *zFormat, ...){$/;"	f
speedtest1_final	.\test\speedtest1.c	/^void speedtest1_final(void){$/;"	f
speedtest1_numbername	.\test\speedtest1.c	/^int speedtest1_numbername(unsigned int n, char *zOut, int nOut){$/;"	f
speedtest1_prepare	.\test\speedtest1.c	/^void speedtest1_prepare(const char *zFormat, ...){$/;"	f
speedtest1_random	.\test\speedtest1.c	/^unsigned int speedtest1_random(void){$/;"	f
speedtest1_run	.\test\speedtest1.c	/^void speedtest1_run(void){$/;"	f
speedtest1_shrink_memory	.\test\speedtest1.c	/^void speedtest1_shrink_memory(void){$/;"	f
speedtest1_timestamp	.\test\speedtest1.c	/^sqlite3_int64 speedtest1_timestamp(void){$/;"	f
spellfix1BestIndex	.\ext\misc\spellfix.c	/^static int spellfix1BestIndex(sqlite3_vtab *tab, sqlite3_index_info *pIdxInfo){$/;"	f	file:
spellfix1Close	.\ext\misc\spellfix.c	/^static int spellfix1Close(sqlite3_vtab_cursor *cur){$/;"	f	file:
spellfix1Column	.\ext\misc\spellfix.c	/^static int spellfix1Column($/;"	f	file:
spellfix1Connect	.\ext\misc\spellfix.c	/^static int spellfix1Connect($/;"	f	file:
spellfix1Create	.\ext\misc\spellfix.c	/^static int spellfix1Create($/;"	f	file:
spellfix1DbExec	.\ext\misc\spellfix.c	/^static void spellfix1DbExec($/;"	f	file:
spellfix1Dequote	.\ext\misc\spellfix.c	/^static char *spellfix1Dequote(const char *zIn){$/;"	f	file:
spellfix1Destroy	.\ext\misc\spellfix.c	/^static int spellfix1Destroy(sqlite3_vtab *pVTab){$/;"	f	file:
spellfix1Disconnect	.\ext\misc\spellfix.c	/^static int spellfix1Disconnect(sqlite3_vtab *pVTab){$/;"	f	file:
spellfix1Eof	.\ext\misc\spellfix.c	/^static int spellfix1Eof(sqlite3_vtab_cursor *cur){$/;"	f	file:
spellfix1Filter	.\ext\misc\spellfix.c	/^static int spellfix1Filter($/;"	f	file:
spellfix1FilterForFullScan	.\ext\misc\spellfix.c	/^static int spellfix1FilterForFullScan($/;"	f	file:
spellfix1FilterForMatch	.\ext\misc\spellfix.c	/^static int spellfix1FilterForMatch($/;"	f	file:
spellfix1GetConflict	.\ext\misc\spellfix.c	/^static const char *spellfix1GetConflict(sqlite3 *db){$/;"	f	file:
spellfix1Init	.\ext\misc\spellfix.c	/^static int spellfix1Init($/;"	f	file:
spellfix1Module	.\ext\misc\spellfix.c	/^static sqlite3_module spellfix1Module = {$/;"	v	file:
spellfix1Next	.\ext\misc\spellfix.c	/^static int spellfix1Next(sqlite3_vtab_cursor *cur){$/;"	f	file:
spellfix1Open	.\ext\misc\spellfix.c	/^static int spellfix1Open(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor){$/;"	f	file:
spellfix1Register	.\ext\misc\spellfix.c	/^static int spellfix1Register(sqlite3 *db){$/;"	f	file:
spellfix1Rename	.\ext\misc\spellfix.c	/^static int spellfix1Rename(sqlite3_vtab *pVTab, const char *zNew){$/;"	f	file:
spellfix1ResetCursor	.\ext\misc\spellfix.c	/^static void spellfix1ResetCursor(spellfix1_cursor *pCur){$/;"	f	file:
spellfix1ResizeCursor	.\ext\misc\spellfix.c	/^static void spellfix1ResizeCursor(spellfix1_cursor *pCur, int N){$/;"	f	file:
spellfix1RowCompare	.\ext\misc\spellfix.c	/^static int spellfix1RowCompare(const void *A, const void *B){$/;"	f	file:
spellfix1Rowid	.\ext\misc\spellfix.c	/^static int spellfix1Rowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid){$/;"	f	file:
spellfix1RunQuery	.\ext\misc\spellfix.c	/^static void spellfix1RunQuery(MatchQuery *p, const char *zQuery, int nQuery){$/;"	f	file:
spellfix1Score	.\ext\misc\spellfix.c	/^static int spellfix1Score(int iDistance, int iRank){$/;"	f	file:
spellfix1Uninit	.\ext\misc\spellfix.c	/^static int spellfix1Uninit(int isDestroy, sqlite3_vtab *pVTab){$/;"	f	file:
spellfix1Update	.\ext\misc\spellfix.c	/^static int spellfix1Update($/;"	f	file:
spellfix1_cursor	.\ext\misc\spellfix.c	/^struct spellfix1_cursor {$/;"	s	file:
spellfix1_cursor	.\ext\misc\spellfix.c	/^typedef struct spellfix1_cursor spellfix1_cursor;$/;"	t	typeref:struct:spellfix1_cursor	file:
spellfix1_row	.\ext\misc\spellfix.c	/^  struct spellfix1_row {       \/* For each row of content *\/$/;"	s	struct:spellfix1_cursor	file:
spellfix1_vtab	.\ext\misc\spellfix.c	/^struct spellfix1_vtab {$/;"	s	file:
spellfix1_vtab	.\ext\misc\spellfix.c	/^typedef struct spellfix1_vtab spellfix1_vtab;$/;"	t	typeref:struct:spellfix1_vtab	file:
splitNodeStartree	.\ext\rtree\rtree.c	/^static int splitNodeStartree($/;"	f	file:
sql	.\ext\fts3\fts3speed.tcl	/^proc sql {sql} {$/;"	p
sql	.\src\sqlite3ext.h	/^  const char *(*sql)(sqlite3_stmt*);$/;"	m	struct:sqlite3_api_routines
sql1	.\test\bc_common.tcl	/^  proc sql1 sql { code1 [list db eval $sql] }$/;"	p
sql1	.\test\lock_common.tcl	/^    proc sql1 {sql} { db eval $sql }$/;"	p
sql2	.\test\bc_common.tcl	/^  proc sql2 sql { code2 [list db eval $sql] }$/;"	p
sql2	.\test\lock_common.tcl	/^    proc sql2 {sql} { code2 [list db2 eval $sql] }$/;"	p
sql3	.\test\lock_common.tcl	/^    proc sql3 {sql} { code3 [list db3 eval $sql] }$/;"	p
sql36231	.\test\tester.tcl	/^proc sql36231 {sql} {$/;"	p
sqlErrorCallback	.\mptest\mptest.c	/^static void sqlErrorCallback(void *pArg, int iErrCode, const char *zMsg){$/;"	f	file:
sqlEvalFunc	.\ext\misc\eval.c	/^static void sqlEvalFunc($/;"	f	file:
sqlEvalFunc	.\tool\fuzzershell.c	/^static void sqlEvalFunc($/;"	f	file:
sqlTraceCallback	.\mptest\mptest.c	/^static void sqlTraceCallback(void *NotUsed1, const char *zSql){$/;"	f	file:
sql_exec	.\ext\fts1\fts1.c	/^static int sql_exec(sqlite3 *db, const char *zDb, const char *zName,$/;"	f	file:
sql_exec	.\ext\fts1\fulltext.c	/^static int sql_exec(sqlite3 *db, const char *zName, const char *zFormat){$/;"	f	file:
sql_exec	.\ext\fts2\fts2.c	/^static int sql_exec(sqlite3 *db, const char *zDb, const char *zName,$/;"	f	file:
sql_get_leaf_statement	.\ext\fts2\fts2.c	/^static int sql_get_leaf_statement(fulltext_vtab *v, int idx,$/;"	f	file:
sql_get_statement	.\ext\fts1\fts1.c	/^static int sql_get_statement(fulltext_vtab *v, fulltext_statement iStmt,$/;"	f	file:
sql_get_statement	.\ext\fts1\fulltext.c	/^static int sql_get_statement(fulltext_vtab *v, fulltext_statement iStmt,$/;"	f	file:
sql_get_statement	.\ext\fts2\fts2.c	/^static int sql_get_statement(fulltext_vtab *v, fulltext_statement iStmt,$/;"	f	file:
sql_prepare	.\ext\fts1\fts1.c	/^static int sql_prepare(sqlite3 *db, const char *zDb, const char *zName,$/;"	f	file:
sql_prepare	.\ext\fts1\fulltext.c	/^static int sql_prepare(sqlite3 *db, const char *zName, sqlite3_stmt **ppStmt,$/;"	f	file:
sql_prepare	.\ext\fts2\fts2.c	/^static int sql_prepare(sqlite3 *db, const char *zDb, const char *zName,$/;"	f	file:
sql_script	.\test\threadtest3.c	45;"	d	file:
sql_script_printf	.\test\threadtest3.c	50;"	d	file:
sql_script_printf_x	.\test\threadtest3.c	/^static void sql_script_printf_x($/;"	f	file:
sql_script_x	.\test\threadtest3.c	/^static void sql_script_x($/;"	f	file:
sql_single_step	.\ext\fts2\fts2.c	/^static int sql_single_step(sqlite3_stmt *s){$/;"	f	file:
sql_single_step_statement	.\ext\fts1\fts1.c	/^static int sql_single_step_statement(fulltext_vtab *v,$/;"	f	file:
sql_single_step_statement	.\ext\fts1\fulltext.c	/^static int sql_single_step_statement(fulltext_vtab *v,$/;"	f	file:
sql_step_statement	.\ext\fts1\fts1.c	/^static int sql_step_statement(fulltext_vtab *v, fulltext_statement iStmt,$/;"	f	file:
sql_step_statement	.\ext\fts1\fulltext.c	/^static int sql_step_statement(fulltext_vtab *v, fulltext_statement iStmt,$/;"	f	file:
sql_trace_callback	.\src\shell.c	/^static void sql_trace_callback(void *pArg, const char *z){$/;"	f	file:
sql_uses_stmt	.\test\tester.tcl	/^proc sql_uses_stmt {db sql} {$/;"	p
sqlexec	.\tool\fuzzershell.c	/^static void sqlexec(sqlite3 *db, const char *zFormat, ...){$/;"	f	file:
sqlite3	.\src\sqliteInt.h	/^struct sqlite3 {$/;"	s
sqlite3	.\test\lock_common.tcl	/^      proc sqlite3 {args} {[info body sqlite3]}$/;"	p
sqlite3	.\test\tester.tcl	/^  proc sqlite3 {args} {$/;"	p
sqlite3AbsInt32	.\src\util.c	/^int sqlite3AbsInt32(int x){$/;"	f
sqlite3AddCheckConstraint	.\src\build.c	/^void sqlite3AddCheckConstraint($/;"	f
sqlite3AddCollateType	.\src\build.c	/^void sqlite3AddCollateType(Parse *pParse, Token *pToken){$/;"	f
sqlite3AddColumn	.\src\build.c	/^void sqlite3AddColumn(Parse *pParse, Token *pName){$/;"	f
sqlite3AddColumnType	.\src\build.c	/^void sqlite3AddColumnType(Parse *pParse, Token *pType){$/;"	f
sqlite3AddDefaultValue	.\src\build.c	/^void sqlite3AddDefaultValue(Parse *pParse, ExprSpan *pSpan){$/;"	f
sqlite3AddInt64	.\src\util.c	/^int sqlite3AddInt64(i64 *pA, i64 iB){$/;"	f
sqlite3AddNotNull	.\src\build.c	/^void sqlite3AddNotNull(Parse *pParse, int onError){$/;"	f
sqlite3AddPrimaryKey	.\src\build.c	/^void sqlite3AddPrimaryKey($/;"	f
sqlite3AffinityType	.\src\build.c	/^char sqlite3AffinityType(const char *zIn, u8 *pszEst){$/;"	f
sqlite3AllocateIndexObject	.\src\build.c	/^Index *sqlite3AllocateIndexObject($/;"	f
sqlite3AlterBeginAddColumn	.\src\alter.c	/^void sqlite3AlterBeginAddColumn(Parse *pParse, SrcList *pSrc){$/;"	f
sqlite3AlterFinishAddColumn	.\src\alter.c	/^void sqlite3AlterFinishAddColumn(Parse *pParse, Token *pColDef){$/;"	f
sqlite3AlterFunctions	.\src\alter.c	/^void sqlite3AlterFunctions(void){$/;"	f
sqlite3AlterRenameTable	.\src\alter.c	/^void sqlite3AlterRenameTable($/;"	f
sqlite3AnalysisLoad	.\src\analyze.c	/^int sqlite3AnalysisLoad(sqlite3 *db, int iDb){$/;"	f
sqlite3Analyze	.\src\analyze.c	/^void sqlite3Analyze(Parse *pParse, Token *pName1, Token *pName2){$/;"	f
sqlite3AnalyzeFunctions	.\src\vdbemem.c	/^void sqlite3AnalyzeFunctions(void){$/;"	f
sqlite3ApiExit	.\src\malloc.c	/^int sqlite3ApiExit(sqlite3* db, int rc){$/;"	f
sqlite3Apis	.\src\loadext.c	/^static const sqlite3_api_routines sqlite3Apis = {$/;"	v	file:
sqlite3Apis	.\src\loadext.c	/^static const sqlite3_api_routines sqlite3Apis;$/;"	v	file:
sqlite3AppendChar	.\src\printf.c	/^void sqlite3AppendChar(StrAccum *p, int N, char c){$/;"	f
sqlite3ArrayAllocate	.\src\build.c	/^void *sqlite3ArrayAllocate($/;"	f
sqlite3AtoF	.\src\util.c	/^int sqlite3AtoF(const char *z, double *pResult, int length, u8 enc){$/;"	f
sqlite3Atoi	.\src\util.c	/^int sqlite3Atoi(const char *z){$/;"	f
sqlite3Atoi64	.\src\util.c	/^int sqlite3Atoi64(const char *zNum, i64 *pNum, int length, u8 enc){$/;"	f
sqlite3Attach	.\src\attach.c	/^void sqlite3Attach(Parse *pParse, Expr *p, Expr *pDbname, Expr *pKey){$/;"	f
sqlite3AuthCheck	.\src\auth.c	/^int sqlite3AuthCheck($/;"	f
sqlite3AuthCheck	.\src\sqliteInt.h	3539;"	d
sqlite3AuthContextPop	.\src\auth.c	/^void sqlite3AuthContextPop(AuthContext *pContext){$/;"	f
sqlite3AuthContextPop	.\src\sqliteInt.h	3541;"	d
sqlite3AuthContextPush	.\src\auth.c	/^void sqlite3AuthContextPush($/;"	f
sqlite3AuthContextPush	.\src\sqliteInt.h	3540;"	d
sqlite3AuthRead	.\src\auth.c	/^void sqlite3AuthRead($/;"	f
sqlite3AuthRead	.\src\sqliteInt.h	3538;"	d
sqlite3AuthReadCol	.\src\auth.c	/^int sqlite3AuthReadCol($/;"	f
sqlite3AutoExtList	.\src\loadext.c	/^static SQLITE_WSD struct sqlite3AutoExtList {$/;"	s	file:
sqlite3AutoExtList	.\src\loadext.c	/^typedef struct sqlite3AutoExtList sqlite3AutoExtList;$/;"	t	typeref:struct:sqlite3AutoExtList	file:
sqlite3AutoLoadExtensions	.\src\loadext.c	/^void sqlite3AutoLoadExtensions(sqlite3 *db){$/;"	f
sqlite3Autoext	.\src\loadext.c	/^} sqlite3Autoext = { 0, 0 };$/;"	v	typeref:struct:sqlite3AutoExtList	file:
sqlite3AutoincrementBegin	.\src\insert.c	/^void sqlite3AutoincrementBegin(Parse *pParse){$/;"	f
sqlite3AutoincrementBegin	.\src\sqliteInt.h	3348;"	d
sqlite3AutoincrementEnd	.\src\insert.c	/^void sqlite3AutoincrementEnd(Parse *pParse){$/;"	f
sqlite3AutoincrementEnd	.\src\sqliteInt.h	3349;"	d
sqlite3BackupRestart	.\src\backup.c	/^void sqlite3BackupRestart(sqlite3_backup *pBackup){$/;"	f
sqlite3BackupUpdate	.\src\backup.c	/^void sqlite3BackupUpdate(sqlite3_backup *pBackup, Pgno iPage, const u8 *aData){$/;"	f
sqlite3BeginBenignMalloc	.\src\fault.c	/^void sqlite3BeginBenignMalloc(void){$/;"	f
sqlite3BeginBenignMalloc	.\src\sqliteInt.h	3849;"	d
sqlite3BeginBenignMalloc	.\src\test_func.c	159;"	d	file:
sqlite3BeginParse	.\src\build.c	/^void sqlite3BeginParse(Parse *pParse, int explainFlag){$/;"	f
sqlite3BeginTransaction	.\src\build.c	/^void sqlite3BeginTransaction(Parse *pParse, int type){$/;"	f
sqlite3BeginTrigger	.\src\trigger.c	/^void sqlite3BeginTrigger($/;"	f
sqlite3BeginWriteOperation	.\src\build.c	/^void sqlite3BeginWriteOperation(Parse *pParse, int setStatement, int iDb){$/;"	f
sqlite3BenignMallocHooks	.\src\fault.c	/^void sqlite3BenignMallocHooks($/;"	f
sqlite3BinaryCompareCollSeq	.\src\expr.c	/^CollSeq *sqlite3BinaryCompareCollSeq($/;"	f
sqlite3BitvecBuiltinTest	.\src\bitvec.c	/^int sqlite3BitvecBuiltinTest(int sz, int *aOp){$/;"	f
sqlite3BitvecClear	.\src\bitvec.c	/^void sqlite3BitvecClear(Bitvec *p, u32 i, void *pBuf){$/;"	f
sqlite3BitvecCreate	.\src\bitvec.c	/^Bitvec *sqlite3BitvecCreate(u32 iSize){$/;"	f
sqlite3BitvecDestroy	.\src\bitvec.c	/^void sqlite3BitvecDestroy(Bitvec *p){$/;"	f
sqlite3BitvecSet	.\src\bitvec.c	/^int sqlite3BitvecSet(Bitvec *p, u32 i){$/;"	f
sqlite3BitvecSize	.\src\bitvec.c	/^u32 sqlite3BitvecSize(Bitvec *p){$/;"	f
sqlite3BitvecTest	.\src\bitvec.c	/^int sqlite3BitvecTest(Bitvec *p, u32 i){$/;"	f
sqlite3BitvecTestNotNull	.\src\bitvec.c	/^int sqlite3BitvecTestNotNull(Bitvec *p, u32 i){$/;"	f
sqlite3BlobCompare	.\src\vdbeaux.c	/^static SQLITE_NOINLINE int sqlite3BlobCompare(const Mem *pB1, const Mem *pB2){$/;"	f	file:
sqlite3BlockedList	.\src\notify.c	/^static sqlite3 *SQLITE_WSD sqlite3BlockedList = 0;$/;"	v	file:
sqlite3BtreeBeginStmt	.\src\btree.c	/^int sqlite3BtreeBeginStmt(Btree *p, int iStatement){$/;"	f
sqlite3BtreeBeginTrans	.\src\btree.c	/^int sqlite3BtreeBeginTrans(Btree *p, int wrflag){$/;"	f
sqlite3BtreeCheckpoint	.\src\btree.c	/^int sqlite3BtreeCheckpoint(Btree *p, int eMode, int *pnLog, int *pnCkpt){$/;"	f
sqlite3BtreeClearCursor	.\src\btree.c	/^void sqlite3BtreeClearCursor(BtCursor *pCur){$/;"	f
sqlite3BtreeClearTable	.\src\btree.c	/^int sqlite3BtreeClearTable(Btree *p, int iTable, int *pnChange){$/;"	f
sqlite3BtreeClearTableOfCursor	.\src\btree.c	/^int sqlite3BtreeClearTableOfCursor(BtCursor *pCur){$/;"	f
sqlite3BtreeClose	.\src\btree.c	/^int sqlite3BtreeClose(Btree *p){$/;"	f
sqlite3BtreeCloseCursor	.\src\btree.c	/^int sqlite3BtreeCloseCursor(BtCursor *pCur){$/;"	f
sqlite3BtreeCommit	.\src\btree.c	/^int sqlite3BtreeCommit(Btree *p){$/;"	f
sqlite3BtreeCommitPhaseOne	.\src\btree.c	/^int sqlite3BtreeCommitPhaseOne(Btree *p, const char *zMaster){$/;"	f
sqlite3BtreeCommitPhaseTwo	.\src\btree.c	/^int sqlite3BtreeCommitPhaseTwo(Btree *p, int bCleanup){$/;"	f
sqlite3BtreeCopyFile	.\src\backup.c	/^int sqlite3BtreeCopyFile(Btree *pTo, Btree *pFrom){$/;"	f
sqlite3BtreeCount	.\src\btree.c	/^int sqlite3BtreeCount(BtCursor *pCur, i64 *pnEntry){$/;"	f
sqlite3BtreeCreateTable	.\src\btree.c	/^int sqlite3BtreeCreateTable(Btree *p, int *piTable, int flags){$/;"	f
sqlite3BtreeCursor	.\src\btree.c	/^int sqlite3BtreeCursor($/;"	f
sqlite3BtreeCursorHasHint	.\src\btree.c	/^int sqlite3BtreeCursorHasHint(BtCursor *pCsr, unsigned int mask){$/;"	f
sqlite3BtreeCursorHasMoved	.\src\btree.c	/^int sqlite3BtreeCursorHasMoved(BtCursor *pCur){$/;"	f
sqlite3BtreeCursorHints	.\src\btree.c	/^void sqlite3BtreeCursorHints(BtCursor *pCsr, unsigned int mask){$/;"	f
sqlite3BtreeCursorIsValid	.\src\btree.c	/^int sqlite3BtreeCursorIsValid(BtCursor *pCur){$/;"	f
sqlite3BtreeCursorList	.\src\test_btree.c	/^void sqlite3BtreeCursorList(Btree *p){$/;"	f
sqlite3BtreeCursorRestore	.\src\btree.c	/^int sqlite3BtreeCursorRestore(BtCursor *pCur, int *pDifferentRow){$/;"	f
sqlite3BtreeCursorSize	.\src\btree.c	/^int sqlite3BtreeCursorSize(void){$/;"	f
sqlite3BtreeCursorZero	.\src\btree.c	/^void sqlite3BtreeCursorZero(BtCursor *p){$/;"	f
sqlite3BtreeData	.\src\btree.c	/^int sqlite3BtreeData(BtCursor *pCur, u32 offset, u32 amt, void *pBuf){$/;"	f
sqlite3BtreeDataFetch	.\src\btree.c	/^const void *sqlite3BtreeDataFetch(BtCursor *pCur, u32 *pAmt){$/;"	f
sqlite3BtreeDataSize	.\src\btree.c	/^int sqlite3BtreeDataSize(BtCursor *pCur, u32 *pSize){$/;"	f
sqlite3BtreeDelete	.\src\btree.c	/^int sqlite3BtreeDelete(BtCursor *pCur, int bPreserve){$/;"	f
sqlite3BtreeDropTable	.\src\btree.c	/^int sqlite3BtreeDropTable(Btree *p, int iTable, int *piMoved){$/;"	f
sqlite3BtreeEnter	.\src\btmutex.c	/^void sqlite3BtreeEnter(Btree *p){$/;"	f
sqlite3BtreeEnter	.\src\btree.h	244;"	d
sqlite3BtreeEnterAll	.\src\btmutex.c	/^void sqlite3BtreeEnterAll(sqlite3 *db){$/;"	f
sqlite3BtreeEnterAll	.\src\btree.h	245;"	d
sqlite3BtreeEnterCursor	.\src\btmutex.c	/^void sqlite3BtreeEnterCursor(BtCursor *pCur){$/;"	f
sqlite3BtreeEnterCursor	.\src\btree.h	264;"	d
sqlite3BtreeEof	.\src\btree.c	/^int sqlite3BtreeEof(BtCursor *pCur){$/;"	f
sqlite3BtreeFirst	.\src\btree.c	/^int sqlite3BtreeFirst(BtCursor *pCur, int *pRes){$/;"	f
sqlite3BtreeGetAutoVacuum	.\src\btree.c	/^int sqlite3BtreeGetAutoVacuum(Btree *p){$/;"	f
sqlite3BtreeGetFilename	.\src\btree.c	/^const char *sqlite3BtreeGetFilename(Btree *p){$/;"	f
sqlite3BtreeGetJournalname	.\src\btree.c	/^const char *sqlite3BtreeGetJournalname(Btree *p){$/;"	f
sqlite3BtreeGetMeta	.\src\btree.c	/^void sqlite3BtreeGetMeta(Btree *p, int idx, u32 *pMeta){$/;"	f
sqlite3BtreeGetOptimalReserve	.\src\btree.c	/^int sqlite3BtreeGetOptimalReserve(Btree *p){$/;"	f
sqlite3BtreeGetPageSize	.\src\btree.c	/^int sqlite3BtreeGetPageSize(Btree *p){$/;"	f
sqlite3BtreeGetReserveNoMutex	.\src\btree.c	/^int sqlite3BtreeGetReserveNoMutex(Btree *p){$/;"	f
sqlite3BtreeHoldsAllMutexes	.\src\btmutex.c	/^int sqlite3BtreeHoldsAllMutexes(sqlite3 *db){$/;"	f
sqlite3BtreeHoldsAllMutexes	.\src\btree.h	269;"	d
sqlite3BtreeHoldsMutex	.\src\btmutex.c	/^int sqlite3BtreeHoldsMutex(Btree *p){$/;"	f
sqlite3BtreeHoldsMutex	.\src\btree.h	268;"	d
sqlite3BtreeIncrVacuum	.\src\btree.c	/^int sqlite3BtreeIncrVacuum(Btree *p){$/;"	f
sqlite3BtreeIncrblobCursor	.\src\btree.c	/^void sqlite3BtreeIncrblobCursor(BtCursor *pCur){$/;"	f
sqlite3BtreeInsert	.\src\btree.c	/^int sqlite3BtreeInsert($/;"	f
sqlite3BtreeIntegrityCheck	.\src\btree.c	/^char *sqlite3BtreeIntegrityCheck($/;"	f
sqlite3BtreeIsInBackup	.\src\btree.c	/^int sqlite3BtreeIsInBackup(Btree *p){$/;"	f
sqlite3BtreeIsInReadTrans	.\src\btree.c	/^int sqlite3BtreeIsInReadTrans(Btree *p){$/;"	f
sqlite3BtreeIsInTrans	.\src\btree.c	/^int sqlite3BtreeIsInTrans(Btree *p){$/;"	f
sqlite3BtreeIsReadonly	.\src\btree.c	/^int sqlite3BtreeIsReadonly(Btree *p){$/;"	f
sqlite3BtreeKey	.\src\btree.c	/^int sqlite3BtreeKey(BtCursor *pCur, u32 offset, u32 amt, void *pBuf){$/;"	f
sqlite3BtreeKeyFetch	.\src\btree.c	/^const void *sqlite3BtreeKeyFetch(BtCursor *pCur, u32 *pAmt){$/;"	f
sqlite3BtreeKeySize	.\src\btree.c	/^int sqlite3BtreeKeySize(BtCursor *pCur, i64 *pSize){$/;"	f
sqlite3BtreeLast	.\src\btree.c	/^int sqlite3BtreeLast(BtCursor *pCur, int *pRes){$/;"	f
sqlite3BtreeLastPage	.\src\btree.c	/^u32 sqlite3BtreeLastPage(Btree *p){$/;"	f
sqlite3BtreeLeave	.\src\btmutex.c	/^void sqlite3BtreeLeave(Btree *p){$/;"	f
sqlite3BtreeLeave	.\src\btree.h	263;"	d
sqlite3BtreeLeaveAll	.\src\btmutex.c	/^void sqlite3BtreeLeaveAll(sqlite3 *db){$/;"	f
sqlite3BtreeLeaveAll	.\src\btree.h	266;"	d
sqlite3BtreeLeaveCursor	.\src\btmutex.c	/^void sqlite3BtreeLeaveCursor(BtCursor *pCur){$/;"	f
sqlite3BtreeLeaveCursor	.\src\btree.h	265;"	d
sqlite3BtreeLockTable	.\src\btree.c	/^int sqlite3BtreeLockTable(Btree *p, int iTab, u8 isWriteLock){$/;"	f
sqlite3BtreeMaxPageCount	.\src\btree.c	/^int sqlite3BtreeMaxPageCount(Btree *p, int mxPage){$/;"	f
sqlite3BtreeMovetoUnpacked	.\src\btree.c	/^int sqlite3BtreeMovetoUnpacked($/;"	f
sqlite3BtreeNewDb	.\src\btree.c	/^int sqlite3BtreeNewDb(Btree *p){$/;"	f
sqlite3BtreeNext	.\src\btree.c	/^int sqlite3BtreeNext(BtCursor *pCur, int *pRes){$/;"	f
sqlite3BtreeOpen	.\src\btree.c	/^int sqlite3BtreeOpen($/;"	f
sqlite3BtreePager	.\src\btree.c	/^Pager *sqlite3BtreePager(Btree *p){$/;"	f
sqlite3BtreePrevious	.\src\btree.c	/^int sqlite3BtreePrevious(BtCursor *pCur, int *pRes){$/;"	f
sqlite3BtreePutData	.\src\btree.c	/^int sqlite3BtreePutData(BtCursor *pCsr, u32 offset, u32 amt, void *z){$/;"	f
sqlite3BtreeRollback	.\src\btree.c	/^int sqlite3BtreeRollback(Btree *p, int tripCode, int writeOnly){$/;"	f
sqlite3BtreeSavepoint	.\src\btree.c	/^int sqlite3BtreeSavepoint(Btree *p, int op, int iSavepoint){$/;"	f
sqlite3BtreeSchema	.\src\btree.c	/^void *sqlite3BtreeSchema(Btree *p, int nBytes, void(*xFree)(void *)){$/;"	f
sqlite3BtreeSchemaLocked	.\src\btree.c	/^int sqlite3BtreeSchemaLocked(Btree *p){$/;"	f
sqlite3BtreeSecureDelete	.\src\btree.c	/^int sqlite3BtreeSecureDelete(Btree *p, int newFlag){$/;"	f
sqlite3BtreeSetAutoVacuum	.\src\btree.c	/^int sqlite3BtreeSetAutoVacuum(Btree *p, int autoVacuum){$/;"	f
sqlite3BtreeSetCacheSize	.\src\btree.c	/^int sqlite3BtreeSetCacheSize(Btree *p, int mxPage){$/;"	f
sqlite3BtreeSetMmapLimit	.\src\btree.c	/^int sqlite3BtreeSetMmapLimit(Btree *p, sqlite3_int64 szMmap){$/;"	f
sqlite3BtreeSetPageSize	.\src\btree.c	/^int sqlite3BtreeSetPageSize(Btree *p, int pageSize, int nReserve, int iFix){$/;"	f
sqlite3BtreeSetPagerFlags	.\src\btree.c	/^int sqlite3BtreeSetPagerFlags($/;"	f
sqlite3BtreeSetVersion	.\src\btree.c	/^int sqlite3BtreeSetVersion(Btree *pBtree, int iVersion){$/;"	f
sqlite3BtreeSharable	.\src\btmutex.c	/^int sqlite3BtreeSharable(Btree *p){$/;"	f
sqlite3BtreeSharable	.\src\btree.h	262;"	d
sqlite3BtreeSharedCacheReport	.\src\test_btree.c	/^int sqlite3BtreeSharedCacheReport($/;"	f
sqlite3BtreeSyncDisabled	.\src\btree.c	/^int sqlite3BtreeSyncDisabled(Btree *p){$/;"	f
sqlite3BtreeTripAllCursors	.\src\btree.c	/^int sqlite3BtreeTripAllCursors(Btree *pBtree, int errCode, int writeOnly){$/;"	f
sqlite3BtreeUpdateMeta	.\src\btree.c	/^int sqlite3BtreeUpdateMeta(Btree *p, int idx, u32 iMeta){$/;"	f
sqlite3CantopenError	.\src\main.c	/^int sqlite3CantopenError(int lineno){$/;"	f
sqlite3ChangeCookie	.\src\build.c	/^void sqlite3ChangeCookie(Parse *pParse, int iDb){$/;"	f
sqlite3CheckCollSeq	.\src\callback.c	/^int sqlite3CheckCollSeq(Parse *pParse, CollSeq *pColl){$/;"	f
sqlite3CheckObjectName	.\src\build.c	/^int sqlite3CheckObjectName(Parse *pParse, const char *zName){$/;"	f
sqlite3Checkpoint	.\src\main.c	/^int sqlite3Checkpoint(sqlite3 *db, int iDb, int eMode, int *pnLog, int *pnCkpt){$/;"	f
sqlite3ClearStatTables	.\src\build.c	/^static void sqlite3ClearStatTables($/;"	f	file:
sqlite3ClearTempRegCache	.\src\expr.c	/^void sqlite3ClearTempRegCache(Parse *pParse){$/;"	f
sqlite3Close	.\src\main.c	/^static int sqlite3Close(sqlite3 *db, int forceZombie){$/;"	f	file:
sqlite3CloseExtensions	.\src\loadext.c	/^void sqlite3CloseExtensions(sqlite3 *db){$/;"	f
sqlite3CloseExtensions	.\src\sqliteInt.h	3731;"	d
sqlite3CloseSavepoints	.\src\main.c	/^void sqlite3CloseSavepoints(sqlite3 *db){$/;"	f
sqlite3CodeDropTable	.\src\build.c	/^void sqlite3CodeDropTable(Parse *pParse, Table *pTab, int iDb, int isView){$/;"	f
sqlite3CodeOnce	.\src\expr.c	/^int sqlite3CodeOnce(Parse *pParse){$/;"	f
sqlite3CodeRowTrigger	.\src\sqliteInt.h	3520;"	d
sqlite3CodeRowTrigger	.\src\trigger.c	/^void sqlite3CodeRowTrigger($/;"	f
sqlite3CodeRowTriggerDirect	.\src\sqliteInt.h	3521;"	d
sqlite3CodeRowTriggerDirect	.\src\trigger.c	/^void sqlite3CodeRowTriggerDirect($/;"	f
sqlite3CodeSubselect	.\src\expr.c	/^int sqlite3CodeSubselect($/;"	f
sqlite3CodeVerifyNamedSchema	.\src\build.c	/^void sqlite3CodeVerifyNamedSchema(Parse *pParse, const char *zDb){$/;"	f
sqlite3CodeVerifySchema	.\src\build.c	/^void sqlite3CodeVerifySchema(Parse *pParse, int iDb){$/;"	f
sqlite3CollapseDatabaseArray	.\src\build.c	/^void sqlite3CollapseDatabaseArray(sqlite3 *db){$/;"	f
sqlite3ColumnDefault	.\src\update.c	/^void sqlite3ColumnDefault(Vdbe *v, Table *pTab, int i, int iReg){$/;"	f
sqlite3ColumnOfIndex	.\src\build.c	/^i16 sqlite3ColumnOfIndex(Index *pIdx, i16 iCol){$/;"	f
sqlite3ColumnsFromExprList	.\src\select.c	/^int sqlite3ColumnsFromExprList($/;"	f
sqlite3CommitInternalChanges	.\src\build.c	/^void sqlite3CommitInternalChanges(sqlite3 *db){$/;"	f
sqlite3CommitTransaction	.\src\build.c	/^void sqlite3CommitTransaction(Parse *pParse){$/;"	f
sqlite3CompareAffinity	.\src\expr.c	/^char sqlite3CompareAffinity(Expr *pExpr, char aff2){$/;"	f
sqlite3CompleteInsertion	.\src\insert.c	/^void sqlite3CompleteInsertion($/;"	f
sqlite3Config	.\src\global.c	/^SQLITE_WSD struct Sqlite3Config sqlite3Config = {$/;"	v	typeref:struct:Sqlite3Config
sqlite3ConnectionBlocked	.\src\notify.c	/^void sqlite3ConnectionBlocked(sqlite3 *db, sqlite3 *pBlocker){$/;"	f
sqlite3ConnectionBlocked	.\src\sqliteInt.h	3900;"	d
sqlite3ConnectionClosed	.\src\notify.c	/^void sqlite3ConnectionClosed(sqlite3 *db){$/;"	f
sqlite3ConnectionClosed	.\src\sqliteInt.h	3902;"	d
sqlite3ConnectionUnlocked	.\src\notify.c	/^void sqlite3ConnectionUnlocked(sqlite3 *db){$/;"	f
sqlite3ConnectionUnlocked	.\src\sqliteInt.h	3901;"	d
sqlite3CorruptError	.\src\main.c	/^int sqlite3CorruptError(int lineno){$/;"	f
sqlite3Coverage	.\src\util.c	/^void sqlite3Coverage(int x){$/;"	f
sqlite3CrashTestEnable	.\src\test6.c	/^static int sqlite3CrashTestEnable = 0;$/;"	v	file:
sqlite3CreateColumnExpr	.\src\resolve.c	/^Expr *sqlite3CreateColumnExpr(sqlite3 *db, SrcList *pSrc, int iSrc, int iCol){$/;"	f
sqlite3CreateForeignKey	.\src\build.c	/^void sqlite3CreateForeignKey($/;"	f
sqlite3CreateFunc	.\src\main.c	/^int sqlite3CreateFunc($/;"	f
sqlite3CreateIndex	.\src\build.c	/^Index *sqlite3CreateIndex($/;"	f
sqlite3CreateView	.\src\build.c	/^void sqlite3CreateView($/;"	f
sqlite3CryptFunc	.\ext\userauth\userauth.c	/^void sqlite3CryptFunc($/;"	f
sqlite3CtypeMap	.\src\global.c	/^const unsigned char sqlite3CtypeMap[256] = {$/;"	v
sqlite3DbFree	.\src\malloc.c	/^void sqlite3DbFree(sqlite3 *db, void *p){$/;"	f
sqlite3DbMallocRaw	.\src\malloc.c	/^void *sqlite3DbMallocRaw(sqlite3 *db, u64 n){$/;"	f
sqlite3DbMallocSize	.\src\malloc.c	/^int sqlite3DbMallocSize(sqlite3 *db, void *p){$/;"	f
sqlite3DbMallocZero	.\src\malloc.c	/^void *sqlite3DbMallocZero(sqlite3 *db, u64 n){$/;"	f
sqlite3DbMaskAllZero	.\src\build.c	/^int sqlite3DbMaskAllZero(yDbMask m){$/;"	f
sqlite3DbNameToBtree	.\src\main.c	/^Btree *sqlite3DbNameToBtree(sqlite3 *db, const char *zDbName){$/;"	f
sqlite3DbRealloc	.\src\malloc.c	/^void *sqlite3DbRealloc(sqlite3 *db, void *p, u64 n){$/;"	f
sqlite3DbReallocOrFree	.\src\malloc.c	/^void *sqlite3DbReallocOrFree(sqlite3 *db, void *p, u64 n){$/;"	f
sqlite3DbStrDup	.\src\malloc.c	/^char *sqlite3DbStrDup(sqlite3 *db, const char *z){$/;"	f
sqlite3DbStrNDup	.\src\malloc.c	/^char *sqlite3DbStrNDup(sqlite3 *db, const char *z, u64 n){$/;"	f
sqlite3DbstatRegister	.\src\dbstat.c	/^int sqlite3DbstatRegister(sqlite3 *db){ return SQLITE_OK; }$/;"	f
sqlite3DbstatRegister	.\src\dbstat.c	/^int sqlite3DbstatRegister(sqlite3 *db){$/;"	f
sqlite3DebugPrintf	.\src\printf.c	/^void sqlite3DebugPrintf(const char *zFormat, ...){$/;"	f
sqlite3DecOrHexToI64	.\src\util.c	/^int sqlite3DecOrHexToI64(const char *z, i64 *pOut){$/;"	f
sqlite3DefaultMutex	.\src\mutex_noop.c	/^sqlite3_mutex_methods const *sqlite3DefaultMutex(void){$/;"	f
sqlite3DefaultMutex	.\src\mutex_unix.c	/^sqlite3_mutex_methods const *sqlite3DefaultMutex(void){$/;"	f
sqlite3DefaultMutex	.\src\mutex_w32.c	/^sqlite3_mutex_methods const *sqlite3DefaultMutex(void){$/;"	f
sqlite3DefaultRowEst	.\src\build.c	/^void sqlite3DefaultRowEst(Index *pIdx){$/;"	f
sqlite3DeferForeignKey	.\src\build.c	/^void sqlite3DeferForeignKey(Parse *pParse, int isDeferred){$/;"	f
sqlite3DeleteColumnNames	.\src\build.c	/^void sqlite3DeleteColumnNames(sqlite3 *db, Table *pTable){$/;"	f
sqlite3DeleteFrom	.\src\delete.c	/^void sqlite3DeleteFrom($/;"	f
sqlite3DeleteIndexSamples	.\src\analyze.c	/^void sqlite3DeleteIndexSamples(sqlite3 *db, Index *pIdx){$/;"	f
sqlite3DeleteTable	.\src\build.c	/^void sqlite3DeleteTable(sqlite3 *db, Table *pTable){$/;"	f
sqlite3DeleteTrigger	.\src\sqliteInt.h	3517;"	d
sqlite3DeleteTrigger	.\src\trigger.c	/^void sqlite3DeleteTrigger(sqlite3 *db, Trigger *pTrigger){$/;"	f
sqlite3DeleteTriggerStep	.\src\trigger.c	/^void sqlite3DeleteTriggerStep(sqlite3 *db, TriggerStep *pTriggerStep){$/;"	f
sqlite3Dequote	.\src\util.c	/^int sqlite3Dequote(char *z){$/;"	f
sqlite3Detach	.\src\attach.c	/^void sqlite3Detach(Parse *pParse, Expr *pDbname){$/;"	f
sqlite3DropIndex	.\src\build.c	/^void sqlite3DropIndex(Parse *pParse, SrcList *pName, int ifExists){$/;"	f
sqlite3DropTable	.\src\build.c	/^void sqlite3DropTable(Parse *pParse, SrcList *pName, int isView, int noErr){$/;"	f
sqlite3DropTrigger	.\src\trigger.c	/^void sqlite3DropTrigger(Parse *pParse, SrcList *pName, int noErr){$/;"	f
sqlite3DropTriggerPtr	.\src\sqliteInt.h	3518;"	d
sqlite3DropTriggerPtr	.\src\trigger.c	/^void sqlite3DropTriggerPtr(Parse *pParse, Trigger *pTrigger){$/;"	f
sqlite3EndBenignMalloc	.\src\fault.c	/^void sqlite3EndBenignMalloc(void){$/;"	f
sqlite3EndBenignMalloc	.\src\sqliteInt.h	3850;"	d
sqlite3EndBenignMalloc	.\src\test_func.c	160;"	d	file:
sqlite3EndTable	.\src\build.c	/^void sqlite3EndTable($/;"	f
sqlite3ErrName	.\src\main.c	/^const char *sqlite3ErrName(int rc){$/;"	f
sqlite3ErrStr	.\src\main.c	/^const char *sqlite3ErrStr(int rc){$/;"	f
sqlite3Error	.\src\util.c	/^void sqlite3Error(sqlite3 *db, int err_code){$/;"	f
sqlite3ErrorMsg	.\src\util.c	/^void sqlite3ErrorMsg(Parse *pParse, const char *zFormat, ...){$/;"	f
sqlite3ErrorWithMsg	.\src\util.c	/^void sqlite3ErrorWithMsg(sqlite3 *db, int err_code, const char *zFormat, ...){$/;"	f
sqlite3ExecFunc	.\src\test1.c	/^static void sqlite3ExecFunc($/;"	f	file:
sqlite3ExpirePreparedStatements	.\src\vdbeaux.c	/^void sqlite3ExpirePreparedStatements(sqlite3 *db){$/;"	f
sqlite3Expr	.\src\expr.c	/^Expr *sqlite3Expr($/;"	f
sqlite3ExprAddCollateString	.\src\expr.c	/^Expr *sqlite3ExprAddCollateString(Parse *pParse, Expr *pExpr, const char *zC){$/;"	f
sqlite3ExprAddCollateToken	.\src\expr.c	/^Expr *sqlite3ExprAddCollateToken($/;"	f
sqlite3ExprAffinity	.\src\expr.c	/^char sqlite3ExprAffinity(Expr *pExpr){$/;"	f
sqlite3ExprAlloc	.\src\expr.c	/^Expr *sqlite3ExprAlloc($/;"	f
sqlite3ExprAnalyzeAggList	.\src\expr.c	/^void sqlite3ExprAnalyzeAggList(NameContext *pNC, ExprList *pList){$/;"	f
sqlite3ExprAnalyzeAggregates	.\src\expr.c	/^void sqlite3ExprAnalyzeAggregates(NameContext *pNC, Expr *pExpr){$/;"	f
sqlite3ExprAnd	.\src\expr.c	/^Expr *sqlite3ExprAnd(sqlite3 *db, Expr *pLeft, Expr *pRight){$/;"	f
sqlite3ExprAssignVarNumber	.\src\expr.c	/^void sqlite3ExprAssignVarNumber(Parse *pParse, Expr *pExpr){$/;"	f
sqlite3ExprAttachSubtrees	.\src\expr.c	/^void sqlite3ExprAttachSubtrees($/;"	f
sqlite3ExprCacheAffinityChange	.\src\expr.c	/^void sqlite3ExprCacheAffinityChange(Parse *pParse, int iStart, int iCount){$/;"	f
sqlite3ExprCacheClear	.\src\expr.c	/^void sqlite3ExprCacheClear(Parse *pParse){$/;"	f
sqlite3ExprCachePinRegister	.\src\expr.c	/^static void sqlite3ExprCachePinRegister(Parse *pParse, int iReg){$/;"	f	file:
sqlite3ExprCachePop	.\src\expr.c	/^void sqlite3ExprCachePop(Parse *pParse){$/;"	f
sqlite3ExprCachePush	.\src\expr.c	/^void sqlite3ExprCachePush(Parse *pParse){$/;"	f
sqlite3ExprCacheRemove	.\src\expr.c	/^void sqlite3ExprCacheRemove(Parse *pParse, int iReg, int nReg){$/;"	f
sqlite3ExprCacheStore	.\src\expr.c	/^void sqlite3ExprCacheStore(Parse *pParse, int iTab, int iCol, int iReg){$/;"	f
sqlite3ExprCanBeNull	.\src\expr.c	/^int sqlite3ExprCanBeNull(const Expr *p){$/;"	f
sqlite3ExprCheckHeight	.\src\expr.c	/^int sqlite3ExprCheckHeight(Parse *pParse, int nHeight){$/;"	f
sqlite3ExprCheckHeight	.\src\sqliteInt.h	3889;"	d
sqlite3ExprCode	.\src\expr.c	/^void sqlite3ExprCode(Parse *pParse, Expr *pExpr, int target){$/;"	f
sqlite3ExprCodeAndCache	.\src\expr.c	/^void sqlite3ExprCodeAndCache(Parse *pParse, Expr *pExpr, int target){$/;"	f
sqlite3ExprCodeAtInit	.\src\expr.c	/^void sqlite3ExprCodeAtInit($/;"	f
sqlite3ExprCodeExprList	.\src\expr.c	/^int sqlite3ExprCodeExprList($/;"	f
sqlite3ExprCodeFactorable	.\src\expr.c	/^void sqlite3ExprCodeFactorable(Parse *pParse, Expr *pExpr, int target){$/;"	f
sqlite3ExprCodeGetColumn	.\src\expr.c	/^int sqlite3ExprCodeGetColumn($/;"	f
sqlite3ExprCodeGetColumnOfTable	.\src\expr.c	/^void sqlite3ExprCodeGetColumnOfTable($/;"	f
sqlite3ExprCodeIN	.\src\expr.c	/^static void sqlite3ExprCodeIN($/;"	f	file:
sqlite3ExprCodeLoadIndexColumn	.\src\expr.c	/^void sqlite3ExprCodeLoadIndexColumn($/;"	f
sqlite3ExprCodeMove	.\src\expr.c	/^void sqlite3ExprCodeMove(Parse *pParse, int iFrom, int iTo, int nReg){$/;"	f
sqlite3ExprCodeTarget	.\src\expr.c	/^int sqlite3ExprCodeTarget(Parse *pParse, Expr *pExpr, int target){$/;"	f
sqlite3ExprCodeTemp	.\src\expr.c	/^int sqlite3ExprCodeTemp(Parse *pParse, Expr *pExpr, int *pReg){$/;"	f
sqlite3ExprCollSeq	.\src\expr.c	/^CollSeq *sqlite3ExprCollSeq(Parse *pParse, Expr *pExpr){$/;"	f
sqlite3ExprCompare	.\src\expr.c	/^int sqlite3ExprCompare(Expr *pA, Expr *pB, int iTab){$/;"	f
sqlite3ExprDelete	.\src\expr.c	/^void sqlite3ExprDelete(sqlite3 *db, Expr *p){$/;"	f
sqlite3ExprDup	.\src\expr.c	/^Expr *sqlite3ExprDup(sqlite3 *db, Expr *p, int flags){$/;"	f
sqlite3ExprFunction	.\src\expr.c	/^Expr *sqlite3ExprFunction(Parse *pParse, ExprList *pList, Token *pToken){$/;"	f
sqlite3ExprIfFalse	.\src\expr.c	/^void sqlite3ExprIfFalse(Parse *pParse, Expr *pExpr, int dest, int jumpIfNull){$/;"	f
sqlite3ExprIfFalseDup	.\src\expr.c	/^void sqlite3ExprIfFalseDup(Parse *pParse, Expr *pExpr, int dest,int jumpIfNull){$/;"	f
sqlite3ExprIfTrue	.\src\expr.c	/^void sqlite3ExprIfTrue(Parse *pParse, Expr *pExpr, int dest, int jumpIfNull){$/;"	f
sqlite3ExprImpliesExpr	.\src\expr.c	/^int sqlite3ExprImpliesExpr(Expr *pE1, Expr *pE2, int iTab){$/;"	f
sqlite3ExprIsConstant	.\src\expr.c	/^int sqlite3ExprIsConstant(Expr *p){$/;"	f
sqlite3ExprIsConstantNotJoin	.\src\expr.c	/^int sqlite3ExprIsConstantNotJoin(Expr *p){$/;"	f
sqlite3ExprIsConstantOrFunction	.\src\expr.c	/^int sqlite3ExprIsConstantOrFunction(Expr *p, u8 isInit){$/;"	f
sqlite3ExprIsInteger	.\src\expr.c	/^int sqlite3ExprIsInteger(Expr *p, int *pValue){$/;"	f
sqlite3ExprIsTableConstant	.\src\expr.c	/^int sqlite3ExprIsTableConstant(Expr *p, int iCur){$/;"	f
sqlite3ExprListAppend	.\src\expr.c	/^ExprList *sqlite3ExprListAppend($/;"	f
sqlite3ExprListCheckLength	.\src\expr.c	/^void sqlite3ExprListCheckLength($/;"	f
sqlite3ExprListCompare	.\src\expr.c	/^int sqlite3ExprListCompare(ExprList *pA, ExprList *pB, int iTab){$/;"	f
sqlite3ExprListDelete	.\src\expr.c	/^void sqlite3ExprListDelete(sqlite3 *db, ExprList *pList){$/;"	f
sqlite3ExprListDup	.\src\expr.c	/^ExprList *sqlite3ExprListDup(sqlite3 *db, ExprList *p, int flags){$/;"	f
sqlite3ExprListFlags	.\src\expr.c	/^u32 sqlite3ExprListFlags(const ExprList *pList){$/;"	f
sqlite3ExprListSetName	.\src\expr.c	/^void sqlite3ExprListSetName($/;"	f
sqlite3ExprListSetSortOrder	.\src\expr.c	/^void sqlite3ExprListSetSortOrder(ExprList *p, int iSortOrder){$/;"	f
sqlite3ExprListSetSpan	.\src\expr.c	/^void sqlite3ExprListSetSpan($/;"	f
sqlite3ExprNeedsNoAffinityChange	.\src\expr.c	/^int sqlite3ExprNeedsNoAffinityChange(const Expr *p, char aff){$/;"	f
sqlite3ExprSetHeightAndFlags	.\src\expr.c	/^void sqlite3ExprSetHeightAndFlags(Parse *pParse, Expr *p){$/;"	f
sqlite3ExprSkipCollate	.\src\expr.c	/^Expr *sqlite3ExprSkipCollate(Expr *pExpr){$/;"	f
sqlite3Fault	.\src\test_malloc.c	/^static void sqlite3Fault(void){$/;"	f	file:
sqlite3FaultSim	.\src\sqliteInt.h	3308;"	d
sqlite3FaultSim	.\src\util.c	/^int sqlite3FaultSim(int iTest){$/;"	f
sqlite3FileSuffix3	.\src\sqliteInt.h	3623;"	d
sqlite3FileSuffix3	.\src\util.c	/^void sqlite3FileSuffix3(const char *zBaseFilename, char *z){$/;"	f
sqlite3FindCollSeq	.\src\callback.c	/^CollSeq *sqlite3FindCollSeq($/;"	f
sqlite3FindDb	.\src\build.c	/^int sqlite3FindDb(sqlite3 *db, Token *pName){$/;"	f
sqlite3FindDbName	.\src\build.c	/^int sqlite3FindDbName(sqlite3 *db, const char *zName){$/;"	f
sqlite3FindFunction	.\src\callback.c	/^FuncDef *sqlite3FindFunction($/;"	f
sqlite3FindInIndex	.\src\expr.c	/^int sqlite3FindInIndex(Parse *pParse, Expr *pX, u32 inFlags, int *prRhsHasNull){$/;"	f
sqlite3FindIndex	.\src\build.c	/^Index *sqlite3FindIndex(sqlite3 *db, const char *zName, const char *zDb){$/;"	f
sqlite3FindTable	.\src\build.c	/^Table *sqlite3FindTable(sqlite3 *db, const char *zName, const char *zDatabase){$/;"	f
sqlite3FinishCoding	.\src\build.c	/^void sqlite3FinishCoding(Parse *pParse){$/;"	f
sqlite3FinishTrigger	.\src\trigger.c	/^void sqlite3FinishTrigger($/;"	f
sqlite3FixExpr	.\src\attach.c	/^int sqlite3FixExpr($/;"	f
sqlite3FixExprList	.\src\attach.c	/^int sqlite3FixExprList($/;"	f
sqlite3FixInit	.\src\attach.c	/^void sqlite3FixInit($/;"	f
sqlite3FixSelect	.\src\attach.c	/^int sqlite3FixSelect($/;"	f
sqlite3FixSrcList	.\src\attach.c	/^int sqlite3FixSrcList($/;"	f
sqlite3FixTriggerStep	.\src\attach.c	/^int sqlite3FixTriggerStep($/;"	f
sqlite3FkActions	.\src\fkey.c	/^void sqlite3FkActions($/;"	f
sqlite3FkActions	.\src\sqliteInt.h	3819;"	d
sqlite3FkCheck	.\src\fkey.c	/^void sqlite3FkCheck($/;"	f
sqlite3FkCheck	.\src\sqliteInt.h	3820;"	d
sqlite3FkDelete	.\src\fkey.c	/^void sqlite3FkDelete(sqlite3 *db, Table *pTab){$/;"	f
sqlite3FkDelete	.\src\sqliteInt.h	3829;"	d
sqlite3FkDropTable	.\src\fkey.c	/^void sqlite3FkDropTable(Parse *pParse, SrcList *pName, Table *pTab){$/;"	f
sqlite3FkDropTable	.\src\sqliteInt.h	3821;"	d
sqlite3FkLocateIndex	.\src\fkey.c	/^int sqlite3FkLocateIndex($/;"	f
sqlite3FkLocateIndex	.\src\sqliteInt.h	3830;"	d
sqlite3FkOldmask	.\src\fkey.c	/^u32 sqlite3FkOldmask($/;"	f
sqlite3FkOldmask	.\src\sqliteInt.h	3822;"	d
sqlite3FkReferences	.\src\fkey.c	/^FKey *sqlite3FkReferences(Table *pTab){$/;"	f
sqlite3FkRequired	.\src\fkey.c	/^int sqlite3FkRequired($/;"	f
sqlite3FkRequired	.\src\sqliteInt.h	3823;"	d
sqlite3Fts1HashClear	.\ext\fts1\fts1_hash.c	/^void sqlite3Fts1HashClear(fts1Hash *pH){$/;"	f
sqlite3Fts1HashFind	.\ext\fts1\fts1_hash.c	/^void *sqlite3Fts1HashFind(const fts1Hash *pH, const void *pKey, int nKey){$/;"	f
sqlite3Fts1HashInit	.\ext\fts1\fts1_hash.c	/^void sqlite3Fts1HashInit(fts1Hash *pNew, int keyClass, int copyKey){$/;"	f
sqlite3Fts1HashInsert	.\ext\fts1\fts1_hash.c	/^void *sqlite3Fts1HashInsert($/;"	f
sqlite3Fts1Init	.\ext\fts1\fts1.c	/^int sqlite3Fts1Init(sqlite3 *db){$/;"	f
sqlite3Fts1PorterTokenizerModule	.\ext\fts1\fts1_porter.c	/^void sqlite3Fts1PorterTokenizerModule($/;"	f
sqlite3Fts1SimpleTokenizerModule	.\ext\fts1\fts1_tokenizer1.c	/^void sqlite3Fts1SimpleTokenizerModule($/;"	f
sqlite3Fts2HashClear	.\ext\fts2\fts2_hash.c	/^void sqlite3Fts2HashClear(fts2Hash *pH){$/;"	f
sqlite3Fts2HashFind	.\ext\fts2\fts2_hash.c	/^void *sqlite3Fts2HashFind(const fts2Hash *pH, const void *pKey, int nKey){$/;"	f
sqlite3Fts2HashInit	.\ext\fts2\fts2_hash.c	/^void sqlite3Fts2HashInit(fts2Hash *pNew, int keyClass, int copyKey){$/;"	f
sqlite3Fts2HashInsert	.\ext\fts2\fts2_hash.c	/^void *sqlite3Fts2HashInsert($/;"	f
sqlite3Fts2IcuTokenizerModule	.\ext\fts2\fts2_icu.c	/^void sqlite3Fts2IcuTokenizerModule($/;"	f
sqlite3Fts2Init	.\ext\fts2\fts2.c	/^int sqlite3Fts2Init(sqlite3 *db){$/;"	f
sqlite3Fts2InitHashTable	.\ext\fts2\fts2_tokenizer.c	/^int sqlite3Fts2InitHashTable($/;"	f
sqlite3Fts2PorterTokenizerModule	.\ext\fts2\fts2_porter.c	/^void sqlite3Fts2PorterTokenizerModule($/;"	f
sqlite3Fts2SimpleTokenizerModule	.\ext\fts2\fts2_tokenizer1.c	/^void sqlite3Fts2SimpleTokenizerModule($/;"	f
sqlite3Fts3AllSegdirs	.\ext\fts3\fts3_write.c	/^int sqlite3Fts3AllSegdirs($/;"	f
sqlite3Fts3Always	.\ext\fts3\fts3.c	/^int sqlite3Fts3Always(int b) { assert( b ); return b; }$/;"	f
sqlite3Fts3CacheDeferredDoclists	.\ext\fts3\fts3Int.h	480;"	d
sqlite3Fts3CacheDeferredDoclists	.\ext\fts3\fts3_write.c	/^int sqlite3Fts3CacheDeferredDoclists(Fts3Cursor *pCsr){$/;"	f
sqlite3Fts3Corrupt	.\ext\fts3\fts3.c	/^int sqlite3Fts3Corrupt(){$/;"	f
sqlite3Fts3CreateStatTable	.\ext\fts3\fts3.c	/^void sqlite3Fts3CreateStatTable(int *pRc, Fts3Table *p){$/;"	f
sqlite3Fts3DeferToken	.\ext\fts3\fts3Int.h	479;"	d
sqlite3Fts3DeferToken	.\ext\fts3\fts3_write.c	/^int sqlite3Fts3DeferToken($/;"	f
sqlite3Fts3DeferredTokenList	.\ext\fts3\fts3Int.h	482;"	d
sqlite3Fts3DeferredTokenList	.\ext\fts3\fts3_write.c	/^int sqlite3Fts3DeferredTokenList($/;"	f
sqlite3Fts3Dequote	.\ext\fts3\fts3.c	/^void sqlite3Fts3Dequote(char *z){$/;"	f
sqlite3Fts3DoclistNext	.\ext\fts3\fts3.c	/^void sqlite3Fts3DoclistNext($/;"	f
sqlite3Fts3DoclistPrev	.\ext\fts3\fts3.c	/^void sqlite3Fts3DoclistPrev($/;"	f
sqlite3Fts3ErrMsg	.\ext\fts3\fts3.c	/^void sqlite3Fts3ErrMsg(char **pzErr, const char *zFormat, ...){$/;"	f
sqlite3Fts3EvalPhraseCleanup	.\ext\fts3\fts3.c	/^void sqlite3Fts3EvalPhraseCleanup(Fts3Phrase *pPhrase){$/;"	f
sqlite3Fts3EvalPhrasePoslist	.\ext\fts3\fts3.c	/^int sqlite3Fts3EvalPhrasePoslist($/;"	f
sqlite3Fts3EvalPhraseStats	.\ext\fts3\fts3.c	/^int sqlite3Fts3EvalPhraseStats($/;"	f
sqlite3Fts3EvalTestDeferred	.\ext\fts3\fts3.c	/^int sqlite3Fts3EvalTestDeferred(Fts3Cursor *pCsr, int *pRc){$/;"	f
sqlite3Fts3ExprFree	.\ext\fts3\fts3_expr.c	/^void sqlite3Fts3ExprFree(Fts3Expr *pDel){$/;"	f
sqlite3Fts3ExprInitTestInterface	.\ext\fts3\fts3_expr.c	/^int sqlite3Fts3ExprInitTestInterface(sqlite3* db){$/;"	f
sqlite3Fts3ExprParse	.\ext\fts3\fts3_expr.c	/^int sqlite3Fts3ExprParse($/;"	f
sqlite3Fts3FirstFilter	.\ext\fts3\fts3.c	/^int sqlite3Fts3FirstFilter($/;"	f
sqlite3Fts3FreeDeferredDoclists	.\ext\fts3\fts3Int.h	481;"	d
sqlite3Fts3FreeDeferredDoclists	.\ext\fts3\fts3_write.c	/^void sqlite3Fts3FreeDeferredDoclists(Fts3Cursor *pCsr){$/;"	f
sqlite3Fts3FreeDeferredTokens	.\ext\fts3\fts3Int.h	478;"	d
sqlite3Fts3FreeDeferredTokens	.\ext\fts3\fts3_write.c	/^void sqlite3Fts3FreeDeferredTokens(Fts3Cursor *pCsr){$/;"	f
sqlite3Fts3GetVarint	.\ext\fts3\fts3.c	/^int sqlite3Fts3GetVarint(const char *p, sqlite_int64 *v){$/;"	f
sqlite3Fts3GetVarint32	.\ext\fts3\fts3.c	/^int sqlite3Fts3GetVarint32(const char *p, int *pi){$/;"	f
sqlite3Fts3HashClear	.\ext\fts3\fts3_hash.c	/^void sqlite3Fts3HashClear(Fts3Hash *pH){$/;"	f
sqlite3Fts3HashFind	.\ext\fts3\fts3_hash.c	/^void *sqlite3Fts3HashFind(const Fts3Hash *pH, const void *pKey, int nKey){$/;"	f
sqlite3Fts3HashFindElem	.\ext\fts3\fts3_hash.c	/^Fts3HashElem *sqlite3Fts3HashFindElem($/;"	f
sqlite3Fts3HashInit	.\ext\fts3\fts3_hash.c	/^void sqlite3Fts3HashInit(Fts3Hash *pNew, char keyClass, char copyKey){$/;"	f
sqlite3Fts3HashInsert	.\ext\fts3\fts3_hash.c	/^void *sqlite3Fts3HashInsert($/;"	f
sqlite3Fts3IcuTokenizerModule	.\ext\fts3\fts3_icu.c	/^void sqlite3Fts3IcuTokenizerModule($/;"	f
sqlite3Fts3Incrmerge	.\ext\fts3\fts3_write.c	/^int sqlite3Fts3Incrmerge(Fts3Table *p, int nMerge, int nMin){$/;"	f
sqlite3Fts3Init	.\ext\fts3\fts3.c	/^int sqlite3Fts3Init(sqlite3 *db){$/;"	f
sqlite3Fts3InitAux	.\ext\fts3\fts3_aux.c	/^int sqlite3Fts3InitAux(sqlite3 *db){$/;"	f
sqlite3Fts3InitHashTable	.\ext\fts3\fts3_tokenizer.c	/^int sqlite3Fts3InitHashTable($/;"	f
sqlite3Fts3InitTerm	.\ext\fts3\fts3_term.c	/^int sqlite3Fts3InitTerm(sqlite3 *db){$/;"	f
sqlite3Fts3InitTok	.\ext\fts3\fts3_tokenize_vtab.c	/^int sqlite3Fts3InitTok(sqlite3 *db, Fts3Hash *pHash){$/;"	f
sqlite3Fts3InitTokenizer	.\ext\fts3\fts3_tokenizer.c	/^int sqlite3Fts3InitTokenizer($/;"	f
sqlite3Fts3IsIdChar	.\ext\fts3\fts3_tokenizer.c	/^int sqlite3Fts3IsIdChar(char c){$/;"	f
sqlite3Fts3MIBufferFree	.\ext\fts3\fts3_snippet.c	/^void sqlite3Fts3MIBufferFree(MatchinfoBuffer *p){$/;"	f
sqlite3Fts3Matchinfo	.\ext\fts3\fts3_snippet.c	/^void sqlite3Fts3Matchinfo($/;"	f
sqlite3Fts3MaxLevel	.\ext\fts3\fts3_write.c	/^int sqlite3Fts3MaxLevel(Fts3Table *p, int *pnMax){$/;"	f
sqlite3Fts3MsrIncrNext	.\ext\fts3\fts3_write.c	/^int sqlite3Fts3MsrIncrNext($/;"	f
sqlite3Fts3MsrIncrRestart	.\ext\fts3\fts3_write.c	/^int sqlite3Fts3MsrIncrRestart(Fts3MultiSegReader *pCsr){$/;"	f
sqlite3Fts3MsrIncrStart	.\ext\fts3\fts3_write.c	/^int sqlite3Fts3MsrIncrStart($/;"	f
sqlite3Fts3MsrOvfl	.\ext\fts3\fts3_write.c	/^int sqlite3Fts3MsrOvfl($/;"	f
sqlite3Fts3Never	.\ext\fts3\fts3.c	/^int sqlite3Fts3Never(int b)  { assert( !b ); return b; }$/;"	f
sqlite3Fts3NextToken	.\ext\fts3\fts3_tokenizer.c	/^const char *sqlite3Fts3NextToken(const char *zStr, int *pn){$/;"	f
sqlite3Fts3Offsets	.\ext\fts3\fts3_snippet.c	/^void sqlite3Fts3Offsets($/;"	f
sqlite3Fts3OpenTokenizer	.\ext\fts3\fts3_expr.c	/^int sqlite3Fts3OpenTokenizer($/;"	f
sqlite3Fts3Optimize	.\ext\fts3\fts3_write.c	/^int sqlite3Fts3Optimize(Fts3Table *p){$/;"	f
sqlite3Fts3PendingTermsClear	.\ext\fts3\fts3_write.c	/^void sqlite3Fts3PendingTermsClear(Fts3Table *p){$/;"	f
sqlite3Fts3PendingTermsFlush	.\ext\fts3\fts3_write.c	/^int sqlite3Fts3PendingTermsFlush(Fts3Table *p){$/;"	f
sqlite3Fts3PorterTokenizerModule	.\ext\fts3\fts3_porter.c	/^void sqlite3Fts3PorterTokenizerModule($/;"	f
sqlite3Fts3PutVarint	.\ext\fts3\fts3.c	/^int sqlite3Fts3PutVarint(char *p, sqlite_int64 v){$/;"	f
sqlite3Fts3ReadBlock	.\ext\fts3\fts3_write.c	/^int sqlite3Fts3ReadBlock($/;"	f
sqlite3Fts3SegReaderCursor	.\ext\fts3\fts3.c	/^int sqlite3Fts3SegReaderCursor($/;"	f
sqlite3Fts3SegReaderFinish	.\ext\fts3\fts3_write.c	/^void sqlite3Fts3SegReaderFinish($/;"	f
sqlite3Fts3SegReaderFree	.\ext\fts3\fts3_write.c	/^void sqlite3Fts3SegReaderFree(Fts3SegReader *pReader){$/;"	f
sqlite3Fts3SegReaderNew	.\ext\fts3\fts3_write.c	/^int sqlite3Fts3SegReaderNew($/;"	f
sqlite3Fts3SegReaderPending	.\ext\fts3\fts3_write.c	/^int sqlite3Fts3SegReaderPending($/;"	f
sqlite3Fts3SegReaderStart	.\ext\fts3\fts3_write.c	/^int sqlite3Fts3SegReaderStart($/;"	f
sqlite3Fts3SegReaderStep	.\ext\fts3\fts3_write.c	/^int sqlite3Fts3SegReaderStep($/;"	f
sqlite3Fts3SegmentsClose	.\ext\fts3\fts3_write.c	/^void sqlite3Fts3SegmentsClose(Fts3Table *p){$/;"	f
sqlite3Fts3SelectDocsize	.\ext\fts3\fts3_write.c	/^int sqlite3Fts3SelectDocsize($/;"	f
sqlite3Fts3SelectDoctotal	.\ext\fts3\fts3_write.c	/^int sqlite3Fts3SelectDoctotal($/;"	f
sqlite3Fts3SimpleTokenizerModule	.\ext\fts3\fts3_tokenizer1.c	/^void sqlite3Fts3SimpleTokenizerModule($/;"	f
sqlite3Fts3Snippet	.\ext\fts3\fts3_snippet.c	/^void sqlite3Fts3Snippet($/;"	f
sqlite3Fts3UnicodeTokenizer	.\ext\fts3\fts3_unicode.c	/^void sqlite3Fts3UnicodeTokenizer(sqlite3_tokenizer_module const **ppModule){$/;"	f
sqlite3Fts3UpdateMethod	.\ext\fts3\fts3_write.c	/^int sqlite3Fts3UpdateMethod($/;"	f
sqlite3Fts3VarintLen	.\ext\fts3\fts3.c	/^int sqlite3Fts3VarintLen(sqlite3_uint64 v){$/;"	f
sqlite3Fts5AuxInit	.\ext\fts5\fts5_aux.c	/^int sqlite3Fts5AuxInit(fts5_api *pApi){$/;"	f
sqlite3Fts5BufferAppend32	.\ext\fts5\fts5_buffer.c	/^void sqlite3Fts5BufferAppend32(int *pRc, Fts5Buffer *pBuf, int iVal){$/;"	f
sqlite3Fts5BufferAppendBlob	.\ext\fts5\fts5_buffer.c	/^void sqlite3Fts5BufferAppendBlob($/;"	f
sqlite3Fts5BufferAppendPrintf	.\ext\fts5\fts5_buffer.c	/^void sqlite3Fts5BufferAppendPrintf($/;"	f
sqlite3Fts5BufferAppendString	.\ext\fts5\fts5_buffer.c	/^void sqlite3Fts5BufferAppendString($/;"	f
sqlite3Fts5BufferAppendVarint	.\ext\fts5\fts5_buffer.c	/^void sqlite3Fts5BufferAppendVarint(int *pRc, Fts5Buffer *pBuf, i64 iVal){$/;"	f
sqlite3Fts5BufferFree	.\ext\fts5\fts5_buffer.c	/^void sqlite3Fts5BufferFree(Fts5Buffer *pBuf){$/;"	f
sqlite3Fts5BufferGrow	.\ext\fts5\fts5_buffer.c	/^int sqlite3Fts5BufferGrow(int *pRc, Fts5Buffer *pBuf, int nByte){$/;"	f
sqlite3Fts5BufferSet	.\ext\fts5\fts5_buffer.c	/^void sqlite3Fts5BufferSet($/;"	f
sqlite3Fts5BufferZero	.\ext\fts5\fts5_buffer.c	/^void sqlite3Fts5BufferZero(Fts5Buffer *pBuf){$/;"	f
sqlite3Fts5ConfigDeclareVtab	.\ext\fts5\fts5_config.c	/^int sqlite3Fts5ConfigDeclareVtab(Fts5Config *pConfig){$/;"	f
sqlite3Fts5ConfigFree	.\ext\fts5\fts5_config.c	/^void sqlite3Fts5ConfigFree(Fts5Config *pConfig){$/;"	f
sqlite3Fts5ConfigLoad	.\ext\fts5\fts5_config.c	/^int sqlite3Fts5ConfigLoad(Fts5Config *pConfig, int iCookie){$/;"	f
sqlite3Fts5ConfigParse	.\ext\fts5\fts5_config.c	/^int sqlite3Fts5ConfigParse($/;"	f
sqlite3Fts5ConfigParseRank	.\ext\fts5\fts5_config.c	/^int sqlite3Fts5ConfigParseRank($/;"	f
sqlite3Fts5ConfigSetValue	.\ext\fts5\fts5_config.c	/^int sqlite3Fts5ConfigSetValue($/;"	f
sqlite3Fts5Corrupt	.\ext\fts5\fts5_index.c	/^int sqlite3Fts5Corrupt() { return SQLITE_CORRUPT_VTAB; }$/;"	f
sqlite3Fts5CreateTable	.\ext\fts5\fts5_storage.c	/^int sqlite3Fts5CreateTable($/;"	f
sqlite3Fts5Dequote	.\ext\fts5\fts5_config.c	/^void sqlite3Fts5Dequote(char *z){$/;"	f
sqlite3Fts5DropAll	.\ext\fts5\fts5_storage.c	/^int sqlite3Fts5DropAll(Fts5Config *pConfig){$/;"	f
sqlite3Fts5ExprClonePhrase	.\ext\fts5\fts5_expr.c	/^int sqlite3Fts5ExprClonePhrase($/;"	f
sqlite3Fts5ExprEof	.\ext\fts5\fts5_expr.c	/^int sqlite3Fts5ExprEof(Fts5Expr *p){$/;"	f
sqlite3Fts5ExprFirst	.\ext\fts5\fts5_expr.c	/^int sqlite3Fts5ExprFirst(Fts5Expr *p, Fts5Index *pIdx, i64 iFirst, int bDesc){$/;"	f
sqlite3Fts5ExprFree	.\ext\fts5\fts5_expr.c	/^void sqlite3Fts5ExprFree(Fts5Expr *p){$/;"	f
sqlite3Fts5ExprInit	.\ext\fts5\fts5_expr.c	/^int sqlite3Fts5ExprInit(Fts5Global *pGlobal, sqlite3 *db){$/;"	f
sqlite3Fts5ExprNew	.\ext\fts5\fts5_expr.c	/^int sqlite3Fts5ExprNew($/;"	f
sqlite3Fts5ExprNext	.\ext\fts5\fts5_expr.c	/^int sqlite3Fts5ExprNext(Fts5Expr *p, i64 iLast){$/;"	f
sqlite3Fts5ExprPhraseCount	.\ext\fts5\fts5_expr.c	/^int sqlite3Fts5ExprPhraseCount(Fts5Expr *pExpr){$/;"	f
sqlite3Fts5ExprPhraseSize	.\ext\fts5\fts5_expr.c	/^int sqlite3Fts5ExprPhraseSize(Fts5Expr *pExpr, int iPhrase){$/;"	f
sqlite3Fts5ExprPoslist	.\ext\fts5\fts5_expr.c	/^int sqlite3Fts5ExprPoslist(Fts5Expr *pExpr, int iPhrase, const u8 **pa){$/;"	f
sqlite3Fts5ExprRowid	.\ext\fts5\fts5_expr.c	/^i64 sqlite3Fts5ExprRowid(Fts5Expr *p){$/;"	f
sqlite3Fts5Get32	.\ext\fts5\fts5_buffer.c	/^int sqlite3Fts5Get32(const u8 *aBuf){$/;"	f
sqlite3Fts5GetTokenizer	.\ext\fts5\fts5_main.c	/^int sqlite3Fts5GetTokenizer($/;"	f
sqlite3Fts5GetVarint	.\ext\fts5\fts5_varint.c	/^u8 sqlite3Fts5GetVarint(const unsigned char *p, u64 *v){$/;"	f
sqlite3Fts5GetVarint32	.\ext\fts5\fts5_varint.c	/^int sqlite3Fts5GetVarint32(const unsigned char *p, u32 *v){$/;"	f
sqlite3Fts5GetVarintLen	.\ext\fts5\fts5_varint.c	/^int sqlite3Fts5GetVarintLen(u32 iVal){$/;"	f
sqlite3Fts5HashClear	.\ext\fts5\fts5_hash.c	/^void sqlite3Fts5HashClear(Fts5Hash *pHash){$/;"	f
sqlite3Fts5HashFree	.\ext\fts5\fts5_hash.c	/^void sqlite3Fts5HashFree(Fts5Hash *pHash){$/;"	f
sqlite3Fts5HashNew	.\ext\fts5\fts5_hash.c	/^int sqlite3Fts5HashNew(Fts5Hash **ppNew, int *pnByte){$/;"	f
sqlite3Fts5HashQuery	.\ext\fts5\fts5_hash.c	/^int sqlite3Fts5HashQuery($/;"	f
sqlite3Fts5HashScanEntry	.\ext\fts5\fts5_hash.c	/^void sqlite3Fts5HashScanEntry($/;"	f
sqlite3Fts5HashScanEof	.\ext\fts5\fts5_hash.c	/^int sqlite3Fts5HashScanEof(Fts5Hash *p){$/;"	f
sqlite3Fts5HashScanInit	.\ext\fts5\fts5_hash.c	/^int sqlite3Fts5HashScanInit($/;"	f
sqlite3Fts5HashScanNext	.\ext\fts5\fts5_hash.c	/^void sqlite3Fts5HashScanNext(Fts5Hash *p){$/;"	f
sqlite3Fts5HashWrite	.\ext\fts5\fts5_hash.c	/^int sqlite3Fts5HashWrite($/;"	f
sqlite3Fts5IndexBeginWrite	.\ext\fts5\fts5_index.c	/^int sqlite3Fts5IndexBeginWrite(Fts5Index *p, int bDelete, i64 iRowid){$/;"	f
sqlite3Fts5IndexCksum	.\ext\fts5\fts5_index.c	/^u64 sqlite3Fts5IndexCksum($/;"	f
sqlite3Fts5IndexClose	.\ext\fts5\fts5_index.c	/^int sqlite3Fts5IndexClose(Fts5Index *p){$/;"	f
sqlite3Fts5IndexFromCsrid	.\ext\fts5\fts5_main.c	/^Fts5Index *sqlite3Fts5IndexFromCsrid($/;"	f
sqlite3Fts5IndexGetAverages	.\ext\fts5\fts5_index.c	/^int sqlite3Fts5IndexGetAverages(Fts5Index *p, i64 *pnRow, i64 *anSize){$/;"	f
sqlite3Fts5IndexInit	.\ext\fts5\fts5_index.c	/^int sqlite3Fts5IndexInit(sqlite3 *db){$/;"	f
sqlite3Fts5IndexIntegrityCheck	.\ext\fts5\fts5_index.c	/^int sqlite3Fts5IndexIntegrityCheck(Fts5Index *p, u64 cksum){$/;"	f
sqlite3Fts5IndexLoadConfig	.\ext\fts5\fts5_index.c	/^int sqlite3Fts5IndexLoadConfig(Fts5Index *p){$/;"	f
sqlite3Fts5IndexMerge	.\ext\fts5\fts5_index.c	/^int sqlite3Fts5IndexMerge(Fts5Index *p, int nMerge){$/;"	f
sqlite3Fts5IndexOpen	.\ext\fts5\fts5_index.c	/^int sqlite3Fts5IndexOpen($/;"	f
sqlite3Fts5IndexOptimize	.\ext\fts5\fts5_index.c	/^int sqlite3Fts5IndexOptimize(Fts5Index *p){$/;"	f
sqlite3Fts5IndexQuery	.\ext\fts5\fts5_index.c	/^int sqlite3Fts5IndexQuery($/;"	f
sqlite3Fts5IndexReads	.\ext\fts5\fts5_index.c	/^int sqlite3Fts5IndexReads(Fts5Index *p){$/;"	f
sqlite3Fts5IndexReinit	.\ext\fts5\fts5_index.c	/^int sqlite3Fts5IndexReinit(Fts5Index *p){$/;"	f
sqlite3Fts5IndexRollback	.\ext\fts5\fts5_index.c	/^int sqlite3Fts5IndexRollback(Fts5Index *p){$/;"	f
sqlite3Fts5IndexSetAverages	.\ext\fts5\fts5_index.c	/^int sqlite3Fts5IndexSetAverages(Fts5Index *p, const u8 *pData, int nData){$/;"	f
sqlite3Fts5IndexSetCookie	.\ext\fts5\fts5_index.c	/^int sqlite3Fts5IndexSetCookie(Fts5Index *p, int iNew){$/;"	f
sqlite3Fts5IndexSync	.\ext\fts5\fts5_index.c	/^int sqlite3Fts5IndexSync(Fts5Index *p, int bCommit){$/;"	f
sqlite3Fts5IndexWrite	.\ext\fts5\fts5_index.c	/^int sqlite3Fts5IndexWrite($/;"	f
sqlite3Fts5Init	.\ext\fts5\fts5_main.c	/^int sqlite3Fts5Init(sqlite3 *db){$/;"	f
sqlite3Fts5IsBareword	.\ext\fts5\fts5_buffer.c	/^int sqlite3Fts5IsBareword(char t){$/;"	f
sqlite3Fts5IterClose	.\ext\fts5\fts5_index.c	/^void sqlite3Fts5IterClose(Fts5IndexIter *pIter){$/;"	f
sqlite3Fts5IterEof	.\ext\fts5\fts5_index.c	/^int sqlite3Fts5IterEof(Fts5IndexIter *pIter){$/;"	f
sqlite3Fts5IterNext	.\ext\fts5\fts5_index.c	/^int sqlite3Fts5IterNext(Fts5IndexIter *pIter){$/;"	f
sqlite3Fts5IterNextFrom	.\ext\fts5\fts5_index.c	/^int sqlite3Fts5IterNextFrom(Fts5IndexIter *pIter, i64 iMatch){$/;"	f
sqlite3Fts5IterNextScan	.\ext\fts5\fts5_index.c	/^int sqlite3Fts5IterNextScan(Fts5IndexIter *pIter){$/;"	f
sqlite3Fts5IterPoslist	.\ext\fts5\fts5_index.c	/^int sqlite3Fts5IterPoslist($/;"	f
sqlite3Fts5IterPoslistBuffer	.\ext\fts5\fts5_index.c	/^int sqlite3Fts5IterPoslistBuffer(Fts5IndexIter *pIter, Fts5Buffer *pBuf){$/;"	f
sqlite3Fts5IterRowid	.\ext\fts5\fts5_index.c	/^i64 sqlite3Fts5IterRowid(Fts5IndexIter *pIter){$/;"	f
sqlite3Fts5IterTerm	.\ext\fts5\fts5_index.c	/^const char *sqlite3Fts5IterTerm(Fts5IndexIter *pIter, int *pn){$/;"	f
sqlite3Fts5MallocZero	.\ext\fts5\fts5_buffer.c	/^void *sqlite3Fts5MallocZero(int *pRc, int nByte){$/;"	f
sqlite3Fts5Mprintf	.\ext\fts5\fts5_buffer.c	/^char *sqlite3Fts5Mprintf(int *pRc, const char *zFmt, ...){$/;"	f
sqlite3Fts5ParseColset	.\ext\fts5\fts5_expr.c	/^Fts5Colset *sqlite3Fts5ParseColset($/;"	f
sqlite3Fts5ParseError	.\ext\fts5\fts5_expr.c	/^void sqlite3Fts5ParseError(Fts5Parse *pParse, const char *zFmt, ...){$/;"	f
sqlite3Fts5ParseFinished	.\ext\fts5\fts5_expr.c	/^void sqlite3Fts5ParseFinished(Fts5Parse *pParse, Fts5ExprNode *p){$/;"	f
sqlite3Fts5ParseNear	.\ext\fts5\fts5_expr.c	/^void sqlite3Fts5ParseNear(Fts5Parse *pParse, Fts5Token *pTok){$/;"	f
sqlite3Fts5ParseNearset	.\ext\fts5\fts5_expr.c	/^Fts5ExprNearset *sqlite3Fts5ParseNearset($/;"	f
sqlite3Fts5ParseNearsetFree	.\ext\fts5\fts5_expr.c	/^void sqlite3Fts5ParseNearsetFree(Fts5ExprNearset *pNear){$/;"	f
sqlite3Fts5ParseNode	.\ext\fts5\fts5_expr.c	/^Fts5ExprNode *sqlite3Fts5ParseNode($/;"	f
sqlite3Fts5ParseNodeFree	.\ext\fts5\fts5_expr.c	/^void sqlite3Fts5ParseNodeFree(Fts5ExprNode *p){$/;"	f
sqlite3Fts5ParsePhraseFree	.\ext\fts5\fts5_expr.c	/^void sqlite3Fts5ParsePhraseFree(Fts5ExprPhrase *pPhrase){$/;"	f
sqlite3Fts5ParseSetColset	.\ext\fts5\fts5_expr.c	/^void sqlite3Fts5ParseSetColset($/;"	f
sqlite3Fts5ParseSetDistance	.\ext\fts5\fts5_expr.c	/^void sqlite3Fts5ParseSetDistance($/;"	f
sqlite3Fts5ParseTerm	.\ext\fts5\fts5_expr.c	/^Fts5ExprPhrase *sqlite3Fts5ParseTerm($/;"	f
sqlite3Fts5PoslistNext64	.\ext\fts5\fts5_buffer.c	/^int sqlite3Fts5PoslistNext64($/;"	f
sqlite3Fts5PoslistReaderInit	.\ext\fts5\fts5_buffer.c	/^int sqlite3Fts5PoslistReaderInit($/;"	f
sqlite3Fts5PoslistReaderNext	.\ext\fts5\fts5_buffer.c	/^int sqlite3Fts5PoslistReaderNext(Fts5PoslistReader *pIter){$/;"	f
sqlite3Fts5PoslistWriterAppend	.\ext\fts5\fts5_buffer.c	/^int sqlite3Fts5PoslistWriterAppend($/;"	f
sqlite3Fts5Put32	.\ext\fts5\fts5_buffer.c	/^void sqlite3Fts5Put32(u8 *aBuf, int iVal){$/;"	f
sqlite3Fts5PutVarint	.\ext\fts5\fts5_varint.c	/^int sqlite3Fts5PutVarint(unsigned char *p, u64 v){$/;"	f
sqlite3Fts5StorageClose	.\ext\fts5\fts5_storage.c	/^int sqlite3Fts5StorageClose(Fts5Storage *p){$/;"	f
sqlite3Fts5StorageConfigValue	.\ext\fts5\fts5_storage.c	/^int sqlite3Fts5StorageConfigValue($/;"	f
sqlite3Fts5StorageContentInsert	.\ext\fts5\fts5_storage.c	/^int sqlite3Fts5StorageContentInsert($/;"	f
sqlite3Fts5StorageDelete	.\ext\fts5\fts5_storage.c	/^int sqlite3Fts5StorageDelete(Fts5Storage *p, i64 iDel){$/;"	f
sqlite3Fts5StorageDeleteAll	.\ext\fts5\fts5_storage.c	/^int sqlite3Fts5StorageDeleteAll(Fts5Storage *p){$/;"	f
sqlite3Fts5StorageDocsize	.\ext\fts5\fts5_storage.c	/^int sqlite3Fts5StorageDocsize(Fts5Storage *p, i64 iRowid, int *aCol){$/;"	f
sqlite3Fts5StorageIndexInsert	.\ext\fts5\fts5_storage.c	/^int sqlite3Fts5StorageIndexInsert($/;"	f
sqlite3Fts5StorageIntegrity	.\ext\fts5\fts5_storage.c	/^int sqlite3Fts5StorageIntegrity(Fts5Storage *p){$/;"	f
sqlite3Fts5StorageMerge	.\ext\fts5\fts5_storage.c	/^int sqlite3Fts5StorageMerge(Fts5Storage *p, int nMerge){$/;"	f
sqlite3Fts5StorageOpen	.\ext\fts5\fts5_storage.c	/^int sqlite3Fts5StorageOpen($/;"	f
sqlite3Fts5StorageOptimize	.\ext\fts5\fts5_storage.c	/^int sqlite3Fts5StorageOptimize(Fts5Storage *p){$/;"	f
sqlite3Fts5StorageRebuild	.\ext\fts5\fts5_storage.c	/^int sqlite3Fts5StorageRebuild(Fts5Storage *p){$/;"	f
sqlite3Fts5StorageRename	.\ext\fts5\fts5_storage.c	/^int sqlite3Fts5StorageRename(Fts5Storage *pStorage, const char *zName){$/;"	f
sqlite3Fts5StorageRollback	.\ext\fts5\fts5_storage.c	/^int sqlite3Fts5StorageRollback(Fts5Storage *p){$/;"	f
sqlite3Fts5StorageRowCount	.\ext\fts5\fts5_storage.c	/^int sqlite3Fts5StorageRowCount(Fts5Storage *p, i64 *pnRow){$/;"	f
sqlite3Fts5StorageSize	.\ext\fts5\fts5_storage.c	/^int sqlite3Fts5StorageSize(Fts5Storage *p, int iCol, i64 *pnToken){$/;"	f
sqlite3Fts5StorageSpecialDelete	.\ext\fts5\fts5_storage.c	/^int sqlite3Fts5StorageSpecialDelete($/;"	f
sqlite3Fts5StorageStmt	.\ext\fts5\fts5_storage.c	/^int sqlite3Fts5StorageStmt($/;"	f
sqlite3Fts5StorageStmtRelease	.\ext\fts5\fts5_storage.c	/^void sqlite3Fts5StorageStmtRelease($/;"	f
sqlite3Fts5StorageSync	.\ext\fts5\fts5_storage.c	/^int sqlite3Fts5StorageSync(Fts5Storage *p, int bCommit){$/;"	f
sqlite3Fts5Strndup	.\ext\fts5\fts5_buffer.c	/^char *sqlite3Fts5Strndup(int *pRc, const char *pIn, int nIn){$/;"	f
sqlite3Fts5TestRegisterMatchinfo	.\ext\fts5\fts5_test_mi.c	/^int sqlite3Fts5TestRegisterMatchinfo(sqlite3 *db){$/;"	f
sqlite3Fts5Tokenize	.\ext\fts5\fts5_config.c	/^int sqlite3Fts5Tokenize($/;"	f
sqlite3Fts5TokenizerInit	.\ext\fts5\fts5_tokenize.c	/^int sqlite3Fts5TokenizerInit(fts5_api *pApi){$/;"	f
sqlite3Fts5UnicodeFold	.\ext\fts5\fts5_unicode2.c	/^int sqlite3Fts5UnicodeFold(int c, int bRemoveDiacritic){$/;"	f
sqlite3Fts5UnicodeIsalnum	.\ext\fts5\fts5_unicode2.c	/^int sqlite3Fts5UnicodeIsalnum(int c){$/;"	f
sqlite3Fts5UnicodeIsdiacritic	.\ext\fts5\fts5_unicode2.c	/^int sqlite3Fts5UnicodeIsdiacritic(int c){$/;"	f
sqlite3Fts5VocabInit	.\ext\fts5\fts5_vocab.c	/^int sqlite3Fts5VocabInit(Fts5Global *pGlobal, sqlite3 *db){$/;"	f
sqlite3FtsUnicodeFold	.\ext\fts3\fts3_unicode2.c	/^int sqlite3FtsUnicodeFold(int c, int bRemoveDiacritic){$/;"	f
sqlite3FtsUnicodeIsalnum	.\ext\fts3\fts3_unicode2.c	/^int sqlite3FtsUnicodeIsalnum(int c){$/;"	f
sqlite3FtsUnicodeIsdiacritic	.\ext\fts3\fts3_unicode2.c	/^int sqlite3FtsUnicodeIsdiacritic(int c){$/;"	f
sqlite3FuncDefInsert	.\src\callback.c	/^void sqlite3FuncDefInsert($/;"	f
sqlite3FunctionUsesThisSrc	.\src\expr.c	/^int sqlite3FunctionUsesThisSrc(Expr *pExpr, SrcList *pSrcList){$/;"	f
sqlite3GenerateConstraintChecks	.\src\insert.c	/^void sqlite3GenerateConstraintChecks($/;"	f
sqlite3GenerateIndexKey	.\src\delete.c	/^int sqlite3GenerateIndexKey($/;"	f
sqlite3GenerateRowDelete	.\src\delete.c	/^void sqlite3GenerateRowDelete($/;"	f
sqlite3GenerateRowIndexDelete	.\src\delete.c	/^void sqlite3GenerateRowIndexDelete($/;"	f
sqlite3Get4byte	.\src\util.c	/^u32 sqlite3Get4byte(const u8 *p){$/;"	f
sqlite3GetBoolean	.\src\pragma.c	/^u8 sqlite3GetBoolean(const char *z, u8 dflt){$/;"	f
sqlite3GetCollSeq	.\src\callback.c	/^CollSeq *sqlite3GetCollSeq($/;"	f
sqlite3GetFuncCollSeq	.\src\func.c	/^static CollSeq *sqlite3GetFuncCollSeq(sqlite3_context *context){$/;"	f	file:
sqlite3GetInt32	.\src\util.c	/^int sqlite3GetInt32(const char *zNum, int *pValue){$/;"	f
sqlite3GetTempRange	.\src\expr.c	/^int sqlite3GetTempRange(Parse *pParse, int nReg){$/;"	f
sqlite3GetTempReg	.\src\expr.c	/^int sqlite3GetTempReg(Parse *pParse){$/;"	f
sqlite3GetToken	.\src\tokenize.c	/^int sqlite3GetToken(const unsigned char *z, int *tokenType){$/;"	f
sqlite3GetVTable	.\src\sqliteInt.h	3754;"	d
sqlite3GetVTable	.\src\vtab.c	/^VTable *sqlite3GetVTable(sqlite3 *db, Table *pTab){$/;"	f
sqlite3GetVarint	.\src\util.c	/^u8 sqlite3GetVarint(const unsigned char *p, u64 *v){$/;"	f
sqlite3GetVarint32	.\src\util.c	/^u8 sqlite3GetVarint32(const unsigned char *p, u32 *v){$/;"	f
sqlite3GetVdbe	.\src\select.c	/^Vdbe *sqlite3GetVdbe(Parse *pParse){$/;"	f
sqlite3GlobalConfig	.\src\sqliteInt.h	885;"	d
sqlite3GlobalConfig	.\src\sqliteInt.h	891;"	d
sqlite3GlobalFunctions	.\src\global.c	/^SQLITE_WSD FuncDefHash sqlite3GlobalFunctions;$/;"	v
sqlite3HaltConstraint	.\src\build.c	/^void sqlite3HaltConstraint($/;"	f
sqlite3HashClear	.\src\hash.c	/^void sqlite3HashClear(Hash *pH){$/;"	f
sqlite3HashFind	.\src\hash.c	/^void *sqlite3HashFind(const Hash *pH, const char *pKey){$/;"	f
sqlite3HashInit	.\src\hash.c	/^void sqlite3HashInit(Hash *pNew){$/;"	f
sqlite3HashInsert	.\src\hash.c	/^void *sqlite3HashInsert(Hash *pH, const char *pKey, void *data){$/;"	f
sqlite3HeaderSizeBtree	.\src\btree.c	/^int sqlite3HeaderSizeBtree(void){ return ROUND8(sizeof(MemPage)); }$/;"	f
sqlite3HeaderSizePcache	.\src\pcache.c	/^int sqlite3HeaderSizePcache(void){ return ROUND8(sizeof(PgHdr)); }$/;"	f
sqlite3HeaderSizePcache1	.\src\pcache1.c	/^int sqlite3HeaderSizePcache1(void){ return ROUND8(sizeof(PgHdr1)); }$/;"	f
sqlite3HeapNearlyFull	.\src\malloc.c	/^int sqlite3HeapNearlyFull(void){$/;"	f
sqlite3HexToBlob	.\src\util.c	/^void *sqlite3HexToBlob(sqlite3 *db, const char *z, int n){$/;"	f
sqlite3HexToInt	.\src\util.c	/^u8 sqlite3HexToInt(int h){$/;"	f
sqlite3Hooks	.\src\fault.c	/^} sqlite3Hooks = { 0, 0 };$/;"	v	typeref:struct:BenignMallocHooks	file:
sqlite3Hwtime	.\src\hwtime.h	/^  __declspec(naked) __inline sqlite_uint64 __cdecl sqlite3Hwtime(void){$/;"	f
sqlite3Hwtime	.\src\hwtime.h	/^  __inline__ sqlite_uint64 sqlite3Hwtime(void){$/;"	f
sqlite3Hwtime	.\src\hwtime.h	/^  sqlite_uint64 sqlite3Hwtime(void){ return ((sqlite_uint64)0); }$/;"	f
sqlite3IcuInit	.\ext\icu\icu.c	/^int sqlite3IcuInit(sqlite3 *db){$/;"	f
sqlite3IdListAppend	.\src\build.c	/^IdList *sqlite3IdListAppend(sqlite3 *db, IdList *pList, Token *pToken){$/;"	f
sqlite3IdListDelete	.\src\build.c	/^void sqlite3IdListDelete(sqlite3 *db, IdList *pList){$/;"	f
sqlite3IdListDup	.\src\expr.c	/^IdList *sqlite3IdListDup(sqlite3 *db, IdList *p){$/;"	f
sqlite3IdListIndex	.\src\build.c	/^int sqlite3IdListIndex(IdList *pList, const char *zName){$/;"	f
sqlite3InRhsIsConstant	.\src\expr.c	/^static int sqlite3InRhsIsConstant(Expr *pIn){$/;"	f	file:
sqlite3IndexAffinityOk	.\src\expr.c	/^int sqlite3IndexAffinityOk(Expr *pExpr, char idx_affinity){$/;"	f
sqlite3IndexAffinityStr	.\src\insert.c	/^const char *sqlite3IndexAffinityStr(sqlite3 *db, Index *pIdx){$/;"	f
sqlite3IndexColumnAffinity	.\src\where.c	/^static char sqlite3IndexColumnAffinity(sqlite3 *db, Index *pIdx, int iCol){$/;"	f	file:
sqlite3IndexedByLookup	.\src\select.c	/^int sqlite3IndexedByLookup(Parse *pParse, struct SrcList_item *pFrom){$/;"	f
sqlite3Init	.\src\prepare.c	/^int sqlite3Init(sqlite3 *db, char **pzErrMsg){$/;"	f
sqlite3InitCallback	.\src\prepare.c	/^int sqlite3InitCallback(void *pInit, int argc, char **argv, char **NotUsed){$/;"	f
sqlite3InitInfo	.\src\sqliteInt.h	/^  struct sqlite3InitInfo {      \/* Information used during initialization *\/$/;"	s	struct:sqlite3
sqlite3InitOne	.\src\prepare.c	/^static int sqlite3InitOne(sqlite3 *db, int iDb, char **pzErrMsg){$/;"	f	file:
sqlite3Insert	.\src\insert.c	/^void sqlite3Insert($/;"	f
sqlite3IntTokens	.\src\global.c	/^const Token sqlite3IntTokens[] = {$/;"	v
sqlite3InvalidFunction	.\src\vdbeapi.c	/^void sqlite3InvalidFunction($/;"	f
sqlite3InvokeBusyHandler	.\src\main.c	/^int sqlite3InvokeBusyHandler(BusyHandler *p){$/;"	f
sqlite3IoTrace	.\src\main.c	/^SQLITE_API void (SQLITE_CDECL *sqlite3IoTrace)(const char*, ...) = 0;$/;"	v
sqlite3IoTrace	.\src\sqliteInt.h	/^SQLITE_API SQLITE_EXTERN void (SQLITE_CDECL *sqlite3IoTrace)(const char*,...);$/;"	v
sqlite3IsEbcdicIdChar	.\src\tokenize.c	/^const char sqlite3IsEbcdicIdChar[] = {$/;"	v
sqlite3IsIdChar	.\src\tokenize.c	/^int sqlite3IsIdChar(u8 c){ return IdChar(c); }$/;"	f
sqlite3IsLikeFunction	.\src\func.c	/^int sqlite3IsLikeFunction(sqlite3 *db, Expr *pExpr, int *pIsNocase, char *aWc){$/;"	f
sqlite3IsMemJournal	.\src\memjournal.c	/^int sqlite3IsMemJournal(sqlite3_file *pJfd){$/;"	f
sqlite3IsNaN	.\src\sqliteInt.h	3221;"	d
sqlite3IsNaN	.\src\util.c	/^int sqlite3IsNaN(double x){$/;"	f
sqlite3IsNumericAffinity	.\src\sqliteInt.h	1562;"	d
sqlite3IsReadOnly	.\src\delete.c	/^int sqlite3IsReadOnly(Parse *pParse, Table *pTab, int viewOk){$/;"	f
sqlite3IsRowid	.\src\expr.c	/^int sqlite3IsRowid(const char *z){$/;"	f
sqlite3IsToplevel	.\src\sqliteInt.h	3514;"	d
sqlite3IsToplevel	.\src\sqliteInt.h	3524;"	d
sqlite3Isalnum	.\src\sqliteInt.h	3121;"	d
sqlite3Isalnum	.\src\sqliteInt.h	3129;"	d
sqlite3Isalpha	.\src\sqliteInt.h	3122;"	d
sqlite3Isalpha	.\src\sqliteInt.h	3130;"	d
sqlite3Isdigit	.\src\sqliteInt.h	3123;"	d
sqlite3Isdigit	.\src\sqliteInt.h	3131;"	d
sqlite3Isspace	.\src\sqliteInt.h	3120;"	d
sqlite3Isspace	.\src\sqliteInt.h	3128;"	d
sqlite3Isxdigit	.\src\sqliteInt.h	3124;"	d
sqlite3Isxdigit	.\src\sqliteInt.h	3132;"	d
sqlite3JoinType	.\src\select.c	/^int sqlite3JoinType(Parse *pParse, Token *pA, Token *pB, Token *pC){$/;"	f
sqlite3JournalCreate	.\src\journal.c	/^int sqlite3JournalCreate(sqlite3_file *p){$/;"	f
sqlite3JournalExists	.\src\journal.c	/^int sqlite3JournalExists(sqlite3_file *p){$/;"	f
sqlite3JournalExists	.\src\sqliteInt.h	3876;"	d
sqlite3JournalModename	.\src\pragma.c	/^const char *sqlite3JournalModename(int eMode){$/;"	f
sqlite3JournalOpen	.\src\journal.c	/^int sqlite3JournalOpen($/;"	f
sqlite3JournalSize	.\src\journal.c	/^int sqlite3JournalSize(sqlite3_vfs *pVfs){$/;"	f
sqlite3JournalSize	.\src\sqliteInt.h	3875;"	d
sqlite3Json1Init	.\ext\misc\json1.c	/^int sqlite3Json1Init(sqlite3 *db){$/;"	f
sqlite3KeyInfoAlloc	.\src\select.c	/^KeyInfo *sqlite3KeyInfoAlloc(sqlite3 *db, int N, int X){$/;"	f
sqlite3KeyInfoIsWriteable	.\src\select.c	/^int sqlite3KeyInfoIsWriteable(KeyInfo *p){ return p->nRef==1; }$/;"	f
sqlite3KeyInfoOfIndex	.\src\build.c	/^KeyInfo *sqlite3KeyInfoOfIndex(Parse *pParse, Index *pIdx){$/;"	f
sqlite3KeyInfoRef	.\src\select.c	/^KeyInfo *sqlite3KeyInfoRef(KeyInfo *p){$/;"	f
sqlite3KeyInfoUnref	.\src\select.c	/^void sqlite3KeyInfoUnref(KeyInfo *p){$/;"	f
sqlite3LeaveMutexAndCloseZombie	.\src\main.c	/^void sqlite3LeaveMutexAndCloseZombie(sqlite3 *db){$/;"	f
sqlite3LimitWhere	.\src\delete.c	/^Expr *sqlite3LimitWhere($/;"	f
sqlite3LoadExtension	.\src\loadext.c	/^static int sqlite3LoadExtension($/;"	f	file:
sqlite3LocateCollSeq	.\src\build.c	/^CollSeq *sqlite3LocateCollSeq(Parse *pParse, const char *zName){$/;"	f
sqlite3LocateTable	.\src\build.c	/^Table *sqlite3LocateTable($/;"	f
sqlite3LocateTableItem	.\src\build.c	/^Table *sqlite3LocateTableItem($/;"	f
sqlite3LockAndPrepare	.\src\prepare.c	/^static int sqlite3LockAndPrepare($/;"	f	file:
sqlite3LogEst	.\src\util.c	/^LogEst sqlite3LogEst(u64 x){$/;"	f
sqlite3LogEstAdd	.\src\util.c	/^LogEst sqlite3LogEstAdd(LogEst a, LogEst b){$/;"	f
sqlite3LogEstFromDouble	.\src\util.c	/^LogEst sqlite3LogEstFromDouble(double x){$/;"	f
sqlite3LogEstToInt	.\src\util.c	/^u64 sqlite3LogEstToInt(LogEst x){$/;"	f
sqlite3MPrintf	.\src\printf.c	/^char *sqlite3MPrintf(sqlite3 *db, const char *zFormat, ...){$/;"	f
sqlite3Malloc	.\src\malloc.c	/^void *sqlite3Malloc(u64 n){$/;"	f
sqlite3MallocAlarm	.\src\malloc.c	/^static void sqlite3MallocAlarm(int nByte){$/;"	f	file:
sqlite3MallocEnd	.\src\malloc.c	/^void sqlite3MallocEnd(void){$/;"	f
sqlite3MallocInit	.\src\malloc.c	/^int sqlite3MallocInit(void){$/;"	f
sqlite3MallocMutex	.\src\malloc.c	/^sqlite3_mutex *sqlite3MallocMutex(void){$/;"	f
sqlite3MallocSize	.\src\malloc.c	/^int sqlite3MallocSize(void *p){$/;"	f
sqlite3MallocZero	.\src\malloc.c	/^void *sqlite3MallocZero(u64 n){$/;"	f
sqlite3MatchSpanName	.\src\resolve.c	/^int sqlite3MatchSpanName($/;"	f
sqlite3MaterializeView	.\src\delete.c	/^void sqlite3MaterializeView($/;"	f
sqlite3MayAbort	.\src\build.c	/^void sqlite3MayAbort(Parse *pParse){$/;"	f
sqlite3MemCompare	.\src\vdbeaux.c	/^int sqlite3MemCompare(const Mem *pMem1, const Mem *pMem2, const CollSeq *pColl){$/;"	f
sqlite3MemFree	.\src\mem0.c	/^static void sqlite3MemFree(void *pPrior){ return; }$/;"	f	file:
sqlite3MemFree	.\src\mem1.c	/^static void sqlite3MemFree(void *pPrior){$/;"	f	file:
sqlite3MemFree	.\src\mem2.c	/^static void sqlite3MemFree(void *pPrior){$/;"	f	file:
sqlite3MemGetMemsys3	.\src\mem3.c	/^const sqlite3_mem_methods *sqlite3MemGetMemsys3(void){$/;"	f
sqlite3MemGetMemsys5	.\src\mem5.c	/^const sqlite3_mem_methods *sqlite3MemGetMemsys5(void){$/;"	f
sqlite3MemGetWin32	.\src\os_win.c	/^const sqlite3_mem_methods *sqlite3MemGetWin32(void){$/;"	f
sqlite3MemInit	.\src\mem0.c	/^static int sqlite3MemInit(void *NotUsed){ return SQLITE_OK; }$/;"	f	file:
sqlite3MemInit	.\src\mem1.c	/^static int sqlite3MemInit(void *NotUsed){$/;"	f	file:
sqlite3MemInit	.\src\mem2.c	/^static int sqlite3MemInit(void *NotUsed){$/;"	f	file:
sqlite3MemJournalOpen	.\src\memjournal.c	/^void sqlite3MemJournalOpen(sqlite3_file *pJfd){$/;"	f
sqlite3MemJournalSize	.\src\memjournal.c	/^int sqlite3MemJournalSize(void){$/;"	f
sqlite3MemMalloc	.\src\mem0.c	/^static void *sqlite3MemMalloc(int nByte){ return 0; }$/;"	f	file:
sqlite3MemMalloc	.\src\mem1.c	/^static void *sqlite3MemMalloc(int nByte){$/;"	f	file:
sqlite3MemMalloc	.\src\mem2.c	/^static void *sqlite3MemMalloc(int nByte){$/;"	f	file:
sqlite3MemRealloc	.\src\mem0.c	/^static void *sqlite3MemRealloc(void *pPrior, int nByte){ return 0; }$/;"	f	file:
sqlite3MemRealloc	.\src\mem1.c	/^static void *sqlite3MemRealloc(void *pPrior, int nByte){$/;"	f	file:
sqlite3MemRealloc	.\src\mem2.c	/^static void *sqlite3MemRealloc(void *pPrior, int nByte){$/;"	f	file:
sqlite3MemRoundup	.\src\mem0.c	/^static int sqlite3MemRoundup(int n){ return n; }$/;"	f	file:
sqlite3MemRoundup	.\src\mem1.c	/^static int sqlite3MemRoundup(int n){$/;"	f	file:
sqlite3MemRoundup	.\src\mem2.c	/^static int sqlite3MemRoundup(int n){$/;"	f	file:
sqlite3MemSetDefault	.\src\mem0.c	/^void sqlite3MemSetDefault(void){$/;"	f
sqlite3MemSetDefault	.\src\mem1.c	/^void sqlite3MemSetDefault(void){$/;"	f
sqlite3MemSetDefault	.\src\mem2.c	/^void sqlite3MemSetDefault(void){$/;"	f
sqlite3MemSetDefault	.\src\os_win.c	/^void sqlite3MemSetDefault(void){$/;"	f
sqlite3MemShutdown	.\src\mem0.c	/^static void sqlite3MemShutdown(void *NotUsed){ return; }$/;"	f	file:
sqlite3MemShutdown	.\src\mem1.c	/^static void sqlite3MemShutdown(void *NotUsed){$/;"	f	file:
sqlite3MemShutdown	.\src\mem2.c	/^static void sqlite3MemShutdown(void *NotUsed){$/;"	f	file:
sqlite3MemSize	.\src\mem0.c	/^static int sqlite3MemSize(void *pPrior){ return 0; }$/;"	f	file:
sqlite3MemSize	.\src\mem1.c	/^static int sqlite3MemSize(void *pPrior){$/;"	f	file:
sqlite3MemSize	.\src\mem2.c	/^static int sqlite3MemSize(void *p){$/;"	f	file:
sqlite3MemdebugBacktrace	.\src\mem2.c	/^void sqlite3MemdebugBacktrace(int depth){$/;"	f
sqlite3MemdebugBacktraceCallback	.\src\mem2.c	/^void sqlite3MemdebugBacktraceCallback(void (*xBacktrace)(int, int, void **)){$/;"	f
sqlite3MemdebugDump	.\src\mem2.c	/^void sqlite3MemdebugDump(const char *zFilename){$/;"	f
sqlite3MemdebugHasType	.\src\mem2.c	/^int sqlite3MemdebugHasType(void *p, u8 eType){$/;"	f
sqlite3MemdebugHasType	.\src\sqliteInt.h	3957;"	d
sqlite3MemdebugMallocCount	.\src\mem2.c	/^int sqlite3MemdebugMallocCount(){$/;"	f
sqlite3MemdebugNoType	.\src\mem2.c	/^int sqlite3MemdebugNoType(void *p, u8 eType){$/;"	f
sqlite3MemdebugNoType	.\src\sqliteInt.h	3958;"	d
sqlite3MemdebugSetType	.\src\mem2.c	/^void sqlite3MemdebugSetType(void *p, u8 eType){$/;"	f
sqlite3MemdebugSetType	.\src\sqliteInt.h	3956;"	d
sqlite3MemdebugSettitle	.\src\mem2.c	/^void sqlite3MemdebugSettitle(const char *zTitle){$/;"	f
sqlite3MemdebugSync	.\src\mem2.c	/^void sqlite3MemdebugSync(){$/;"	f
sqlite3MemoryBarrier	.\src\mutex_unix.c	/^void sqlite3MemoryBarrier(void){$/;"	f
sqlite3MemoryBarrier	.\src\mutex_w32.c	/^void sqlite3MemoryBarrier(void){$/;"	f
sqlite3MemoryBarrier	.\src\sqliteInt.h	3206;"	d
sqlite3Memsys3Dump	.\src\mem3.c	/^void sqlite3Memsys3Dump(const char *zFilename){$/;"	f
sqlite3Memsys5Dump	.\src\mem5.c	/^void sqlite3Memsys5Dump(const char *zFilename){$/;"	f
sqlite3MemsysGetHeader	.\src\mem2.c	/^static struct MemBlockHdr *sqlite3MemsysGetHeader(void *pAllocation){$/;"	f	file:
sqlite3MinimumFileFormat	.\src\alter.c	/^void sqlite3MinimumFileFormat(Parse *pParse, int iDb, int minFormat){$/;"	f
sqlite3MisuseError	.\src\main.c	/^int sqlite3MisuseError(int lineno){$/;"	f
sqlite3MulInt64	.\src\util.c	/^int sqlite3MulInt64(i64 *pA, i64 iB){$/;"	f
sqlite3MultiWrite	.\src\build.c	/^void sqlite3MultiWrite(Parse *pParse){$/;"	f
sqlite3MutexAlloc	.\src\mutex.c	/^sqlite3_mutex *sqlite3MutexAlloc(int id){$/;"	f
sqlite3MutexAlloc	.\src\mutex.h	64;"	d
sqlite3MutexEnd	.\src\mutex.c	/^int sqlite3MutexEnd(void){$/;"	f
sqlite3MutexEnd	.\src\mutex.h	66;"	d
sqlite3MutexInit	.\src\mutex.c	/^int sqlite3MutexInit(void){ $/;"	f
sqlite3MutexInit	.\src\mutex.h	65;"	d
sqlite3NameFromToken	.\src\build.c	/^char *sqlite3NameFromToken(sqlite3 *db, Token *pName){$/;"	f
sqlite3NestedParse	.\src\build.c	/^void sqlite3NestedParse(Parse *pParse, const char *zFormat, ...){$/;"	f
sqlite3NoopMutex	.\src\mutex_noop.c	/^sqlite3_mutex_methods const *sqlite3NoopMutex(void){$/;"	f
sqlite3OSTrace	.\src\main.c	/^  int sqlite3OSTrace = SQLITE_DEBUG_OS_TRACE;$/;"	v
sqlite3OpcodeProperty	.\src\global.c	/^const unsigned char sqlite3OpcodeProperty[] = OPFLG_INITIALIZER;$/;"	v
sqlite3OpenMasterTable	.\src\build.c	/^void sqlite3OpenMasterTable(Parse *p, int iDb){$/;"	f
sqlite3OpenTable	.\src\insert.c	/^void sqlite3OpenTable($/;"	f
sqlite3OpenTableAndIndices	.\src\insert.c	/^int sqlite3OpenTableAndIndices($/;"	f
sqlite3OpenTempDatabase	.\src\build.c	/^int sqlite3OpenTempDatabase(Parse *pParse){$/;"	f
sqlite3OsAccess	.\src\os.c	/^int sqlite3OsAccess($/;"	f
sqlite3OsCheckReservedLock	.\src\os.c	/^int sqlite3OsCheckReservedLock(sqlite3_file *id, int *pResOut){$/;"	f
sqlite3OsClose	.\src\os.c	/^int sqlite3OsClose(sqlite3_file *pId){$/;"	f
sqlite3OsCloseFree	.\src\os.c	/^int sqlite3OsCloseFree(sqlite3_file *pFile){$/;"	f
sqlite3OsCurrentTimeInt64	.\src\os.c	/^int sqlite3OsCurrentTimeInt64(sqlite3_vfs *pVfs, sqlite3_int64 *pTimeOut){$/;"	f
sqlite3OsDelete	.\src\os.c	/^int sqlite3OsDelete(sqlite3_vfs *pVfs, const char *zPath, int dirSync){$/;"	f
sqlite3OsDeviceCharacteristics	.\src\os.c	/^int sqlite3OsDeviceCharacteristics(sqlite3_file *id){$/;"	f
sqlite3OsDlClose	.\src\os.c	/^void sqlite3OsDlClose(sqlite3_vfs *pVfs, void *pHandle){$/;"	f
sqlite3OsDlError	.\src\os.c	/^void sqlite3OsDlError(sqlite3_vfs *pVfs, int nByte, char *zBufOut){$/;"	f
sqlite3OsDlOpen	.\src\os.c	/^void *sqlite3OsDlOpen(sqlite3_vfs *pVfs, const char *zPath){$/;"	f
sqlite3OsDlSym	.\src\os.c	/^void (*sqlite3OsDlSym(sqlite3_vfs *pVfs, void *pHdle, const char *zSym))(void){$/;"	f
sqlite3OsFetch	.\src\os.c	/^int sqlite3OsFetch(sqlite3_file *id, i64 iOff, int iAmt, void **pp){$/;"	f
sqlite3OsFileControl	.\src\os.c	/^int sqlite3OsFileControl(sqlite3_file *id, int op, void *pArg){$/;"	f
sqlite3OsFileControlHint	.\src\os.c	/^void sqlite3OsFileControlHint(sqlite3_file *id, int op, void *pArg){$/;"	f
sqlite3OsFileSize	.\src\os.c	/^int sqlite3OsFileSize(sqlite3_file *id, i64 *pSize){$/;"	f
sqlite3OsFullPathname	.\src\os.c	/^int sqlite3OsFullPathname($/;"	f
sqlite3OsInit	.\src\os.c	/^int sqlite3OsInit(void){$/;"	f
sqlite3OsLock	.\src\os.c	/^int sqlite3OsLock(sqlite3_file *id, int lockType){$/;"	f
sqlite3OsOpen	.\src\os.c	/^int sqlite3OsOpen($/;"	f
sqlite3OsOpenMalloc	.\src\os.c	/^int sqlite3OsOpenMalloc($/;"	f
sqlite3OsRandomness	.\src\os.c	/^int sqlite3OsRandomness(sqlite3_vfs *pVfs, int nByte, char *zBufOut){$/;"	f
sqlite3OsRead	.\src\os.c	/^int sqlite3OsRead(sqlite3_file *id, void *pBuf, int amt, i64 offset){$/;"	f
sqlite3OsSectorSize	.\src\os.c	/^int sqlite3OsSectorSize(sqlite3_file *id){$/;"	f
sqlite3OsShmBarrier	.\src\os.c	/^void sqlite3OsShmBarrier(sqlite3_file *id){$/;"	f
sqlite3OsShmLock	.\src\os.c	/^int sqlite3OsShmLock(sqlite3_file *id, int offset, int n, int flags){$/;"	f
sqlite3OsShmMap	.\src\os.c	/^int sqlite3OsShmMap($/;"	f
sqlite3OsShmUnmap	.\src\os.c	/^int sqlite3OsShmUnmap(sqlite3_file *id, int deleteFlag){$/;"	f
sqlite3OsSleep	.\src\os.c	/^int sqlite3OsSleep(sqlite3_vfs *pVfs, int nMicro){$/;"	f
sqlite3OsSync	.\src\os.c	/^int sqlite3OsSync(sqlite3_file *id, int flags){$/;"	f
sqlite3OsTruncate	.\src\os.c	/^int sqlite3OsTruncate(sqlite3_file *id, i64 size){$/;"	f
sqlite3OsUnfetch	.\src\os.c	/^int sqlite3OsUnfetch(sqlite3_file *id, i64 iOff, void *p){$/;"	f
sqlite3OsUnlock	.\src\os.c	/^int sqlite3OsUnlock(sqlite3_file *id, int lockType){$/;"	f
sqlite3OsWrite	.\src\os.c	/^int sqlite3OsWrite(sqlite3_file *id, const void *pBuf, int amt, i64 offset){$/;"	f
sqlite3PCacheBufferSetup	.\src\pcache1.c	/^void sqlite3PCacheBufferSetup(void *pBuf, int sz, int n){$/;"	f
sqlite3PCacheSetDefault	.\src\pcache1.c	/^void sqlite3PCacheSetDefault(void){$/;"	f
sqlite3PExpr	.\src\expr.c	/^Expr *sqlite3PExpr($/;"	f
sqlite3PageFree	.\src\pcache1.c	/^void sqlite3PageFree(void *p){$/;"	f
sqlite3PageMalloc	.\src\pcache1.c	/^void *sqlite3PageMalloc(int sz){$/;"	f
sqlite3PagerAcquire	.\src\pager.c	/^int sqlite3PagerAcquire($/;"	f
sqlite3PagerAlignReserve	.\src\pager.c	/^void sqlite3PagerAlignReserve(Pager *pDest, Pager *pSrc){$/;"	f
sqlite3PagerBackupPtr	.\src\pager.c	/^sqlite3_backup **sqlite3PagerBackupPtr(Pager *pPager){$/;"	f
sqlite3PagerBegin	.\src\pager.c	/^int sqlite3PagerBegin(Pager *pPager, int exFlag, int subjInMemory){$/;"	f
sqlite3PagerCacheStat	.\src\pager.c	/^void sqlite3PagerCacheStat(Pager *pPager, int eStat, int reset, int *pnVal){$/;"	f
sqlite3PagerCheckpoint	.\src\pager.c	/^int sqlite3PagerCheckpoint(Pager *pPager, int eMode, int *pnLog, int *pnCkpt){$/;"	f
sqlite3PagerClearCache	.\src\pager.c	/^void sqlite3PagerClearCache(Pager *pPager){$/;"	f
sqlite3PagerClose	.\src\pager.c	/^int sqlite3PagerClose(Pager *pPager){$/;"	f
sqlite3PagerCloseWal	.\src\pager.c	/^int sqlite3PagerCloseWal(Pager *pPager){$/;"	f
sqlite3PagerCodec	.\src\pager.c	/^void *sqlite3PagerCodec(PgHdr *pPg){$/;"	f
sqlite3PagerCommitPhaseOne	.\src\pager.c	/^int sqlite3PagerCommitPhaseOne($/;"	f
sqlite3PagerCommitPhaseTwo	.\src\pager.c	/^int sqlite3PagerCommitPhaseTwo(Pager *pPager){$/;"	f
sqlite3PagerDataVersion	.\src\pager.c	/^u32 sqlite3PagerDataVersion(Pager *pPager){$/;"	f
sqlite3PagerDontWrite	.\src\pager.c	/^void sqlite3PagerDontWrite(PgHdr *pPg){$/;"	f
sqlite3PagerExclusiveLock	.\src\pager.c	/^int sqlite3PagerExclusiveLock(Pager *pPager){$/;"	f
sqlite3PagerFile	.\src\pager.c	/^sqlite3_file *sqlite3PagerFile(Pager *pPager){$/;"	f
sqlite3PagerFilename	.\src\pager.c	/^const char *sqlite3PagerFilename(Pager *pPager, int nullIfMemDb){$/;"	f
sqlite3PagerGet	.\src\pager.h	138;"	d
sqlite3PagerGetCodec	.\src\pager.c	/^void *sqlite3PagerGetCodec(Pager *pPager){$/;"	f
sqlite3PagerGetData	.\src\pager.c	/^void *sqlite3PagerGetData(DbPage *pPg){$/;"	f
sqlite3PagerGetExtra	.\src\pager.c	/^void *sqlite3PagerGetExtra(DbPage *pPg){$/;"	f
sqlite3PagerGetJournalMode	.\src\pager.c	/^int sqlite3PagerGetJournalMode(Pager *pPager){$/;"	f
sqlite3PagerIsMemdb	.\src\pager.c	/^int sqlite3PagerIsMemdb(Pager *pPager){$/;"	f
sqlite3PagerIsreadonly	.\src\pager.c	/^u8 sqlite3PagerIsreadonly(Pager *pPager){$/;"	f
sqlite3PagerIswriteable	.\src\pager.c	/^int sqlite3PagerIswriteable(DbPage *pPg){$/;"	f
sqlite3PagerJournalSizeLimit	.\src\pager.c	/^i64 sqlite3PagerJournalSizeLimit(Pager *pPager, i64 iLimit){$/;"	f
sqlite3PagerJournalname	.\src\pager.c	/^const char *sqlite3PagerJournalname(Pager *pPager){$/;"	f
sqlite3PagerLockingMode	.\src\pager.c	/^int sqlite3PagerLockingMode(Pager *pPager, int eMode){$/;"	f
sqlite3PagerLookup	.\src\pager.c	/^DbPage *sqlite3PagerLookup(Pager *pPager, Pgno pgno){$/;"	f
sqlite3PagerMaxPageCount	.\src\pager.c	/^int sqlite3PagerMaxPageCount(Pager *pPager, int mxPage){$/;"	f
sqlite3PagerMemUsed	.\src\pager.c	/^int sqlite3PagerMemUsed(Pager *pPager){$/;"	f
sqlite3PagerMovepage	.\src\pager.c	/^int sqlite3PagerMovepage(Pager *pPager, DbPage *pPg, Pgno pgno, int isCommit){$/;"	f
sqlite3PagerNosync	.\src\pager.c	/^int sqlite3PagerNosync(Pager *pPager){$/;"	f
sqlite3PagerOkToChangeJournalMode	.\src\pager.c	/^int sqlite3PagerOkToChangeJournalMode(Pager *pPager){$/;"	f
sqlite3PagerOpen	.\src\pager.c	/^int sqlite3PagerOpen($/;"	f
sqlite3PagerOpenSavepoint	.\src\pager.c	/^int sqlite3PagerOpenSavepoint(Pager *pPager, int nSavepoint){$/;"	f
sqlite3PagerOpenWal	.\src\pager.c	/^int sqlite3PagerOpenWal($/;"	f
sqlite3PagerPageRefcount	.\src\pager.c	/^int sqlite3PagerPageRefcount(DbPage *pPage){$/;"	f
sqlite3PagerPagecount	.\src\pager.c	/^void sqlite3PagerPagecount(Pager *pPager, int *pnPage){$/;"	f
sqlite3PagerPagenumber	.\src\pager.c	/^Pgno sqlite3PagerPagenumber(DbPage *pPg){$/;"	f
sqlite3PagerReadFileheader	.\src\pager.c	/^int sqlite3PagerReadFileheader(Pager *pPager, int N, unsigned char *pDest){$/;"	f
sqlite3PagerRef	.\src\pager.c	/^void sqlite3PagerRef(DbPage *pPg){$/;"	f
sqlite3PagerRefcount	.\src\pager.c	/^int sqlite3PagerRefcount(Pager *pPager){$/;"	f
sqlite3PagerRekey	.\src\pager.c	/^void sqlite3PagerRekey(DbPage *pPg, Pgno iNew, u16 flags){$/;"	f
sqlite3PagerRollback	.\src\pager.c	/^int sqlite3PagerRollback(Pager *pPager){$/;"	f
sqlite3PagerSavepoint	.\src\pager.c	/^int sqlite3PagerSavepoint(Pager *pPager, int op, int iSavepoint){$/;"	f
sqlite3PagerSetBusyhandler	.\src\pager.c	/^void sqlite3PagerSetBusyhandler($/;"	f
sqlite3PagerSetCachesize	.\src\pager.c	/^void sqlite3PagerSetCachesize(Pager *pPager, int mxPage){$/;"	f
sqlite3PagerSetCodec	.\src\pager.c	/^void sqlite3PagerSetCodec($/;"	f
sqlite3PagerSetFlags	.\src\pager.c	/^void sqlite3PagerSetFlags($/;"	f
sqlite3PagerSetJournalMode	.\src\pager.c	/^int sqlite3PagerSetJournalMode(Pager *pPager, int eMode){$/;"	f
sqlite3PagerSetMmapLimit	.\src\pager.c	/^void sqlite3PagerSetMmapLimit(Pager *pPager, sqlite3_int64 szMmap){$/;"	f
sqlite3PagerSetPagesize	.\src\pager.c	/^int sqlite3PagerSetPagesize(Pager *pPager, u32 *pPageSize, int nReserve){$/;"	f
sqlite3PagerSharedLock	.\src\pager.c	/^int sqlite3PagerSharedLock(Pager *pPager){$/;"	f
sqlite3PagerShrink	.\src\pager.c	/^void sqlite3PagerShrink(Pager *pPager){$/;"	f
sqlite3PagerState	.\src\pager.c	/^int sqlite3PagerState(Pager *pPager){$/;"	f
sqlite3PagerStats	.\src\pager.c	/^int *sqlite3PagerStats(Pager *pPager){$/;"	f
sqlite3PagerSync	.\src\pager.c	/^int sqlite3PagerSync(Pager *pPager, const char *zMaster){$/;"	f
sqlite3PagerTempSpace	.\src\pager.c	/^void *sqlite3PagerTempSpace(Pager *pPager){$/;"	f
sqlite3PagerTruncateImage	.\src\pager.c	/^void sqlite3PagerTruncateImage(Pager *pPager, Pgno nPage){$/;"	f
sqlite3PagerUnref	.\src\pager.c	/^void sqlite3PagerUnref(DbPage *pPg){$/;"	f
sqlite3PagerUnrefNotNull	.\src\pager.c	/^void sqlite3PagerUnrefNotNull(DbPage *pPg){$/;"	f
sqlite3PagerVfs	.\src\pager.c	/^const sqlite3_vfs *sqlite3PagerVfs(Pager *pPager){$/;"	f
sqlite3PagerWalCallback	.\src\pager.c	/^int sqlite3PagerWalCallback(Pager *pPager){$/;"	f
sqlite3PagerWalFramesize	.\src\pager.c	/^int sqlite3PagerWalFramesize(Pager *pPager){$/;"	f
sqlite3PagerWalSupported	.\src\pager.c	/^int sqlite3PagerWalSupported(Pager *pPager){$/;"	f
sqlite3PagerWrite	.\src\pager.c	/^int sqlite3PagerWrite(PgHdr *pPg){$/;"	f
sqlite3ParseToplevel	.\src\sqliteInt.h	3513;"	d
sqlite3ParseToplevel	.\src\sqliteInt.h	3523;"	d
sqlite3ParseUri	.\src\main.c	/^int sqlite3ParseUri($/;"	f
sqlite3ParserReset	.\src\prepare.c	/^void sqlite3ParserReset(Parse *pParse){$/;"	f
sqlite3Pcache1Mutex	.\src\pcache1.c	/^sqlite3_mutex *sqlite3Pcache1Mutex(void){$/;"	f
sqlite3PcacheCleanAll	.\src\pcache.c	/^void sqlite3PcacheCleanAll(PCache *pCache){$/;"	f
sqlite3PcacheClear	.\src\pcache.c	/^void sqlite3PcacheClear(PCache *pCache){$/;"	f
sqlite3PcacheClearSyncFlags	.\src\pcache.c	/^void sqlite3PcacheClearSyncFlags(PCache *pCache){$/;"	f
sqlite3PcacheClose	.\src\pcache.c	/^void sqlite3PcacheClose(PCache *pCache){$/;"	f
sqlite3PcacheDirtyList	.\src\pcache.c	/^PgHdr *sqlite3PcacheDirtyList(PCache *pCache){$/;"	f
sqlite3PcacheDrop	.\src\pcache.c	/^void sqlite3PcacheDrop(PgHdr *p){$/;"	f
sqlite3PcacheFetch	.\src\pcache.c	/^sqlite3_pcache_page *sqlite3PcacheFetch($/;"	f
sqlite3PcacheFetchFinish	.\src\pcache.c	/^PgHdr *sqlite3PcacheFetchFinish($/;"	f
sqlite3PcacheFetchStress	.\src\pcache.c	/^int sqlite3PcacheFetchStress($/;"	f
sqlite3PcacheGetCachesize	.\src\pcache.c	/^int sqlite3PcacheGetCachesize(PCache *pCache){$/;"	f
sqlite3PcacheInitialize	.\src\pcache.c	/^int sqlite3PcacheInitialize(void){$/;"	f
sqlite3PcacheIterateDirty	.\src\pcache.c	/^void sqlite3PcacheIterateDirty(PCache *pCache, void (*xIter)(PgHdr *)){$/;"	f
sqlite3PcacheMakeClean	.\src\pcache.c	/^void sqlite3PcacheMakeClean(PgHdr *p){$/;"	f
sqlite3PcacheMakeDirty	.\src\pcache.c	/^void sqlite3PcacheMakeDirty(PgHdr *p){$/;"	f
sqlite3PcacheMove	.\src\pcache.c	/^void sqlite3PcacheMove(PgHdr *p, Pgno newPgno){$/;"	f
sqlite3PcacheOpen	.\src\pcache.c	/^int sqlite3PcacheOpen($/;"	f
sqlite3PcachePageRefcount	.\src\pcache.c	/^int sqlite3PcachePageRefcount(PgHdr *p){$/;"	f
sqlite3PcachePagecount	.\src\pcache.c	/^int sqlite3PcachePagecount(PCache *pCache){$/;"	f
sqlite3PcacheRef	.\src\pcache.c	/^void sqlite3PcacheRef(PgHdr *p){$/;"	f
sqlite3PcacheRefCount	.\src\pcache.c	/^int sqlite3PcacheRefCount(PCache *pCache){$/;"	f
sqlite3PcacheRelease	.\src\pcache.c	/^void SQLITE_NOINLINE sqlite3PcacheRelease(PgHdr *p){$/;"	f
sqlite3PcacheReleaseMemory	.\src\pcache1.c	/^int sqlite3PcacheReleaseMemory(int nReq){$/;"	f
sqlite3PcacheSetCachesize	.\src\pcache.c	/^void sqlite3PcacheSetCachesize(PCache *pCache, int mxPage){$/;"	f
sqlite3PcacheSetPageSize	.\src\pcache.c	/^int sqlite3PcacheSetPageSize(PCache *pCache, int szPage){$/;"	f
sqlite3PcacheShrink	.\src\pcache.c	/^void sqlite3PcacheShrink(PCache *pCache){$/;"	f
sqlite3PcacheShutdown	.\src\pcache.c	/^void sqlite3PcacheShutdown(void){$/;"	f
sqlite3PcacheSize	.\src\pcache.c	/^int sqlite3PcacheSize(void){ return sizeof(PCache); }$/;"	f
sqlite3PcacheStats	.\src\pcache1.c	/^void sqlite3PcacheStats($/;"	f
sqlite3PcacheTruncate	.\src\pcache.c	/^void sqlite3PcacheTruncate(PCache *pCache, Pgno pgno){$/;"	f
sqlite3PendingByte	.\src\global.c	/^int sqlite3PendingByte = 0x40000000;$/;"	v
sqlite3Pragma	.\src\pragma.c	/^void sqlite3Pragma($/;"	f
sqlite3Prepare	.\src\prepare.c	/^static int sqlite3Prepare($/;"	f	file:
sqlite3Prepare16	.\src\prepare.c	/^static int sqlite3Prepare16($/;"	f	file:
sqlite3PrimaryKeyIndex	.\src\build.c	/^Index *sqlite3PrimaryKeyIndex(Table *pTab){$/;"	f
sqlite3Prng	.\src\random.c	/^} sqlite3Prng;$/;"	v	typeref:struct:sqlite3PrngType	file:
sqlite3PrngRestoreState	.\src\random.c	/^void sqlite3PrngRestoreState(void){$/;"	f
sqlite3PrngSaveState	.\src\random.c	/^void sqlite3PrngSaveState(void){$/;"	f
sqlite3PrngType	.\src\random.c	/^static SQLITE_WSD struct sqlite3PrngType {$/;"	s	file:
sqlite3Put4byte	.\src\util.c	/^void sqlite3Put4byte(unsigned char *p, u32 v){$/;"	f
sqlite3PutVarint	.\src\util.c	/^int sqlite3PutVarint(unsigned char *p, u64 v){$/;"	f
sqlite3ReadSchema	.\src\prepare.c	/^int sqlite3ReadSchema(Parse *pParse){$/;"	f
sqlite3Realloc	.\src\malloc.c	/^void *sqlite3Realloc(void *pOld, u64 nBytes){$/;"	f
sqlite3RefillIndex	.\src\build.c	/^static void sqlite3RefillIndex(Parse *pParse, Index *pIndex, int memRootPage){$/;"	f	file:
sqlite3RegisterBuiltinFunctions	.\src\func.c	/^void sqlite3RegisterBuiltinFunctions(sqlite3 *db){$/;"	f
sqlite3RegisterDateTimeFunctions	.\src\date.c	/^void sqlite3RegisterDateTimeFunctions(void){$/;"	f
sqlite3RegisterGlobalFunctions	.\src\func.c	/^void sqlite3RegisterGlobalFunctions(void){$/;"	f
sqlite3RegisterLikeFunctions	.\src\func.c	/^void sqlite3RegisterLikeFunctions(sqlite3 *db, int caseSensitive){$/;"	f
sqlite3Reindex	.\src\build.c	/^void sqlite3Reindex(Parse *pParse, Token *pName1, Token *pName2){$/;"	f
sqlite3ReleaseTempRange	.\src\expr.c	/^void sqlite3ReleaseTempRange(Parse *pParse, int iReg, int nReg){$/;"	f
sqlite3ReleaseTempReg	.\src\expr.c	/^void sqlite3ReleaseTempReg(Parse *pParse, int iReg){$/;"	f
sqlite3Reprepare	.\src\prepare.c	/^int sqlite3Reprepare(Vdbe *p){$/;"	f
sqlite3ResetAllSchemasOfConnection	.\src\build.c	/^void sqlite3ResetAllSchemasOfConnection(sqlite3 *db){$/;"	f
sqlite3ResetOneSchema	.\src\build.c	/^void sqlite3ResetOneSchema(sqlite3 *db, int iDb){$/;"	f
sqlite3ResolveExprListNames	.\src\resolve.c	/^int sqlite3ResolveExprListNames( $/;"	f
sqlite3ResolveExprNames	.\src\resolve.c	/^int sqlite3ResolveExprNames( $/;"	f
sqlite3ResolveOrderGroupBy	.\src\resolve.c	/^int sqlite3ResolveOrderGroupBy($/;"	f
sqlite3ResolvePartIdxLabel	.\src\delete.c	/^void sqlite3ResolvePartIdxLabel(Parse *pParse, int iLabel){$/;"	f
sqlite3ResolveSelectNames	.\src\resolve.c	/^void sqlite3ResolveSelectNames($/;"	f
sqlite3ResolveSelfReference	.\src\resolve.c	/^void sqlite3ResolveSelfReference($/;"	f
sqlite3ResultSetOfSelect	.\src\select.c	/^Table *sqlite3ResultSetOfSelect(Parse *pParse, Select *pSelect){$/;"	f
sqlite3RollbackAll	.\src\main.c	/^void sqlite3RollbackAll(sqlite3 *db, int tripCode){$/;"	f
sqlite3RollbackTransaction	.\src\build.c	/^void sqlite3RollbackTransaction(Parse *pParse){$/;"	f
sqlite3RootPageMoved	.\src\build.c	/^void sqlite3RootPageMoved(sqlite3 *db, int iDb, int iFrom, int iTo){$/;"	f
sqlite3RowSetClear	.\src\rowset.c	/^void sqlite3RowSetClear(RowSet *p){$/;"	f
sqlite3RowSetInit	.\src\rowset.c	/^RowSet *sqlite3RowSetInit(sqlite3 *db, void *pSpace, unsigned int N){$/;"	f
sqlite3RowSetInsert	.\src\rowset.c	/^void sqlite3RowSetInsert(RowSet *p, i64 rowid){$/;"	f
sqlite3RowSetNext	.\src\rowset.c	/^int sqlite3RowSetNext(RowSet *p, i64 *pRowid){$/;"	f
sqlite3RowSetTest	.\src\rowset.c	/^int sqlite3RowSetTest(RowSet *pRowSet, int iBatch, sqlite3_int64 iRowid){$/;"	f
sqlite3RowidConstraint	.\src\build.c	/^void sqlite3RowidConstraint($/;"	f
sqlite3RtreeInit	.\ext\rtree\rtree.c	/^int sqlite3RtreeInit(sqlite3 *db){$/;"	f
sqlite3RunParser	.\src\tokenize.c	/^int sqlite3RunParser(Parse *pParse, const char *zSql, char **pzErrMsg){$/;"	f
sqlite3RunVacuum	.\src\vacuum.c	/^int sqlite3RunVacuum(char **pzErrMsg, sqlite3 *db){$/;"	f
sqlite3SafetyCheckOk	.\src\util.c	/^int sqlite3SafetyCheckOk(sqlite3 *db){$/;"	f
sqlite3SafetyCheckSickOrOk	.\src\util.c	/^int sqlite3SafetyCheckSickOrOk(sqlite3 *db){$/;"	f
sqlite3SavedPrng	.\src\random.c	/^static SQLITE_WSD struct sqlite3PrngType sqlite3SavedPrng;$/;"	v	typeref:struct:sqlite3PrngType	file:
sqlite3Savepoint	.\src\build.c	/^void sqlite3Savepoint(Parse *pParse, int op, Token *pName){$/;"	f
sqlite3SchemaClear	.\src\callback.c	/^void sqlite3SchemaClear(void *p){$/;"	f
sqlite3SchemaGet	.\src\callback.c	/^Schema *sqlite3SchemaGet(sqlite3 *db, Btree *pBt){$/;"	f
sqlite3SchemaMutexHeld	.\src\btmutex.c	/^int sqlite3SchemaMutexHeld(sqlite3 *db, int iDb, Schema *pSchema){$/;"	f
sqlite3SchemaMutexHeld	.\src\btree.h	270;"	d
sqlite3SchemaToIndex	.\src\prepare.c	/^int sqlite3SchemaToIndex(sqlite3 *db, Schema *pSchema){$/;"	f
sqlite3ScratchFree	.\src\malloc.c	/^void sqlite3ScratchFree(void *p){$/;"	f
sqlite3ScratchMalloc	.\src\malloc.c	/^void *sqlite3ScratchMalloc(int n){$/;"	f
sqlite3SectorSize	.\src\pager.c	/^int sqlite3SectorSize(sqlite3_file *pFile){$/;"	f
sqlite3Select	.\src\select.c	/^int sqlite3Select($/;"	f
sqlite3SelectAddTypeInfo	.\src\select.c	/^static void sqlite3SelectAddTypeInfo(Parse *pParse, Select *pSelect){$/;"	f	file:
sqlite3SelectDelete	.\src\select.c	/^void sqlite3SelectDelete(sqlite3 *db, Select *p){$/;"	f
sqlite3SelectDestInit	.\src\select.c	/^void sqlite3SelectDestInit(SelectDest *pDest, int eDest, int iParm){$/;"	f
sqlite3SelectDup	.\src\expr.c	/^Select *sqlite3SelectDup(sqlite3 *db, Select *p, int flags){$/;"	f
sqlite3SelectExpand	.\src\select.c	/^static void sqlite3SelectExpand(Parse *pParse, Select *pSelect){$/;"	f	file:
sqlite3SelectExprHeight	.\src\expr.c	/^int sqlite3SelectExprHeight(Select *p){$/;"	f
sqlite3SelectExprHeight	.\src\sqliteInt.h	3888;"	d
sqlite3SelectNew	.\src\select.c	/^Select *sqlite3SelectNew($/;"	f
sqlite3SelectPrep	.\src\select.c	/^void sqlite3SelectPrep($/;"	f
sqlite3SelectSetName	.\src\select.c	/^void sqlite3SelectSetName(Select *p, const char *zName){$/;"	f
sqlite3SelectSetName	.\src\sqliteInt.h	3477;"	d
sqlite3SelectTrace	.\src\select.c	/^\/***\/ int sqlite3SelectTrace = 0;$/;"	v
sqlite3SelectWrongNumTermsError	.\src\select.c	/^void sqlite3SelectWrongNumTermsError(Parse *pParse, Select *p){$/;"	f
sqlite3SetHasNullFlag	.\src\expr.c	/^static void sqlite3SetHasNullFlag(Vdbe *v, int iCur, int regHasNull){$/;"	f	file:
sqlite3SetString	.\src\malloc.c	/^void sqlite3SetString(char **pz, sqlite3 *db, const char *zNew){$/;"	f
sqlite3SharedCacheList	.\src\btree.c	/^BtShared *SQLITE_WSD sqlite3SharedCacheList = 0;$/;"	v
sqlite3SharedCacheList	.\src\btree.c	/^static BtShared *SQLITE_WSD sqlite3SharedCacheList = 0;$/;"	v	file:
sqlite3SkipAccumulatorLoad	.\src\func.c	/^static void sqlite3SkipAccumulatorLoad(sqlite3_context *context){$/;"	f	file:
sqlite3SmallTypeSizes	.\src\vdbeaux.c	/^static const u8 sqlite3SmallTypeSizes[] = {$/;"	v	file:
sqlite3SrcListAppend	.\src\build.c	/^SrcList *sqlite3SrcListAppend($/;"	f
sqlite3SrcListAppendFromTerm	.\src\build.c	/^SrcList *sqlite3SrcListAppendFromTerm($/;"	f
sqlite3SrcListAssignCursors	.\src\build.c	/^void sqlite3SrcListAssignCursors(Parse *pParse, SrcList *pList){$/;"	f
sqlite3SrcListDelete	.\src\build.c	/^void sqlite3SrcListDelete(sqlite3 *db, SrcList *pList){$/;"	f
sqlite3SrcListDup	.\src\expr.c	/^SrcList *sqlite3SrcListDup(sqlite3 *db, SrcList *p, int flags){$/;"	f
sqlite3SrcListEnlarge	.\src\build.c	/^SrcList *sqlite3SrcListEnlarge($/;"	f
sqlite3SrcListFuncArgs	.\src\build.c	/^void sqlite3SrcListFuncArgs(Parse *pParse, SrcList *p, ExprList *pList){$/;"	f
sqlite3SrcListIndexedBy	.\src\build.c	/^void sqlite3SrcListIndexedBy(Parse *pParse, SrcList *p, Token *pIndexedBy){$/;"	f
sqlite3SrcListLookup	.\src\delete.c	/^Table *sqlite3SrcListLookup(Parse *pParse, SrcList *pSrc){$/;"	f
sqlite3SrcListShiftJoinType	.\src\build.c	/^void sqlite3SrcListShiftJoinType(SrcList *p){$/;"	f
sqlite3StackAllocRaw	.\src\sqliteInt.h	3179;"	d
sqlite3StackAllocRaw	.\src\sqliteInt.h	3183;"	d
sqlite3StackAllocZero	.\src\sqliteInt.h	3180;"	d
sqlite3StackAllocZero	.\src\sqliteInt.h	3184;"	d
sqlite3StackDepth	.\src\test1.c	/^u64 sqlite3StackDepth(void){$/;"	f
sqlite3StackFree	.\src\sqliteInt.h	3181;"	d
sqlite3StackFree	.\src\sqliteInt.h	3185;"	d
sqlite3StartTable	.\src\build.c	/^void sqlite3StartTable($/;"	f
sqlite3Stat	.\src\status.c	/^} sqlite3Stat = { {0,}, {0,} };$/;"	v	typeref:struct:sqlite3StatType	file:
sqlite3Stat4Column	.\src\vdbemem.c	/^int sqlite3Stat4Column($/;"	f
sqlite3Stat4ProbeFree	.\src\vdbemem.c	/^void sqlite3Stat4ProbeFree(UnpackedRecord *pRec){$/;"	f
sqlite3Stat4ProbeSetValue	.\src\vdbemem.c	/^int sqlite3Stat4ProbeSetValue($/;"	f
sqlite3Stat4ValueFromExpr	.\src\vdbemem.c	/^int sqlite3Stat4ValueFromExpr($/;"	f
sqlite3StatType	.\src\status.c	/^static SQLITE_WSD struct sqlite3StatType {$/;"	s	file:
sqlite3StatType	.\src\status.c	/^typedef struct sqlite3StatType sqlite3StatType;$/;"	t	typeref:struct:sqlite3StatType	file:
sqlite3StatusDown	.\src\status.c	/^void sqlite3StatusDown(int op, int N){$/;"	f
sqlite3StatusSet	.\src\status.c	/^void sqlite3StatusSet(int op, int X){$/;"	f
sqlite3StatusUp	.\src\status.c	/^void sqlite3StatusUp(int op, int N){$/;"	f
sqlite3StatusValue	.\src\status.c	/^sqlite3_int64 sqlite3StatusValue(int op){$/;"	f
sqlite3Step	.\src\vdbeapi.c	/^static int sqlite3Step(Vdbe *p){$/;"	f	file:
sqlite3StmtCurrentTime	.\src\vdbeapi.c	/^sqlite3_int64 sqlite3StmtCurrentTime(sqlite3_context *p){$/;"	f
sqlite3StrAccumAppend	.\src\printf.c	/^void sqlite3StrAccumAppend(StrAccum *p, const char *z, int N){$/;"	f
sqlite3StrAccumAppendAll	.\src\printf.c	/^void sqlite3StrAccumAppendAll(StrAccum *p, const char *z){$/;"	f
sqlite3StrAccumEnlarge	.\src\printf.c	/^static int sqlite3StrAccumEnlarge(StrAccum *p, int N){$/;"	f	file:
sqlite3StrAccumFinish	.\src\printf.c	/^char *sqlite3StrAccumFinish(StrAccum *p){$/;"	f
sqlite3StrAccumInit	.\src\printf.c	/^void sqlite3StrAccumInit(StrAccum *p, sqlite3 *db, char *zBase, int n, int mx){$/;"	f
sqlite3StrAccumReset	.\src\printf.c	/^void sqlite3StrAccumReset(StrAccum *p){$/;"	f
sqlite3StrICmp	.\src\sqliteInt.h	3142;"	d
sqlite3StrNICmp	.\src\sqliteInt.h	3144;"	d
sqlite3StringToId	.\src\build.c	/^static void sqlite3StringToId(Expr *p){$/;"	f	file:
sqlite3Strlen30	.\src\util.c	/^int sqlite3Strlen30(const char *z){$/;"	f
sqlite3SubInt64	.\src\util.c	/^int sqlite3SubInt64(i64 *pA, i64 iB){$/;"	f
sqlite3TableAffinity	.\src\insert.c	/^void sqlite3TableAffinity(Vdbe *v, Table *pTab, int iReg){$/;"	f
sqlite3TableLock	.\src\build.c	/^void sqlite3TableLock($/;"	f
sqlite3TableLock	.\src\sqliteInt.h	3737;"	d
sqlite3TempInMemory	.\src\main.c	/^int sqlite3TempInMemory(const sqlite3 *db){$/;"	f
sqlite3TestBinToHex	.\src\test_hexio.c	/^void sqlite3TestBinToHex(unsigned char *zBuf, int N){$/;"	f
sqlite3TestErrCode	.\src\test1.c	/^int sqlite3TestErrCode(Tcl_Interp *interp, sqlite3 *db, int rc){$/;"	f
sqlite3TestHexToBin	.\src\test_hexio.c	/^int sqlite3TestHexToBin(const unsigned char *zIn, int N, unsigned char *aOut){$/;"	f
sqlite3TestMakePointerStr	.\src\test1.c	/^int sqlite3TestMakePointerStr(Tcl_Interp *interp, char *zPtr, void *p){$/;"	f
sqlite3TestTextToPtr	.\src\test1.c	/^void *sqlite3TestTextToPtr(const char *z){$/;"	f
sqlite3ThreadCreate	.\src\threads.c	/^int sqlite3ThreadCreate($/;"	f
sqlite3ThreadJoin	.\src\threads.c	/^int sqlite3ThreadJoin(SQLiteThread *p, void **ppOut){$/;"	f
sqlite3ThreadProc	.\src\threads.c	/^static unsigned __stdcall sqlite3ThreadProc($/;"	f	file:
sqlite3Tolower	.\src\sqliteInt.h	3125;"	d
sqlite3Tolower	.\src\sqliteInt.h	3133;"	d
sqlite3Toupper	.\src\sqliteInt.h	3119;"	d
sqlite3Toupper	.\src\sqliteInt.h	3127;"	d
sqlite3TransferBindings	.\src\vdbeapi.c	/^int sqlite3TransferBindings(sqlite3_stmt *pFromStmt, sqlite3_stmt *pToStmt){$/;"	f
sqlite3TreeViewExpr	.\src\treeview.c	/^void sqlite3TreeViewExpr(TreeView *pView, const Expr *pExpr, u8 moreToFollow){$/;"	f
sqlite3TreeViewExprList	.\src\treeview.c	/^void sqlite3TreeViewExprList($/;"	f
sqlite3TreeViewItem	.\src\treeview.c	/^static void sqlite3TreeViewItem(TreeView *p, const char *zLabel,u8 moreFollows){$/;"	f	file:
sqlite3TreeViewLine	.\src\treeview.c	/^static void sqlite3TreeViewLine(TreeView *p, const char *zFormat, ...){$/;"	f	file:
sqlite3TreeViewPop	.\src\treeview.c	/^static void sqlite3TreeViewPop(TreeView *p){$/;"	f	file:
sqlite3TreeViewPush	.\src\treeview.c	/^static TreeView *sqlite3TreeViewPush(TreeView *p, u8 moreToFollow){$/;"	f	file:
sqlite3TreeViewSelect	.\src\treeview.c	/^void sqlite3TreeViewSelect(TreeView *pView, const Select *p, u8 moreToFollow){$/;"	f
sqlite3TriggerColmask	.\src\sqliteInt.h	3525;"	d
sqlite3TriggerColmask	.\src\trigger.c	/^u32 sqlite3TriggerColmask($/;"	f
sqlite3TriggerDeleteStep	.\src\trigger.c	/^TriggerStep *sqlite3TriggerDeleteStep($/;"	f
sqlite3TriggerInsertStep	.\src\trigger.c	/^TriggerStep *sqlite3TriggerInsertStep($/;"	f
sqlite3TriggerList	.\src\sqliteInt.h	3522;"	d
sqlite3TriggerList	.\src\trigger.c	/^Trigger *sqlite3TriggerList(Parse *pParse, Table *pTab){$/;"	f
sqlite3TriggerSelectStep	.\src\trigger.c	/^TriggerStep *sqlite3TriggerSelectStep(sqlite3 *db, Select *pSelect){$/;"	f
sqlite3TriggerUpdateStep	.\src\trigger.c	/^TriggerStep *sqlite3TriggerUpdateStep($/;"	f
sqlite3TriggersExist	.\src\sqliteInt.h	3516;"	d
sqlite3TriggersExist	.\src\trigger.c	/^Trigger *sqlite3TriggersExist($/;"	f
sqlite3TwoPartName	.\src\build.c	/^int sqlite3TwoPartName($/;"	f
sqlite3UniqueConstraint	.\src\build.c	/^void sqlite3UniqueConstraint($/;"	f
sqlite3UnlinkAndDeleteIndex	.\src\build.c	/^void sqlite3UnlinkAndDeleteIndex(sqlite3 *db, int iDb, const char *zIdxName){$/;"	f
sqlite3UnlinkAndDeleteTable	.\src\build.c	/^void sqlite3UnlinkAndDeleteTable(sqlite3 *db, int iDb, const char *zTabName){$/;"	f
sqlite3UnlinkAndDeleteTrigger	.\src\sqliteInt.h	3519;"	d
sqlite3UnlinkAndDeleteTrigger	.\src\trigger.c	/^void sqlite3UnlinkAndDeleteTrigger(sqlite3 *db, int iDb, const char *zName){$/;"	f
sqlite3Update	.\src\update.c	/^void sqlite3Update($/;"	f
sqlite3UpperToLower	.\src\global.c	/^const unsigned char sqlite3UpperToLower[] = {$/;"	v
sqlite3UpperToLower	.\tool\mkkeywordhash.c	/^const unsigned char sqlite3UpperToLower[] = {$/;"	v
sqlite3UserAuthCheckLogin	.\ext\userauth\userauth.c	/^int sqlite3UserAuthCheckLogin($/;"	f
sqlite3UserAuthInit	.\ext\userauth\userauth.c	/^void sqlite3UserAuthInit(sqlite3 *db){$/;"	f
sqlite3UserAuthPrepare	.\ext\userauth\userauth.c	/^static sqlite3_stmt *sqlite3UserAuthPrepare($/;"	f	file:
sqlite3UserAuthTable	.\src\build.c	/^int sqlite3UserAuthTable(const char *zTable){$/;"	f
sqlite3Utf16ByteLen	.\src\utf.c	/^int sqlite3Utf16ByteLen(const void *zIn, int nChar){$/;"	f
sqlite3Utf16to8	.\src\utf.c	/^char *sqlite3Utf16to8(sqlite3 *db, const void *z, int nByte, u8 enc){$/;"	f
sqlite3Utf8CharLen	.\src\utf.c	/^int sqlite3Utf8CharLen(const char *zIn, int nByte){$/;"	f
sqlite3Utf8Read	.\src\func.c	583;"	d	file:
sqlite3Utf8Read	.\src\utf.c	/^u32 sqlite3Utf8Read($/;"	f
sqlite3Utf8To8	.\src\utf.c	/^int sqlite3Utf8To8(unsigned char *zIn){$/;"	f
sqlite3Utf8Trans1	.\ext\fts3\fts3_unicode.c	/^static const unsigned char sqlite3Utf8Trans1[] = {$/;"	v	file:
sqlite3Utf8Trans1	.\ext\fts5\fts5_tokenize.c	/^static const unsigned char sqlite3Utf8Trans1[] = {$/;"	v	file:
sqlite3Utf8Trans1	.\ext\misc\spellfix.c	/^static const unsigned char sqlite3Utf8Trans1[] = {$/;"	v	file:
sqlite3Utf8Trans1	.\src\utf.c	/^static const unsigned char sqlite3Utf8Trans1[] = {$/;"	v	file:
sqlite3UtfSelfTest	.\src\utf.c	/^void sqlite3UtfSelfTest(void){$/;"	f
sqlite3VMPrintf	.\src\printf.c	/^char *sqlite3VMPrintf(sqlite3 *db, const char *zFormat, va_list ap){$/;"	f
sqlite3VXPrintf	.\src\printf.c	/^void sqlite3VXPrintf($/;"	f
sqlite3Vacuum	.\src\vacuum.c	/^void sqlite3Vacuum(Parse *pParse){$/;"	f
sqlite3ValueApplyAffinity	.\src\vdbe.c	/^void sqlite3ValueApplyAffinity($/;"	f
sqlite3ValueBytes	.\src\vdbemem.c	/^int sqlite3ValueBytes(sqlite3_value *pVal, u8 enc){$/;"	f
sqlite3ValueFree	.\src\vdbemem.c	/^void sqlite3ValueFree(sqlite3_value *v){$/;"	f
sqlite3ValueFromExpr	.\src\vdbemem.c	/^int sqlite3ValueFromExpr($/;"	f
sqlite3ValueNew	.\src\vdbemem.c	/^sqlite3_value *sqlite3ValueNew(sqlite3 *db){$/;"	f
sqlite3ValueSetNull	.\src\vdbemem.c	/^void sqlite3ValueSetNull(sqlite3_value *p){$/;"	f
sqlite3ValueSetStr	.\src\vdbemem.c	/^void sqlite3ValueSetStr($/;"	f
sqlite3ValueText	.\src\vdbemem.c	/^const void *sqlite3ValueText(sqlite3_value* pVal, u8 enc){$/;"	f
sqlite3VarintLen	.\src\util.c	/^int sqlite3VarintLen(u64 v){$/;"	f
sqlite3VdbeAddOp0	.\src\vdbeaux.c	/^int sqlite3VdbeAddOp0(Vdbe *p, int op){$/;"	f
sqlite3VdbeAddOp1	.\src\vdbeaux.c	/^int sqlite3VdbeAddOp1(Vdbe *p, int op, int p1){$/;"	f
sqlite3VdbeAddOp2	.\src\vdbeaux.c	/^int sqlite3VdbeAddOp2(Vdbe *p, int op, int p1, int p2){$/;"	f
sqlite3VdbeAddOp3	.\src\vdbeaux.c	/^int sqlite3VdbeAddOp3(Vdbe *p, int op, int p1, int p2, int p3){$/;"	f
sqlite3VdbeAddOp4	.\src\vdbeaux.c	/^int sqlite3VdbeAddOp4($/;"	f
sqlite3VdbeAddOp4Dup8	.\src\vdbeaux.c	/^int sqlite3VdbeAddOp4Dup8($/;"	f
sqlite3VdbeAddOp4Int	.\src\vdbeaux.c	/^int sqlite3VdbeAddOp4Int($/;"	f
sqlite3VdbeAddOpList	.\src\vdbeaux.c	/^int sqlite3VdbeAddOpList(Vdbe *p, int nOp, VdbeOpList const *aOp, int iLineno){$/;"	f
sqlite3VdbeAddParseSchemaOp	.\src\vdbeaux.c	/^void sqlite3VdbeAddParseSchemaOp(Vdbe *p, int iDb, char *zWhere){$/;"	f
sqlite3VdbeAllocUnpackedRecord	.\src\vdbeaux.c	/^UnpackedRecord *sqlite3VdbeAllocUnpackedRecord($/;"	f
sqlite3VdbeAssertMayAbort	.\src\vdbeaux.c	/^int sqlite3VdbeAssertMayAbort(Vdbe *v, int mayAbort){$/;"	f
sqlite3VdbeChangeEncoding	.\src\vdbemem.c	/^int sqlite3VdbeChangeEncoding(Mem *pMem, int desiredEnc){$/;"	f
sqlite3VdbeChangeOpcode	.\src\vdbeaux.c	/^void sqlite3VdbeChangeOpcode(Vdbe *p, u32 addr, u8 iNewOpcode){$/;"	f
sqlite3VdbeChangeP1	.\src\vdbeaux.c	/^void sqlite3VdbeChangeP1(Vdbe *p, u32 addr, int val){$/;"	f
sqlite3VdbeChangeP2	.\src\vdbeaux.c	/^void sqlite3VdbeChangeP2(Vdbe *p, u32 addr, int val){$/;"	f
sqlite3VdbeChangeP3	.\src\vdbeaux.c	/^void sqlite3VdbeChangeP3(Vdbe *p, u32 addr, int val){$/;"	f
sqlite3VdbeChangeP4	.\src\vdbeaux.c	/^void sqlite3VdbeChangeP4(Vdbe *p, int addr, const char *zP4, int n){$/;"	f
sqlite3VdbeChangeP5	.\src\vdbeaux.c	/^void sqlite3VdbeChangeP5(Vdbe *p, u8 p5){$/;"	f
sqlite3VdbeChangeToNoop	.\src\vdbeaux.c	/^void sqlite3VdbeChangeToNoop(Vdbe *p, int addr){$/;"	f
sqlite3VdbeCheckFk	.\src\vdbeInt.h	490;"	d
sqlite3VdbeCheckFk	.\src\vdbeaux.c	/^int sqlite3VdbeCheckFk(Vdbe *p, int deferred){$/;"	f
sqlite3VdbeCheckMemInvariants	.\src\vdbemem.c	/^int sqlite3VdbeCheckMemInvariants(Mem *p){$/;"	f
sqlite3VdbeClearObject	.\src\vdbeaux.c	/^void sqlite3VdbeClearObject(sqlite3 *db, Vdbe *p){$/;"	f
sqlite3VdbeCloseStatement	.\src\vdbeaux.c	/^int sqlite3VdbeCloseStatement(Vdbe *p, int eOp){$/;"	f
sqlite3VdbeComment	.\src\vdbeaux.c	/^void sqlite3VdbeComment(Vdbe *p, const char *zFormat, ...){$/;"	f
sqlite3VdbeCountChanges	.\src\vdbeaux.c	/^void sqlite3VdbeCountChanges(Vdbe *v){$/;"	f
sqlite3VdbeCreate	.\src\vdbeaux.c	/^Vdbe *sqlite3VdbeCreate(Parse *pParse){$/;"	f
sqlite3VdbeCurrentAddr	.\src\vdbeaux.c	/^int sqlite3VdbeCurrentAddr(Vdbe *p){$/;"	f
sqlite3VdbeCursorMoveto	.\src\vdbeaux.c	/^int sqlite3VdbeCursorMoveto(VdbeCursor *p){$/;"	f
sqlite3VdbeCursorRestore	.\src\vdbeaux.c	/^int sqlite3VdbeCursorRestore(VdbeCursor *p){$/;"	f
sqlite3VdbeDb	.\src\vdbeaux.c	/^sqlite3 *sqlite3VdbeDb(Vdbe *v){$/;"	f
sqlite3VdbeDelete	.\src\vdbeaux.c	/^void sqlite3VdbeDelete(Vdbe *p){$/;"	f
sqlite3VdbeDeleteAuxData	.\src\vdbeaux.c	/^void sqlite3VdbeDeleteAuxData(Vdbe *pVdbe, int iOp, int mask){$/;"	f
sqlite3VdbeDeletePriorOpcode	.\src\vdbeaux.c	/^int sqlite3VdbeDeletePriorOpcode(Vdbe *p, u8 op){$/;"	f
sqlite3VdbeEnter	.\src\vdbeInt.h	478;"	d
sqlite3VdbeEnter	.\src\vdbeaux.c	/^void sqlite3VdbeEnter(Vdbe *p){$/;"	f
sqlite3VdbeError	.\src\vdbeaux.c	/^void sqlite3VdbeError(Vdbe *p, const char *zFormat, ...){$/;"	f
sqlite3VdbeExec	.\src\vdbe.c	/^int sqlite3VdbeExec($/;"	f
sqlite3VdbeExpandSql	.\src\vdbetrace.c	/^char *sqlite3VdbeExpandSql($/;"	f
sqlite3VdbeFinalize	.\src\vdbeaux.c	/^int sqlite3VdbeFinalize(Vdbe *p){$/;"	f
sqlite3VdbeFindCompare	.\src\vdbeaux.c	/^RecordCompare sqlite3VdbeFindCompare(UnpackedRecord *p){$/;"	f
sqlite3VdbeFrameDelete	.\src\vdbeaux.c	/^void sqlite3VdbeFrameDelete(VdbeFrame *p){$/;"	f
sqlite3VdbeFrameRestore	.\src\vdbeaux.c	/^int sqlite3VdbeFrameRestore(VdbeFrame *pFrame){$/;"	f
sqlite3VdbeFreeCursor	.\src\vdbeaux.c	/^void sqlite3VdbeFreeCursor(Vdbe *p, VdbeCursor *pCx){$/;"	f
sqlite3VdbeGetBoundValue	.\src\vdbeaux.c	/^sqlite3_value *sqlite3VdbeGetBoundValue(Vdbe *v, int iVar, u8 aff){$/;"	f
sqlite3VdbeGetOp	.\src\vdbeaux.c	/^VdbeOp *sqlite3VdbeGetOp(Vdbe *p, int addr){$/;"	f
sqlite3VdbeGoto	.\src\vdbeaux.c	/^int sqlite3VdbeGoto(Vdbe *p, int iDest){$/;"	f
sqlite3VdbeHalt	.\src\vdbeaux.c	/^int sqlite3VdbeHalt(Vdbe *p){$/;"	f
sqlite3VdbeIOTraceSql	.\src\sqliteInt.h	3920;"	d
sqlite3VdbeIOTraceSql	.\src\vdbeaux.c	/^void sqlite3VdbeIOTraceSql(Vdbe *p){$/;"	f
sqlite3VdbeIdxKeyCompare	.\src\vdbeaux.c	/^int sqlite3VdbeIdxKeyCompare($/;"	f
sqlite3VdbeIdxRowid	.\src\vdbeaux.c	/^int sqlite3VdbeIdxRowid(sqlite3 *db, BtCursor *pCur, i64 *rowid){$/;"	f
sqlite3VdbeIntValue	.\src\vdbemem.c	/^i64 sqlite3VdbeIntValue(Mem *pMem){$/;"	f
sqlite3VdbeIntegerAffinity	.\src\vdbemem.c	/^void sqlite3VdbeIntegerAffinity(Mem *pMem){$/;"	f
sqlite3VdbeJumpHere	.\src\vdbeaux.c	/^void sqlite3VdbeJumpHere(Vdbe *p, int addr){$/;"	f
sqlite3VdbeLeave	.\src\vdbeInt.h	479;"	d
sqlite3VdbeLeave	.\src\vdbeaux.c	/^void sqlite3VdbeLeave(Vdbe *p){$/;"	f
sqlite3VdbeLinkSubProgram	.\src\vdbeaux.c	/^void sqlite3VdbeLinkSubProgram(Vdbe *pVdbe, SubProgram *p){$/;"	f
sqlite3VdbeList	.\src\vdbeaux.c	/^int sqlite3VdbeList($/;"	f
sqlite3VdbeLoadString	.\src\vdbeaux.c	/^int sqlite3VdbeLoadString(Vdbe *p, int iDest, const char *zStr){$/;"	f
sqlite3VdbeMakeLabel	.\src\vdbeaux.c	/^int sqlite3VdbeMakeLabel(Vdbe *v){$/;"	f
sqlite3VdbeMakeReady	.\src\vdbeaux.c	/^void sqlite3VdbeMakeReady($/;"	f
sqlite3VdbeMemAboutToChange	.\src\vdbemem.c	/^void sqlite3VdbeMemAboutToChange(Vdbe *pVdbe, Mem *pMem){$/;"	f
sqlite3VdbeMemCast	.\src\vdbemem.c	/^void sqlite3VdbeMemCast(Mem *pMem, u8 aff, u8 encoding){$/;"	f
sqlite3VdbeMemClearAndResize	.\src\vdbemem.c	/^int sqlite3VdbeMemClearAndResize(Mem *pMem, int szNew){$/;"	f
sqlite3VdbeMemCopy	.\src\vdbemem.c	/^int sqlite3VdbeMemCopy(Mem *pTo, const Mem *pFrom){$/;"	f
sqlite3VdbeMemExpandBlob	.\src\vdbeInt.h	504;"	d
sqlite3VdbeMemExpandBlob	.\src\vdbemem.c	/^int sqlite3VdbeMemExpandBlob(Mem *pMem){$/;"	f
sqlite3VdbeMemFinalize	.\src\vdbemem.c	/^int sqlite3VdbeMemFinalize(Mem *pMem, FuncDef *pFunc){$/;"	f
sqlite3VdbeMemFromBtree	.\src\vdbemem.c	/^int sqlite3VdbeMemFromBtree($/;"	f
sqlite3VdbeMemGrow	.\src\vdbemem.c	/^SQLITE_NOINLINE int sqlite3VdbeMemGrow(Mem *pMem, int n, int bPreserve){$/;"	f
sqlite3VdbeMemHandleBom	.\src\utf.c	/^int sqlite3VdbeMemHandleBom(Mem *pMem){$/;"	f
sqlite3VdbeMemInit	.\src\vdbemem.c	/^void sqlite3VdbeMemInit(Mem *pMem, sqlite3 *db, u16 flags){$/;"	f
sqlite3VdbeMemIntegerify	.\src\vdbemem.c	/^int sqlite3VdbeMemIntegerify(Mem *pMem){$/;"	f
sqlite3VdbeMemMakeWriteable	.\src\vdbemem.c	/^int sqlite3VdbeMemMakeWriteable(Mem *pMem){$/;"	f
sqlite3VdbeMemMove	.\src\vdbemem.c	/^void sqlite3VdbeMemMove(Mem *pTo, Mem *pFrom){$/;"	f
sqlite3VdbeMemNulTerminate	.\src\vdbemem.c	/^int sqlite3VdbeMemNulTerminate(Mem *pMem){$/;"	f
sqlite3VdbeMemNumerify	.\src\vdbemem.c	/^int sqlite3VdbeMemNumerify(Mem *pMem){$/;"	f
sqlite3VdbeMemPrettyPrint	.\src\vdbe.c	/^void sqlite3VdbeMemPrettyPrint(Mem *pMem, char *zBuf){$/;"	f
sqlite3VdbeMemRealify	.\src\vdbemem.c	/^int sqlite3VdbeMemRealify(Mem *pMem){$/;"	f
sqlite3VdbeMemRelease	.\src\vdbemem.c	/^void sqlite3VdbeMemRelease(Mem *p){$/;"	f
sqlite3VdbeMemSetDouble	.\src\vdbeInt.h	435;"	d
sqlite3VdbeMemSetDouble	.\src\vdbemem.c	/^void sqlite3VdbeMemSetDouble(Mem *pMem, double val){$/;"	f
sqlite3VdbeMemSetInt64	.\src\vdbemem.c	/^void sqlite3VdbeMemSetInt64(Mem *pMem, i64 val){$/;"	f
sqlite3VdbeMemSetNull	.\src\vdbemem.c	/^void sqlite3VdbeMemSetNull(Mem *pMem){$/;"	f
sqlite3VdbeMemSetRowSet	.\src\vdbemem.c	/^void sqlite3VdbeMemSetRowSet(Mem *pMem){$/;"	f
sqlite3VdbeMemSetStr	.\src\vdbemem.c	/^int sqlite3VdbeMemSetStr($/;"	f
sqlite3VdbeMemSetZeroBlob	.\src\vdbemem.c	/^void sqlite3VdbeMemSetZeroBlob(Mem *pMem, int n){$/;"	f
sqlite3VdbeMemShallowCopy	.\src\vdbemem.c	/^void sqlite3VdbeMemShallowCopy(Mem *pTo, const Mem *pFrom, int srcType){$/;"	f
sqlite3VdbeMemStringify	.\src\vdbemem.c	/^int sqlite3VdbeMemStringify(Mem *pMem, u8 enc, u8 bForce){$/;"	f
sqlite3VdbeMemTooBig	.\src\vdbemem.c	/^int sqlite3VdbeMemTooBig(Mem *p){$/;"	f
sqlite3VdbeMemTranslate	.\src\utf.c	/^SQLITE_NOINLINE int sqlite3VdbeMemTranslate(Mem *pMem, u8 desiredEnc){$/;"	f
sqlite3VdbeMultiLoad	.\src\vdbeaux.c	/^void sqlite3VdbeMultiLoad(Vdbe *p, int iDest, const char *zTypes, ...){$/;"	f
sqlite3VdbeNoopComment	.\src\vdbeaux.c	/^void sqlite3VdbeNoopComment(Vdbe *p, const char *zFormat, ...){$/;"	f
sqlite3VdbeParameterIndex	.\src\vdbeapi.c	/^int sqlite3VdbeParameterIndex(Vdbe *p, const char *zName, int nName){$/;"	f
sqlite3VdbePrintOp	.\src\vdbeaux.c	/^void sqlite3VdbePrintOp(FILE *pOut, int pc, Op *pOp){$/;"	f
sqlite3VdbePrintSql	.\src\vdbeaux.c	/^void sqlite3VdbePrintSql(Vdbe *p){$/;"	f
sqlite3VdbeRealValue	.\src\vdbemem.c	/^double sqlite3VdbeRealValue(Mem *pMem){$/;"	f
sqlite3VdbeRecordCompare	.\src\vdbeaux.c	/^int sqlite3VdbeRecordCompare($/;"	f
sqlite3VdbeRecordCompareWithSkip	.\src\vdbeaux.c	/^int sqlite3VdbeRecordCompareWithSkip($/;"	f
sqlite3VdbeRecordUnpack	.\src\vdbeaux.c	/^void sqlite3VdbeRecordUnpack($/;"	f
sqlite3VdbeReset	.\src\vdbeaux.c	/^int sqlite3VdbeReset(Vdbe *p){$/;"	f
sqlite3VdbeResetStepResult	.\src\vdbeaux.c	/^void sqlite3VdbeResetStepResult(Vdbe *p){$/;"	f
sqlite3VdbeResolveLabel	.\src\vdbeaux.c	/^void sqlite3VdbeResolveLabel(Vdbe *v, int x){$/;"	f
sqlite3VdbeRewind	.\src\vdbeaux.c	/^void sqlite3VdbeRewind(Vdbe *p){$/;"	f
sqlite3VdbeRunOnlyOnce	.\src\vdbeaux.c	/^void sqlite3VdbeRunOnlyOnce(Vdbe *p){$/;"	f
sqlite3VdbeScanStatus	.\src\vdbe.h	296;"	d
sqlite3VdbeScanStatus	.\src\vdbeaux.c	/^void sqlite3VdbeScanStatus($/;"	f
sqlite3VdbeSerialGet	.\src\vdbeaux.c	/^u32 sqlite3VdbeSerialGet($/;"	f
sqlite3VdbeSerialPut	.\src\vdbeaux.c	/^u32 sqlite3VdbeSerialPut(u8 *buf, Mem *pMem, u32 serial_type){$/;"	f
sqlite3VdbeSerialType	.\src\vdbeaux.c	/^u32 sqlite3VdbeSerialType(Mem *pMem, int file_format){$/;"	f
sqlite3VdbeSerialTypeLen	.\src\vdbeaux.c	/^u32 sqlite3VdbeSerialTypeLen(u32 serial_type){$/;"	f
sqlite3VdbeSetChanges	.\src\vdbeaux.c	/^void sqlite3VdbeSetChanges(sqlite3 *db, int nChange){$/;"	f
sqlite3VdbeSetColName	.\src\vdbeaux.c	/^int sqlite3VdbeSetColName($/;"	f
sqlite3VdbeSetLineNumber	.\src\vdbeaux.c	/^void sqlite3VdbeSetLineNumber(Vdbe *v, int iLine){$/;"	f
sqlite3VdbeSetNumCols	.\src\vdbeaux.c	/^void sqlite3VdbeSetNumCols(Vdbe *p, int nResColumn){$/;"	f
sqlite3VdbeSetP4KeyInfo	.\src\vdbeaux.c	/^void sqlite3VdbeSetP4KeyInfo(Parse *pParse, Index *pIdx){$/;"	f
sqlite3VdbeSetSql	.\src\vdbeaux.c	/^void sqlite3VdbeSetSql(Vdbe *p, const char *z, int n, int isPrepareV2){$/;"	f
sqlite3VdbeSetVarmask	.\src\vdbeaux.c	/^void sqlite3VdbeSetVarmask(Vdbe *v, int iVar){$/;"	f
sqlite3VdbeSorterClose	.\src\vdbesort.c	/^void sqlite3VdbeSorterClose(sqlite3 *db, VdbeCursor *pCsr){$/;"	f
sqlite3VdbeSorterCompare	.\src\vdbesort.c	/^int sqlite3VdbeSorterCompare($/;"	f
sqlite3VdbeSorterInit	.\src\vdbesort.c	/^int sqlite3VdbeSorterInit($/;"	f
sqlite3VdbeSorterNext	.\src\vdbesort.c	/^int sqlite3VdbeSorterNext(sqlite3 *db, const VdbeCursor *pCsr, int *pbEof){$/;"	f
sqlite3VdbeSorterReset	.\src\vdbesort.c	/^void sqlite3VdbeSorterReset(sqlite3 *db, VdbeSorter *pSorter){$/;"	f
sqlite3VdbeSorterRewind	.\src\vdbesort.c	/^int sqlite3VdbeSorterRewind(const VdbeCursor *pCsr, int *pbEof){$/;"	f
sqlite3VdbeSorterRowkey	.\src\vdbesort.c	/^int sqlite3VdbeSorterRowkey(const VdbeCursor *pCsr, Mem *pOut){$/;"	f
sqlite3VdbeSorterWrite	.\src\vdbesort.c	/^int sqlite3VdbeSorterWrite($/;"	f
sqlite3VdbeSwap	.\src\vdbeaux.c	/^void sqlite3VdbeSwap(Vdbe *pA, Vdbe *pB){$/;"	f
sqlite3VdbeTakeOpArray	.\src\vdbeaux.c	/^VdbeOp *sqlite3VdbeTakeOpArray(Vdbe *p, int *pnOp, int *pnMaxArg){$/;"	f
sqlite3VdbeTransferError	.\src\vdbeaux.c	/^int sqlite3VdbeTransferError(Vdbe *p){$/;"	f
sqlite3VdbeUsesBtree	.\src\vdbeaux.c	/^void sqlite3VdbeUsesBtree(Vdbe *p, int i){$/;"	f
sqlite3ViewGetColumnNames	.\src\build.c	/^int sqlite3ViewGetColumnNames(Parse *pParse, Table *pTable){$/;"	f
sqlite3ViewGetColumnNames	.\src\sqliteInt.h	3335;"	d
sqlite3VtabArgExtend	.\src\vtab.c	/^void sqlite3VtabArgExtend(Parse *pParse, Token *p){$/;"	f
sqlite3VtabArgInit	.\src\vtab.c	/^void sqlite3VtabArgInit(Parse *pParse){$/;"	f
sqlite3VtabBegin	.\src\vtab.c	/^int sqlite3VtabBegin(sqlite3 *db, VTable *pVTab){$/;"	f
sqlite3VtabBeginParse	.\src\vtab.c	/^void sqlite3VtabBeginParse($/;"	f
sqlite3VtabCallConnect	.\src\vtab.c	/^int sqlite3VtabCallConnect(Parse *pParse, Table *pTab){$/;"	f
sqlite3VtabCallCreate	.\src\vtab.c	/^int sqlite3VtabCallCreate(sqlite3 *db, int iDb, const char *zTab, char **pzErr){$/;"	f
sqlite3VtabCallDestroy	.\src\vtab.c	/^int sqlite3VtabCallDestroy(sqlite3 *db, int iDb, const char *zTab){$/;"	f
sqlite3VtabClear	.\src\sqliteInt.h	3745;"	d
sqlite3VtabClear	.\src\vtab.c	/^void sqlite3VtabClear(sqlite3 *db, Table *p){$/;"	f
sqlite3VtabCommit	.\src\sqliteInt.h	3748;"	d
sqlite3VtabCommit	.\src\vtab.c	/^int sqlite3VtabCommit(sqlite3 *db){$/;"	f
sqlite3VtabDisconnect	.\src\vtab.c	/^void sqlite3VtabDisconnect(sqlite3 *db, Table *p){$/;"	f
sqlite3VtabEponymousTableClear	.\src\vtab.c	/^void sqlite3VtabEponymousTableClear(sqlite3 *db, Module *pMod){$/;"	f
sqlite3VtabEponymousTableInit	.\src\vtab.c	/^int sqlite3VtabEponymousTableInit(Parse *pParse, Module *pMod){$/;"	f
sqlite3VtabFinishParse	.\src\vtab.c	/^void sqlite3VtabFinishParse(Parse *pParse, Token *pEnd){$/;"	f
sqlite3VtabImportErrmsg	.\src\vdbeaux.c	/^void sqlite3VtabImportErrmsg(Vdbe *p, sqlite3_vtab *pVtab){$/;"	f
sqlite3VtabInSync	.\src\sqliteInt.h	3749;"	d
sqlite3VtabInSync	.\src\sqliteInt.h	3767;"	d
sqlite3VtabLock	.\src\sqliteInt.h	3750;"	d
sqlite3VtabLock	.\src\vtab.c	/^void sqlite3VtabLock(VTable *pVTab){$/;"	f
sqlite3VtabMakeWritable	.\src\vtab.c	/^void sqlite3VtabMakeWritable(Parse *pParse, Table *pTab){$/;"	f
sqlite3VtabOverloadFunction	.\src\vtab.c	/^FuncDef *sqlite3VtabOverloadFunction($/;"	f
sqlite3VtabRollback	.\src\sqliteInt.h	3747;"	d
sqlite3VtabRollback	.\src\vtab.c	/^int sqlite3VtabRollback(sqlite3 *db){$/;"	f
sqlite3VtabSavepoint	.\src\sqliteInt.h	3753;"	d
sqlite3VtabSavepoint	.\src\vtab.c	/^int sqlite3VtabSavepoint(sqlite3 *db, int op, int iSavepoint){$/;"	f
sqlite3VtabSync	.\src\sqliteInt.h	3746;"	d
sqlite3VtabSync	.\src\vtab.c	/^int sqlite3VtabSync(sqlite3 *db, Vdbe *p){$/;"	f
sqlite3VtabUnlock	.\src\sqliteInt.h	3751;"	d
sqlite3VtabUnlock	.\src\vtab.c	/^void sqlite3VtabUnlock(VTable *pVTab){$/;"	f
sqlite3VtabUnlockList	.\src\sqliteInt.h	3752;"	d
sqlite3VtabUnlockList	.\src\vtab.c	/^void sqlite3VtabUnlockList(sqlite3 *db){$/;"	f
sqlite3WalBeginReadTransaction	.\src\wal.c	/^int sqlite3WalBeginReadTransaction(Wal *pWal, int *pChanged){$/;"	f
sqlite3WalBeginReadTransaction	.\src\wal.h	32;"	d
sqlite3WalBeginWriteTransaction	.\src\wal.c	/^int sqlite3WalBeginWriteTransaction(Wal *pWal){$/;"	f
sqlite3WalBeginWriteTransaction	.\src\wal.h	35;"	d
sqlite3WalCallback	.\src\wal.c	/^int sqlite3WalCallback(Wal *pWal){$/;"	f
sqlite3WalCallback	.\src\wal.h	42;"	d
sqlite3WalCheckpoint	.\src\wal.c	/^int sqlite3WalCheckpoint($/;"	f
sqlite3WalCheckpoint	.\src\wal.h	41;"	d
sqlite3WalClose	.\src\wal.c	/^int sqlite3WalClose($/;"	f
sqlite3WalClose	.\src\wal.h	31;"	d
sqlite3WalDbsize	.\src\wal.c	/^Pgno sqlite3WalDbsize(Wal *pWal){$/;"	f
sqlite3WalDbsize	.\src\wal.h	34;"	d
sqlite3WalDefaultHook	.\src\main.c	/^int sqlite3WalDefaultHook($/;"	f
sqlite3WalEndReadTransaction	.\src\wal.c	/^void sqlite3WalEndReadTransaction(Wal *pWal){$/;"	f
sqlite3WalEndReadTransaction	.\src\wal.h	33;"	d
sqlite3WalEndWriteTransaction	.\src\wal.c	/^int sqlite3WalEndWriteTransaction(Wal *pWal){$/;"	f
sqlite3WalEndWriteTransaction	.\src\wal.h	36;"	d
sqlite3WalExclusiveMode	.\src\wal.c	/^int sqlite3WalExclusiveMode(Wal *pWal, int op){$/;"	f
sqlite3WalExclusiveMode	.\src\wal.h	43;"	d
sqlite3WalFindFrame	.\src\wal.c	/^int sqlite3WalFindFrame($/;"	f
sqlite3WalFindFrame	.\src\wal.h	46;"	d
sqlite3WalFrames	.\src\wal.c	/^int sqlite3WalFrames($/;"	f
sqlite3WalFrames	.\src\wal.h	40;"	d
sqlite3WalFramesize	.\src\wal.c	/^int sqlite3WalFramesize(Wal *pWal){$/;"	f
sqlite3WalFramesize	.\src\wal.h	45;"	d
sqlite3WalHeapMemory	.\src\wal.c	/^int sqlite3WalHeapMemory(Wal *pWal){$/;"	f
sqlite3WalHeapMemory	.\src\wal.h	44;"	d
sqlite3WalLimit	.\src\wal.c	/^void sqlite3WalLimit(Wal *pWal, i64 iLimit){$/;"	f
sqlite3WalLimit	.\src\wal.h	30;"	d
sqlite3WalOpen	.\src\wal.c	/^int sqlite3WalOpen($/;"	f
sqlite3WalOpen	.\src\wal.h	29;"	d
sqlite3WalReadFrame	.\src\wal.c	/^int sqlite3WalReadFrame($/;"	f
sqlite3WalSavepoint	.\src\wal.c	/^void sqlite3WalSavepoint(Wal *pWal, u32 *aWalData){$/;"	f
sqlite3WalSavepoint	.\src\wal.h	38;"	d
sqlite3WalSavepointUndo	.\src\wal.c	/^int sqlite3WalSavepointUndo(Wal *pWal, u32 *aWalData){$/;"	f
sqlite3WalSavepointUndo	.\src\wal.h	39;"	d
sqlite3WalTrace	.\src\wal.c	/^int sqlite3WalTrace = 0;$/;"	v
sqlite3WalUndo	.\src\wal.c	/^int sqlite3WalUndo(Wal *pWal, int (*xUndo)(void *, Pgno), void *pUndoCtx){$/;"	f
sqlite3WalUndo	.\src\wal.h	37;"	d
sqlite3WalkExpr	.\src\walker.c	/^int sqlite3WalkExpr(Walker *pWalker, Expr *pExpr){$/;"	f
sqlite3WalkExprList	.\src\walker.c	/^int sqlite3WalkExprList(Walker *pWalker, ExprList *p){$/;"	f
sqlite3WalkSelect	.\src\walker.c	/^int sqlite3WalkSelect(Walker *pWalker, Select *p){$/;"	f
sqlite3WalkSelectExpr	.\src\walker.c	/^int sqlite3WalkSelectExpr(Walker *pWalker, Select *p){$/;"	f
sqlite3WalkSelectFrom	.\src\walker.c	/^int sqlite3WalkSelectFrom(Walker *pWalker, Select *p){$/;"	f
sqlite3WhereAddScanStatus	.\src\whereInt.h	465;"	d
sqlite3WhereAddScanStatus	.\src\wherecode.c	/^void sqlite3WhereAddScanStatus($/;"	f
sqlite3WhereBegin	.\src\where.c	/^WhereInfo *sqlite3WhereBegin($/;"	f
sqlite3WhereBreakLabel	.\src\where.c	/^int sqlite3WhereBreakLabel(WhereInfo *pWInfo){$/;"	f
sqlite3WhereClauseClear	.\src\whereexpr.c	/^void sqlite3WhereClauseClear(WhereClause *pWC){$/;"	f
sqlite3WhereClauseInit	.\src\whereexpr.c	/^void sqlite3WhereClauseInit($/;"	f
sqlite3WhereCodeOneLoopStart	.\src\wherecode.c	/^Bitmask sqlite3WhereCodeOneLoopStart($/;"	f
sqlite3WhereContinueLabel	.\src\where.c	/^int sqlite3WhereContinueLabel(WhereInfo *pWInfo){$/;"	f
sqlite3WhereEnd	.\src\where.c	/^void sqlite3WhereEnd(WhereInfo *pWInfo){$/;"	f
sqlite3WhereExplainOneScan	.\src\whereInt.h	455;"	d
sqlite3WhereExplainOneScan	.\src\wherecode.c	/^int sqlite3WhereExplainOneScan($/;"	f
sqlite3WhereExprAnalyze	.\src\whereexpr.c	/^void sqlite3WhereExprAnalyze($/;"	f
sqlite3WhereExprListUsage	.\src\whereexpr.c	/^Bitmask sqlite3WhereExprListUsage(WhereMaskSet *pMaskSet, ExprList *pList){$/;"	f
sqlite3WhereExprUsage	.\src\whereexpr.c	/^Bitmask sqlite3WhereExprUsage(WhereMaskSet *pMaskSet, Expr *p){$/;"	f
sqlite3WhereFindTerm	.\src\where.c	/^WhereTerm *sqlite3WhereFindTerm($/;"	f
sqlite3WhereGetMask	.\src\where.c	/^Bitmask sqlite3WhereGetMask(WhereMaskSet *pMaskSet, int iCursor){$/;"	f
sqlite3WhereIsDistinct	.\src\where.c	/^int sqlite3WhereIsDistinct(WhereInfo *pWInfo){$/;"	f
sqlite3WhereIsOrdered	.\src\where.c	/^int sqlite3WhereIsOrdered(WhereInfo *pWInfo){$/;"	f
sqlite3WhereIsSorted	.\src\where.c	/^int sqlite3WhereIsSorted(WhereInfo *pWInfo){$/;"	f
sqlite3WhereOkOnePass	.\src\where.c	/^int sqlite3WhereOkOnePass(WhereInfo *pWInfo, int *aiCur){$/;"	f
sqlite3WhereOutputRowCount	.\src\where.c	/^u64 sqlite3WhereOutputRowCount(WhereInfo *pWInfo){$/;"	f
sqlite3WhereSplit	.\src\whereexpr.c	/^void sqlite3WhereSplit(WhereClause *pWC, Expr *pExpr, u8 op){$/;"	f
sqlite3WhereTabFuncArgs	.\src\whereexpr.c	/^void sqlite3WhereTabFuncArgs($/;"	f
sqlite3WhereTrace	.\src\where.c	/^\/***\/ int sqlite3WhereTrace = 0;$/;"	v
sqlite3WhereTrace	.\src\whereInt.h	/^\/***\/ int sqlite3WhereTrace;$/;"	v
sqlite3Win32Wait	.\src\os_win.c	/^DWORD sqlite3Win32Wait(HANDLE hObject){$/;"	f
sqlite3WithAdd	.\src\build.c	/^With *sqlite3WithAdd($/;"	f
sqlite3WithDelete	.\src\build.c	/^void sqlite3WithDelete(sqlite3 *db, With *pWith){$/;"	f
sqlite3WithDelete	.\src\sqliteInt.h	3801;"	d
sqlite3WithPush	.\src\select.c	/^void sqlite3WithPush(Parse *pParse, With *pWith, u8 bFree){$/;"	f
sqlite3WithPush	.\src\sqliteInt.h	3800;"	d
sqlite3XPrintf	.\src\printf.c	/^void sqlite3XPrintf(StrAccum *p, u32 bFlags, const char *zFormat, ...){$/;"	f
sqlite3_aggregate_context	.\src\sqlite3ext.h	292;"	d
sqlite3_aggregate_context	.\src\vdbeapi.c	/^void *sqlite3_aggregate_context(sqlite3_context *p, int nByte){$/;"	f
sqlite3_aggregate_count	.\src\sqlite3ext.h	294;"	d
sqlite3_aggregate_count	.\src\vdbeapi.c	/^int sqlite3_aggregate_count(sqlite3_context *p){$/;"	f
sqlite3_api_routines	.\src\sqlite3ext.h	/^struct sqlite3_api_routines {$/;"	s
sqlite3_api_routines	.\src\sqlite3ext.h	/^typedef struct sqlite3_api_routines sqlite3_api_routines;$/;"	t	typeref:struct:sqlite3_api_routines
sqlite3_api_routines	.\src\test1.c	/^typedef struct sqlite3_api_routines sqlite3_api_routines;$/;"	t	typeref:struct:sqlite3_api_routines	file:
sqlite3_auto_extension	.\src\loadext.c	/^int sqlite3_auto_extension(void (*xInit)(void)){$/;"	f
sqlite3_auto_extension	.\src\sqlite3ext.h	497;"	d
sqlite3_backup	.\src\backup.c	/^struct sqlite3_backup {$/;"	s	file:
sqlite3_backup_finish	.\src\backup.c	/^int sqlite3_backup_finish(sqlite3_backup *p){$/;"	f
sqlite3_backup_finish	.\src\sqlite3ext.h	458;"	d
sqlite3_backup_init	.\src\backup.c	/^sqlite3_backup *sqlite3_backup_init($/;"	f
sqlite3_backup_init	.\src\sqlite3ext.h	459;"	d
sqlite3_backup_pagecount	.\src\backup.c	/^int sqlite3_backup_pagecount(sqlite3_backup *p){$/;"	f
sqlite3_backup_pagecount	.\src\sqlite3ext.h	460;"	d
sqlite3_backup_remaining	.\src\backup.c	/^int sqlite3_backup_remaining(sqlite3_backup *p){$/;"	f
sqlite3_backup_remaining	.\src\sqlite3ext.h	461;"	d
sqlite3_backup_step	.\src\backup.c	/^int sqlite3_backup_step(sqlite3_backup *p, int nPage){$/;"	f
sqlite3_backup_step	.\src\sqlite3ext.h	462;"	d
sqlite3_bind_blob	.\src\sqlite3ext.h	296;"	d
sqlite3_bind_blob	.\src\vdbeapi.c	/^int sqlite3_bind_blob($/;"	f
sqlite3_bind_blob64	.\src\sqlite3ext.h	498;"	d
sqlite3_bind_blob64	.\src\vdbeapi.c	/^int sqlite3_bind_blob64($/;"	f
sqlite3_bind_double	.\src\sqlite3ext.h	297;"	d
sqlite3_bind_double	.\src\vdbeapi.c	/^int sqlite3_bind_double(sqlite3_stmt *pStmt, int i, double rValue){$/;"	f
sqlite3_bind_int	.\src\sqlite3ext.h	298;"	d
sqlite3_bind_int	.\src\vdbeapi.c	/^int sqlite3_bind_int(sqlite3_stmt *p, int i, int iValue){$/;"	f
sqlite3_bind_int64	.\src\sqlite3ext.h	299;"	d
sqlite3_bind_int64	.\src\vdbeapi.c	/^int sqlite3_bind_int64(sqlite3_stmt *pStmt, int i, sqlite_int64 iValue){$/;"	f
sqlite3_bind_null	.\src\sqlite3ext.h	300;"	d
sqlite3_bind_null	.\src\vdbeapi.c	/^int sqlite3_bind_null(sqlite3_stmt *pStmt, int i){$/;"	f
sqlite3_bind_parameter_count	.\src\sqlite3ext.h	301;"	d
sqlite3_bind_parameter_count	.\src\vdbeapi.c	/^int sqlite3_bind_parameter_count(sqlite3_stmt *pStmt){$/;"	f
sqlite3_bind_parameter_index	.\src\sqlite3ext.h	302;"	d
sqlite3_bind_parameter_index	.\src\vdbeapi.c	/^int sqlite3_bind_parameter_index(sqlite3_stmt *pStmt, const char *zName){$/;"	f
sqlite3_bind_parameter_name	.\src\sqlite3ext.h	303;"	d
sqlite3_bind_parameter_name	.\src\vdbeapi.c	/^const char *sqlite3_bind_parameter_name(sqlite3_stmt *pStmt, int i){$/;"	f
sqlite3_bind_text	.\src\sqlite3ext.h	304;"	d
sqlite3_bind_text	.\src\vdbeapi.c	/^int sqlite3_bind_text( $/;"	f
sqlite3_bind_text16	.\src\loadext.c	44;"	d	file:
sqlite3_bind_text16	.\src\sqlite3ext.h	305;"	d
sqlite3_bind_text16	.\src\vdbeapi.c	/^int sqlite3_bind_text16($/;"	f
sqlite3_bind_text64	.\src\sqlite3ext.h	499;"	d
sqlite3_bind_text64	.\src\vdbeapi.c	/^int sqlite3_bind_text64( $/;"	f
sqlite3_bind_value	.\src\sqlite3ext.h	306;"	d
sqlite3_bind_value	.\src\vdbeapi.c	/^int sqlite3_bind_value(sqlite3_stmt *pStmt, int i, const sqlite3_value *pValue){$/;"	f
sqlite3_bind_zeroblob	.\src\loadext.c	105;"	d	file:
sqlite3_bind_zeroblob	.\src\sqlite3ext.h	423;"	d
sqlite3_bind_zeroblob	.\src\vdbeapi.c	/^int sqlite3_bind_zeroblob(sqlite3_stmt *pStmt, int i, int n){$/;"	f
sqlite3_bind_zeroblob64	.\src\sqlite3ext.h	513;"	d
sqlite3_bind_zeroblob64	.\src\vdbeapi.c	/^int sqlite3_bind_zeroblob64(sqlite3_stmt *pStmt, int i, sqlite3_uint64 n){$/;"	f
sqlite3_blob_bytes	.\src\loadext.c	106;"	d	file:
sqlite3_blob_bytes	.\src\sqlite3ext.h	424;"	d
sqlite3_blob_bytes	.\src\vdbeblob.c	/^int sqlite3_blob_bytes(sqlite3_blob *pBlob){$/;"	f
sqlite3_blob_close	.\src\loadext.c	107;"	d	file:
sqlite3_blob_close	.\src\sqlite3ext.h	425;"	d
sqlite3_blob_close	.\src\vdbeblob.c	/^int sqlite3_blob_close(sqlite3_blob *pBlob){$/;"	f
sqlite3_blob_open	.\src\loadext.c	108;"	d	file:
sqlite3_blob_open	.\src\sqlite3ext.h	426;"	d
sqlite3_blob_open	.\src\vdbeblob.c	/^int sqlite3_blob_open($/;"	f
sqlite3_blob_read	.\src\loadext.c	109;"	d	file:
sqlite3_blob_read	.\src\sqlite3ext.h	427;"	d
sqlite3_blob_read	.\src\vdbeblob.c	/^int sqlite3_blob_read(sqlite3_blob *pBlob, void *z, int n, int iOffset){$/;"	f
sqlite3_blob_reopen	.\src\loadext.c	111;"	d	file:
sqlite3_blob_reopen	.\src\sqlite3ext.h	479;"	d
sqlite3_blob_reopen	.\src\vdbeblob.c	/^int sqlite3_blob_reopen(sqlite3_blob *pBlob, sqlite3_int64 iRow){$/;"	f
sqlite3_blob_write	.\src\loadext.c	110;"	d	file:
sqlite3_blob_write	.\src\sqlite3ext.h	428;"	d
sqlite3_blob_write	.\src\vdbeblob.c	/^int sqlite3_blob_write(sqlite3_blob *pBlob, const void *z, int n, int iOffset){$/;"	f
sqlite3_blocking_prepare_v2	.\src\test_thread.c	/^int sqlite3_blocking_prepare_v2($/;"	f
sqlite3_blocking_step	.\src\test_thread.c	/^int sqlite3_blocking_step(sqlite3_stmt *pStmt){$/;"	f
sqlite3_busy_handler	.\src\main.c	/^int sqlite3_busy_handler($/;"	f
sqlite3_busy_handler	.\src\sqlite3ext.h	307;"	d
sqlite3_busy_timeout	.\src\main.c	/^int sqlite3_busy_timeout(sqlite3 *db, int ms){$/;"	f
sqlite3_busy_timeout	.\src\sqlite3ext.h	308;"	d
sqlite3_cancel_auto_extension	.\src\loadext.c	/^int sqlite3_cancel_auto_extension(void (*xInit)(void)){$/;"	f
sqlite3_cancel_auto_extension	.\src\sqlite3ext.h	500;"	d
sqlite3_changes	.\src\main.c	/^int sqlite3_changes(sqlite3 *db){$/;"	f
sqlite3_changes	.\src\sqlite3ext.h	309;"	d
sqlite3_clear_bindings	.\src\sqlite3ext.h	422;"	d
sqlite3_clear_bindings	.\src\vdbeapi.c	/^int sqlite3_clear_bindings(sqlite3_stmt *pStmt){$/;"	f
sqlite3_client_close	.\src\test_server.c	/^int sqlite3_client_close(sqlite3 *pDb){$/;"	f
sqlite3_client_finalize	.\src\test_server.c	/^int sqlite3_client_finalize(sqlite3_stmt *pStmt){$/;"	f
sqlite3_client_open	.\src\test_server.c	/^int sqlite3_client_open(const char *zDatabaseName, sqlite3 **ppDb){$/;"	f
sqlite3_client_prepare	.\src\test_server.c	/^int sqlite3_client_prepare($/;"	f
sqlite3_client_reset	.\src\test_server.c	/^int sqlite3_client_reset(sqlite3_stmt *pStmt){$/;"	f
sqlite3_client_step	.\src\test_server.c	/^int sqlite3_client_step(sqlite3_stmt *pStmt){$/;"	f
sqlite3_close	.\src\main.c	/^int sqlite3_close(sqlite3 *db){ return sqlite3Close(db,0); }$/;"	f
sqlite3_close	.\src\sqlite3ext.h	310;"	d
sqlite3_close_v2	.\src\main.c	/^int sqlite3_close_v2(sqlite3 *db){ return sqlite3Close(db,1); }$/;"	f
sqlite3_close_v2	.\src\sqlite3ext.h	483;"	d
sqlite3_collation_needed	.\src\main.c	/^int sqlite3_collation_needed($/;"	f
sqlite3_collation_needed	.\src\sqlite3ext.h	311;"	d
sqlite3_collation_needed16	.\src\loadext.c	45;"	d	file:
sqlite3_collation_needed16	.\src\main.c	/^int sqlite3_collation_needed16($/;"	f
sqlite3_collation_needed16	.\src\sqlite3ext.h	312;"	d
sqlite3_column_blob	.\src\sqlite3ext.h	313;"	d
sqlite3_column_blob	.\src\vdbeapi.c	/^const void *sqlite3_column_blob(sqlite3_stmt *pStmt, int i){$/;"	f
sqlite3_column_bytes	.\src\sqlite3ext.h	314;"	d
sqlite3_column_bytes	.\src\vdbeapi.c	/^int sqlite3_column_bytes(sqlite3_stmt *pStmt, int i){$/;"	f
sqlite3_column_bytes16	.\src\sqlite3ext.h	315;"	d
sqlite3_column_bytes16	.\src\vdbeapi.c	/^int sqlite3_column_bytes16(sqlite3_stmt *pStmt, int i){$/;"	f
sqlite3_column_count	.\src\sqlite3ext.h	316;"	d
sqlite3_column_count	.\src\vdbeapi.c	/^int sqlite3_column_count(sqlite3_stmt *pStmt){$/;"	f
sqlite3_column_database_name	.\src\loadext.c	31;"	d	file:
sqlite3_column_database_name	.\src\sqlite3ext.h	317;"	d
sqlite3_column_database_name	.\src\vdbeapi.c	/^const char *sqlite3_column_database_name(sqlite3_stmt *pStmt, int N){$/;"	f
sqlite3_column_database_name16	.\src\loadext.c	32;"	d	file:
sqlite3_column_database_name16	.\src\loadext.c	63;"	d	file:
sqlite3_column_database_name16	.\src\sqlite3ext.h	318;"	d
sqlite3_column_database_name16	.\src\vdbeapi.c	/^const void *sqlite3_column_database_name16(sqlite3_stmt *pStmt, int N){$/;"	f
sqlite3_column_decltype	.\src\loadext.c	75;"	d	file:
sqlite3_column_decltype	.\src\sqlite3ext.h	319;"	d
sqlite3_column_decltype	.\src\vdbeapi.c	/^const char *sqlite3_column_decltype(sqlite3_stmt *pStmt, int N){$/;"	f
sqlite3_column_decltype16	.\src\loadext.c	46;"	d	file:
sqlite3_column_decltype16	.\src\loadext.c	74;"	d	file:
sqlite3_column_decltype16	.\src\sqlite3ext.h	320;"	d
sqlite3_column_decltype16	.\src\vdbeapi.c	/^const void *sqlite3_column_decltype16(sqlite3_stmt *pStmt, int N){$/;"	f
sqlite3_column_double	.\src\sqlite3ext.h	321;"	d
sqlite3_column_double	.\src\vdbeapi.c	/^double sqlite3_column_double(sqlite3_stmt *pStmt, int i){$/;"	f
sqlite3_column_int	.\src\sqlite3ext.h	322;"	d
sqlite3_column_int	.\src\vdbeapi.c	/^int sqlite3_column_int(sqlite3_stmt *pStmt, int i){$/;"	f
sqlite3_column_int64	.\src\sqlite3ext.h	323;"	d
sqlite3_column_int64	.\src\vdbeapi.c	/^sqlite_int64 sqlite3_column_int64(sqlite3_stmt *pStmt, int i){$/;"	f
sqlite3_column_name	.\src\sqlite3ext.h	324;"	d
sqlite3_column_name	.\src\vdbeapi.c	/^const char *sqlite3_column_name(sqlite3_stmt *pStmt, int N){$/;"	f
sqlite3_column_name16	.\src\loadext.c	47;"	d	file:
sqlite3_column_name16	.\src\sqlite3ext.h	325;"	d
sqlite3_column_name16	.\src\vdbeapi.c	/^const void *sqlite3_column_name16(sqlite3_stmt *pStmt, int N){$/;"	f
sqlite3_column_origin_name	.\src\loadext.c	35;"	d	file:
sqlite3_column_origin_name	.\src\sqlite3ext.h	326;"	d
sqlite3_column_origin_name	.\src\vdbeapi.c	/^const char *sqlite3_column_origin_name(sqlite3_stmt *pStmt, int N){$/;"	f
sqlite3_column_origin_name16	.\src\loadext.c	36;"	d	file:
sqlite3_column_origin_name16	.\src\loadext.c	65;"	d	file:
sqlite3_column_origin_name16	.\src\sqlite3ext.h	327;"	d
sqlite3_column_origin_name16	.\src\vdbeapi.c	/^const void *sqlite3_column_origin_name16(sqlite3_stmt *pStmt, int N){$/;"	f
sqlite3_column_table_name	.\src\loadext.c	33;"	d	file:
sqlite3_column_table_name	.\src\sqlite3ext.h	328;"	d
sqlite3_column_table_name	.\src\vdbeapi.c	/^const char *sqlite3_column_table_name(sqlite3_stmt *pStmt, int N){$/;"	f
sqlite3_column_table_name16	.\src\loadext.c	34;"	d	file:
sqlite3_column_table_name16	.\src\loadext.c	64;"	d	file:
sqlite3_column_table_name16	.\src\sqlite3ext.h	329;"	d
sqlite3_column_table_name16	.\src\vdbeapi.c	/^const void *sqlite3_column_table_name16(sqlite3_stmt *pStmt, int N){$/;"	f
sqlite3_column_text	.\src\sqlite3ext.h	330;"	d
sqlite3_column_text	.\src\vdbeapi.c	/^const unsigned char *sqlite3_column_text(sqlite3_stmt *pStmt, int i){$/;"	f
sqlite3_column_text16	.\src\loadext.c	48;"	d	file:
sqlite3_column_text16	.\src\sqlite3ext.h	331;"	d
sqlite3_column_text16	.\src\vdbeapi.c	/^const void *sqlite3_column_text16(sqlite3_stmt *pStmt, int i){$/;"	f
sqlite3_column_type	.\src\sqlite3ext.h	332;"	d
sqlite3_column_type	.\src\vdbeapi.c	/^int sqlite3_column_type(sqlite3_stmt *pStmt, int i){$/;"	f
sqlite3_column_value	.\src\sqlite3ext.h	333;"	d
sqlite3_column_value	.\src\vdbeapi.c	/^sqlite3_value *sqlite3_column_value(sqlite3_stmt *pStmt, int i){$/;"	f
sqlite3_commit_hook	.\src\main.c	/^void *sqlite3_commit_hook($/;"	f
sqlite3_commit_hook	.\src\sqlite3ext.h	334;"	d
sqlite3_compileoption_get	.\src\ctime.c	/^const char *sqlite3_compileoption_get(int N){$/;"	f
sqlite3_compileoption_get	.\src\sqlite3ext.h	463;"	d
sqlite3_compileoption_used	.\src\ctime.c	/^int sqlite3_compileoption_used(const char *zOptName){$/;"	f
sqlite3_compileoption_used	.\src\sqlite3ext.h	464;"	d
sqlite3_complete	.\src\complete.c	/^int sqlite3_complete(const char *zSql){$/;"	f
sqlite3_complete	.\src\loadext.c	69;"	d	file:
sqlite3_complete	.\src\sqlite3ext.h	335;"	d
sqlite3_complete16	.\src\complete.c	/^int sqlite3_complete16(const void *zSql){$/;"	f
sqlite3_complete16	.\src\loadext.c	49;"	d	file:
sqlite3_complete16	.\src\loadext.c	70;"	d	file:
sqlite3_complete16	.\src\sqlite3ext.h	336;"	d
sqlite3_config	.\src\main.c	/^int sqlite3_config(int op, ...){$/;"	f
sqlite3_context	.\src\vdbeInt.h	/^struct sqlite3_context {$/;"	s
sqlite3_context_db_handle	.\src\sqlite3ext.h	452;"	d
sqlite3_context_db_handle	.\src\vdbeapi.c	/^sqlite3 *sqlite3_context_db_handle(sqlite3_context *p){$/;"	f
sqlite3_create_collation	.\src\main.c	/^int sqlite3_create_collation($/;"	f
sqlite3_create_collation	.\src\sqlite3ext.h	337;"	d
sqlite3_create_collation16	.\src\loadext.c	50;"	d	file:
sqlite3_create_collation16	.\src\main.c	/^int sqlite3_create_collation16($/;"	f
sqlite3_create_collation16	.\src\sqlite3ext.h	338;"	d
sqlite3_create_collation_v2	.\src\main.c	/^int sqlite3_create_collation_v2($/;"	f
sqlite3_create_collation_v2	.\src\sqlite3ext.h	429;"	d
sqlite3_create_function	.\src\main.c	/^int sqlite3_create_function($/;"	f
sqlite3_create_function	.\src\sqlite3ext.h	339;"	d
sqlite3_create_function16	.\src\loadext.c	51;"	d	file:
sqlite3_create_function16	.\src\main.c	/^int sqlite3_create_function16($/;"	f
sqlite3_create_function16	.\src\sqlite3ext.h	340;"	d
sqlite3_create_function_v2	.\src\main.c	/^int sqlite3_create_function_v2($/;"	f
sqlite3_create_function_v2	.\src\sqlite3ext.h	465;"	d
sqlite3_create_module	.\src\loadext.c	83;"	d	file:
sqlite3_create_module	.\src\sqlite3ext.h	341;"	d
sqlite3_create_module	.\src\vtab.c	/^int sqlite3_create_module($/;"	f
sqlite3_create_module_v2	.\src\loadext.c	84;"	d	file:
sqlite3_create_module_v2	.\src\sqlite3ext.h	342;"	d
sqlite3_create_module_v2	.\src\vtab.c	/^int sqlite3_create_module_v2($/;"	f
sqlite3_current_time	.\src\os_unix.c	/^int sqlite3_current_time = 0;  \/* Fake system time in seconds since 1970. *\/$/;"	v
sqlite3_current_time	.\src\os_win.c	/^int sqlite3_current_time = 0;  \/* Fake system time in seconds since 1970. *\/$/;"	v
sqlite3_data_count	.\src\sqlite3ext.h	343;"	d
sqlite3_data_count	.\src\vdbeapi.c	/^int sqlite3_data_count(sqlite3_stmt *pStmt){$/;"	f
sqlite3_data_directory	.\src\main.c	/^char *sqlite3_data_directory = 0;$/;"	v
sqlite3_db_config	.\src\main.c	/^int sqlite3_db_config(sqlite3 *db, int op, ...){$/;"	f
sqlite3_db_config	.\src\sqlite3ext.h	466;"	d
sqlite3_db_filename	.\src\main.c	/^const char *sqlite3_db_filename(sqlite3 *db, const char *zDbName){$/;"	f
sqlite3_db_filename	.\src\sqlite3ext.h	484;"	d
sqlite3_db_handle	.\src\sqlite3ext.h	344;"	d
sqlite3_db_handle	.\src\vdbeapi.c	/^sqlite3 *sqlite3_db_handle(sqlite3_stmt *pStmt){$/;"	f
sqlite3_db_mutex	.\src\main.c	/^sqlite3_mutex *sqlite3_db_mutex(sqlite3 *db){$/;"	f
sqlite3_db_mutex	.\src\sqlite3ext.h	467;"	d
sqlite3_db_readonly	.\src\main.c	/^int sqlite3_db_readonly(sqlite3 *db, const char *zDbName){$/;"	f
sqlite3_db_readonly	.\src\sqlite3ext.h	485;"	d
sqlite3_db_release_memory	.\src\main.c	/^int sqlite3_db_release_memory(sqlite3 *db){$/;"	f
sqlite3_db_release_memory	.\src\sqlite3ext.h	486;"	d
sqlite3_db_status	.\src\sqlite3ext.h	468;"	d
sqlite3_db_status	.\src\status.c	/^int sqlite3_db_status($/;"	f
sqlite3_debug_mutex	.\src\mutex_noop.c	/^typedef struct sqlite3_debug_mutex {$/;"	s	file:
sqlite3_debug_mutex	.\src\mutex_noop.c	/^} sqlite3_debug_mutex;$/;"	t	typeref:struct:sqlite3_debug_mutex	file:
sqlite3_declare_vtab	.\src\loadext.c	85;"	d	file:
sqlite3_declare_vtab	.\src\sqlite3ext.h	345;"	d
sqlite3_declare_vtab	.\src\vtab.c	/^int sqlite3_declare_vtab(sqlite3 *db, const char *zCreateTable){$/;"	f
sqlite3_demovfs	.\src\test_demovfs.c	/^sqlite3_vfs *sqlite3_demovfs(void){$/;"	f
sqlite3_diskfull	.\src\os_common.h	/^int sqlite3_diskfull = 0;$/;"	v
sqlite3_diskfull_pending	.\src\os_common.h	/^int sqlite3_diskfull_pending = 0;$/;"	v
sqlite3_enable_load_extension	.\src\loadext.c	/^int sqlite3_enable_load_extension(sqlite3 *db, int onoff){$/;"	f
sqlite3_enable_shared_cache	.\src\btree.c	/^int sqlite3_enable_shared_cache(int enable){$/;"	f
sqlite3_enable_shared_cache	.\src\loadext.c	91;"	d	file:
sqlite3_enable_shared_cache	.\src\sqlite3ext.h	346;"	d
sqlite3_errcode	.\src\main.c	/^int sqlite3_errcode(sqlite3 *db){$/;"	f
sqlite3_errcode	.\src\sqlite3ext.h	347;"	d
sqlite3_errmsg	.\src\main.c	/^const char *sqlite3_errmsg(sqlite3 *db){$/;"	f
sqlite3_errmsg	.\src\sqlite3ext.h	348;"	d
sqlite3_errmsg16	.\src\loadext.c	52;"	d	file:
sqlite3_errmsg16	.\src\main.c	/^const void *sqlite3_errmsg16(sqlite3 *db){$/;"	f
sqlite3_errmsg16	.\src\sqlite3ext.h	349;"	d
sqlite3_errstr	.\src\main.c	/^const char *sqlite3_errstr(int rc){$/;"	f
sqlite3_errstr	.\src\sqlite3ext.h	487;"	d
sqlite3_exec	.\src\legacy.c	/^int sqlite3_exec($/;"	f
sqlite3_exec	.\src\sqlite3ext.h	350;"	d
sqlite3_expired	.\src\sqlite3ext.h	352;"	d
sqlite3_expired	.\src\vdbeapi.c	/^int sqlite3_expired(sqlite3_stmt *pStmt){$/;"	f
sqlite3_extended_errcode	.\src\main.c	/^int sqlite3_extended_errcode(sqlite3 *db){$/;"	f
sqlite3_extended_errcode	.\src\sqlite3ext.h	469;"	d
sqlite3_extended_result_codes	.\src\main.c	/^int sqlite3_extended_result_codes(sqlite3 *db, int onoff){$/;"	f
sqlite3_extended_result_codes	.\src\sqlite3ext.h	453;"	d
sqlite3_file_control	.\src\main.c	/^int sqlite3_file_control(sqlite3 *db, const char *zDbName, int op, void *pArg){$/;"	f
sqlite3_file_control	.\src\sqlite3ext.h	430;"	d
sqlite3_finalize	.\src\sqlite3ext.h	354;"	d
sqlite3_finalize	.\src\vdbeapi.c	/^int sqlite3_finalize(sqlite3_stmt *pStmt){$/;"	f
sqlite3_found_count	.\src\vdbe.c	/^int sqlite3_found_count = 0;$/;"	v
sqlite3_free	.\src\malloc.c	/^void sqlite3_free(void *p){$/;"	f
sqlite3_free	.\src\sqlite3ext.h	355;"	d
sqlite3_free_table	.\src\loadext.c	100;"	d	file:
sqlite3_free_table	.\src\sqlite3ext.h	356;"	d
sqlite3_free_table	.\src\table.c	/^void sqlite3_free_table($/;"	f
sqlite3_fts3_enable_parentheses	.\ext\fts3\fts3_expr.c	/^int sqlite3_fts3_enable_parentheses = 0;$/;"	v
sqlite3_fts3_enable_parentheses	.\ext\fts3\fts3_expr.c	70;"	d	file:
sqlite3_fts3_enable_parentheses	.\ext\fts3\fts3_expr.c	72;"	d	file:
sqlite3_fts5_may_be_corrupt	.\ext\fts5\fts5_main.c	/^int sqlite3_fts5_may_be_corrupt = 1;$/;"	v
sqlite3_fullsync_count	.\src\os_unix.c	/^int sqlite3_fullsync_count = 0;$/;"	v
sqlite3_fullsync_count	.\src\os_win.c	/^int sqlite3_fullsync_count = 0;$/;"	v
sqlite3_get_autocommit	.\src\main.c	/^int sqlite3_get_autocommit(sqlite3 *db){$/;"	f
sqlite3_get_autocommit	.\src\sqlite3ext.h	357;"	d
sqlite3_get_auxdata	.\src\sqlite3ext.h	358;"	d
sqlite3_get_auxdata	.\src\vdbeapi.c	/^void *sqlite3_get_auxdata(sqlite3_context *pCtx, int iArg){$/;"	f
sqlite3_get_table	.\src\loadext.c	101;"	d	file:
sqlite3_get_table	.\src\sqlite3ext.h	359;"	d
sqlite3_get_table	.\src\table.c	/^int sqlite3_get_table($/;"	f
sqlite3_get_table_cb	.\src\table.c	/^static int sqlite3_get_table_cb(void *pArg, int nCol, char **argv, char **colv){$/;"	f	file:
sqlite3_global_recover	.\src\main.c	/^int sqlite3_global_recover(void){$/;"	f
sqlite3_global_recover	.\src\sqlite3ext.h	361;"	d
sqlite3_hostid_num	.\src\os_unix.c	/^int sqlite3_hostid_num = 0;$/;"	v
sqlite3_init_sqllog	.\src\test_sqllog.c	/^void sqlite3_init_sqllog(void){$/;"	f
sqlite3_initialize	.\src\main.c	/^int sqlite3_initialize(void){$/;"	f
sqlite3_int64	.\test\speedtest1.c	52;"	d	file:
sqlite3_intarray	.\src\test_intarray.c	/^struct sqlite3_intarray {$/;"	s	file:
sqlite3_intarray	.\src\test_intarray.h	/^typedef struct sqlite3_intarray sqlite3_intarray;$/;"	t	typeref:struct:sqlite3_intarray
sqlite3_intarray_bind	.\src\test_intarray.c	/^SQLITE_API int sqlite3_intarray_bind($/;"	f
sqlite3_intarray_create	.\src\test_intarray.c	/^SQLITE_API int sqlite3_intarray_create($/;"	f
sqlite3_interrupt	.\src\main.c	/^void sqlite3_interrupt(sqlite3 *db){$/;"	f
sqlite3_interrupt	.\src\sqlite3ext.h	363;"	d
sqlite3_interrupt_count	.\src\vdbe.c	/^int sqlite3_interrupt_count = 0;$/;"	v
sqlite3_io_error_benign	.\src\os_common.h	/^int sqlite3_io_error_benign = 0;         \/* True if errors are benign *\/$/;"	v
sqlite3_io_error_hardhit	.\src\os_common.h	/^int sqlite3_io_error_hardhit = 0;        \/* Number of non-benign errors *\/$/;"	v
sqlite3_io_error_hit	.\src\os_common.h	/^int sqlite3_io_error_hit = 0;            \/* Total number of I\/O Errors *\/$/;"	v
sqlite3_io_error_pending	.\src\os_common.h	/^int sqlite3_io_error_pending = 0;        \/* Count down to first I\/O error *\/$/;"	v
sqlite3_io_error_persist	.\src\os_common.h	/^int sqlite3_io_error_persist = 0;        \/* True if I\/O errors persist *\/$/;"	v
sqlite3_last_insert_rowid	.\src\main.c	/^sqlite_int64 sqlite3_last_insert_rowid(sqlite3 *db){$/;"	f
sqlite3_last_insert_rowid	.\src\sqlite3ext.h	364;"	d
sqlite3_libversion	.\src\main.c	/^const char *sqlite3_libversion(void){ return sqlite3_version; }$/;"	f
sqlite3_libversion	.\src\sqlite3ext.h	365;"	d
sqlite3_libversion_number	.\src\main.c	/^int sqlite3_libversion_number(void){ return SQLITE_VERSION_NUMBER; }$/;"	f
sqlite3_libversion_number	.\src\sqlite3ext.h	366;"	d
sqlite3_like_count	.\src\func.c	/^int sqlite3_like_count = 0;$/;"	v
sqlite3_limit	.\src\main.c	/^int sqlite3_limit(sqlite3 *db, int limitId, int newLimit){$/;"	f
sqlite3_limit	.\src\sqlite3ext.h	454;"	d
sqlite3_load_extension	.\src\loadext.c	/^int sqlite3_load_extension($/;"	f
sqlite3_load_extension	.\src\sqlite3ext.h	501;"	d
sqlite3_log	.\src\printf.c	/^void sqlite3_log(int iErrCode, const char *zFormat, ...){$/;"	f
sqlite3_log	.\src\sqlite3ext.h	470;"	d
sqlite3_malloc	.\src\malloc.c	/^void *sqlite3_malloc(int n){$/;"	f
sqlite3_malloc	.\src\sqlite3ext.h	367;"	d
sqlite3_malloc64	.\src\malloc.c	/^void *sqlite3_malloc64(sqlite3_uint64 n){$/;"	f
sqlite3_malloc64	.\src\sqlite3ext.h	502;"	d
sqlite3_max_blobsize	.\src\vdbe.c	/^int sqlite3_max_blobsize = 0;$/;"	v
sqlite3_memdebug_title_count	.\src\test_malloc.c	/^static int sqlite3_memdebug_title_count = 0;$/;"	v	file:
sqlite3_memdebug_vfs_oom_test	.\src\os.c	/^int sqlite3_memdebug_vfs_oom_test = 1;$/;"	v
sqlite3_memory_alarm	.\src\malloc.c	/^int sqlite3_memory_alarm($/;"	f
sqlite3_memory_highwater	.\src\malloc.c	/^sqlite3_int64 sqlite3_memory_highwater(int resetFlag){$/;"	f
sqlite3_memory_highwater	.\src\sqlite3ext.h	431;"	d
sqlite3_memory_used	.\src\malloc.c	/^sqlite3_int64 sqlite3_memory_used(void){$/;"	f
sqlite3_memory_used	.\src\sqlite3ext.h	432;"	d
sqlite3_mprintf	.\src\printf.c	/^char *sqlite3_mprintf(const char *zFormat, ...){$/;"	f
sqlite3_mprintf	.\src\sqlite3ext.h	368;"	d
sqlite3_mprintf_double	.\src\test1.c	/^static int sqlite3_mprintf_double($/;"	f	file:
sqlite3_mprintf_hexdouble	.\src\test1.c	/^static int sqlite3_mprintf_hexdouble($/;"	f	file:
sqlite3_mprintf_int	.\src\test1.c	/^static int sqlite3_mprintf_int($/;"	f	file:
sqlite3_mprintf_int64	.\src\test1.c	/^static int sqlite3_mprintf_int64($/;"	f	file:
sqlite3_mprintf_long	.\src\test1.c	/^static int sqlite3_mprintf_long($/;"	f	file:
sqlite3_mprintf_scaled	.\src\test1.c	/^static int sqlite3_mprintf_scaled($/;"	f	file:
sqlite3_mprintf_str	.\src\test1.c	/^static int sqlite3_mprintf_str($/;"	f	file:
sqlite3_mprintf_stronly	.\src\test1.c	/^static int sqlite3_mprintf_stronly($/;"	f	file:
sqlite3_msize	.\src\malloc.c	/^sqlite3_uint64 sqlite3_msize(void *p){$/;"	f
sqlite3_msize	.\src\sqlite3ext.h	503;"	d
sqlite3_multiplex_initialize	.\src\test_multiplex.c	/^int sqlite3_multiplex_initialize(const char *zOrigVfsName, int makeDefault){$/;"	f
sqlite3_multiplex_shutdown	.\src\test_multiplex.c	/^int sqlite3_multiplex_shutdown(int eForce){$/;"	f
sqlite3_mutex	.\src\mutex_unix.c	/^struct sqlite3_mutex {$/;"	s	file:
sqlite3_mutex	.\src\mutex_w32.c	/^struct sqlite3_mutex {$/;"	s	file:
sqlite3_mutex	.\src\test_mutex.c	/^struct sqlite3_mutex {$/;"	s	file:
sqlite3_mutex_alloc	.\src\mutex.c	/^sqlite3_mutex *sqlite3_mutex_alloc(int id){$/;"	f
sqlite3_mutex_alloc	.\src\mutex.h	57;"	d
sqlite3_mutex_alloc	.\src\sqlite3ext.h	433;"	d
sqlite3_mutex_alloc	.\src\test_multiplex.c	75;"	d	file:
sqlite3_mutex_alloc	.\src\test_quota.c	38;"	d	file:
sqlite3_mutex_enter	.\src\mutex.c	/^void sqlite3_mutex_enter(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_enter	.\src\mutex.h	59;"	d
sqlite3_mutex_enter	.\src\sqlite3ext.h	434;"	d
sqlite3_mutex_enter	.\src\test_multiplex.c	77;"	d	file:
sqlite3_mutex_enter	.\src\test_quota.c	40;"	d	file:
sqlite3_mutex_free	.\src\mutex.c	/^void sqlite3_mutex_free(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_free	.\src\mutex.h	58;"	d
sqlite3_mutex_free	.\src\sqlite3ext.h	435;"	d
sqlite3_mutex_free	.\src\test_multiplex.c	76;"	d	file:
sqlite3_mutex_free	.\src\test_quota.c	39;"	d	file:
sqlite3_mutex_held	.\src\mutex.c	/^int sqlite3_mutex_held(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_held	.\src\mutex.h	62;"	d
sqlite3_mutex_held	.\src\test_multiplex.c	80;"	d	file:
sqlite3_mutex_held	.\src\test_quota.c	43;"	d	file:
sqlite3_mutex_leave	.\src\mutex.c	/^void sqlite3_mutex_leave(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_leave	.\src\mutex.h	61;"	d
sqlite3_mutex_leave	.\src\sqlite3ext.h	436;"	d
sqlite3_mutex_leave	.\src\test_multiplex.c	79;"	d	file:
sqlite3_mutex_leave	.\src\test_quota.c	42;"	d	file:
sqlite3_mutex_notheld	.\src\mutex.c	/^int sqlite3_mutex_notheld(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_notheld	.\src\mutex.h	63;"	d
sqlite3_mutex_notheld	.\src\test_multiplex.c	81;"	d	file:
sqlite3_mutex_notheld	.\src\test_quota.c	44;"	d	file:
sqlite3_mutex_try	.\src\mutex.c	/^int sqlite3_mutex_try(sqlite3_mutex *p){$/;"	f
sqlite3_mutex_try	.\src\mutex.h	60;"	d
sqlite3_mutex_try	.\src\sqlite3ext.h	437;"	d
sqlite3_mutex_try	.\src\test_multiplex.c	78;"	d	file:
sqlite3_mutex_try	.\src\test_quota.c	41;"	d	file:
sqlite3_next_stmt	.\src\sqlite3ext.h	455;"	d
sqlite3_next_stmt	.\src\vdbeapi.c	/^sqlite3_stmt *sqlite3_next_stmt(sqlite3 *pDb, sqlite3_stmt *pStmt){$/;"	f
sqlite3_open	.\src\main.c	/^int sqlite3_open($/;"	f
sqlite3_open	.\src\sqlite3ext.h	369;"	d
sqlite3_open16	.\src\loadext.c	53;"	d	file:
sqlite3_open16	.\src\main.c	/^int sqlite3_open16($/;"	f
sqlite3_open16	.\src\sqlite3ext.h	370;"	d
sqlite3_open_file_count	.\src\os_common.h	/^int sqlite3_open_file_count = 0;$/;"	v
sqlite3_open_v2	.\src\main.c	/^int sqlite3_open_v2($/;"	f
sqlite3_open_v2	.\src\sqlite3ext.h	438;"	d
sqlite3_opentemp_count	.\src\pager.c	/^int sqlite3_opentemp_count = 0;$/;"	v
sqlite3_os_end	.\src\os_unix.c	/^int sqlite3_os_end(void){ $/;"	f
sqlite3_os_end	.\src\os_win.c	/^int sqlite3_os_end(void){$/;"	f
sqlite3_os_init	.\src\os_unix.c	/^int sqlite3_os_init(void){ $/;"	f
sqlite3_os_init	.\src\os_win.c	/^int sqlite3_os_init(void){$/;"	f
sqlite3_os_type	.\src\os_win.c	/^LONG SQLITE_WIN32_VOLATILE sqlite3_os_type = 0;$/;"	v
sqlite3_os_type	.\src\os_win.c	/^static LONG SQLITE_WIN32_VOLATILE sqlite3_os_type = 0;$/;"	v	file:
sqlite3_overload_function	.\src\main.c	/^int sqlite3_overload_function($/;"	f
sqlite3_overload_function	.\src\sqlite3ext.h	419;"	d
sqlite3_pager_readdb_count	.\src\pager.c	/^int sqlite3_pager_readdb_count = 0;    \/* Number of full pages read from DB *\/$/;"	v
sqlite3_pager_writedb_count	.\src\pager.c	/^int sqlite3_pager_writedb_count = 0;   \/* Number of full pages written to DB *\/$/;"	v
sqlite3_pager_writej_count	.\src\pager.c	/^int sqlite3_pager_writej_count = 0;    \/* Number of pages written to journal *\/$/;"	v
sqlite3_prepare	.\src\prepare.c	/^int sqlite3_prepare($/;"	f
sqlite3_prepare	.\src\sqlite3ext.h	371;"	d
sqlite3_prepare16	.\src\loadext.c	54;"	d	file:
sqlite3_prepare16	.\src\prepare.c	/^int sqlite3_prepare16($/;"	f
sqlite3_prepare16	.\src\sqlite3ext.h	372;"	d
sqlite3_prepare16_v2	.\src\loadext.c	55;"	d	file:
sqlite3_prepare16_v2	.\src\prepare.c	/^int sqlite3_prepare16_v2($/;"	f
sqlite3_prepare16_v2	.\src\sqlite3ext.h	374;"	d
sqlite3_prepare16_v2	.\src\sqlite3ext.h	421;"	d
sqlite3_prepare_v2	.\src\prepare.c	/^int sqlite3_prepare_v2($/;"	f
sqlite3_prepare_v2	.\src\sqlite3ext.h	373;"	d
sqlite3_prepare_v2	.\src\sqlite3ext.h	420;"	d
sqlite3_profile	.\src\loadext.c	95;"	d	file:
sqlite3_profile	.\src\main.c	/^void *sqlite3_profile($/;"	f
sqlite3_profile	.\src\sqlite3ext.h	375;"	d
sqlite3_progress_handler	.\src\loadext.c	79;"	d	file:
sqlite3_progress_handler	.\src\main.c	/^void sqlite3_progress_handler($/;"	f
sqlite3_progress_handler	.\src\sqlite3ext.h	376;"	d
sqlite3_quota_fclose	.\src\test_quota.c	/^int sqlite3_quota_fclose(quota_FILE *p){$/;"	f
sqlite3_quota_ferror	.\src\test_quota.c	/^int sqlite3_quota_ferror(quota_FILE *p){$/;"	f
sqlite3_quota_fflush	.\src\test_quota.c	/^int sqlite3_quota_fflush(quota_FILE *p, int doFsync){$/;"	f
sqlite3_quota_file	.\src\test_quota.c	/^int sqlite3_quota_file(const char *zFilename){$/;"	f
sqlite3_quota_file_available	.\src\test_quota.c	/^long sqlite3_quota_file_available(quota_FILE *p){$/;"	f
sqlite3_quota_file_mtime	.\src\test_quota.c	/^int sqlite3_quota_file_mtime(quota_FILE *p, time_t *pTime){$/;"	f
sqlite3_quota_file_size	.\src\test_quota.c	/^sqlite3_int64 sqlite3_quota_file_size(quota_FILE *p){$/;"	f
sqlite3_quota_file_truesize	.\src\test_quota.c	/^sqlite3_int64 sqlite3_quota_file_truesize(quota_FILE *p){$/;"	f
sqlite3_quota_fopen	.\src\test_quota.c	/^quota_FILE *sqlite3_quota_fopen(const char *zFilename, const char *zMode){$/;"	f
sqlite3_quota_fread	.\src\test_quota.c	/^size_t sqlite3_quota_fread($/;"	f
sqlite3_quota_fseek	.\src\test_quota.c	/^int sqlite3_quota_fseek(quota_FILE *p, long offset, int whence){$/;"	f
sqlite3_quota_ftell	.\src\test_quota.c	/^long sqlite3_quota_ftell(quota_FILE *p){$/;"	f
sqlite3_quota_ftruncate	.\src\test_quota.c	/^int sqlite3_quota_ftruncate(quota_FILE *p, sqlite3_int64 szNew){$/;"	f
sqlite3_quota_fwrite	.\src\test_quota.c	/^size_t sqlite3_quota_fwrite($/;"	f
sqlite3_quota_initialize	.\src\test_quota.c	/^int sqlite3_quota_initialize(const char *zOrigVfsName, int makeDefault){$/;"	f
sqlite3_quota_remove	.\src\test_quota.c	/^int sqlite3_quota_remove(const char *zFilename){$/;"	f
sqlite3_quota_rewind	.\src\test_quota.c	/^void sqlite3_quota_rewind(quota_FILE *p){$/;"	f
sqlite3_quota_set	.\src\test_quota.c	/^int sqlite3_quota_set($/;"	f
sqlite3_quota_shutdown	.\src\test_quota.c	/^int sqlite3_quota_shutdown(void){$/;"	f
sqlite3_randomness	.\src\random.c	/^void sqlite3_randomness(int N, void *pBuf){$/;"	f
sqlite3_randomness	.\src\sqlite3ext.h	451;"	d
sqlite3_realloc	.\src\malloc.c	/^void *sqlite3_realloc(void *pOld, int n){$/;"	f
sqlite3_realloc	.\src\sqlite3ext.h	377;"	d
sqlite3_realloc64	.\src\malloc.c	/^void *sqlite3_realloc64(void *pOld, sqlite3_uint64 n){$/;"	f
sqlite3_realloc64	.\src\sqlite3ext.h	504;"	d
sqlite3_register_vfslog	.\ext\misc\vfslog.c	/^int sqlite3_register_vfslog(const char *zArg){$/;"	f
sqlite3_release_memory	.\src\malloc.c	/^int sqlite3_release_memory(int n){$/;"	f
sqlite3_release_memory	.\src\sqlite3ext.h	439;"	d
sqlite3_reset	.\src\sqlite3ext.h	378;"	d
sqlite3_reset	.\src\vdbeapi.c	/^int sqlite3_reset(sqlite3_stmt *pStmt){$/;"	f
sqlite3_reset_auto_extension	.\src\loadext.c	/^void sqlite3_reset_auto_extension(void){$/;"	f
sqlite3_reset_auto_extension	.\src\sqlite3ext.h	505;"	d
sqlite3_result_blob	.\src\sqlite3ext.h	379;"	d
sqlite3_result_blob	.\src\vdbeapi.c	/^void sqlite3_result_blob($/;"	f
sqlite3_result_blob64	.\src\sqlite3ext.h	506;"	d
sqlite3_result_blob64	.\src\vdbeapi.c	/^void sqlite3_result_blob64($/;"	f
sqlite3_result_double	.\src\sqlite3ext.h	380;"	d
sqlite3_result_double	.\src\vdbeapi.c	/^void sqlite3_result_double(sqlite3_context *pCtx, double rVal){$/;"	f
sqlite3_result_error	.\src\sqlite3ext.h	381;"	d
sqlite3_result_error	.\src\vdbeapi.c	/^void sqlite3_result_error(sqlite3_context *pCtx, const char *z, int n){$/;"	f
sqlite3_result_error16	.\src\loadext.c	56;"	d	file:
sqlite3_result_error16	.\src\sqlite3ext.h	382;"	d
sqlite3_result_error16	.\src\vdbeapi.c	/^void sqlite3_result_error16(sqlite3_context *pCtx, const void *z, int n){$/;"	f
sqlite3_result_error_code	.\src\sqlite3ext.h	449;"	d
sqlite3_result_error_code	.\src\vdbeapi.c	/^void sqlite3_result_error_code(sqlite3_context *pCtx, int errCode){$/;"	f
sqlite3_result_error_nomem	.\src\sqlite3ext.h	440;"	d
sqlite3_result_error_nomem	.\src\vdbeapi.c	/^void sqlite3_result_error_nomem(sqlite3_context *pCtx){$/;"	f
sqlite3_result_error_toobig	.\src\sqlite3ext.h	441;"	d
sqlite3_result_error_toobig	.\src\vdbeapi.c	/^void sqlite3_result_error_toobig(sqlite3_context *pCtx){$/;"	f
sqlite3_result_int	.\src\sqlite3ext.h	383;"	d
sqlite3_result_int	.\src\vdbeapi.c	/^void sqlite3_result_int(sqlite3_context *pCtx, int iVal){$/;"	f
sqlite3_result_int64	.\src\sqlite3ext.h	384;"	d
sqlite3_result_int64	.\src\vdbeapi.c	/^void sqlite3_result_int64(sqlite3_context *pCtx, i64 iVal){$/;"	f
sqlite3_result_null	.\src\sqlite3ext.h	385;"	d
sqlite3_result_null	.\src\vdbeapi.c	/^void sqlite3_result_null(sqlite3_context *pCtx){$/;"	f
sqlite3_result_subtype	.\src\sqlite3ext.h	516;"	d
sqlite3_result_subtype	.\src\vdbeapi.c	/^void sqlite3_result_subtype(sqlite3_context *pCtx, unsigned int eSubtype){$/;"	f
sqlite3_result_text	.\src\sqlite3ext.h	386;"	d
sqlite3_result_text	.\src\vdbeapi.c	/^void sqlite3_result_text($/;"	f
sqlite3_result_text16	.\src\loadext.c	57;"	d	file:
sqlite3_result_text16	.\src\sqlite3ext.h	387;"	d
sqlite3_result_text16	.\src\vdbeapi.c	/^void sqlite3_result_text16($/;"	f
sqlite3_result_text16be	.\src\loadext.c	58;"	d	file:
sqlite3_result_text16be	.\src\sqlite3ext.h	388;"	d
sqlite3_result_text16be	.\src\vdbeapi.c	/^void sqlite3_result_text16be($/;"	f
sqlite3_result_text16le	.\src\loadext.c	59;"	d	file:
sqlite3_result_text16le	.\src\sqlite3ext.h	389;"	d
sqlite3_result_text16le	.\src\vdbeapi.c	/^void sqlite3_result_text16le($/;"	f
sqlite3_result_text64	.\src\sqlite3ext.h	507;"	d
sqlite3_result_text64	.\src\vdbeapi.c	/^void sqlite3_result_text64($/;"	f
sqlite3_result_value	.\src\sqlite3ext.h	390;"	d
sqlite3_result_value	.\src\vdbeapi.c	/^void sqlite3_result_value(sqlite3_context *pCtx, sqlite3_value *pValue){$/;"	f
sqlite3_result_zeroblob	.\src\sqlite3ext.h	448;"	d
sqlite3_result_zeroblob	.\src\vdbeapi.c	/^void sqlite3_result_zeroblob(sqlite3_context *pCtx, int n){$/;"	f
sqlite3_result_zeroblob64	.\src\sqlite3ext.h	512;"	d
sqlite3_result_zeroblob64	.\src\vdbeapi.c	/^int sqlite3_result_zeroblob64(sqlite3_context *pCtx, u64 n){$/;"	f
sqlite3_rollback_hook	.\src\main.c	/^void *sqlite3_rollback_hook($/;"	f
sqlite3_rollback_hook	.\src\sqlite3ext.h	391;"	d
sqlite3_rtree_dbl	.\ext\rtree\sqlite3rtree.h	/^  typedef double sqlite3_rtree_dbl;$/;"	t
sqlite3_rtree_dbl	.\ext\rtree\sqlite3rtree.h	/^  typedef sqlite3_int64 sqlite3_rtree_dbl;$/;"	t
sqlite3_rtree_geometry	.\ext\rtree\sqlite3rtree.h	/^struct sqlite3_rtree_geometry {$/;"	s
sqlite3_rtree_geometry	.\ext\rtree\sqlite3rtree.h	/^typedef struct sqlite3_rtree_geometry sqlite3_rtree_geometry;$/;"	t	typeref:struct:sqlite3_rtree_geometry
sqlite3_rtree_geometry_callback	.\ext\rtree\rtree.c	/^int sqlite3_rtree_geometry_callback($/;"	f
sqlite3_rtree_query_callback	.\ext\rtree\rtree.c	/^int sqlite3_rtree_query_callback($/;"	f
sqlite3_rtree_query_info	.\ext\rtree\sqlite3rtree.h	/^struct sqlite3_rtree_query_info {$/;"	s
sqlite3_rtree_query_info	.\ext\rtree\sqlite3rtree.h	/^typedef struct sqlite3_rtree_query_info sqlite3_rtree_query_info;$/;"	t	typeref:struct:sqlite3_rtree_query_info
sqlite3_search_count	.\src\vdbe.c	/^int sqlite3_search_count = 0;$/;"	v
sqlite3_server	.\src\test_server.c	/^void *sqlite3_server(void *NotUsed){$/;"	f
sqlite3_server_start	.\src\test_server.c	/^void sqlite3_server_start(void){$/;"	f
sqlite3_server_start2	.\src\test_server.c	/^void sqlite3_server_start2(int *pnDecr){$/;"	f
sqlite3_server_stop	.\src\test_server.c	/^void sqlite3_server_stop(void){$/;"	f
sqlite3_set_authorizer	.\src\auth.c	/^int sqlite3_set_authorizer($/;"	f
sqlite3_set_authorizer	.\src\loadext.c	40;"	d	file:
sqlite3_set_authorizer	.\src\sqlite3ext.h	392;"	d
sqlite3_set_auxdata	.\src\sqlite3ext.h	393;"	d
sqlite3_set_auxdata	.\src\vdbeapi.c	/^void sqlite3_set_auxdata($/;"	f
sqlite3_shutdown	.\src\main.c	/^int sqlite3_shutdown(void){$/;"	f
sqlite3_sleep	.\src\main.c	/^int sqlite3_sleep(int ms){$/;"	f
sqlite3_sleep	.\src\sqlite3ext.h	442;"	d
sqlite3_snprintf	.\src\printf.c	/^char *sqlite3_snprintf(int n, char *zBuf, const char *zFormat, ...){$/;"	f
sqlite3_snprintf	.\src\sqlite3ext.h	394;"	d
sqlite3_snprintf_str	.\src\test1.c	/^static int sqlite3_snprintf_str($/;"	f	file:
sqlite3_soft_heap_limit	.\src\malloc.c	/^void sqlite3_soft_heap_limit(int n){$/;"	f
sqlite3_soft_heap_limit	.\src\sqlite3ext.h	443;"	d
sqlite3_soft_heap_limit64	.\src\malloc.c	/^sqlite3_int64 sqlite3_soft_heap_limit64(sqlite3_int64 n){$/;"	f
sqlite3_soft_heap_limit64	.\src\sqlite3ext.h	471;"	d
sqlite3_sort_count	.\src\vdbe.c	/^int sqlite3_sort_count = 0;$/;"	v
sqlite3_sourceid	.\src\main.c	/^const char *sqlite3_sourceid(void){ return SQLITE_SOURCE_ID; }$/;"	f
sqlite3_sourceid	.\src\sqlite3ext.h	472;"	d
sqlite3_sql	.\src\sqlite3ext.h	456;"	d
sqlite3_sql	.\src\vdbeaux.c	/^const char *sqlite3_sql(sqlite3_stmt *pStmt){$/;"	f
sqlite3_stack_baseline	.\src\test1.c	/^static u8 *sqlite3_stack_baseline = 0;$/;"	v	file:
sqlite3_status	.\src\sqlite3ext.h	457;"	d
sqlite3_status	.\src\status.c	/^int sqlite3_status(int op, int *pCurrent, int *pHighwater, int resetFlag){$/;"	f
sqlite3_status64	.\src\status.c	/^int sqlite3_status64($/;"	f
sqlite3_step	.\src\sqlite3ext.h	395;"	d
sqlite3_step	.\src\vdbeapi.c	/^int sqlite3_step(sqlite3_stmt *pStmt){$/;"	f
sqlite3_stmt_busy	.\src\sqlite3ext.h	488;"	d
sqlite3_stmt_busy	.\src\vdbeapi.c	/^int sqlite3_stmt_busy(sqlite3_stmt *pStmt){$/;"	f
sqlite3_stmt_readonly	.\src\sqlite3ext.h	489;"	d
sqlite3_stmt_readonly	.\src\vdbeapi.c	/^int sqlite3_stmt_readonly(sqlite3_stmt *pStmt){$/;"	f
sqlite3_stmt_scanstatus	.\src\vdbeapi.c	/^int sqlite3_stmt_scanstatus($/;"	f
sqlite3_stmt_scanstatus_reset	.\src\vdbeapi.c	/^void sqlite3_stmt_scanstatus_reset(sqlite3_stmt *pStmt){$/;"	f
sqlite3_stmt_status	.\src\sqlite3ext.h	473;"	d
sqlite3_stmt_status	.\src\vdbeapi.c	/^int sqlite3_stmt_status(sqlite3_stmt *pStmt, int op, int resetFlag){$/;"	f
sqlite3_strglob	.\src\func.c	/^int sqlite3_strglob(const char *zGlobPattern, const char *zString){$/;"	f
sqlite3_strglob	.\src\sqlite3ext.h	508;"	d
sqlite3_stricmp	.\src\sqlite3ext.h	490;"	d
sqlite3_stricmp	.\src\util.c	/^int sqlite3_stricmp(const char *zLeft, const char *zRight){$/;"	f
sqlite3_stricmp	.\test\speedtest1.c	103;"	d	file:
sqlite3_strnicmp	.\src\sqlite3ext.h	474;"	d
sqlite3_strnicmp	.\src\util.c	/^int sqlite3_strnicmp(const char *zLeft, const char *zRight, int N){$/;"	f
sqlite3_sync_count	.\src\os_unix.c	/^int sqlite3_sync_count = 0;$/;"	v
sqlite3_sync_count	.\src\os_win.c	/^int sqlite3_sync_count = 0;$/;"	v
sqlite3_table_column_metadata	.\src\main.c	/^int sqlite3_table_column_metadata($/;"	f
sqlite3_table_column_metadata	.\src\sqlite3ext.h	396;"	d
sqlite3_temp_directory	.\src\main.c	/^char *sqlite3_temp_directory = 0;$/;"	v
sqlite3_test_control	.\src\main.c	/^int sqlite3_test_control(int op, ...){$/;"	f
sqlite3_test_control	.\src\sqlite3ext.h	450;"	d
sqlite3_thread_cleanup	.\src\main.c	/^void sqlite3_thread_cleanup(void){$/;"	f
sqlite3_thread_cleanup	.\src\sqlite3ext.h	397;"	d
sqlite3_threadsafe	.\src\main.c	/^int sqlite3_threadsafe(void){ return SQLITE_THREADSAFE; }$/;"	f
sqlite3_threadsafe	.\src\sqlite3ext.h	447;"	d
sqlite3_tokenizer	.\ext\fts1\fts1_tokenizer.h	/^struct sqlite3_tokenizer {$/;"	s
sqlite3_tokenizer	.\ext\fts1\fts1_tokenizer.h	/^typedef struct sqlite3_tokenizer sqlite3_tokenizer;$/;"	t	typeref:struct:sqlite3_tokenizer
sqlite3_tokenizer	.\ext\fts1\tokenizer.h	/^struct sqlite3_tokenizer {$/;"	s
sqlite3_tokenizer	.\ext\fts1\tokenizer.h	/^typedef struct sqlite3_tokenizer sqlite3_tokenizer;$/;"	t	typeref:struct:sqlite3_tokenizer
sqlite3_tokenizer	.\ext\fts2\fts2_tokenizer.h	/^struct sqlite3_tokenizer {$/;"	s
sqlite3_tokenizer	.\ext\fts2\fts2_tokenizer.h	/^typedef struct sqlite3_tokenizer sqlite3_tokenizer;$/;"	t	typeref:struct:sqlite3_tokenizer
sqlite3_tokenizer	.\ext\fts3\fts3_tokenizer.h	/^struct sqlite3_tokenizer {$/;"	s
sqlite3_tokenizer	.\ext\fts3\fts3_tokenizer.h	/^typedef struct sqlite3_tokenizer sqlite3_tokenizer;$/;"	t	typeref:struct:sqlite3_tokenizer
sqlite3_tokenizer_cursor	.\ext\fts1\fts1_tokenizer.h	/^struct sqlite3_tokenizer_cursor {$/;"	s
sqlite3_tokenizer_cursor	.\ext\fts1\fts1_tokenizer.h	/^typedef struct sqlite3_tokenizer_cursor sqlite3_tokenizer_cursor;$/;"	t	typeref:struct:sqlite3_tokenizer_cursor
sqlite3_tokenizer_cursor	.\ext\fts1\tokenizer.h	/^struct sqlite3_tokenizer_cursor {$/;"	s
sqlite3_tokenizer_cursor	.\ext\fts1\tokenizer.h	/^typedef struct sqlite3_tokenizer_cursor sqlite3_tokenizer_cursor;$/;"	t	typeref:struct:sqlite3_tokenizer_cursor
sqlite3_tokenizer_cursor	.\ext\fts2\fts2_tokenizer.h	/^struct sqlite3_tokenizer_cursor {$/;"	s
sqlite3_tokenizer_cursor	.\ext\fts2\fts2_tokenizer.h	/^typedef struct sqlite3_tokenizer_cursor sqlite3_tokenizer_cursor;$/;"	t	typeref:struct:sqlite3_tokenizer_cursor
sqlite3_tokenizer_cursor	.\ext\fts3\fts3_tokenizer.h	/^struct sqlite3_tokenizer_cursor {$/;"	s
sqlite3_tokenizer_cursor	.\ext\fts3\fts3_tokenizer.h	/^typedef struct sqlite3_tokenizer_cursor sqlite3_tokenizer_cursor;$/;"	t	typeref:struct:sqlite3_tokenizer_cursor
sqlite3_tokenizer_module	.\ext\fts1\fts1_tokenizer.h	/^struct sqlite3_tokenizer_module {$/;"	s
sqlite3_tokenizer_module	.\ext\fts1\fts1_tokenizer.h	/^typedef struct sqlite3_tokenizer_module sqlite3_tokenizer_module;$/;"	t	typeref:struct:sqlite3_tokenizer_module
sqlite3_tokenizer_module	.\ext\fts1\tokenizer.h	/^struct sqlite3_tokenizer_module {$/;"	s
sqlite3_tokenizer_module	.\ext\fts1\tokenizer.h	/^typedef struct sqlite3_tokenizer_module sqlite3_tokenizer_module;$/;"	t	typeref:struct:sqlite3_tokenizer_module
sqlite3_tokenizer_module	.\ext\fts2\fts2_tokenizer.h	/^struct sqlite3_tokenizer_module {$/;"	s
sqlite3_tokenizer_module	.\ext\fts2\fts2_tokenizer.h	/^typedef struct sqlite3_tokenizer_module sqlite3_tokenizer_module;$/;"	t	typeref:struct:sqlite3_tokenizer_module
sqlite3_tokenizer_module	.\ext\fts3\fts3_tokenizer.h	/^struct sqlite3_tokenizer_module {$/;"	s
sqlite3_tokenizer_module	.\ext\fts3\fts3_tokenizer.h	/^typedef struct sqlite3_tokenizer_module sqlite3_tokenizer_module;$/;"	t	typeref:struct:sqlite3_tokenizer_module
sqlite3_total_changes	.\src\main.c	/^int sqlite3_total_changes(sqlite3 *db){$/;"	f
sqlite3_total_changes	.\src\sqlite3ext.h	398;"	d
sqlite3_trace	.\src\loadext.c	96;"	d	file:
sqlite3_trace	.\src\main.c	/^void *sqlite3_trace(sqlite3 *db, void (*xTrace)(void*,const char*), void *pArg){$/;"	f
sqlite3_trace	.\src\sqlite3ext.h	399;"	d
sqlite3_transfer_bindings	.\src\sqlite3ext.h	401;"	d
sqlite3_transfer_bindings	.\src\vdbeapi.c	/^int sqlite3_transfer_bindings(sqlite3_stmt *pFromStmt, sqlite3_stmt *pToStmt){$/;"	f
sqlite3_unlock_notify	.\src\notify.c	/^int sqlite3_unlock_notify($/;"	f
sqlite3_unlock_notify	.\src\sqlite3ext.h	475;"	d
sqlite3_update_hook	.\src\main.c	/^void *sqlite3_update_hook($/;"	f
sqlite3_update_hook	.\src\sqlite3ext.h	403;"	d
sqlite3_uri_boolean	.\src\main.c	/^int sqlite3_uri_boolean(const char *zFilename, const char *zParam, int bDflt){$/;"	f
sqlite3_uri_boolean	.\src\sqlite3ext.h	491;"	d
sqlite3_uri_int64	.\src\main.c	/^sqlite3_int64 sqlite3_uri_int64($/;"	f
sqlite3_uri_int64	.\src\sqlite3ext.h	492;"	d
sqlite3_uri_parameter	.\src\main.c	/^const char *sqlite3_uri_parameter(const char *zFilename, const char *zParam){$/;"	f
sqlite3_uri_parameter	.\src\sqlite3ext.h	493;"	d
sqlite3_uri_vsnprintf	.\src\sqlite3ext.h	494;"	d
sqlite3_user_add	.\ext\userauth\userauth.c	/^int sqlite3_user_add($/;"	f
sqlite3_user_authenticate	.\ext\userauth\userauth.c	/^int sqlite3_user_authenticate($/;"	f
sqlite3_user_change	.\ext\userauth\userauth.c	/^int sqlite3_user_change($/;"	f
sqlite3_user_data	.\src\sqlite3ext.h	404;"	d
sqlite3_user_data	.\src\vdbeapi.c	/^void *sqlite3_user_data(sqlite3_context *p){$/;"	f
sqlite3_user_delete	.\ext\userauth\userauth.c	/^int sqlite3_user_delete($/;"	f
sqlite3_userauth	.\src\sqliteInt.h	/^struct sqlite3_userauth {$/;"	s
sqlite3_userauth	.\src\sqliteInt.h	/^typedef struct sqlite3_userauth sqlite3_userauth;$/;"	t	typeref:struct:sqlite3_userauth
sqlite3_value_blob	.\src\sqlite3ext.h	405;"	d
sqlite3_value_blob	.\src\vdbeapi.c	/^const void *sqlite3_value_blob(sqlite3_value *pVal){$/;"	f
sqlite3_value_bytes	.\src\sqlite3ext.h	406;"	d
sqlite3_value_bytes	.\src\vdbeapi.c	/^int sqlite3_value_bytes(sqlite3_value *pVal){$/;"	f
sqlite3_value_bytes16	.\src\sqlite3ext.h	407;"	d
sqlite3_value_bytes16	.\src\vdbeapi.c	/^int sqlite3_value_bytes16(sqlite3_value *pVal){$/;"	f
sqlite3_value_double	.\src\sqlite3ext.h	408;"	d
sqlite3_value_double	.\src\vdbeapi.c	/^double sqlite3_value_double(sqlite3_value *pVal){$/;"	f
sqlite3_value_dup	.\src\sqlite3ext.h	510;"	d
sqlite3_value_dup	.\src\vdbeapi.c	/^sqlite3_value *sqlite3_value_dup(const sqlite3_value *pOrig){$/;"	f
sqlite3_value_free	.\src\sqlite3ext.h	511;"	d
sqlite3_value_free	.\src\vdbeapi.c	/^void sqlite3_value_free(sqlite3_value *pOld){$/;"	f
sqlite3_value_int	.\src\sqlite3ext.h	409;"	d
sqlite3_value_int	.\src\vdbeapi.c	/^int sqlite3_value_int(sqlite3_value *pVal){$/;"	f
sqlite3_value_int64	.\src\sqlite3ext.h	410;"	d
sqlite3_value_int64	.\src\vdbeapi.c	/^sqlite_int64 sqlite3_value_int64(sqlite3_value *pVal){$/;"	f
sqlite3_value_numeric_type	.\src\sqlite3ext.h	411;"	d
sqlite3_value_numeric_type	.\src\vdbe.c	/^int sqlite3_value_numeric_type(sqlite3_value *pVal){$/;"	f
sqlite3_value_subtype	.\src\sqlite3ext.h	515;"	d
sqlite3_value_subtype	.\src\vdbeapi.c	/^unsigned int sqlite3_value_subtype(sqlite3_value *pVal){$/;"	f
sqlite3_value_text	.\src\sqlite3ext.h	412;"	d
sqlite3_value_text	.\src\vdbeapi.c	/^const unsigned char *sqlite3_value_text(sqlite3_value *pVal){$/;"	f
sqlite3_value_text16	.\src\loadext.c	60;"	d	file:
sqlite3_value_text16	.\src\sqlite3ext.h	413;"	d
sqlite3_value_text16	.\src\vdbeapi.c	/^const void *sqlite3_value_text16(sqlite3_value* pVal){$/;"	f
sqlite3_value_text16be	.\src\loadext.c	61;"	d	file:
sqlite3_value_text16be	.\src\sqlite3ext.h	414;"	d
sqlite3_value_text16be	.\src\vdbeapi.c	/^const void *sqlite3_value_text16be(sqlite3_value *pVal){$/;"	f
sqlite3_value_text16le	.\src\loadext.c	62;"	d	file:
sqlite3_value_text16le	.\src\sqlite3ext.h	415;"	d
sqlite3_value_text16le	.\src\vdbeapi.c	/^const void *sqlite3_value_text16le(sqlite3_value *pVal){$/;"	f
sqlite3_value_type	.\src\sqlite3ext.h	416;"	d
sqlite3_value_type	.\src\vdbeapi.c	/^int sqlite3_value_type(sqlite3_value* pVal){$/;"	f
sqlite3_version	.\src\main.c	/^const char sqlite3_version[] = SQLITE_VERSION;$/;"	v
sqlite3_vfs_find	.\src\os.c	/^sqlite3_vfs *sqlite3_vfs_find(const char *zVfs){$/;"	f
sqlite3_vfs_find	.\src\sqlite3ext.h	444;"	d
sqlite3_vfs_register	.\src\os.c	/^int sqlite3_vfs_register(sqlite3_vfs *pVfs, int makeDflt){$/;"	f
sqlite3_vfs_register	.\src\sqlite3ext.h	445;"	d
sqlite3_vfs_unregister	.\src\os.c	/^int sqlite3_vfs_unregister(sqlite3_vfs *pVfs){$/;"	f
sqlite3_vfs_unregister	.\src\sqlite3ext.h	446;"	d
sqlite3_vfslog_annotate	.\src\test_osinst.c	/^int sqlite3_vfslog_annotate(const char *zVfs, const char *zMsg){$/;"	f
sqlite3_vfslog_finalize	.\src\test_osinst.c	/^int sqlite3_vfslog_finalize(const char *zVfs){$/;"	f
sqlite3_vfslog_new	.\src\test_osinst.c	/^int sqlite3_vfslog_new($/;"	f
sqlite3_vfslog_register	.\src\test_osinst.c	/^int sqlite3_vfslog_register(sqlite3 *db){$/;"	f
sqlite3_vmprintf	.\src\printf.c	/^char *sqlite3_vmprintf(const char *zFormat, va_list ap){$/;"	f
sqlite3_vmprintf	.\src\sqlite3ext.h	417;"	d
sqlite3_vsnprintf	.\src\printf.c	/^char *sqlite3_vsnprintf(int n, char *zBuf, const char *zFormat, va_list ap){$/;"	f
sqlite3_vsnprintf	.\src\sqlite3ext.h	418;"	d
sqlite3_vtab_config	.\src\loadext.c	86;"	d	file:
sqlite3_vtab_config	.\src\sqlite3ext.h	480;"	d
sqlite3_vtab_config	.\src\vtab.c	/^int sqlite3_vtab_config(sqlite3 *db, int op, ...){$/;"	f
sqlite3_vtab_on_conflict	.\src\loadext.c	87;"	d	file:
sqlite3_vtab_on_conflict	.\src\sqlite3ext.h	481;"	d
sqlite3_vtab_on_conflict	.\src\vtab.c	/^int sqlite3_vtab_on_conflict(sqlite3 *db){$/;"	f
sqlite3_wal_autocheckpoint	.\src\main.c	/^int sqlite3_wal_autocheckpoint(sqlite3 *db, int nFrame){$/;"	f
sqlite3_wal_autocheckpoint	.\src\sqlite3ext.h	476;"	d
sqlite3_wal_checkpoint	.\src\main.c	/^int sqlite3_wal_checkpoint(sqlite3 *db, const char *zDb){$/;"	f
sqlite3_wal_checkpoint	.\src\sqlite3ext.h	477;"	d
sqlite3_wal_checkpoint_v2	.\src\main.c	/^int sqlite3_wal_checkpoint_v2($/;"	f
sqlite3_wal_checkpoint_v2	.\src\sqlite3ext.h	495;"	d
sqlite3_wal_hook	.\src\main.c	/^void *sqlite3_wal_hook($/;"	f
sqlite3_wal_hook	.\src\sqlite3ext.h	478;"	d
sqlite3_win32_compact_heap	.\src\os_win.c	/^int sqlite3_win32_compact_heap(LPUINT pnLargest){$/;"	f
sqlite3_win32_is_nt	.\src\os_win.c	/^int sqlite3_win32_is_nt(void){$/;"	f
sqlite3_win32_mbcs_to_utf8	.\src\os_win.c	/^char *sqlite3_win32_mbcs_to_utf8(const char *zFilename){$/;"	f
sqlite3_win32_reset_heap	.\src\os_win.c	/^int sqlite3_win32_reset_heap(){$/;"	f
sqlite3_win32_set_directory	.\src\os_win.c	/^int sqlite3_win32_set_directory(DWORD type, LPCWSTR zValue){$/;"	f
sqlite3_win32_sleep	.\src\os_win.c	/^void sqlite3_win32_sleep(DWORD milliseconds){$/;"	f
sqlite3_win32_utf8_to_mbcs	.\src\os_win.c	/^char *sqlite3_win32_utf8_to_mbcs(const char *zFilename){$/;"	f
sqlite3_win32_write_debug	.\src\os_win.c	/^void sqlite3_win32_write_debug(const char *zBuf, int nBuf){$/;"	f
sqlite3_wsd_find	.\src\test_wsd.c	/^void *sqlite3_wsd_find(void *K, int L){$/;"	f
sqlite3_wsd_init	.\src\test_wsd.c	/^int sqlite3_wsd_init(int N, int J){$/;"	f
sqlite3_xauth	.\src\sqliteInt.h	/^  typedef int (*sqlite3_xauth)(void*,int,const char*,const char*,const char*,$/;"	t
sqlite3_xferopt_count	.\src\insert.c	/^int sqlite3_xferopt_count;$/;"	v
sqlite3async_control	.\ext\async\sqlite3async.c	/^int sqlite3async_control(int op, ...){$/;"	f
sqlite3async_initialize	.\ext\async\sqlite3async.c	/^int sqlite3async_initialize(const char *zParent, int isDefault){$/;"	f
sqlite3async_run	.\ext\async\sqlite3async.c	/^void sqlite3async_run(void){$/;"	f
sqlite3async_shutdown	.\ext\async\sqlite3async.c	/^void sqlite3async_shutdown(void){$/;"	f
sqlite3async_trace	.\ext\async\sqlite3async.c	/^static int sqlite3async_trace = 0;$/;"	v	file:
sqlite3demo_superlock	.\src\test_superlock.c	/^int sqlite3demo_superlock($/;"	f
sqlite3demo_superunlock	.\src\test_superlock.c	/^void sqlite3demo_superunlock(void *pLock){$/;"	f
sqlite3one	.\src\sqliteInt.h	/^const int sqlite3one = 1;$/;"	v
sqlite3one	.\src\utf.c	/^const int sqlite3one = 1;$/;"	v
sqlite3rbu	.\ext\rbu\sqlite3rbu.c	/^struct sqlite3rbu {$/;"	s	file:
sqlite3rbu	.\ext\rbu\sqlite3rbu.h	/^typedef struct sqlite3rbu sqlite3rbu;$/;"	t	typeref:struct:sqlite3rbu
sqlite3rbu_close	.\ext\rbu\sqlite3rbu.c	/^int sqlite3rbu_close(sqlite3rbu *p, char **pzErrmsg){$/;"	f
sqlite3rbu_create_vfs	.\ext\rbu\sqlite3rbu.c	/^int sqlite3rbu_create_vfs(const char *zName, const char *zParent){$/;"	f
sqlite3rbu_db	.\ext\rbu\sqlite3rbu.c	/^sqlite3 *sqlite3rbu_db(sqlite3rbu *pRbu, int bRbu){$/;"	f
sqlite3rbu_destroy_vfs	.\ext\rbu\sqlite3rbu.c	/^void sqlite3rbu_destroy_vfs(const char *zName){$/;"	f
sqlite3rbu_open	.\ext\rbu\sqlite3rbu.c	/^sqlite3rbu *sqlite3rbu_open($/;"	f
sqlite3rbu_progress	.\ext\rbu\sqlite3rbu.c	/^sqlite3_int64 sqlite3rbu_progress(sqlite3rbu *pRbu){$/;"	f
sqlite3rbu_savestate	.\ext\rbu\sqlite3rbu.c	/^int sqlite3rbu_savestate(sqlite3rbu *p){$/;"	f
sqlite3rbu_step	.\ext\rbu\sqlite3rbu.c	/^int sqlite3rbu_step(sqlite3rbu *p){$/;"	f
sqliteAuthBadReturnCode	.\src\auth.c	/^static void sqliteAuthBadReturnCode(Parse *pParse){$/;"	f	file:
sqliteDefaultBusyCallback	.\src\main.c	/^static int sqliteDefaultBusyCallback($/;"	f	file:
sqliteErrorFromPosixError	.\src\os_unix.c	/^static int sqliteErrorFromPosixError(int posixError, int sqliteIOErr) {$/;"	f	file:
sqliteHashData	.\src\hash.h	87;"	d
sqliteHashFirst	.\src\hash.h	85;"	d
sqliteHashNext	.\src\hash.h	86;"	d
sqliteProcessJoin	.\src\select.c	/^static int sqliteProcessJoin(Parse *pParse, Select *p){$/;"	f	file:
sqliteViewResetAll	.\src\build.c	/^static void sqliteViewResetAll(sqlite3 *db, int idx){$/;"	f	file:
sqliteViewResetAll	.\src\build.c	2280;"	d	file:
sqlite_abort	.\src\test1.c	/^static int sqlite_abort($/;"	f	file:
sqlite_error	.\test\threadtest3.c	/^static void sqlite_error($/;"	f	file:
sqlite_error_out	.\tool\loadfts.c	/^static void sqlite_error_out(const char *zText, sqlite3 *db){$/;"	f	file:
sqlite_set_magic	.\src\test1.c	/^static int sqlite_set_magic($/;"	f	file:
sqlite_static_bind_nbyte	.\src\test1.c	/^static int sqlite_static_bind_nbyte = 0;$/;"	v	file:
sqlite_static_bind_value	.\src\test1.c	/^static char *sqlite_static_bind_value = 0;$/;"	v	file:
sqlite_test_close	.\src\test1.c	/^static int sqlite_test_close($/;"	f	file:
sqlite_test_close_v2	.\src\test1.c	/^static int sqlite_test_close_v2($/;"	f	file:
sqlitecon::B1Leave	.\contrib\sqlitecon.tcl	/^proc sqlitecon::B1Leave {w x y} {$/;"	p
sqlitecon::B1Motion	.\contrib\sqlitecon.tcl	/^proc sqlitecon::B1Motion {w x y} {$/;"	p
sqlitecon::Backspace	.\contrib\sqlitecon.tcl	/^proc sqlitecon::Backspace {w} {$/;"	p
sqlitecon::Button1	.\contrib\sqlitecon.tcl	/^proc sqlitecon::Button1 {w x y} {$/;"	p
sqlitecon::Clear	.\contrib\sqlitecon.tcl	/^proc sqlitecon::Clear w {$/;"	p
sqlitecon::Copy	.\contrib\sqlitecon.tcl	/^proc sqlitecon::Copy w {$/;"	p
sqlitecon::Cut	.\contrib\sqlitecon.tcl	/^proc sqlitecon::Cut w {$/;"	p
sqlitecon::Delete	.\contrib\sqlitecon.tcl	/^proc sqlitecon::Delete w {$/;"	p
sqlitecon::DoCommand	.\contrib\sqlitecon.tcl	/^proc sqlitecon::DoCommand {w cmd} {$/;"	p
sqlitecon::EnableEditMenu	.\contrib\sqlitecon.tcl	/^proc sqlitecon::EnableEditMenu w {$/;"	p
sqlitecon::End	.\contrib\sqlitecon.tcl	/^proc sqlitecon::End w {$/;"	p
sqlitecon::Enter	.\contrib\sqlitecon.tcl	/^proc sqlitecon::Enter w {$/;"	p
sqlitecon::EraseEOL	.\contrib\sqlitecon.tcl	/^proc sqlitecon::EraseEOL {w} {$/;"	p
sqlitecon::Home	.\contrib\sqlitecon.tcl	/^proc sqlitecon::Home w {$/;"	p
sqlitecon::Insert	.\contrib\sqlitecon.tcl	/^proc sqlitecon::Insert {w a} {$/;"	p
sqlitecon::Left	.\contrib\sqlitecon.tcl	/^proc sqlitecon::Left {w} {$/;"	p
sqlitecon::Next	.\contrib\sqlitecon.tcl	/^proc sqlitecon::Next w {$/;"	p
sqlitecon::Paste	.\contrib\sqlitecon.tcl	/^proc sqlitecon::Paste w {$/;"	p
sqlitecon::Prior	.\contrib\sqlitecon.tcl	/^proc sqlitecon::Prior w {$/;"	p
sqlitecon::Right	.\contrib\sqlitecon.tcl	/^proc sqlitecon::Right {w} {$/;"	p
sqlitecon::SaveFile	.\contrib\sqlitecon.tcl	/^proc sqlitecon::SaveFile w {$/;"	p
sqlitecon::SelectTo	.\contrib\sqlitecon.tcl	/^proc sqlitecon::SelectTo {w x y} {$/;"	p
sqlitecon::SetLine	.\contrib\sqlitecon.tcl	/^proc sqlitecon::SetLine {w line} {$/;"	p
sqlitecon::_edit	.\contrib\sqlitecon.tcl	/^proc sqlitecon::_edit {origtxt {title {}}} {$/;"	p
sqlitecon::addHistory	.\contrib\sqlitecon.tcl	/^proc sqlitecon::addHistory {w line} {$/;"	p
sqlitecon::canCut	.\contrib\sqlitecon.tcl	/^proc sqlitecon::canCut w {$/;"	p
sqlitecon::cancelMotor	.\contrib\sqlitecon.tcl	/^proc sqlitecon::cancelMotor w {$/;"	p
sqlitecon::create	.\contrib\sqlitecon.tcl	/^proc sqlitecon::create {w prompt title db} {$/;"	p
sqlitecon::create_child	.\contrib\sqlitecon.tcl	/^proc sqlitecon::create_child {w prompt editmenu} {$/;"	p
sqlitecon::motor	.\contrib\sqlitecon.tcl	/^proc sqlitecon::motor w {$/;"	p
sqlitecon::nearestBoundry	.\contrib\sqlitecon.tcl	/^proc sqlitecon::nearestBoundry {w x y} {$/;"	p
sqllogCopydb	.\src\test_sqllog.c	/^static void sqllogCopydb(struct SLConn *p, const char *zSearch, int bLog){$/;"	f	file:
sqllogFindAttached	.\src\test_sqllog.c	/^static int sqllogFindAttached($/;"	f	file:
sqllogFindFile	.\src\test_sqllog.c	/^static char *sqllogFindFile(const char *zFile){$/;"	f	file:
sqllogOpenlog	.\src\test_sqllog.c	/^static void sqllogOpenlog(struct SLConn *p){$/;"	f	file:
sqllogTokenize	.\src\test_sqllog.c	/^static void sqllogTokenize(const char *z, const char **pz, int *pn){$/;"	f	file:
sqllog_isspace	.\src\test_sqllog.c	/^static int sqllog_isspace(char c){$/;"	f	file:
sqllogglobal	.\src\test_sqllog.c	/^} sqllogglobal;$/;"	v	typeref:struct:SLGlobal	file:
sqlthread_id	.\src\test_thread.c	/^static int sqlthread_id($/;"	f	file:
sqlthread_open	.\src\test_thread.c	/^static int sqlthread_open($/;"	f	file:
sqlthread_parent	.\src\test_thread.c	/^static int sqlthread_parent($/;"	f	file:
sqlthread_proc	.\src\test_thread.c	/^static Tcl_ObjCmdProc sqlthread_proc;$/;"	v	file:
sqlthread_proc	.\src\test_thread.c	/^static int sqlthread_proc($/;"	f	file:
sqlthread_spawn	.\src\test_thread.c	/^static int sqlthread_spawn($/;"	f	file:
sqrFunc	.\src\test_autoext.c	/^static void sqrFunc($/;"	f	file:
sqr_init	.\src\test_autoext.c	/^static int sqr_init($/;"	f	file:
stacksize	.\tool\lemon.c	/^  char *stacksize;         \/* Size of the parser stack *\/$/;"	m	struct:lemon	file:
star_oh	.\ext\fts1\fts1_porter.c	/^static int star_oh(const char *z){$/;"	f	file:
star_oh	.\ext\fts2\fts2_porter.c	/^static int star_oh(const char *z){$/;"	f	file:
star_oh	.\ext\fts3\fts3_porter.c	/^static int star_oh(const char *z){$/;"	f	file:
start	.\tool\lemon.c	/^  char *start;             \/* Name of the start symbol for the grammar *\/$/;"	m	struct:lemon	file:
startClient	.\mptest\mptest.c	/^static void startClient(int iClient){$/;"	f	file:
startEndFlag	.\src\os_unix.c	/^  unsigned char startEndFlag;       \/* 1=rel to end of fork, 0=rel to start *\/$/;"	m	struct:ByteRangeLockPB2	file:
startScript	.\mptest\mptest.c	/^static int startScript($/;"	f	file:
startTime	.\src\vdbeInt.h	/^  i64 startTime;          \/* Time when query started - used for profiling *\/$/;"	m	struct:Vdbe
start_ioerr_simulation	.\src\test_journal.c	/^static void start_ioerr_simulation(int iSave, int iSave2){$/;"	f	file:
startsWith	.\ext\fts1\fts1.c	/^static int startsWith(const char *s, const char *t){$/;"	f	file:
startsWith	.\ext\fts2\fts2.c	/^static int startsWith(const char *s, const char *t){$/;"	f	file:
stat4Destructor	.\src\analyze.c	/^static void stat4Destructor(void *pOld){$/;"	f	file:
stat4ValueFromExpr	.\src\vdbemem.c	/^static int stat4ValueFromExpr($/;"	f	file:
statBestIndex	.\src\dbstat.c	/^static int statBestIndex(sqlite3_vtab *tab, sqlite3_index_info *pIdxInfo){$/;"	f	file:
statClearPage	.\src\dbstat.c	/^static void statClearPage(StatPage *p){$/;"	f	file:
statClose	.\src\dbstat.c	/^static int statClose(sqlite3_vtab_cursor *pCursor){$/;"	f	file:
statColumn	.\src\dbstat.c	/^static int statColumn($/;"	f	file:
statConnect	.\src\dbstat.c	/^static int statConnect($/;"	f	file:
statDecodePage	.\src\dbstat.c	/^static int statDecodePage(Btree *pBt, StatPage *p){$/;"	f	file:
statDisconnect	.\src\dbstat.c	/^static int statDisconnect(sqlite3_vtab *pVtab){$/;"	f	file:
statEof	.\src\dbstat.c	/^static int statEof(sqlite3_vtab_cursor *pCursor){$/;"	f	file:
statFilter	.\src\dbstat.c	/^static int statFilter($/;"	f	file:
statGet	.\src\analyze.c	/^static void statGet($/;"	f	file:
statGetFuncdef	.\src\analyze.c	/^static const FuncDef statGetFuncdef = {$/;"	v	file:
statInit	.\src\analyze.c	/^static void statInit($/;"	f	file:
statInitFuncdef	.\src\analyze.c	/^static const FuncDef statInitFuncdef = {$/;"	v	file:
statMutex	.\src\status.c	/^static const char statMutex[] = {$/;"	v	file:
statNext	.\src\dbstat.c	/^static int statNext(sqlite3_vtab_cursor *pCursor){$/;"	f	file:
statOpen	.\src\dbstat.c	/^static int statOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor){$/;"	f	file:
statPush	.\src\analyze.c	/^static void statPush($/;"	f	file:
statPushFuncdef	.\src\analyze.c	/^static const FuncDef statPushFuncdef = {$/;"	v	file:
statResetCsr	.\src\dbstat.c	/^static void statResetCsr(StatCursor *pCsr){$/;"	f	file:
statRowid	.\src\dbstat.c	/^static int statRowid(sqlite3_vtab_cursor *pCursor, sqlite_int64 *pRowid){$/;"	f	file:
statSizeAndOffset	.\src\dbstat.c	/^static void statSizeAndOffset(StatCursor *pCsr){$/;"	f	file:
state	.\tool\lemon.c	/^  enum e_state state;        \/* The state of the parser *\/$/;"	m	struct:pstate	typeref:enum:pstate::e_state	file:
state	.\tool\lemon.c	/^struct state {$/;"	s	file:
stateResortCompare	.\tool\lemon.c	/^static int stateResortCompare(const void *a, const void *b){$/;"	f	file:
statecmp	.\tool\lemon.c	/^PRIVATE int statecmp(struct config *a, struct config *b)$/;"	f
statehash	.\tool\lemon.c	/^PRIVATE unsigned statehash(struct config *a)$/;"	f
stateno	.\src\lempar.c	/^  YYACTIONTYPE stateno;  \/* The state-number, or reduce action in SHIFTREDUCE *\/$/;"	m	struct:yyStackEntry	file:
stateno	.\tool\lempar.c	/^  YYACTIONTYPE stateno;  \/* The state-number, or reduce action in SHIFTREDUCE *\/$/;"	m	struct:yyStackEntry	file:
statenum	.\tool\lemon.c	/^  int statenum;            \/* Sequential number for this state *\/$/;"	m	struct:state	file:
statline	.\tool\spaceanal.tcl	/^proc statline {title value {extra {}}} {$/;"	p
statsOn	.\src\shell.c	/^  int statsOn;           \/* True to display memory stats before each finalize *\/$/;"	m	struct:ShellState	file:
stats_line	.\tool\lemon.c	/^static void stats_line(const char *zLabel, int iValue){$/;"	f	file:
status	.\src\sqlite3ext.h	/^  int (*status)(int,int*,int*,int);$/;"	m	struct:sqlite3_api_routines
status	.\tool\lemon.c	/^  enum cfgstatus status;   \/* used during followset and shift computations *\/$/;"	m	struct:config	typeref:enum:config::cfgstatus	file:
statusFunc	.\src\test_loadext.c	/^static void statusFunc($/;"	f	file:
stdin_is_interactive	.\src\shell.c	/^static int stdin_is_interactive = 1;$/;"	v	file:
stem	.\ext\fts1\fts1_porter.c	/^static int stem($/;"	f	file:
stem	.\ext\fts2\fts2_porter.c	/^static int stem($/;"	f	file:
stem	.\ext\fts3\fts3_porter.c	/^static int stem($/;"	f	file:
step	.\src\sqlite3ext.h	/^  int  (*step)(sqlite3_stmt*);$/;"	m	struct:sqlite3_api_routines
step_list	.\src\sqliteInt.h	/^  TriggerStep *step_list; \/* Link list of trigger program steps             *\/$/;"	m	struct:Trigger
step_rbu	.\ext\rbu\rbu_common.tcl	/^proc step_rbu {target rbu} {$/;"	p
stepsql	.\test\tester.tcl	/^proc stepsql {dbptr sql} {$/;"	p
stmtLast	.\src\tclsqlite.c	/^  SqlPreparedStmt *stmtLast; \/* Last statement in the list *\/$/;"	m	struct:SqliteDb	file:
stmtList	.\src\tclsqlite.c	/^  SqlPreparedStmt *stmtList; \/* List of prepared statements*\/$/;"	m	struct:SqliteDb	file:
stmt_busy	.\src\sqlite3ext.h	/^  int (*stmt_busy)(sqlite3_stmt*);$/;"	m	struct:sqlite3_api_routines
stmt_readonly	.\src\sqlite3ext.h	/^  int (*stmt_readonly)(sqlite3_stmt*);$/;"	m	struct:sqlite3_api_routines
stmt_status	.\src\sqlite3ext.h	/^  int (*stmt_status)(sqlite3_stmt*,int,int);$/;"	m	struct:sqlite3_api_routines
stop_ioerr_simulation	.\src\test_journal.c	/^static void stop_ioerr_simulation(int *piSave, int *piSave2){$/;"	f	file:
stop_thread	.\src\test4.c	/^static void stop_thread(Thread *p){$/;"	f	file:
stop_thread	.\src\test7.c	/^static void stop_thread(Thread *p){$/;"	f	file:
storeLastErrno	.\src\os_unix.c	/^static void storeLastErrno(unixFile *pFile, int error){$/;"	f	file:
stp	.\tool\lemon.c	/^    struct state *stp;     \/* The new state, if a shift *\/$/;"	m	union:action::__anon34	typeref:struct:action::__anon34::state	file:
stp	.\tool\lemon.c	/^  struct state *stp;       \/* Pointer to state which contains this *\/$/;"	m	struct:config	typeref:struct:config::state	file:
stp	.\tool\lemon.c	/^  struct state *stp;   \/* A pointer to a state *\/$/;"	m	struct:axset	typeref:struct:axset::state	file:
str	.\src\vdbeInt.h	/^  StrAccum str;      \/* The string being accumulated *\/$/;"	m	struct:Explain
strCompare	.\ext\fts1\ft_hash.c	/^static int strCompare(const void *pKey1, int n1, const void *pKey2, int n2){$/;"	f	file:
strCompare	.\ext\fts1\fts1_hash.c	/^static int strCompare(const void *pKey1, int n1, const void *pKey2, int n2){$/;"	f	file:
strCompare	.\ext\fts2\fts2_hash.c	/^static int strCompare(const void *pKey1, int n1, const void *pKey2, int n2){$/;"	f	file:
strFree	.\tool\sqldiff.c	/^static void strFree(Str *p){$/;"	f	file:
strHash	.\ext\fts1\ft_hash.c	/^static int strHash(const void *pKey, int nKey){$/;"	f	file:
strHash	.\ext\fts1\fts1_hash.c	/^static int strHash(const void *pKey, int nKey){$/;"	f	file:
strHash	.\ext\fts2\fts2_hash.c	/^static int strHash(const void *pKey, int nKey){$/;"	f	file:
strHash	.\src\hash.c	/^static unsigned int strHash(const char *z){$/;"	f	file:
strInit	.\tool\sqldiff.c	/^static void strInit(Str *p){$/;"	f	file:
strPrintf	.\tool\sqldiff.c	/^static void strPrintf(Str *p, const char *zFormat, ...){$/;"	f	file:
strPrintfArray	.\tool\sqldiff.c	/^static void strPrintfArray($/;"	f	file:
str_in_array	.\src\shell.c	/^static int str_in_array(const char *zStr, const char **azArray){$/;"	f	file:
strappend	.\src\test_vfstrace.c	/^static void strappend(char *z, int *pI, const char *zAppend){$/;"	f	file:
stress1	.\test\tt3_stress.c	/^static void stress1(int nMs){$/;"	f	file:
stress2	.\test\tt3_stress.c	/^static void stress2(int nMs){$/;"	f	file:
stress2_launch_thread_loop	.\test\tt3_stress.c	/^static void stress2_launch_thread_loop($/;"	f	file:
stress2_thread_wrapper	.\test\tt3_stress.c	/^static char *stress2_thread_wrapper(int iTid, void *pArg){$/;"	f	file:
stress2_workload1	.\test\tt3_stress.c	/^static void stress2_workload1(Error *pErr, Sqlite *pDb, int i){$/;"	f	file:
stress2_workload10	.\test\tt3_stress.c	/^static void stress2_workload10(Error *pErr, Sqlite *pDb, int i){$/;"	f	file:
stress2_workload11	.\test\tt3_stress.c	/^static void stress2_workload11(Error *pErr, Sqlite *pDb, int i){$/;"	f	file:
stress2_workload14	.\test\tt3_stress.c	/^static void stress2_workload14(Error *pErr, Sqlite *pDb, int i){$/;"	f	file:
stress2_workload17	.\test\tt3_stress.c	/^static void stress2_workload17(Error *pErr, Sqlite *pDb, int i){$/;"	f	file:
stress2_workload19	.\test\tt3_stress.c	/^static char *stress2_workload19(int iTid, void *pArg){$/;"	f	file:
stress2_workload2	.\test\tt3_stress.c	/^static void stress2_workload2(Error *pErr, Sqlite *pDb, int i){$/;"	f	file:
stress2_workload3	.\test\tt3_stress.c	/^static void stress2_workload3(Error *pErr, Sqlite *pDb, int i){$/;"	f	file:
stress2_workload4	.\test\tt3_stress.c	/^static void stress2_workload4(Error *pErr, Sqlite *pDb, int i){$/;"	f	file:
stress2_workload5	.\test\tt3_stress.c	/^static void stress2_workload5(Error *pErr, Sqlite *pDb, int i){$/;"	f	file:
stress2_workload6	.\test\tt3_stress.c	/^static void stress2_workload6(Error *pErr, Sqlite *pDb, int i){$/;"	f	file:
stress2_workload7	.\test\tt3_stress.c	/^static void stress2_workload7(Error *pErr, Sqlite *pDb, int i){$/;"	f	file:
stress2_workload8	.\test\tt3_stress.c	/^static void stress2_workload8(Error *pErr, Sqlite *pDb, int i){$/;"	f	file:
stress2_workload9	.\test\tt3_stress.c	/^static void stress2_workload9(Error *pErr, Sqlite *pDb, int i){$/;"	f	file:
stress_thread_1	.\test\tt3_stress.c	/^static char *stress_thread_1(int iTid, void *pArg){$/;"	f	file:
stress_thread_2	.\test\tt3_stress.c	/^static char *stress_thread_2(int iTid, void *pArg){$/;"	f	file:
stress_thread_3	.\test\tt3_stress.c	/^static char *stress_thread_3(int iTid, void *pArg){$/;"	f	file:
stress_thread_4	.\test\tt3_stress.c	/^static char *stress_thread_4(int iTid, void *pArg){$/;"	f	file:
stress_thread_5	.\test\tt3_stress.c	/^static char *stress_thread_5(int iTid, void *pArg){$/;"	f	file:
strftimeFunc	.\src\date.c	/^static void strftimeFunc($/;"	f	file:
strglob	.\mptest\mptest.c	/^int strglob(const char *zGlob, const char *z){$/;"	f
strglob	.\src\sqlite3ext.h	/^  int (*strglob)(const char*,const char*);$/;"	m	struct:sqlite3_api_routines
strhash	.\tool\lemon.c	/^PRIVATE unsigned strhash(const char *x)$/;"	f
stricmp	.\src\sqlite3ext.h	/^  int (*stricmp)(const char*,const char*);$/;"	m	struct:sqlite3_api_routines
stringAppend	.\mptest\mptest.c	/^static void stringAppend(String *p, const char *z, int n){$/;"	f	file:
stringAppendTerm	.\mptest\mptest.c	/^static void stringAppendTerm(String *p, const char *z){$/;"	f	file:
stringBufferData	.\ext\fts2\fts2.c	/^static char *stringBufferData(StringBuffer *sb){$/;"	f	file:
stringBufferDestroy	.\ext\fts2\fts2.c	/^static void stringBufferDestroy(StringBuffer *sb){$/;"	f	file:
stringBufferLength	.\ext\fts2\fts2.c	/^static int stringBufferLength(StringBuffer *sb){$/;"	f	file:
stringFree	.\mptest\mptest.c	/^static void stringFree(String *p){$/;"	f	file:
stringReset	.\mptest\mptest.c	/^static void stringReset(String *p){$/;"	f	file:
string_concat	.\src\test8.c	/^static void string_concat(char **pzStr, char *zAppend, int doFree, int *pRc){$/;"	f	file:
string_dup	.\ext\fts1\fts1.c	/^static char *string_dup(const char *s){$/;"	f	file:
string_dup	.\ext\fts1\fulltext.c	/^static char *string_dup(const char *s){$/;"	f	file:
string_dup	.\ext\fts1\simple_tokenizer.c	/^static char *string_dup(const char *s){$/;"	f	file:
string_dup	.\ext\fts2\fts2.c	/^static char *string_dup(const char *s){$/;"	f	file:
string_dup_n	.\ext\fts1\fts1.c	/^static char *string_dup_n(const char *s, int n){$/;"	f	file:
string_dup_n	.\ext\fts1\fulltext.c	/^static char *string_dup_n(const char *s, int n){$/;"	f	file:
string_dup_n	.\ext\fts2\fts2.c	/^static char *string_dup_n(const char *s, int n){$/;"	f	file:
string_format	.\ext\fts1\fts1.c	/^static char *string_format(const char *zFormat,$/;"	f	file:
string_format	.\ext\fts1\fulltext.c	/^static char *string_format(const char *zFormat, const char *zName){$/;"	f	file:
string_format	.\ext\fts2\fts2.c	/^static char *string_format(const char *zFormat,$/;"	f	file:
stringcompare	.\tool\speedtest8inst1.c	/^static int stringcompare(const char *zLeft, const char *zRight){$/;"	f	file:
strip_comments	.\test\releasetest.tcl	/^proc strip_comments {in} {$/;"	p
strlen30	.\src\shell.c	/^static int strlen30(const char *z){$/;"	f	file:
strlen30	.\src\tclsqlite.c	/^static int strlen30(const char *z){$/;"	f	file:
strnicmp	.\src\sqlite3ext.h	/^  int (*strnicmp)(const char*,const char*,int);$/;"	m	struct:sqlite3_api_routines
subjInMemory	.\src\pager.c	/^  u8 subjInMemory;            \/* True to use in-memory sub-journals *\/$/;"	m	struct:Pager	file:
subjRequiresPage	.\src\pager.c	/^static int subjRequiresPage(PgHdr *pPg){$/;"	f	file:
subjournalPage	.\src\pager.c	/^static int subjournalPage(PgHdr *pPg){$/;"	f	file:
subjournalPageIfRequired	.\src\pager.c	/^static int subjournalPageIfRequired(PgHdr *pPg){$/;"	f	file:
subreport	.\tool\spaceanal.tcl	/^proc subreport {title where showFrag} {$/;"	p
substExpr	.\src\select.c	/^static Expr *substExpr($/;"	f	file:
substExprList	.\src\select.c	/^static void substExprList($/;"	f	file:
substFile	.\tool\mkvsix.tcl	/^proc substFile { fileName } {$/;"	p
substSelect	.\src\select.c	/^static void substSelect($/;"	f	file:
substituteCost	.\ext\misc\spellfix.c	/^static int substituteCost(char cPrev, char cFrom, char cTo){$/;"	f	file:
substrFunc	.\src\func.c	/^static void substrFunc($/;"	f	file:
substrId	.\tool\mkkeywordhash.c	/^  int substrId;        \/* Id to another keyword this keyword is embedded in *\/$/;"	m	struct:Keyword	file:
substrOffset	.\tool\mkkeywordhash.c	/^  int substrOffset;    \/* Offset into substrId for start of this keyword *\/$/;"	m	struct:Keyword	file:
subsym	.\tool\lemon.c	/^  struct symbol **subsym;  \/* Array of constituent symbols *\/$/;"	m	struct:symbol	typeref:struct:symbol::symbol	file:
sumFinalize	.\src\func.c	/^static void sumFinalize(sqlite3_context *context){$/;"	f	file:
sumStep	.\src\func.c	/^static void sumStep(sqlite3_context *context, int argc, sqlite3_value **argv){$/;"	f	file:
summarize_one_table	.\tool\sqldiff.c	/^static void summarize_one_table(const char *zTab, FILE *out){$/;"	f	file:
superlockBusyHandler	.\src\test_superlock.c	/^static int superlockBusyHandler(void *pCtx, int UNUSED){$/;"	f	file:
superlockIsWal	.\src\test_superlock.c	/^static int superlockIsWal(Superlock *pLock){$/;"	f	file:
superlockShmLock	.\src\test_superlock.c	/^static int superlockShmLock($/;"	f	file:
superlockWalLock	.\src\test_superlock.c	/^static int superlockWalLock($/;"	f	file:
superlock_busy	.\src\test_superlock.c	/^static int superlock_busy(void *pCtx, int nBusy){$/;"	f	file:
superlock_cmd	.\src\test_superlock.c	/^static int superlock_cmd($/;"	f	file:
superunlock_cmd	.\src\test_superlock.c	/^static int superunlock_cmd($/;"	f	file:
superunlock_del	.\src\test_superlock.c	/^static void superunlock_del(ClientData cd){$/;"	f	file:
suppressErr	.\src\sqliteInt.h	/^  u8 suppressErr;               \/* Do not issue error messages if true *\/$/;"	m	struct:sqlite3
swab32	.\tool\showwal.c	/^static unsigned int swab32(unsigned int x){$/;"	f	file:
swapMixedEndianFloat	.\src\vdbeaux.c	3047;"	d	file:
swapMixedEndianFloat	.\src\vdbeaux.c	3049;"	d	file:
switchLockProxyPath	.\src\os_unix.c	/^static int switchLockProxyPath(unixFile *pFile, const char *path) {$/;"	f	file:
swizzle	.\test\speedtest1.c	/^unsigned swizzle(unsigned in, unsigned limit){$/;"	f
symbol	.\tool\lemon.c	/^struct symbol {$/;"	s	file:
symbol_type	.\tool\lemon.c	/^enum symbol_type {$/;"	g	file:
symbols	.\tool\lemon.c	/^  struct symbol **symbols; \/* Sorted array of pointers to symbols *\/$/;"	m	struct:lemon	typeref:struct:lemon::symbol	file:
syncFlags	.\src\pager.c	/^  u8 syncFlags;               \/* SYNC_NORMAL or SYNC_FULL otherwise *\/$/;"	m	struct:Pager	file:
syncFlags	.\src\wal.c	/^  int syncFlags;               \/* Flags for the fsync *\/$/;"	m	struct:WalWriter	file:
syncFlags	.\src\wal.c	/^  u8 syncFlags;              \/* Flags to use to sync header writes *\/$/;"	m	struct:Wal	file:
syncHeader	.\src\wal.c	/^  u8 syncHeader;             \/* Fsync the WAL header if true *\/$/;"	m	struct:Wal	file:
syncJournal	.\src\pager.c	/^static int syncJournal(Pager *pPager, int newHdr){$/;"	f	file:
synthCollSeq	.\src\callback.c	/^static int synthCollSeq(sqlite3 *db, CollSeq *pColl){$/;"	f	file:
system_error	.\test\threadtest3.c	/^static void system_error(Error *pErr, int iSys){$/;"	f	file:
sz	.\src\sqliteInt.h	/^  u16 sz;                 \/* Size of each buffer in bytes *\/$/;"	m	struct:Lookaside
sz	.\test\fuzzcheck.c	/^  int sz;                 \/* Size of the file in bytes *\/$/;"	m	struct:VFile	file:
sz	.\test\fuzzcheck.c	/^  int sz;                 \/* Size of this Blob in bytes *\/$/;"	m	struct:Blob	file:
szAlloc	.\src\pcache1.c	/^  int szAlloc;                        \/* Total size of one pcache line *\/$/;"	m	struct:PCache1	file:
szAtom	.\src\mem5.c	/^  int szAtom;      \/* Smallest possible allocation in bytes *\/$/;"	m	struct:Mem5Global	file:
szCache	.\src\pcache.c	/^  int szCache;                        \/* Configured cache size *\/$/;"	m	struct:PCache	file:
szCell	.\src\btree.c	/^  u16 *szCell;            \/* Local size of all cells in apCell[] *\/$/;"	m	struct:CellArray	file:
szChunk	.\src\os_unix.c	/^  int szChunk;                        \/* Configured by FCNTL_CHUNK_SIZE *\/$/;"	m	struct:unixFile	file:
szChunk	.\src\os_win.c	/^  int szChunk;            \/* Chunk size configured by FCNTL_CHUNK_SIZE *\/$/;"	m	struct:winFile	file:
szChunk	.\src\test_multiplex.c	/^  unsigned int szChunk;            \/* Chunk size used for this group *\/$/;"	m	struct:multiplexGroup	file:
szCol	.\ext\fts5\fts5_storage.c	/^  int szCol;                      \/* Size of column value in tokens *\/$/;"	m	struct:Fts5InsertCtx	file:
szCol	.\ext\fts5\fts5_storage.c	/^  int szCol;$/;"	m	struct:Fts5IntegrityCtx	file:
szEst	.\src\sqliteInt.h	/^  u8 szEst;        \/* Estimated size of this column.  INT==1 *\/$/;"	m	struct:Column
szExtra	.\src\pcache.c	/^  int szExtra;                        \/* Size of extra space for each page *\/$/;"	m	struct:PCache	file:
szExtra	.\src\pcache1.c	/^  int szExtra;                        \/* sizeof(MemPage)+sizeof(PgHdr) *\/$/;"	m	struct:PCache1	file:
szExtra	.\src\test_pcache.c	/^  int szExtra;              \/* Size of extra data that accompanies each page *\/$/;"	m	struct:testpcache	file:
szFirstBlock	.\src\wal.c	/^  int szFirstBlock;          \/* Size of first block written to WAL file *\/$/;"	m	struct:Wal	file:
szIdxRow	.\src\sqliteInt.h	/^  LogEst szIdxRow;         \/* Estimated average row size in bytes *\/$/;"	m	struct:Index
szLeaf	.\ext\fts5\fts5_index.c	/^  int szLeaf;                     \/* Size of leaf without page-index *\/$/;"	m	struct:Fts5Data	file:
szLookaside	.\src\sqliteInt.h	/^  int szLookaside;                  \/* Default lookaside buffer size *\/$/;"	m	struct:Sqlite3Config
szMalloc	.\src\vdbeInt.h	/^  int szMalloc;       \/* Size of the zMalloc allocation *\/$/;"	m	struct:Mem
szMaster	.\src\mem3.c	/^  u32 szMaster;$/;"	m	struct:Mem3Global	file:
szMmap	.\src\pager.c	/^  sqlite3_int64 szMmap;       \/* Desired maximum mmap size *\/$/;"	m	struct:Pager	file:
szMmap	.\src\sqliteInt.h	/^  i64 szMmap;                   \/* Default mmap_size setting *\/$/;"	m	struct:sqlite3
szMmap	.\src\sqliteInt.h	/^  sqlite3_int64 szMmap;             \/* mmap() space per open file *\/$/;"	m	struct:Sqlite3Config
szPMA	.\src\vdbesort.c	/^  int szPMA;                      \/* Size of pList as PMA in bytes *\/$/;"	m	struct:SorterList	file:
szPage	.\src\dbstat.c	/^  int szPage;                     \/* Value of 'pgSize' column *\/$/;"	m	struct:StatCursor	file:
szPage	.\src\pcache.c	/^  int szPage;                         \/* Size of every page in this cache *\/$/;"	m	struct:PCache	file:
szPage	.\src\pcache1.c	/^  int szPage;                         \/* Size of database content section *\/$/;"	m	struct:PCache1	file:
szPage	.\src\sqliteInt.h	/^  int szPage;                       \/* Size of each page in pPage[] *\/$/;"	m	struct:Sqlite3Config
szPage	.\src\test_pcache.c	/^  int szPage;               \/* Size of each page.  Multiple of 8. *\/$/;"	m	struct:testpcache	file:
szPage	.\src\wal.c	/^  int szPage;                  \/* Size of one page *\/$/;"	m	struct:WalWriter	file:
szPage	.\src\wal.c	/^  u16 szPage;                     \/* Database page size in bytes. 1==64K *\/$/;"	m	struct:WalIndexHdr	file:
szPage	.\src\wal.c	/^  u32 szPage;                \/* Database page size *\/$/;"	m	struct:Wal	file:
szPg	.\tool\offsets.c	/^  int szPg;             \/* Page size for the database file *\/$/;"	m	struct:GState	file:
szPma	.\src\sqliteInt.h	/^  u32 szPma;                        \/* Maximum Sorter PMA size *\/$/;"	m	struct:Sqlite3Config
szRegion	.\src\os_unix.c	/^  int szRegion;              \/* Size of shared-memory regions *\/$/;"	m	struct:unixShmNode	file:
szRegion	.\src\os_win.c	/^  int szRegion;              \/* Size of shared-memory regions *\/$/;"	m	struct:winShmNode	file:
szRow	.\src\vdbeInt.h	/^  u32 szRow;            \/* Byte available in aRow *\/$/;"	m	struct:VdbeCursor
szScratch	.\src\sqliteInt.h	/^  int szScratch;                    \/* Size of each scratch buffer *\/$/;"	m	struct:Sqlite3Config
szSep	.\ext\misc\eval.c	/^  int szSep;             \/* Size of the separator string *\/$/;"	m	struct:EvalResult	file:
szSep	.\tool\fuzzershell.c	/^  int szSep;             \/* Size of the separator string *\/$/;"	m	struct:EvalResult	file:
szSlot	.\src\pcache1.c	/^  int szSlot;                    \/* Size of each free slot *\/$/;"	m	struct:PCacheGlobal	file:
szTabRow	.\src\sqliteInt.h	/^  LogEst szTabRow;     \/* Estimated size of each table row in bytes *\/$/;"	m	struct:Table
szTest	.\test\speedtest1.c	/^  int szTest;                \/* Scale factor for test iterations *\/$/;"	m	struct:Global	file:
t1CountCtx	.\src\test1.c	/^struct t1CountCtx {$/;"	s	file:
t1CountCtx	.\src\test1.c	/^typedef struct t1CountCtx t1CountCtx;$/;"	t	typeref:struct:t1CountCtx	file:
t1CountFinalize	.\src\test1.c	/^static void t1CountFinalize(sqlite3_context *context){$/;"	f	file:
t1CountStep	.\src\test1.c	/^static void t1CountStep($/;"	f	file:
t1ErrorName	.\src\test1.c	128;"	d	file:
t1_ifnullFunc	.\src\test1.c	/^static void t1_ifnullFunc($/;"	f	file:
tFinal	.\src\test_func.c	/^static void tFinal(sqlite3_context *a){}$/;"	f	file:
tRowcnt	.\src\sqliteInt.h	/^ typedef u32 tRowcnt;    \/* 32-bit is the default *\/$/;"	t
tRowcnt	.\src\sqliteInt.h	/^ typedef u64 tRowcnt;    \/* 64-bit only if requested at compile-time *\/$/;"	t
tStep	.\src\test_func.c	/^static void tStep(sqlite3_context *a, int b, sqlite3_value **c){}$/;"	f	file:
tabFlags	.\src\sqliteInt.h	/^  u8 tabFlags;         \/* Mask of TF_* values *\/$/;"	m	struct:Table
tabTnct	.\src\select.c	/^  int tabTnct;    \/* Ephemeral table used for DISTINCT processing *\/$/;"	m	struct:DistinctCtx	file:
table	.\src\sqliteInt.h	/^  char *table;            \/* The table or view to which the trigger applies *\/$/;"	m	struct:Trigger
tableAndColumnIndex	.\src\select.c	/^static int tableAndColumnIndex($/;"	f	file:
tableOfTrigger	.\src\trigger.c	/^static Table *tableOfTrigger(Trigger *pTrigger){$/;"	f	file:
table_column_metadata	.\src\sqlite3ext.h	/^  int  (*table_column_metadata)(sqlite3*,const char*,const char*,const char*,$/;"	m	struct:sqlite3_api_routines
tablesize	.\tool\lemon.c	/^  int tablesize;           \/* Total table size of all tables in bytes *\/$/;"	m	struct:lemon	file:
targetSrcList	.\src\trigger.c	/^static SrcList *targetSrcList($/;"	f	file:
taskId	.\mptest\mptest.c	/^  int taskId;            \/* Task ID.  0 means supervisor. *\/$/;"	m	struct:Global	file:
tbl	.\tool\lemon.c	/^  struct s_x1node *tbl;  \/* The data stored here *\/$/;"	m	struct:s_x1	typeref:struct:s_x1::s_x1node	file:
tbl	.\tool\lemon.c	/^  struct s_x2node *tbl;  \/* The data stored here *\/$/;"	m	struct:s_x2	typeref:struct:s_x2::s_x2node	file:
tbl	.\tool\lemon.c	/^  struct s_x3node *tbl;  \/* The data stored here *\/$/;"	m	struct:s_x3	typeref:struct:s_x3::s_x3node	file:
tbl	.\tool\lemon.c	/^  struct s_x4node *tbl;  \/* The data stored here *\/$/;"	m	struct:s_x4	typeref:struct:s_x4::s_x4node	file:
tblHash	.\src\sqliteInt.h	/^  Hash tblHash;        \/* All tables indexed by name *\/$/;"	m	struct:Schema
tclCallbackDestructor	.\src\test_quota.c	/^static void tclCallbackDestructor(void *pObj){$/;"	f	file:
tclCollateNeeded	.\src\tclsqlite.c	/^static void tclCollateNeeded($/;"	f	file:
tclLoadStaticExtensionCmd	.\src\test1.c	/^static int tclLoadStaticExtensionCmd($/;"	f	file:
tclQuotaCallback	.\src\test_quota.c	/^static void tclQuotaCallback($/;"	f	file:
tclScriptEvent	.\src\test_thread.c	/^static int tclScriptEvent(Tcl_Event *evPtr, int flags){$/;"	f	file:
tclScriptThread	.\src\test_thread.c	/^static Tcl_ThreadCreateType tclScriptThread(ClientData pSqlThread){$/;"	f	file:
tclSqlCollate	.\src\tclsqlite.c	/^static int tclSqlCollate($/;"	f	file:
tclSqlFunc	.\src\tclsqlite.c	/^static void tclSqlFunc(sqlite3_context *context, int argc, sqlite3_value**argv){$/;"	f	file:
tclWriterThread	.\src\test_async.c	/^static Tcl_ThreadCreateType tclWriterThread(ClientData pIsStarted){$/;"	f	file:
tcl_client_argc	.\src\test7.c	/^static int tcl_client_argc($/;"	f	file:
tcl_client_argv	.\src\test7.c	/^static int tcl_client_argv($/;"	f	file:
tcl_client_colname	.\src\test7.c	/^static int tcl_client_colname($/;"	f	file:
tcl_client_compile	.\src\test7.c	/^static int tcl_client_compile($/;"	f	file:
tcl_client_create	.\src\test7.c	/^static int tcl_client_create($/;"	f	file:
tcl_client_error	.\src\test7.c	/^static int tcl_client_error($/;"	f	file:
tcl_client_finalize	.\src\test7.c	/^static int tcl_client_finalize($/;"	f	file:
tcl_client_halt	.\src\test7.c	/^static int tcl_client_halt($/;"	f	file:
tcl_client_reset	.\src\test7.c	/^static int tcl_client_reset($/;"	f	file:
tcl_client_result	.\src\test7.c	/^static int tcl_client_result($/;"	f	file:
tcl_client_step	.\src\test7.c	/^static int tcl_client_step($/;"	f	file:
tcl_client_swap	.\src\test7.c	/^static int tcl_client_swap($/;"	f	file:
tcl_client_wait	.\src\test7.c	/^static int tcl_client_wait($/;"	f	file:
tcl_thread_argc	.\src\test4.c	/^static int tcl_thread_argc($/;"	f	file:
tcl_thread_argv	.\src\test4.c	/^static int tcl_thread_argv($/;"	f	file:
tcl_thread_colname	.\src\test4.c	/^static int tcl_thread_colname($/;"	f	file:
tcl_thread_compile	.\src\test4.c	/^static int tcl_thread_compile($/;"	f	file:
tcl_thread_create	.\src\test4.c	/^static int tcl_thread_create($/;"	f	file:
tcl_thread_db_get	.\src\test4.c	/^static int tcl_thread_db_get($/;"	f	file:
tcl_thread_db_put	.\src\test4.c	/^static int tcl_thread_db_put($/;"	f	file:
tcl_thread_error	.\src\test4.c	/^static int tcl_thread_error($/;"	f	file:
tcl_thread_finalize	.\src\test4.c	/^static int tcl_thread_finalize($/;"	f	file:
tcl_thread_halt	.\src\test4.c	/^static int tcl_thread_halt($/;"	f	file:
tcl_thread_result	.\src\test4.c	/^static int tcl_thread_result($/;"	f	file:
tcl_thread_step	.\src\test4.c	/^static int tcl_thread_step($/;"	f	file:
tcl_thread_stmt_get	.\src\test4.c	/^static int tcl_thread_stmt_get($/;"	f	file:
tcl_thread_swap	.\src\test4.c	/^static int tcl_thread_swap($/;"	f	file:
tcl_thread_wait	.\src\test4.c	/^static int tcl_thread_wait($/;"	f	file:
tcl_variable_type	.\src\test1.c	/^static int tcl_variable_type($/;"	f	file:
tclsh_main_loop	.\src\tclsqlite.c	/^static const char *tclsh_main_loop(void){$/;"	f	file:
tclvarBestIndex	.\src\test_tclvar.c	/^static int tclvarBestIndex(sqlite3_vtab *tab, sqlite3_index_info *pIdxInfo){$/;"	f	file:
tclvarClose	.\src\test_tclvar.c	/^static int tclvarClose(sqlite3_vtab_cursor *cur){$/;"	f	file:
tclvarColumn	.\src\test_tclvar.c	/^static int tclvarColumn(sqlite3_vtab_cursor *cur, sqlite3_context *ctx, int i){$/;"	f	file:
tclvarConnect	.\src\test_tclvar.c	/^static int tclvarConnect($/;"	f	file:
tclvarDisconnect	.\src\test_tclvar.c	/^static int tclvarDisconnect(sqlite3_vtab *pVtab){$/;"	f	file:
tclvarEof	.\src\test_tclvar.c	/^static int tclvarEof(sqlite3_vtab_cursor *cur){$/;"	f	file:
tclvarFilter	.\src\test_tclvar.c	/^static int tclvarFilter($/;"	f	file:
tclvarModule	.\src\test_tclvar.c	/^static sqlite3_module tclvarModule = {$/;"	v	file:
tclvarNext	.\src\test_tclvar.c	/^static int tclvarNext(sqlite3_vtab_cursor *cur){$/;"	f	file:
tclvarOpen	.\src\test_tclvar.c	/^static int tclvarOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor){$/;"	f	file:
tclvarRowid	.\src\test_tclvar.c	/^static int tclvarRowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid){$/;"	f	file:
tclvar_cursor	.\src\test_tclvar.c	/^struct tclvar_cursor {$/;"	s	file:
tclvar_cursor	.\src\test_tclvar.c	/^typedef struct tclvar_cursor tclvar_cursor;$/;"	t	typeref:struct:tclvar_cursor	file:
tclvar_vtab	.\src\test_tclvar.c	/^struct tclvar_vtab {$/;"	s	file:
tclvar_vtab	.\src\test_tclvar.c	/^typedef struct tclvar_vtab tclvar_vtab;$/;"	t	typeref:struct:tclvar_vtab	file:
tcons	.\src\parse.y	/^tcons ::= CHECK LP expr(E) RP onconf.$/;"	l
tcons	.\src\parse.y	/^tcons ::= CONSTRAINT nm(X).      {pParse->constraintName = X;}$/;"	l
tcons	.\src\parse.y	/^tcons ::= FOREIGN KEY LP eidlist(FA) RP$/;"	l
tcons	.\src\parse.y	/^tcons ::= PRIMARY KEY LP sortlist(X) autoinc(I) RP onconf(R).$/;"	l
tcons	.\src\parse.y	/^tcons ::= UNIQUE LP sortlist(X) RP onconf(R).$/;"	l
tconscomma	.\src\parse.y	/^tconscomma ::= .$/;"	l
tconscomma	.\src\parse.y	/^tconscomma ::= COMMA.            {pParse->constraintName.n = 0;}$/;"	l
tempFile	.\src\pager.c	/^  u8 tempFile;                \/* zFilename is a temporary or immutable file *\/$/;"	m	struct:Pager	file:
tempReg	.\src\sqliteInt.h	/^    u8 tempReg;           \/* iReg is a temp register that needs to be freed *\/$/;"	m	struct:Parse::yColCache
temp_store	.\src\sqliteInt.h	/^  u8 temp_store;                \/* 1: file 2: memory 0: default *\/$/;"	m	struct:sqlite3
term	.\ext\fts2\fts2.c	/^  DataBuffer term;                \/* previous encoded term *\/$/;"	m	struct:LeafWriter	file:
term	.\ext\fts2\fts2.c	/^  DataBuffer term;               \/* Last term written to block "last". *\/$/;"	m	struct:InteriorWriter	file:
term	.\ext\fts2\fts2.c	/^  DataBuffer term;           \/* Leftmost term in block's subtree. *\/$/;"	m	struct:InteriorBlock	file:
term	.\ext\fts2\fts2.c	/^  DataBuffer term;          \/* copy of current term. *\/$/;"	m	struct:LeafReader	file:
term	.\ext\fts2\fts2.c	/^  DataBuffer term;          \/* previous term, for decoding term delta. *\/$/;"	m	struct:InteriorReader	file:
term	.\ext\fts3\fts3_write.c	/^  Blob term;                      \/* Current term *\/$/;"	m	struct:NodeReader	file:
term	.\ext\fts5\fts5_index.c	/^  Fts5Buffer term;                \/* Buffer containing previous term on page *\/$/;"	m	struct:Fts5PageWriter	file:
term	.\ext\fts5\fts5_index.c	/^  Fts5Buffer term;                \/* Current term *\/$/;"	m	struct:Fts5SegIter	file:
term	.\ext\fts5\fts5_vocab.c	/^  Fts5Buffer term;                \/* Current value of 'term' column *\/$/;"	m	struct:Fts5VocabCursor	file:
termCanDriveIndex	.\src\where.c	/^static int termCanDriveIndex($/;"	f	file:
termDataCmp	.\ext\fts2\fts2.c	/^static int termDataCmp(const void *av, const void *bv){$/;"	f	file:
termIsEquivalence	.\src\whereexpr.c	/^static int termIsEquivalence(Parse *pParse, Expr *pExpr){$/;"	f	file:
termSelect	.\ext\fts2\fts2.c	/^static int termSelect(fulltext_vtab *v, int iColumn,$/;"	f	file:
term_chunk_select	.\ext\fts1\fulltext.c	/^static int term_chunk_select(fulltext_vtab *v, const char *zTerm, int nTerm,$/;"	f	file:
term_delete	.\ext\fts1\fts1.c	/^static int term_delete(fulltext_vtab *v, sqlite_int64 rowid){$/;"	f	file:
term_delete	.\ext\fts1\fulltext.c	/^static int term_delete(fulltext_vtab *v, sqlite_int64 rowid){$/;"	f	file:
term_insert	.\ext\fts1\fts1.c	/^static int term_insert(fulltext_vtab *v, sqlite_int64 *piRowid,$/;"	f	file:
term_insert	.\ext\fts1\fulltext.c	/^static int term_insert(fulltext_vtab *v, const char *zTerm, int nTerm,$/;"	f	file:
term_select	.\ext\fts1\fts1.c	/^static int term_select(fulltext_vtab *v, const char *pTerm, int nTerm,$/;"	f	file:
term_select	.\ext\fts1\fulltext.c	/^static int term_select(fulltext_vtab *v, const char *zTerm, int nTerm,$/;"	f	file:
term_select_all	.\ext\fts1\fts1.c	/^static int term_select_all($/;"	f	file:
term_select_doclist	.\ext\fts1\fulltext.c	/^static int term_select_doclist(fulltext_vtab *v, const char *pTerm, int nTerm,$/;"	f	file:
term_update	.\ext\fts1\fts1.c	/^static int term_update(fulltext_vtab *v, sqlite_int64 rowid,$/;"	f	file:
term_update	.\ext\fts1\fulltext.c	/^static int term_update(fulltext_vtab *v, sqlite_int64 rowid,$/;"	f	file:
testAsyncControl	.\src\test_async.c	/^static int testAsyncControl($/;"	f	file:
testAsyncInit	.\src\test_async.c	/^static int testAsyncInit($/;"	f	file:
testAsyncShutdown	.\src\test_async.c	/^static int testAsyncShutdown($/;"	f	file:
testAsyncStart	.\src\test_async.c	/^static int testAsyncStart($/;"	f	file:
testAsyncWait	.\src\test_async.c	/^static int testAsyncWait($/;"	f	file:
testBitvecBuiltinTest	.\src\test2.c	/^static int testBitvecBuiltinTest($/;"	f	file:
testContextMalloc	.\src\test_func.c	/^static void *testContextMalloc(sqlite3_context *context, int nByte){$/;"	f	file:
testCreateCollationCmp	.\src\test1.c	/^static int testCreateCollationCmp($/;"	f	file:
testCreateCollationDel	.\src\test1.c	/^static void testCreateCollationDel(void *pCtx){$/;"	f	file:
testFunc	.\ext\fts2\fts2_tokenizer.c	/^static void testFunc($/;"	f	file:
testFunc	.\ext\fts3\fts3_tokenizer.c	/^static void testFunc($/;"	f	file:
testFunc	.\src\test1.c	/^static void testFunc(sqlite3_context *context, int argc, sqlite3_value **argv){$/;"	f	file:
testHexChar	.\src\test_func.c	/^static int testHexChar(char c){$/;"	f	file:
testHexToBin	.\src\test_func.c	/^static void testHexToBin(const char *zIn, char *zOut){$/;"	f	file:
testHexToInt	.\src\test1.c	/^static int testHexToInt(int h){$/;"	f	file:
testHexToUtf16be	.\src\test_func.c	/^static void testHexToUtf16be($/;"	f	file:
testHexToUtf16le	.\src\test_func.c	/^static void testHexToUtf16le($/;"	f	file:
testHexToUtf8	.\src\test_func.c	/^static void testHexToUtf8($/;"	f	file:
testIsTokenChar	.\ext\fts3\fts3_test.c	/^static int testIsTokenChar(char c){$/;"	f	file:
testPendingByte	.\src\test2.c	/^static int testPendingByte($/;"	f	file:
testSqllog	.\src\test_sqllog.c	/^static void testSqllog(void *pCtx, sqlite3 *db, const char *zSql, int eType){$/;"	f	file:
testSqllogStmt	.\src\test_sqllog.c	/^static void testSqllogStmt(struct SLConn *p, const char *zSql){$/;"	f	file:
testTokenizerClose	.\ext\fts3\fts3_test.c	/^static int testTokenizerClose(sqlite3_tokenizer_cursor *pCursor){$/;"	f	file:
testTokenizerCreate	.\ext\fts3\fts3_test.c	/^static int testTokenizerCreate($/;"	f	file:
testTokenizerDestroy	.\ext\fts3\fts3_test.c	/^static int testTokenizerDestroy(sqlite3_tokenizer *pTokenizer){$/;"	f	file:
testTokenizerLanguage	.\ext\fts3\fts3_test.c	/^static int testTokenizerLanguage($/;"	f	file:
testTokenizerNext	.\ext\fts3\fts3_test.c	/^static int testTokenizerNext($/;"	f	file:
testTokenizerOpen	.\ext\fts3\fts3_test.c	/^static int testTokenizerOpen($/;"	f	file:
testTolower	.\ext\fts3\fts3_test.c	/^static int testTolower(char c){$/;"	f	file:
test_1	.\ext\fts3\fts3speed.tcl	/^proc test_1 {nInsert} {$/;"	p
test_2	.\ext\fts3\fts3speed.tcl	/^proc test_2 {} {$/;"	p
test_3	.\ext\fts3\fts3speed.tcl	/^proc test_3 {nSelect} {$/;"	p
test_4	.\ext\fts3\fts3speed.tcl	/^proc test_4 {nSelect} {$/;"	p
test_addop_breakpoint	.\src\vdbeaux.c	/^static void test_addop_breakpoint(void){$/;"	f	file:
test_agg_errmsg16_final	.\src\test_func.c	/^static void test_agg_errmsg16_final(sqlite3_context *ctx){$/;"	f	file:
test_agg_errmsg16_step	.\src\test_func.c	/^static void test_agg_errmsg16_step(sqlite3_context *a, int b,sqlite3_value **c){$/;"	f	file:
test_alloc_mutex	.\src\test_mutex.c	/^static int test_alloc_mutex($/;"	f	file:
test_alt_pcache	.\src\test_malloc.c	/^static int test_alt_pcache($/;"	f	file:
test_append_token	.\ext\fts5\test\fts5_common.tcl	/^proc test_append_token {varname token iStart iEnd} {$/;"	p
test_auxdata	.\src\test_func.c	/^static void test_auxdata($/;"	f	file:
test_bad_behavior	.\src\test1.c	/^static int test_bad_behavior($/;"	f	file:
test_bind	.\src\test1.c	/^static int test_bind($/;"	f	file:
test_bind_blob	.\src\test1.c	/^static int test_bind_blob($/;"	f	file:
test_bind_double	.\src\test1.c	/^static int test_bind_double($/;"	f	file:
test_bind_int	.\src\test1.c	/^static int test_bind_int($/;"	f	file:
test_bind_int64	.\src\test1.c	/^static int test_bind_int64($/;"	f	file:
test_bind_null	.\src\test1.c	/^static int test_bind_null($/;"	f	file:
test_bind_parameter_count	.\src\test1.c	/^static int test_bind_parameter_count($/;"	f	file:
test_bind_parameter_index	.\src\test1.c	/^static int test_bind_parameter_index($/;"	f	file:
test_bind_parameter_name	.\src\test1.c	/^static int test_bind_parameter_name($/;"	f	file:
test_bind_text	.\src\test1.c	/^static int test_bind_text($/;"	f	file:
test_bind_text16	.\src\test1.c	/^static int test_bind_text16($/;"	f	file:
test_bind_zeroblob	.\src\test1.c	/^static int test_bind_zeroblob($/;"	f	file:
test_bind_zeroblob64	.\src\test1.c	/^static int test_bind_zeroblob64($/;"	f	file:
test_blob_bytes	.\src\test_blob.c	/^static int test_blob_bytes($/;"	f	file:
test_blob_close	.\src\test_blob.c	/^static int test_blob_close($/;"	f	file:
test_blob_open	.\src\test_blob.c	/^static int test_blob_open($/;"	f	file:
test_blob_read	.\src\test_blob.c	/^static int test_blob_read($/;"	f	file:
test_blob_reopen	.\src\test1.c	/^static int test_blob_reopen($/;"	f	file:
test_blob_write	.\src\test_blob.c	/^static int test_blob_write($/;"	f	file:
test_breakpoint	.\mptest\mptest.c	/^static void test_breakpoint(void){ static volatile int cnt = 0; cnt++; }$/;"	f	file:
test_breakpoint	.\src\shell.c	/^static void test_breakpoint(void){$/;"	f	file:
test_breakpoint	.\src\test1.c	/^static int test_breakpoint($/;"	f	file:
test_busy_timeout	.\src\test1.c	/^static int test_busy_timeout($/;"	f	file:
test_changes	.\src\test1.c	/^static int test_changes($/;"	f	file:
test_clear_bindings	.\src\test1.c	/^static int test_clear_bindings($/;"	f	file:
test_clear_mutex_counters	.\src\test_mutex.c	/^static int test_clear_mutex_counters($/;"	f	file:
test_collate	.\src\test1.c	/^static int test_collate($/;"	f	file:
test_collate_func	.\src\test1.c	/^static int test_collate_func($/;"	f	file:
test_collate_needed	.\src\test1.c	/^static int test_collate_needed($/;"	f	file:
test_collate_needed_cb	.\src\test1.c	/^static void test_collate_needed_cb($/;"	f	file:
test_column_blob	.\src\test1.c	/^static int test_column_blob($/;"	f	file:
test_column_count	.\src\test1.c	/^static int test_column_count($/;"	f	file:
test_column_double	.\src\test1.c	/^static int test_column_double($/;"	f	file:
test_column_int64	.\src\test1.c	/^static int test_column_int64($/;"	f	file:
test_column_type	.\src\test1.c	/^static int test_column_type($/;"	f	file:
test_complete16	.\src\test1.c	/^static int test_complete16($/;"	f	file:
test_config	.\src\test_mutex.c	/^static int test_config($/;"	f	file:
test_config_cis	.\src\test_malloc.c	/^static int test_config_cis($/;"	f	file:
test_config_error	.\src\test_malloc.c	/^static int test_config_error($/;"	f	file:
test_config_heap	.\src\test_malloc.c	/^static int test_config_heap($/;"	f	file:
test_config_heap_size	.\src\test_malloc.c	/^static int test_config_heap_size($/;"	f	file:
test_config_lookaside	.\src\test_malloc.c	/^static int test_config_lookaside($/;"	f	file:
test_config_memstatus	.\src\test_malloc.c	/^static int test_config_memstatus($/;"	f	file:
test_config_pagecache	.\src\test_malloc.c	/^static int test_config_pagecache($/;"	f	file:
test_config_pmasz	.\src\test_malloc.c	/^static int test_config_pmasz($/;"	f	file:
test_config_scratch	.\src\test_malloc.c	/^static int test_config_scratch($/;"	f	file:
test_config_uri	.\src\test_malloc.c	/^static int test_config_uri($/;"	f	file:
test_control	.\src\sqlite3ext.h	/^  int (*test_control)(int, ...);$/;"	m	struct:sqlite3_api_routines
test_create_aggregate	.\src\test1.c	/^static int test_create_aggregate($/;"	f	file:
test_create_collation_v2	.\src\test1.c	/^static int test_create_collation_v2($/;"	f	file:
test_create_function	.\src\test1.c	/^static int test_create_function($/;"	f	file:
test_create_function_v2	.\src\test1.c	/^static int test_create_function_v2($/;"	f	file:
test_data_count	.\src\test1.c	/^static int test_data_count($/;"	f	file:
test_db_config_lookaside	.\src\test_malloc.c	/^static int test_db_config_lookaside($/;"	f	file:
test_db_filename	.\src\test1.c	/^static int test_db_filename($/;"	f	file:
test_db_readonly	.\src\test1.c	/^static int test_db_readonly($/;"	f	file:
test_db_release_memory	.\src\test1.c	/^static int test_db_release_memory($/;"	f	file:
test_db_status	.\src\test_malloc.c	/^static int test_db_status($/;"	f	file:
test_decode	.\src\test_func.c	/^static void test_decode($/;"	f	file:
test_destructor	.\src\test_func.c	/^static void test_destructor($/;"	f	file:
test_destructor16	.\src\test_func.c	/^static void test_destructor16($/;"	f	file:
test_destructor_count	.\src\test_func.c	/^static void test_destructor_count($/;"	f	file:
test_destructor_count_var	.\src\test_func.c	/^static int test_destructor_count_var = 0;$/;"	v	file:
test_dump_memsys3	.\src\test_malloc.c	/^static int test_dump_memsys3($/;"	f	file:
test_enable_load	.\src\test1.c	/^static int test_enable_load($/;"	f	file:
test_enable_shared	.\src\test1.c	/^static int test_enable_shared($/;"	f	file:
test_enter_db_mutex	.\src\test_mutex.c	/^static int test_enter_db_mutex($/;"	f	file:
test_enter_static_mutex	.\src\test_mutex.c	/^static int test_enter_static_mutex($/;"	f	file:
test_errcode	.\src\test1.c	/^static int test_errcode($/;"	f	file:
test_errmsg	.\src\test1.c	/^static int test_errmsg($/;"	f	file:
test_errmsg16	.\src\test1.c	/^static int test_errmsg16($/;"	f	file:
test_error	.\src\test_func.c	/^static void test_error($/;"	f	file:
test_error	.\test\threadtest3.c	63;"	d	file:
test_error_x	.\test\threadtest3.c	/^static void test_error_x($/;"	f	file:
test_errstr	.\src\test1.c	/^static int test_errstr($/;"	f	file:
test_eval	.\src\test_func.c	/^static void test_eval($/;"	f	file:
test_ex_errcode	.\src\test1.c	/^static int test_ex_errcode($/;"	f	file:
test_exec	.\src\test1.c	/^static int test_exec($/;"	f	file:
test_exec_hex	.\src\test1.c	/^static int test_exec_hex($/;"	f	file:
test_exec_nr	.\src\test1.c	/^static int test_exec_nr($/;"	f	file:
test_exec_printf	.\src\test1.c	/^static int test_exec_printf($/;"	f	file:
test_expired	.\src\test1.c	/^static int test_expired($/;"	f	file:
test_extended_result_codes	.\src\test1.c	/^static int test_extended_result_codes($/;"	f	file:
test_extract	.\src\test_func.c	/^static void test_extract($/;"	f	file:
test_finalize	.\src\test1.c	/^static int test_finalize($/;"	f	file:
test_free	.\src\test_malloc.c	/^static int test_free($/;"	f	file:
test_fts3_node_chunk_threshold	.\ext\fts3\fts3_write.c	/^int test_fts3_node_chunk_threshold = (4*1024)*4;$/;"	v
test_fts3_node_chunksize	.\ext\fts3\fts3_write.c	/^int test_fts3_node_chunksize = (4*1024);$/;"	v
test_function	.\src\test1.c	/^static int test_function($/;"	f	file:
test_function_utf16be	.\src\test1.c	/^static void test_function_utf16be($/;"	f	file:
test_function_utf16le	.\src\test1.c	/^static void test_function_utf16le($/;"	f	file:
test_function_utf8	.\src\test1.c	/^static void test_function_utf8($/;"	f	file:
test_get_table_printf	.\src\test1.c	/^static int test_get_table_printf($/;"	f	file:
test_getrusage	.\src\test1.c	/^static int test_getrusage($/;"	f	file:
test_getsubtype	.\src\test_func.c	/^static void test_getsubtype($/;"	f	file:
test_global_recover	.\src\test1.c	/^static int test_global_recover($/;"	f	file:
test_initialize	.\src\test_mutex.c	/^static int test_initialize($/;"	f	file:
test_install_malloc_faultsim	.\src\test_malloc.c	/^static int test_install_malloc_faultsim($/;"	f	file:
test_install_memsys3	.\src\test_malloc.c	/^static int test_install_memsys3($/;"	f	file:
test_install_mutex_counters	.\src\test_mutex.c	/^static int test_install_mutex_counters($/;"	f	file:
test_intarray_bind	.\src\test_intarray.c	/^static int test_intarray_bind($/;"	f	file:
test_intarray_create	.\src\test_intarray.c	/^static int test_intarray_create($/;"	f	file:
test_interrupt	.\src\test1.c	/^static int test_interrupt($/;"	f	file:
test_io_trace	.\src\test1.c	/^static int test_io_trace($/;"	f	file:
test_isolation	.\src\test_func.c	/^static void test_isolation($/;"	f	file:
test_key	.\src\test1.c	/^static int test_key($/;"	f	file:
test_last_rowid	.\src\test1.c	/^static int test_last_rowid($/;"	f	file:
test_leave_db_mutex	.\src\test_mutex.c	/^static int test_leave_db_mutex($/;"	f	file:
test_leave_static_mutex	.\src\test_mutex.c	/^static int test_leave_static_mutex($/;"	f	file:
test_libversion_number	.\src\test1.c	/^static int test_libversion_number($/;"	f	file:
test_limit	.\src\test1.c	/^static int test_limit($/;"	f	file:
test_load_extension	.\src\test1.c	/^static int test_load_extension($/;"	f	file:
test_malloc	.\src\test_malloc.c	/^static int test_malloc($/;"	f	file:
test_memdebug_backtrace	.\src\test_malloc.c	/^static int test_memdebug_backtrace($/;"	f	file:
test_memdebug_callback	.\src\test_malloc.c	/^static void test_memdebug_callback(int nByte, int nFrame, void **aFrame){$/;"	f	file:
test_memdebug_dump	.\src\test_malloc.c	/^static int test_memdebug_dump($/;"	f	file:
test_memdebug_fail	.\src\test_malloc.c	/^static int test_memdebug_fail($/;"	f	file:
test_memdebug_log	.\src\test_malloc.c	/^static int test_memdebug_log($/;"	f	file:
test_memdebug_log_clear	.\src\test_malloc.c	/^static void test_memdebug_log_clear(void){$/;"	f	file:
test_memdebug_malloc_count	.\src\test_malloc.c	/^static int test_memdebug_malloc_count($/;"	f	file:
test_memdebug_pending	.\src\test_malloc.c	/^static int test_memdebug_pending($/;"	f	file:
test_memdebug_settitle	.\src\test_malloc.c	/^static int test_memdebug_settitle($/;"	f	file:
test_memget	.\src\test_malloc.c	/^static int test_memget($/;"	f	file:
test_memory_highwater	.\src\test_malloc.c	/^static int test_memory_highwater($/;"	f	file:
test_memory_used	.\src\test_malloc.c	/^static int test_memory_used($/;"	f	file:
test_memset	.\src\test_malloc.c	/^static int test_memset($/;"	f	file:
test_mprintf_n	.\src\test1.c	/^static int test_mprintf_n($/;"	f	file:
test_mprintf_z	.\src\test1.c	/^static int test_mprintf_z($/;"	f	file:
test_multiplex_control	.\src\test_multiplex.c	/^static int test_multiplex_control($/;"	f	file:
test_multiplex_dump	.\src\test_multiplex.c	/^static int test_multiplex_dump($/;"	f	file:
test_multiplex_initialize	.\src\test_multiplex.c	/^static int test_multiplex_initialize($/;"	f	file:
test_multiplex_shutdown	.\src\test_multiplex.c	/^static int test_multiplex_shutdown($/;"	f	file:
test_mutex_globals	.\src\test_mutex.c	/^static struct test_mutex_globals {$/;"	s	file:
test_next_stmt	.\src\test1.c	/^static int test_next_stmt($/;"	f	file:
test_open	.\src\test1.c	/^static int test_open($/;"	f	file:
test_open16	.\src\test1.c	/^static int test_open16($/;"	f	file:
test_open_v2	.\src\test1.c	/^static int test_open_v2($/;"	f	file:
test_pager_refcounts	.\src\test1.c	/^static int test_pager_refcounts($/;"	f	file:
test_pagesize	.\src\test2.c	/^static int test_pagesize = 1024;$/;"	v	file:
test_pcache_stats	.\src\test1.c	/^static int test_pcache_stats($/;"	f	file:
test_prepare	.\src\test1.c	/^static int test_prepare($/;"	f	file:
test_prepare16	.\src\test1.c	/^static int test_prepare16($/;"	f	file:
test_prepare16_v2	.\src\test1.c	/^static int test_prepare16_v2($/;"	f	file:
test_prepare_tkt3134	.\src\test1.c	/^static int test_prepare_tkt3134($/;"	f	file:
test_prepare_v2	.\src\test1.c	/^static int test_prepare_v2($/;"	f	file:
test_print_eqp	.\src\test1.c	/^static int test_print_eqp($/;"	f	file:
test_printf	.\src\test1.c	/^static int test_printf($/;"	f	file:
test_pwd	.\test\tester.tcl	/^proc test_pwd { args } {$/;"	p
test_queryphrase_cb	.\ext\fts5\test\fts5_common.tcl	/^proc test_queryphrase_cb {cnt cmd} {$/;"	p
test_quota_dump	.\src\test_quota.c	/^static int test_quota_dump($/;"	f	file:
test_quota_fclose	.\src\test_quota.c	/^static int test_quota_fclose($/;"	f	file:
test_quota_ferror	.\src\test_quota.c	/^static int test_quota_ferror($/;"	f	file:
test_quota_fflush	.\src\test_quota.c	/^static int test_quota_fflush($/;"	f	file:
test_quota_file	.\src\test_quota.c	/^static int test_quota_file($/;"	f	file:
test_quota_file_available	.\src\test_quota.c	/^static int test_quota_file_available($/;"	f	file:
test_quota_file_mtime	.\src\test_quota.c	/^static int test_quota_file_mtime($/;"	f	file:
test_quota_file_size	.\src\test_quota.c	/^static int test_quota_file_size($/;"	f	file:
test_quota_file_truesize	.\src\test_quota.c	/^static int test_quota_file_truesize($/;"	f	file:
test_quota_fopen	.\src\test_quota.c	/^static int test_quota_fopen($/;"	f	file:
test_quota_fread	.\src\test_quota.c	/^static int test_quota_fread($/;"	f	file:
test_quota_fseek	.\src\test_quota.c	/^static int test_quota_fseek($/;"	f	file:
test_quota_ftell	.\src\test_quota.c	/^static int test_quota_ftell($/;"	f	file:
test_quota_ftruncate	.\src\test_quota.c	/^static int test_quota_ftruncate($/;"	f	file:
test_quota_fwrite	.\src\test_quota.c	/^static int test_quota_fwrite($/;"	f	file:
test_quota_glob	.\src\test_quota.c	/^static int test_quota_glob($/;"	f	file:
test_quota_initialize	.\src\test_quota.c	/^static int test_quota_initialize($/;"	f	file:
test_quota_remove	.\src\test_quota.c	/^static int test_quota_remove($/;"	f	file:
test_quota_rewind	.\src\test_quota.c	/^static int test_quota_rewind($/;"	f	file:
test_quota_set	.\src\test_quota.c	/^static int test_quota_set($/;"	f	file:
test_quota_shutdown	.\src\test_quota.c	/^static int test_quota_shutdown($/;"	f	file:
test_rbu_delta	.\ext\rbu\test_rbu.c	/^void test_rbu_delta(sqlite3_context *pCtx, int nArg, sqlite3_value **apVal){$/;"	f
test_read_mutex_counters	.\src\test_mutex.c	/^static int test_read_mutex_counters($/;"	f	file:
test_realloc	.\src\test_malloc.c	/^static int test_realloc($/;"	f	file:
test_register_dbstat_vtab	.\src\test1.c	/^static int test_register_dbstat_vtab($/;"	f	file:
test_register_func	.\src\test1.c	/^static int test_register_func($/;"	f	file:
test_rekey	.\src\test1.c	/^static int test_rekey($/;"	f	file:
test_release_memory	.\src\test1.c	/^static int test_release_memory($/;"	f	file:
test_reset	.\src\test1.c	/^static int test_reset($/;"	f	file:
test_restore_config_pagecache	.\test\tester.tcl	/^proc test_restore_config_pagecache {} {$/;"	p
test_set_config_pagecache	.\test\tester.tcl	/^proc test_set_config_pagecache {sz nPg} {$/;"	p
test_setsubtype	.\src\test_func.c	/^static void test_setsubtype($/;"	f	file:
test_shutdown	.\src\test_mutex.c	/^static int test_shutdown($/;"	f	file:
test_sleep	.\src\test1.c	/^static int test_sleep($/;"	f	file:
test_snprintf_int	.\src\test1.c	/^static int test_snprintf_int($/;"	f	file:
test_soft_heap_limit	.\src\test1.c	/^static int test_soft_heap_limit($/;"	f	file:
test_sql	.\src\test1.c	/^static int test_sql($/;"	f	file:
test_sqlite3_log	.\src\test1.c	/^static int test_sqlite3_log($/;"	f	file:
test_sqlite3rbu	.\ext\rbu\test_rbu.c	/^static int test_sqlite3rbu($/;"	f	file:
test_sqlite3rbu_cmd	.\ext\rbu\test_rbu.c	/^static int test_sqlite3rbu_cmd($/;"	f	file:
test_sqlite3rbu_create_vfs	.\ext\rbu\test_rbu.c	/^static int test_sqlite3rbu_create_vfs($/;"	f	file:
test_sqlite3rbu_destroy_vfs	.\ext\rbu\test_rbu.c	/^static int test_sqlite3rbu_destroy_vfs($/;"	f	file:
test_sqlite3rbu_internal_test	.\ext\rbu\test_rbu.c	/^static int test_sqlite3rbu_internal_test($/;"	f	file:
test_stack_used	.\src\test1.c	/^static int test_stack_used($/;"	f	file:
test_status	.\src\test_malloc.c	/^static int test_status($/;"	f	file:
test_step	.\src\test1.c	/^static int test_step($/;"	f	file:
test_stmt_busy	.\src\test1.c	/^static int test_stmt_busy($/;"	f	file:
test_stmt_int	.\src\test1.c	/^static int test_stmt_int($/;"	f	file:
test_stmt_readonly	.\src\test1.c	/^static int test_stmt_readonly($/;"	f	file:
test_stmt_scanstatus	.\src\test1.c	/^static int test_stmt_scanstatus($/;"	f	file:
test_stmt_scanstatus_reset	.\src\test1.c	/^static int test_stmt_scanstatus_reset($/;"	f	file:
test_stmt_status	.\src\test1.c	/^static int test_stmt_status($/;"	f	file:
test_stmt_utf16	.\src\test1.c	/^static int test_stmt_utf16($/;"	f	file:
test_stmt_utf8	.\src\test1.c	/^static int test_stmt_utf8($/;"	f	file:
test_syscall	.\src\test_syscall.c	/^static int test_syscall($/;"	f	file:
test_syscall_defaultvfs	.\src\test_syscall.c	/^static int test_syscall_defaultvfs($/;"	f	file:
test_syscall_errno	.\src\test_syscall.c	/^static int test_syscall_errno($/;"	f	file:
test_syscall_exists	.\src\test_syscall.c	/^static int test_syscall_exists($/;"	f	file:
test_syscall_fault	.\src\test_syscall.c	/^static int test_syscall_fault($/;"	f	file:
test_syscall_install	.\src\test_syscall.c	/^static int test_syscall_install($/;"	f	file:
test_syscall_list	.\src\test_syscall.c	/^static int test_syscall_list($/;"	f	file:
test_syscall_pagesize	.\src\test_syscall.c	/^static int test_syscall_pagesize($/;"	f	file:
test_syscall_reset	.\src\test_syscall.c	/^static int test_syscall_reset($/;"	f	file:
test_syscall_uninstall	.\src\test_syscall.c	/^static int test_syscall_uninstall($/;"	f	file:
test_table_column_metadata	.\src\test1.c	/^static int test_table_column_metadata($/;"	f	file:
test_test_control	.\src\test1.c	/^static int test_test_control($/;"	f	file:
test_thread_cleanup	.\src\test1.c	/^static int test_thread_cleanup($/;"	f	file:
test_tokenizer	.\ext\fts3\fts3_test.c	/^typedef struct test_tokenizer {$/;"	s	file:
test_tokenizer	.\ext\fts3\fts3_test.c	/^} test_tokenizer;$/;"	t	typeref:struct:test_tokenizer	file:
test_tokenizer_cursor	.\ext\fts3\fts3_test.c	/^typedef struct test_tokenizer_cursor {$/;"	s	file:
test_tokenizer_cursor	.\ext\fts3\fts3_test.c	/^} test_tokenizer_cursor;$/;"	t	typeref:struct:test_tokenizer_cursor	file:
test_transfer_bind	.\src\test1.c	/^static int test_transfer_bind($/;"	f	file:
test_translate	.\src\test5.c	/^static int test_translate($/;"	f	file:
test_translate_selftest	.\src\test5.c	/^static int test_translate_selftest($/;"	f	file:
test_unlock_notify	.\src\test1.c	/^static int test_unlock_notify($/;"	f	file:
test_unlock_notify_cb	.\src\test1.c	/^static void test_unlock_notify_cb(void **aArg, int nArg){$/;"	f	file:
test_user_add	.\src\test1.c	/^static int test_user_add($/;"	f	file:
test_user_authenticate	.\src\test1.c	/^static int test_user_authenticate($/;"	f	file:
test_user_change	.\src\test1.c	/^static int test_user_change($/;"	f	file:
test_user_delete	.\src\test1.c	/^static int test_user_delete($/;"	f	file:
test_utf16bin_collate	.\src\test1.c	/^static int test_utf16bin_collate($/;"	f	file:
test_utf16bin_collate_func	.\src\test1.c	/^static int test_utf16bin_collate_func($/;"	f	file:
test_value_overhead	.\src\test5.c	/^static int test_value_overhead($/;"	f	file:
test_vfs_oom_test	.\src\test_malloc.c	/^static int test_vfs_oom_test($/;"	f	file:
test_vfslog	.\src\test_osinst.c	/^static int test_vfslog($/;"	f	file:
test_wal_autocheckpoint	.\src\test1.c	/^static int test_wal_autocheckpoint($/;"	f	file:
test_wal_checkpoint	.\src\test1.c	/^static int test_wal_checkpoint($/;"	f	file:
test_wal_checkpoint_v2	.\src\test1.c	/^static int test_wal_checkpoint_v2($/;"	f	file:
test_zeroblob	.\src\test_func.c	/^static void test_zeroblob($/;"	f	file:
testasync_g	.\src\test_async.c	/^} testasync_g = { 0 };$/;"	v	typeref:struct:TestAsyncGlobal
testasync_g_writerMutex	.\src\test_async.c	/^TCL_DECLARE_MUTEX(testasync_g_writerMutex);$/;"	v
testcase	.\ext\fts3\fts3Int.h	115;"	d
testcase	.\ext\fts5\fts5Int.h	34;"	d
testcase	.\src\sqliteInt.h	334;"	d
testcase	.\src\sqliteInt.h	336;"	d
testfixture	.\test\lock_common.tcl	/^proc testfixture {chan cmd args} {$/;"	p
testfixture_nb	.\test\lock_common.tcl	/^proc testfixture_nb {varname cmd} {$/;"	p
testfixture_nb_cb	.\test\lock_common.tcl	/^proc testfixture_nb_cb {varname chan} {$/;"	p
testfixture_script_cb	.\test\lock_common.tcl	/^proc testfixture_script_cb {chan script} {$/;"	p
testpcache	.\src\test_pcache.c	/^struct testpcache {$/;"	s	file:
testpcache	.\src\test_pcache.c	/^typedef struct testpcache testpcache;$/;"	t	typeref:struct:testpcache	file:
testpcacheCachesize	.\src\test_pcache.c	/^static void testpcacheCachesize(sqlite3_pcache *pCache, int newSize){$/;"	f	file:
testpcacheCreate	.\src\test_pcache.c	/^static sqlite3_pcache *testpcacheCreate($/;"	f	file:
testpcacheDestroy	.\src\test_pcache.c	/^static void testpcacheDestroy(sqlite3_pcache *pCache){$/;"	f	file:
testpcacheFetch	.\src\test_pcache.c	/^static sqlite3_pcache_page *testpcacheFetch($/;"	f	file:
testpcacheGlobal	.\src\test_pcache.c	/^static testpcacheGlobalType testpcacheGlobal;$/;"	v	file:
testpcacheGlobalType	.\src\test_pcache.c	/^struct testpcacheGlobalType {$/;"	s	file:
testpcacheGlobalType	.\src\test_pcache.c	/^typedef struct testpcacheGlobalType testpcacheGlobalType;$/;"	t	typeref:struct:testpcacheGlobalType	file:
testpcacheInit	.\src\test_pcache.c	/^static int testpcacheInit(void *pArg){$/;"	f	file:
testpcachePage	.\src\test_pcache.c	/^  struct testpcachePage {$/;"	s	struct:testpcache	file:
testpcachePagecount	.\src\test_pcache.c	/^static int testpcachePagecount(sqlite3_pcache *pCache){$/;"	f	file:
testpcacheRandom	.\src\test_pcache.c	/^static unsigned testpcacheRandom(testpcache *p){$/;"	f	file:
testpcacheRekey	.\src\test_pcache.c	/^static void testpcacheRekey($/;"	f	file:
testpcacheShutdown	.\src\test_pcache.c	/^static void testpcacheShutdown(void *pArg){$/;"	f	file:
testpcacheTruncate	.\src\test_pcache.c	/^static void testpcacheTruncate(sqlite3_pcache *pCache, unsigned iLimit){$/;"	f	file:
testpcacheUnpin	.\src\test_pcache.c	/^static void testpcacheUnpin($/;"	f	file:
testset_cte	.\test\speedtest1.c	/^void testset_cte(void){$/;"	f
testset_debug1	.\test\speedtest1.c	/^void testset_debug1(void){$/;"	f
testset_main	.\test\speedtest1.c	/^void testset_main(void){$/;"	f
testset_rtree	.\test\speedtest1.c	/^void testset_rtree(int p1, int p2){$/;"	f
testvfs_cmd	.\src\test_vfs.c	/^static int testvfs_cmd($/;"	f	file:
testvfs_obj_cmd	.\src\test_vfs.c	/^static int testvfs_obj_cmd($/;"	f	file:
testvfs_obj_del	.\src\test_vfs.c	/^static void testvfs_obj_del(ClientData cd){$/;"	f	file:
textToPointer	.\src\test_malloc.c	/^static int textToPointer(const char *z, void **pp){$/;"	f	file:
thread_cleanup	.\src\sqlite3ext.h	/^  void  (*thread_cleanup)(void);$/;"	m	struct:sqlite3_api_routines
thread_cnt	.\test\threadtest1.c	/^int thread_cnt = 0;$/;"	v
thread_main	.\src\test4.c	/^static void *thread_main(void *pArg){$/;"	f	file:
thread_spawn	.\test\thread_common.tcl	/^proc thread_spawn {varname args} {$/;"	p
thread_wait	.\src\test4.c	/^static void thread_wait(Thread *p){$/;"	f	file:
threadid	.\src\os_unix.c	291;"	d	file:
threadid	.\src\os_unix.c	293;"	d	file:
threadset	.\src\test4.c	/^static Thread threadset[N_THREAD];$/;"	v	file:
threadset	.\src\test7.c	/^static Thread threadset[N_THREAD];$/;"	v	file:
tid	.\src\threads.c	/^  pthread_t tid;                 \/* Thread ID *\/$/;"	m	struct:SQLiteThread	file:
tid	.\src\threads.c	/^  void *tid;               \/* The thread handle *\/$/;"	m	struct:SQLiteThread	file:
tid	.\test\threadtest3.c	/^  pthread_t tid;                  \/* Thread id *\/$/;"	m	struct:Thread	file:
tid	.\test\threadtest4.c	/^  int tid;                    \/* Thread ID *\/$/;"	m	struct:WorkerInfo	file:
timeDiff	.\src\shell.c	/^static double timeDiff(FILETIME *pStart, FILETIME *pEnd){$/;"	f	file:
timeDiff	.\src\shell.c	/^static double timeDiff(struct timeval *pStart, struct timeval *pEnd){$/;"	f	file:
timeFunc	.\src\date.c	/^static void timeFunc($/;"	f	file:
timeOfDay	.\src\shell.c	/^static sqlite3_int64 timeOfDay(void){$/;"	f	file:
timeOfDay	.\test\fuzzcheck.c	/^static sqlite3_int64 timeOfDay(void){$/;"	f	file:
timeOfDay	.\tool\fuzzershell.c	/^static sqlite3_int64 timeOfDay(void){$/;"	f	file:
timelimit	.\test\threadtest3.c	/^static double timelimit = 0.0;$/;"	v	file:
timeoutHandler	.\test\fuzzcheck.c	/^static void timeoutHandler(int NotUsed){$/;"	f	file:
timetostop	.\test\threadtest3.c	60;"	d	file:
timetostop_x	.\test\threadtest3.c	/^static int timetostop_x($/;"	f	file:
titleline	.\tool\spaceanal.tcl	/^proc titleline {title} {$/;"	p
tkCREATE	.\src\complete.c	45;"	d	file:
tkEND	.\src\complete.c	48;"	d	file:
tkEXPLAIN	.\src\complete.c	44;"	d	file:
tkOTHER	.\src\complete.c	42;"	d	file:
tkSEMI	.\src\complete.c	40;"	d	file:
tkTEMP	.\src\complete.c	46;"	d	file:
tkTRIGGER	.\src\complete.c	47;"	d	file:
tkWS	.\src\complete.c	41;"	d	file:
tkclass	.\tool\lemon.c	/^  struct symbol *tkclass;    \/* Token class symbol *\/$/;"	m	struct:pstate	typeref:struct:pstate::symbol	file:
tkt2213Function	.\src\test1.c	/^static void tkt2213Function($/;"	f	file:
tl_create_records	.\ext\fts3\unicode\mkunicode.tcl	/^proc tl_create_records {} {$/;"	p
tl_generate_ioff_table	.\ext\fts3\unicode\mkunicode.tcl	/^proc tl_generate_ioff_table {lRecord} {$/;"	p
tl_load_casefolding_txt	.\ext\fts3\unicode\parseunicode.tcl	/^proc tl_load_casefolding_txt {zName} {$/;"	p
tl_print_if_entry	.\ext\fts3\unicode\mkunicode.tcl	/^proc tl_print_if_entry {entry} {$/;"	p
tl_print_ioff_table	.\ext\fts3\unicode\mkunicode.tcl	/^proc tl_print_ioff_table {liOff} {$/;"	p
tl_print_table_entry	.\ext\fts3\unicode\mkunicode.tcl	/^proc tl_print_table_entry {togglevar entry liOff} {$/;"	p
tl_print_table_footer	.\ext\fts3\unicode\mkunicode.tcl	/^proc tl_print_table_footer {togglevar} {$/;"	p
tl_print_table_header	.\ext\fts3\unicode\mkunicode.tcl	/^proc tl_print_table_header {} {$/;"	p
tmask	.\src\insert.c	1055;"	d	file:
tmpCheckReservedLock	.\src\test_onefile.c	/^static int tmpCheckReservedLock(sqlite3_file *pFile, int *pResOut){$/;"	f	file:
tmpClose	.\src\test_onefile.c	/^static int tmpClose(sqlite3_file *pFile){$/;"	f	file:
tmpDeviceCharacteristics	.\src\test_onefile.c	/^static int tmpDeviceCharacteristics(sqlite3_file *pFile){$/;"	f	file:
tmpFileControl	.\src\test_onefile.c	/^static int tmpFileControl(sqlite3_file *pFile, int op, void *pArg){$/;"	f	file:
tmpFileSize	.\src\test_onefile.c	/^static int tmpFileSize(sqlite3_file *pFile, sqlite_int64 *pSize){$/;"	f	file:
tmpLock	.\src\test_onefile.c	/^static int tmpLock(sqlite3_file *pFile, int eLock){$/;"	f	file:
tmpRead	.\src\test_onefile.c	/^static int tmpRead($/;"	f	file:
tmpSectorSize	.\src\test_onefile.c	/^static int tmpSectorSize(sqlite3_file *pFile){$/;"	f	file:
tmpSync	.\src\test_onefile.c	/^static int tmpSync(sqlite3_file *pFile, int flags){$/;"	f	file:
tmpTruncate	.\src\test_onefile.c	/^static int tmpTruncate(sqlite3_file *pFile, sqlite_int64 size){$/;"	f	file:
tmpUnlock	.\src\test_onefile.c	/^static int tmpUnlock(sqlite3_file *pFile, int eLock){$/;"	f	file:
tmpWrite	.\src\test_onefile.c	/^static int tmpWrite($/;"	f	file:
tmp_file	.\src\test_onefile.c	/^struct tmp_file {$/;"	s	file:
tmp_file	.\src\test_onefile.c	/^typedef struct tmp_file tmp_file;$/;"	t	typeref:struct:tmp_file	file:
tmp_io_methods	.\src\test_onefile.c	/^static sqlite3_io_methods tmp_io_methods = {$/;"	v	file:
tnum	.\src\sqliteInt.h	/^  int tnum;                \/* DB Page containing root of this index *\/$/;"	m	struct:Index
tnum	.\src\sqliteInt.h	/^  int tnum;            \/* Root BTree page for this table *\/$/;"	m	struct:Table
toHex	.\tool\varint.c	/^static char toHex(unsigned char c){$/;"	f	file:
tointegerFunc	.\ext\misc\totype.c	/^static void tointegerFunc($/;"	f	file:
token	.\src\vdbe.h	/^  void *token;                  \/* id that may be used to recursive triggers *\/$/;"	m	struct:SubProgram
token	.\src\vdbeInt.h	/^  void *token;            \/* Copy of SubProgram.token *\/$/;"	m	struct:VdbeFrame
tokenLength	.\mptest\mptest.c	/^static int tokenLength(const char *z, int *pnLine){$/;"	f	file:
tokenListToIdList	.\ext\fts1\fts1.c	/^static void tokenListToIdList(char **azIn){$/;"	f	file:
tokenListToIdList	.\ext\fts2\fts2.c	/^static void tokenListToIdList(char **azIn){$/;"	f	file:
tokendest	.\tool\lemon.c	/^  char *tokendest;         \/* Code to execute to destroy token data *\/$/;"	m	struct:lemon	file:
tokenizeSegment	.\ext\fts1\fts1.c	/^static int tokenizeSegment($/;"	f	file:
tokenizeSegment	.\ext\fts2\fts2.c	/^static int tokenizeSegment($/;"	f	file:
tokenizeString	.\ext\fts1\fts1.c	/^static char **tokenizeString(const char *z, int *pnToken){$/;"	f	file:
tokenizeString	.\ext\fts2\fts2.c	/^static char **tokenizeString(const char *z, int *pnToken){$/;"	f	file:
tokenize_segment	.\ext\fts1\fulltext.c	/^static int tokenize_segment(sqlite3_tokenizer *pTokenizer,$/;"	f	file:
tokenizer	.\ext\fts5\fts5_tokenize.c	/^  fts5_tokenizer tokenizer;       \/* Parent tokenizer module *\/$/;"	m	struct:PorterTokenizer	file:
tokenlineno	.\tool\lemon.c	/^  int tokenlineno;      \/* Linenumber at which current token starts *\/$/;"	m	struct:pstate	file:
tokenprefix	.\tool\lemon.c	/^  char *tokenprefix;       \/* A prefix added to token names in the .h file *\/$/;"	m	struct:lemon	file:
tokenstart	.\tool\lemon.c	/^  char *tokenstart;     \/* Text of current token *\/$/;"	m	struct:pstate	file:
tokentype	.\tool\lemon.c	/^  char *tokentype;         \/* Type of terminal symbols in the parser stack *\/$/;"	m	struct:lemon	file:
torealFunc	.\ext\misc\totype.c	/^static void torealFunc($/;"	f	file:
totalAlloc	.\src\mem5.c	/^  u64 totalAlloc;     \/* Total of all malloc calls - includes internal frag *\/$/;"	m	struct:Mem5Global	file:
totalExcess	.\src\mem5.c	/^  u64 totalExcess;    \/* Total internal fragmentation *\/$/;"	m	struct:Mem5Global	file:
totalFinalize	.\src\func.c	/^static void totalFinalize(sqlite3_context *context){$/;"	f	file:
total_changes	.\src\func.c	/^static void total_changes($/;"	f	file:
total_changes	.\src\sqlite3ext.h	/^  int  (*total_changes)(sqlite3*);$/;"	m	struct:sqlite3_api_routines
totypeAtoF	.\ext\misc\totype.c	/^static int totypeAtoF(const char *z, double *pResult, int length){$/;"	f	file:
totypeAtoi64	.\ext\misc\totype.c	/^static int totypeAtoi64(const char *zNum, sqlite3_int64 *pNum, int length){$/;"	f	file:
totypeCompare2pow63	.\ext\misc\totype.c	/^static int totypeCompare2pow63(const char *zNum){$/;"	f	file:
totypeIsdigit	.\ext\misc\totype.c	/^static int totypeIsdigit(unsigned char c){$/;"	f	file:
totypeIsspace	.\ext\misc\totype.c	/^static int totypeIsspace(unsigned char c){$/;"	f	file:
tplt_linedir	.\tool\lemon.c	/^PRIVATE void tplt_linedir(FILE *out, int lineno, char *filename)$/;"	f
tplt_open	.\tool\lemon.c	/^PRIVATE FILE *tplt_open(struct lemon *lemp)$/;"	f
tplt_print	.\tool\lemon.c	/^PRIVATE void tplt_print(FILE *out, struct lemon *lemp, char *str, int *lineno)$/;"	f
tplt_xfer	.\tool\lemon.c	/^PRIVATE void tplt_xfer(char *name, FILE *in, FILE *out, int *lineno)$/;"	f
tr_tm	.\src\sqliteInt.h	/^  u8 tr_tm;               \/* One of TRIGGER_BEFORE, TRIGGER_AFTER *\/$/;"	m	struct:Trigger
trace	.\src\mutex_unix.c	/^  int trace;                 \/* True to trace changes *\/$/;"	m	struct:sqlite3_mutex	file:
trace	.\src\mutex_w32.c	/^  volatile int trace;        \/* True to trace changes *\/$/;"	m	struct:sqlite3_mutex	file:
trace	.\src\sqlite3ext.h	/^  void * (*trace)(sqlite3*,void(*xTrace)(void*,const char*),void*);$/;"	m	struct:sqlite3_api_routines
traceCallback	.\test\speedtest1.c	/^static void traceCallback(void *NotUsed, const char *zSql){$/;"	f	file:
traceCallback	.\test\wordcount.c	/^static void traceCallback(void *NotUsed, const char *zSql){$/;"	f	file:
traceCallback	.\tool\fuzzershell.c	/^static void traceCallback(void *NotUsed, const char *zMsg){$/;"	f	file:
traceNoop	.\tool\fuzzershell.c	/^static void traceNoop(void *NotUsed, const char *zMsg){$/;"	f	file:
traceOut	.\src\shell.c	/^  FILE *traceOut;        \/* Output for sqlite3_trace() *\/$/;"	m	struct:ShellState	file:
trace_cmd	.\test\releasetest.tcl	/^proc trace_cmd {args} {$/;"	p
transCntrChng	.\src\os_unix.c	/^  unsigned char transCntrChng;   \/* True if the transaction counter changed *\/$/;"	m	struct:unixFile	file:
trans_opt	.\src\parse.y	/^trans_opt ::= .$/;"	l
trans_opt	.\src\parse.y	/^trans_opt ::= TRANSACTION nm.$/;"	l
trans_opt	.\src\parse.y	/^trans_opt ::= TRANSACTION.$/;"	l
transferJoinMarkings	.\src\whereexpr.c	/^static void transferJoinMarkings(Expr *pDerived, Expr *pBase){$/;"	f	file:
transferParseError	.\src\trigger.c	/^static void transferParseError(Parse *pTo, Parse *pFrom){$/;"	f	file:
transfer_bindings	.\src\sqlite3ext.h	/^  int  (*transfer_bindings)(sqlite3_stmt*,sqlite3_stmt*);$/;"	m	struct:sqlite3_api_routines
translateColumnToCopy	.\src\where.c	/^static void translateColumnToCopy($/;"	f	file:
translateP	.\src\vdbeaux.c	/^static int translateP(char c, const Op *pOp){$/;"	f	file:
translate_code	.\tool\lemon.c	/^PRIVATE void translate_code(struct lemon *lemp, struct rule *rp){$/;"	f
translen_to_charlen	.\ext\misc\spellfix.c	/^static int translen_to_charlen(const char *zIn, int nIn, int nTrans){$/;"	f	file:
translit	.\ext\misc\spellfix.c	/^} translit[] = {$/;"	v	typeref:struct:__anon5	file:
transliterate	.\ext\misc\spellfix.c	/^static unsigned char *transliterate(const unsigned char *zIn, int nIn){$/;"	f	file:
transliterateSqlFunc	.\ext\misc\spellfix.c	/^static void transliterateSqlFunc($/;"	f	file:
traverse	.\tool\loadfts.c	/^static void traverse($/;"	f	file:
tridxby	.\src\parse.y	/^tridxby ::= .$/;"	l
tridxby	.\src\parse.y	/^tridxby ::= INDEXED BY nm. {$/;"	l
tridxby	.\src\parse.y	/^tridxby ::= NOT INDEXED. {$/;"	l
trigHash	.\src\sqliteInt.h	/^  Hash trigHash;       \/* All triggers indexed by name *\/$/;"	m	struct:Schema
triggerStepAllocate	.\src\trigger.c	/^static TriggerStep *triggerStepAllocate($/;"	f	file:
trimFunc	.\src\func.c	/^static void trimFunc($/;"	f	file:
trimWhiteSpace	.\ext\fts1\fts1.c	/^static void trimWhiteSpace(StringBuffer *p){$/;"	f	file:
trimWhiteSpace	.\ext\fts2\fts2.c	/^static void trimWhiteSpace(StringBuffer *p){$/;"	f	file:
truncateOnCommit	.\src\wal.c	/^  u8 truncateOnCommit;       \/* True to truncate WAL file on commit *\/$/;"	m	struct:Wal	file:
truthProb	.\src\whereInt.h	/^  LogEst truthProb;       \/* Probability of truth for this expression *\/$/;"	m	struct:WhereTerm
trySql	.\mptest\mptest.c	/^static int trySql(const char *zFormat, ...){$/;"	f	file:
tryToClone	.\src\shell.c	/^static void tryToClone(ShellState *p, const char *zNewDb){$/;"	f	file:
tryToCloneData	.\src\shell.c	/^static void tryToCloneData($/;"	f	file:
tryToCloneSchema	.\src\shell.c	/^static void tryToCloneSchema($/;"	f	file:
ts	.\ext\fts5\fts5_main.c	/^  struct Fts5TransactionState ts;$/;"	m	struct:Fts5Table	typeref:struct:Fts5Table::Fts5TransactionState	file:
tsErrno	.\src\test_syscall.c	/^static int tsErrno(const char *zFunc){$/;"	f	file:
tsIsFail	.\src\test_syscall.c	/^static int tsIsFail(void){$/;"	f	file:
tsIsFailErrno	.\src\test_syscall.c	/^static int tsIsFailErrno(const char *zFunc){$/;"	f	file:
ts_access	.\src\test_syscall.c	/^static int ts_access(const char *zPath, int mode){$/;"	f	file:
ts_close	.\src\test_syscall.c	/^static int ts_close(int fd){$/;"	f	file:
ts_fallocate	.\src\test_syscall.c	/^static int ts_fallocate(int fd, off_t off, off_t len){$/;"	f	file:
ts_fchmod	.\src\test_syscall.c	/^static int ts_fchmod(int fd, mode_t mode){$/;"	f	file:
ts_fcntl	.\src\test_syscall.c	/^static int ts_fcntl(int fd, int cmd, ... ){$/;"	f	file:
ts_fstat	.\src\test_syscall.c	/^static int ts_fstat(int fd, struct stat *p){$/;"	f	file:
ts_ftruncate	.\src\test_syscall.c	/^static int ts_ftruncate(int fd, off_t n){$/;"	f	file:
ts_getcwd	.\src\test_syscall.c	/^static char *ts_getcwd(char *zPath, size_t nPath){$/;"	f	file:
ts_getpagesize	.\src\test_syscall.c	/^static int ts_getpagesize(void){$/;"	f	file:
ts_mmap	.\src\test_syscall.c	/^static void *ts_mmap($/;"	f	file:
ts_mremap	.\src\test_syscall.c	/^static void *ts_mremap(void *a, size_t b, size_t c, int d, ...){$/;"	f	file:
ts_open	.\src\test_syscall.c	/^static int ts_open(const char *zFile, int flags, int mode){$/;"	f	file:
ts_pread	.\src\test_syscall.c	/^static int ts_pread(int fd, void *aBuf, size_t nBuf, off_t off){$/;"	f	file:
ts_pread64	.\src\test_syscall.c	/^static int ts_pread64(int fd, void *aBuf, size_t nBuf, off_t off){$/;"	f	file:
ts_pwrite	.\src\test_syscall.c	/^static int ts_pwrite(int fd, const void *aBuf, size_t nBuf, off_t off){$/;"	f	file:
ts_pwrite64	.\src\test_syscall.c	/^static int ts_pwrite64(int fd, const void *aBuf, size_t nBuf, off_t off){$/;"	f	file:
ts_read	.\src\test_syscall.c	/^static int ts_read(int fd, void *aBuf, size_t nBuf){$/;"	f	file:
ts_stat	.\src\test_syscall.c	/^static int ts_stat(const char *zPath, struct stat *p){$/;"	f	file:
ts_write	.\src\test_syscall.c	/^static int ts_write(int fd, const void *aBuf, size_t nBuf){$/;"	f	file:
tvfsAccess	.\src\test_vfs.c	/^static int tvfsAccess($/;"	f	file:
tvfsAllocPage	.\src\test_vfs.c	/^static void tvfsAllocPage(TestvfsBuffer *p, int iPage, int pgsz){$/;"	f	file:
tvfsCheckReservedLock	.\src\test_vfs.c	/^static int tvfsCheckReservedLock(sqlite3_file *pFile, int *pResOut){$/;"	f	file:
tvfsClose	.\src\test_vfs.c	/^static int tvfsClose(sqlite3_file *pFile){$/;"	f	file:
tvfsCurrentTime	.\src\test_vfs.c	/^static int tvfsCurrentTime(sqlite3_vfs *pVfs, double *pTimeOut){$/;"	f	file:
tvfsDelete	.\src\test_vfs.c	/^static int tvfsDelete(sqlite3_vfs *pVfs, const char *zPath, int dirSync){$/;"	f	file:
tvfsDeviceCharacteristics	.\src\test_vfs.c	/^static int tvfsDeviceCharacteristics(sqlite3_file *pFile){$/;"	f	file:
tvfsDlClose	.\src\test_vfs.c	/^static void tvfsDlClose(sqlite3_vfs *pVfs, void *pHandle){$/;"	f	file:
tvfsDlError	.\src\test_vfs.c	/^static void tvfsDlError(sqlite3_vfs *pVfs, int nByte, char *zErrMsg){$/;"	f	file:
tvfsDlOpen	.\src\test_vfs.c	/^static void *tvfsDlOpen(sqlite3_vfs *pVfs, const char *zPath){$/;"	f	file:
tvfsDlSym	.\src\test_vfs.c	/^static void (*tvfsDlSym(sqlite3_vfs *pVfs, void *p, const char *zSym))(void){$/;"	f	file:
tvfsExecTcl	.\src\test_vfs.c	/^static void tvfsExecTcl($/;"	f	file:
tvfsFetch	.\src\test_vfs.c	/^static int tvfsFetch($/;"	f	file:
tvfsFileControl	.\src\test_vfs.c	/^static int tvfsFileControl(sqlite3_file *pFile, int op, void *pArg){$/;"	f	file:
tvfsFileSize	.\src\test_vfs.c	/^static int tvfsFileSize(sqlite3_file *pFile, sqlite_int64 *pSize){$/;"	f	file:
tvfsFullPathname	.\src\test_vfs.c	/^static int tvfsFullPathname($/;"	f	file:
tvfsGetFd	.\src\test_vfs.c	46;"	d	file:
tvfsInjectCantopenerr	.\src\test_vfs.c	/^static int tvfsInjectCantopenerr(Testvfs *p){$/;"	f	file:
tvfsInjectFault	.\src\test_vfs.c	/^static int tvfsInjectFault(TestFaultInject *p){$/;"	f	file:
tvfsInjectFullerr	.\src\test_vfs.c	/^static int tvfsInjectFullerr(Testvfs *p){$/;"	f	file:
tvfsInjectIoerr	.\src\test_vfs.c	/^static int tvfsInjectIoerr(Testvfs *p){$/;"	f	file:
tvfsLock	.\src\test_vfs.c	/^static int tvfsLock(sqlite3_file *pFile, int eLock){$/;"	f	file:
tvfsOpen	.\src\test_vfs.c	/^static int tvfsOpen($/;"	f	file:
tvfsRandomness	.\src\test_vfs.c	/^static int tvfsRandomness(sqlite3_vfs *pVfs, int nByte, char *zBufOut){$/;"	f	file:
tvfsRead	.\src\test_vfs.c	/^static int tvfsRead($/;"	f	file:
tvfsResultCode	.\src\test_vfs.c	/^static int tvfsResultCode(Testvfs *p, int *pRc){$/;"	f	file:
tvfsSectorSize	.\src\test_vfs.c	/^static int tvfsSectorSize(sqlite3_file *pFile){$/;"	f	file:
tvfsShmBarrier	.\src\test_vfs.c	/^static void tvfsShmBarrier(sqlite3_file *pFile){$/;"	f	file:
tvfsShmLock	.\src\test_vfs.c	/^static int tvfsShmLock($/;"	f	file:
tvfsShmMap	.\src\test_vfs.c	/^static int tvfsShmMap($/;"	f	file:
tvfsShmOpen	.\src\test_vfs.c	/^static int tvfsShmOpen(sqlite3_file *pFile){$/;"	f	file:
tvfsShmUnmap	.\src\test_vfs.c	/^static int tvfsShmUnmap($/;"	f	file:
tvfsSleep	.\src\test_vfs.c	/^static int tvfsSleep(sqlite3_vfs *pVfs, int nMicro){$/;"	f	file:
tvfsSync	.\src\test_vfs.c	/^static int tvfsSync(sqlite3_file *pFile, int flags){$/;"	f	file:
tvfsTruncate	.\src\test_vfs.c	/^static int tvfsTruncate(sqlite3_file *pFile, sqlite_int64 size){$/;"	f	file:
tvfsUnfetch	.\src\test_vfs.c	/^static int tvfsUnfetch(sqlite3_file *pFile, sqlite3_int64 iOfst, void *p){$/;"	f	file:
tvfsUnlock	.\src\test_vfs.c	/^static int tvfsUnlock(sqlite3_file *pFile, int eLock){$/;"	f	file:
tvfsWrite	.\src\test_vfs.c	/^static int tvfsWrite($/;"	f	file:
tvfs_io_methods	.\src\test_vfs.c	/^static sqlite3_io_methods tvfs_io_methods = {$/;"	v	file:
twoCoords	.\test\speedtest1.c	/^static void twoCoords($/;"	f	file:
type	.\src\parse.y	/^type ::= .$/;"	l
type	.\src\parse.y	/^type ::= typetoken(X).                   {sqlite3AddColumnType(pParse,&X);}$/;"	l
type	.\src\printf.c	/^  etByte type;             \/* Conversion paradigm *\/$/;"	m	struct:et_info	file:
type	.\tool\lemon.c	/^  enum e_action type;$/;"	m	struct:action	typeref:enum:action::e_action	file:
type	.\tool\lemon.c	/^  enum option_type type;$/;"	m	struct:s_options	typeref:enum:s_options::option_type	file:
type	.\tool\lemon.c	/^  enum symbol_type type;   \/* Symbols are all either TERMINALS or NTs *\/$/;"	m	struct:symbol	typeref:enum:symbol::symbol_type	file:
typeMask	.\src\vdbesort.c	/^  u8 typeMask;$/;"	m	struct:VdbeSorter	file:
typeofFunc	.\src\func.c	/^static void typeofFunc($/;"	f	file:
tz	.\src\date.c	/^  int tz;            \/* Timezone offset in minutes *\/$/;"	m	struct:DateTime	file:
u	.\ext\misc\json1.c	/^  } u;$/;"	m	struct:JsonNode	typeref:union:JsonNode::__anon4	file:
u	.\ext\rtree\rtree.c	/^  u32 u;             \/* Unsigned for byte-order conversions *\/$/;"	m	union:RtreeCoord	file:
u	.\ext\rtree\rtree.c	/^  } u;$/;"	m	struct:RtreeConstraint	typeref:union:RtreeConstraint::__anon6	file:
u	.\src\analyze.c	/^  } u;$/;"	m	struct:Stat4Sample	typeref:union:Stat4Sample::__anon7	file:
u	.\src\bitvec.c	/^  } u;$/;"	m	struct:Bitvec	typeref:union:Bitvec::__anon8	file:
u	.\src\mem3.c	/^  } u;$/;"	m	struct:Mem3Block	typeref:union:Mem3Block::__anon11	file:
u	.\src\sqliteInt.h	/^    } u;$/;"	m	struct:ExprList::ExprList_item	typeref:union:ExprList::ExprList_item::__anon17
u	.\src\sqliteInt.h	/^  } u;$/;"	m	struct:Expr	typeref:union:Expr::__anon15
u	.\src\sqliteInt.h	/^  } u;$/;"	m	struct:Walker	typeref:union:Walker::__anon22
u	.\src\vdbeInt.h	/^  } u;$/;"	m	struct:Mem	typeref:union:Mem::MemValue
u	.\src\vdbesort.c	/^  } u;$/;"	m	struct:SorterRecord	typeref:union:SorterRecord::__anon25	file:
u	.\src\whereInt.h	/^  } u;$/;"	m	struct:WhereLevel	typeref:union:WhereLevel::__anon26
u	.\src\whereInt.h	/^  } u;$/;"	m	struct:WhereLoop	typeref:union:WhereLoop::__anon28
u	.\src\whereInt.h	/^  } u;$/;"	m	struct:WhereTerm	typeref:union:WhereTerm::__anon31
u	.\test\threadtest3.c	/^  } u;$/;"	m	struct:MD5Context	typeref:union:MD5Context::__anon32	file:
u1	.\src\sqliteInt.h	/^    } u1;$/;"	m	struct:SrcList::SrcList_item	typeref:union:SrcList::SrcList_item::__anon20
u1	.\src\sqliteInt.h	/^  } u1;$/;"	m	struct:sqlite3	typeref:union:sqlite3::__anon14
u16	.\ext\fts5\fts5Int.h	/^typedef unsigned short u16;$/;"	t
u16	.\ext\misc\spellfix.c	/^  typedef unsigned short u16;$/;"	t	file:
u16	.\ext\rtree\rtree.c	/^typedef unsigned short u16;$/;"	t	file:
u16	.\src\sqliteInt.h	/^typedef UINT16_TYPE u16;           \/* 2-byte unsigned integer *\/$/;"	t
u16	.\tool\sqldiff.c	/^typedef unsigned short u16;$/;"	t	file:
u32	.\ext\fts3\fts3Int.h	/^typedef unsigned int u32;         \/* 4-byte unsigned integer *\/$/;"	t
u32	.\ext\fts5\fts5Int.h	/^typedef unsigned int   u32;$/;"	t
u32	.\ext\fts5\fts5_test_mi.c	/^typedef unsigned int u32;$/;"	t	file:
u32	.\ext\misc\json1.c	/^  typedef unsigned int u32;$/;"	t	file:
u32	.\ext\rbu\sqlite3rbu.c	/^typedef unsigned int u32;$/;"	t	file:
u32	.\ext\rtree\rtree.c	/^typedef unsigned int u32;$/;"	t	file:
u32	.\src\sqliteInt.h	/^typedef UINT32_TYPE u32;           \/* 4-byte unsigned integer *\/$/;"	t
u32	.\tool\sqldiff.c	/^typedef unsigned int u32;$/;"	t	file:
u64	.\ext\fts3\fts3Int.h	/^typedef sqlite3_uint64 u64;       \/* 8-byte unsigned integer *\/$/;"	t
u64	.\ext\fts5\fts5Int.h	/^typedef sqlite3_uint64 u64;$/;"	t
u64	.\ext\misc\json1.c	/^  typedef sqlite3_uint64 u64;$/;"	t	file:
u64	.\src\sqliteInt.h	/^typedef sqlite_uint64 u64;         \/* 8-byte unsigned integer *\/$/;"	t
u64	.\tool\varint.c	/^  typedef unsigned __int64 u64;$/;"	t	file:
u64	.\tool\varint.c	/^  typedef unsigned long long int u64;$/;"	t	file:
u8	.\ext\fts3\fts3Int.h	/^typedef unsigned char u8;         \/* 1-byte (or larger) unsigned integer *\/$/;"	t
u8	.\ext\fts5\fts5Int.h	/^typedef unsigned char  u8;$/;"	t
u8	.\ext\misc\json1.c	/^  typedef unsigned char u8;$/;"	t	file:
u8	.\ext\misc\spellfix.c	/^  typedef unsigned char u8;$/;"	t	file:
u8	.\ext\rbu\sqlite3rbu.c	/^typedef unsigned char u8;$/;"	t	file:
u8	.\ext\rtree\rtree.c	/^typedef unsigned char u8;$/;"	t	file:
u8	.\src\sqliteInt.h	/^typedef UINT8_TYPE u8;             \/* 1-byte unsigned integer *\/$/;"	t
u8	.\src\tclsqlite.c	/^  typedef unsigned char u8;$/;"	t	file:
u8	.\tool\offsets.c	/^typedef unsigned char u8;$/;"	t	file:
u8	.\tool\sqldiff.c	/^typedef unsigned char u8;$/;"	t	file:
uTemp	.\src\vdbeInt.h	/^  u32 uTemp;          \/* Transient storage for serial_type in OP_MakeRecord *\/$/;"	m	struct:Mem
uint32	.\src\tclsqlite.c	3193;"	d	file:
uint32	.\test\threadtest3.c	117;"	d	file:
unLockFlag	.\src\os_unix.c	/^  unsigned char unLockFlag;         \/* 1 = unlock, 0 = lock *\/$/;"	m	struct:ByteRangeLockPB2	file:
unaligned_string_counter	.\src\test1.c	/^static int unaligned_string_counter = 0;$/;"	v	file:
uncompressFunc	.\ext\misc\compress.c	/^static void uncompressFunc($/;"	f	file:
unicodeAddExceptions	.\ext\fts3\fts3_unicode.c	/^static int unicodeAddExceptions($/;"	f	file:
unicodeClose	.\ext\fts3\fts3_unicode.c	/^static int unicodeClose(sqlite3_tokenizer_cursor *pCursor){$/;"	f	file:
unicodeCreate	.\ext\fts3\fts3_unicode.c	/^static int unicodeCreate($/;"	f	file:
unicodeDestroy	.\ext\fts3\fts3_unicode.c	/^static int unicodeDestroy(sqlite3_tokenizer *pTokenizer){$/;"	f	file:
unicodeFunc	.\src\func.c	/^static void unicodeFunc($/;"	f	file:
unicodeIsAlnum	.\ext\fts3\fts3_unicode.c	/^static int unicodeIsAlnum(unicode_tokenizer *p, int iCode){$/;"	f	file:
unicodeIsException	.\ext\fts3\fts3_unicode.c	/^static int unicodeIsException(unicode_tokenizer *p, int iCode){$/;"	f	file:
unicodeNext	.\ext\fts3\fts3_unicode.c	/^static int unicodeNext($/;"	f	file:
unicodeOpen	.\ext\fts3\fts3_unicode.c	/^static int unicodeOpen($/;"	f	file:
unicode_cursor	.\ext\fts3\fts3_unicode.c	/^struct unicode_cursor {$/;"	s	file:
unicode_cursor	.\ext\fts3\fts3_unicode.c	/^typedef struct unicode_cursor unicode_cursor;$/;"	t	typeref:struct:unicode_cursor	file:
unicode_tokenizer	.\ext\fts3\fts3_unicode.c	/^struct unicode_tokenizer {$/;"	s	file:
unicode_tokenizer	.\ext\fts3\fts3_unicode.c	/^typedef struct unicode_tokenizer unicode_tokenizer;$/;"	t	typeref:struct:unicode_tokenizer	file:
uniqNotNull	.\src\sqliteInt.h	/^  unsigned uniqNotNull:1;  \/* True if UNIQUE and NOT NULL for all columns *\/$/;"	m	struct:Index
unixAccess	.\src\os_unix.c	/^static int unixAccess($/;"	f	file:
unixCheckReservedLock	.\src\os_unix.c	/^static int unixCheckReservedLock(sqlite3_file *id, int *pResOut){$/;"	f	file:
unixClose	.\src\os_unix.c	/^static int unixClose(sqlite3_file *id){$/;"	f	file:
unixCurrentTime	.\src\os_unix.c	/^static int unixCurrentTime(sqlite3_vfs *NotUsed, double *prNow){$/;"	f	file:
unixCurrentTimeInt64	.\src\os_unix.c	/^static int unixCurrentTimeInt64(sqlite3_vfs *NotUsed, sqlite3_int64 *piNow){$/;"	f	file:
unixDelete	.\src\os_unix.c	/^static int unixDelete($/;"	f	file:
unixDeviceCharacteristics	.\src\os_unix.c	/^static int unixDeviceCharacteristics(sqlite3_file *id){$/;"	f	file:
unixDlClose	.\src\os_unix.c	/^static void unixDlClose(sqlite3_vfs *NotUsed, void *pHandle){$/;"	f	file:
unixDlClose	.\src\os_unix.c	6114;"	d	file:
unixDlError	.\src\os_unix.c	/^static void unixDlError(sqlite3_vfs *NotUsed, int nBuf, char *zBufOut){$/;"	f	file:
unixDlError	.\src\os_unix.c	6112;"	d	file:
unixDlOpen	.\src\os_unix.c	/^static void *unixDlOpen(sqlite3_vfs *NotUsed, const char *zFilename){$/;"	f	file:
unixDlOpen	.\src\os_unix.c	6111;"	d	file:
unixDlSym	.\src\os_unix.c	/^static void (*unixDlSym(sqlite3_vfs *NotUsed, void *p, const char*zSym))(void){$/;"	f	file:
unixDlSym	.\src\os_unix.c	6113;"	d	file:
unixEnterMutex	.\src\os_unix.c	/^static void unixEnterMutex(void){$/;"	f	file:
unixFetch	.\src\os_unix.c	/^static int unixFetch(sqlite3_file *fd, i64 iOff, int nAmt, void **pp){$/;"	f	file:
unixFile	.\src\os_unix.c	/^struct unixFile {$/;"	s	file:
unixFile	.\src\os_unix.c	/^typedef struct unixFile unixFile;$/;"	t	typeref:struct:unixFile	file:
unixFileControl	.\src\os_unix.c	/^static int unixFileControl(sqlite3_file *id, int op, void *pArg){$/;"	f	file:
unixFileId	.\src\os_unix.c	/^struct unixFileId {$/;"	s	file:
unixFileLock	.\src\os_unix.c	/^static int unixFileLock(unixFile *pFile, struct flock *pLock){$/;"	f	file:
unixFileSize	.\src\os_unix.c	/^static int unixFileSize(sqlite3_file *id, i64 *pSize){$/;"	f	file:
unixFullPathname	.\src\os_unix.c	/^static int unixFullPathname($/;"	f	file:
unixGetLastError	.\src\os_unix.c	/^static int unixGetLastError(sqlite3_vfs *NotUsed, int NotUsed2, char *NotUsed3){$/;"	f	file:
unixGetSystemCall	.\src\os_unix.c	/^static sqlite3_syscall_ptr unixGetSystemCall($/;"	f	file:
unixGetTempname	.\src\os_unix.c	/^static int unixGetTempname(int nBuf, char *zBuf){$/;"	f	file:
unixGetpagesize	.\src\os_unix.c	/^static int unixGetpagesize(void){$/;"	f	file:
unixInodeInfo	.\src\os_unix.c	/^struct unixInodeInfo {$/;"	s	file:
unixInodeInfo	.\src\os_unix.c	/^typedef struct unixInodeInfo unixInodeInfo;   \/* An i-node *\/$/;"	t	typeref:struct:unixInodeInfo	file:
unixLeaveMutex	.\src\os_unix.c	/^static void unixLeaveMutex(void){$/;"	f	file:
unixLock	.\src\os_unix.c	/^static int unixLock(sqlite3_file *id, int eFileLock){$/;"	f	file:
unixLogError	.\src\os_unix.c	1113;"	d	file:
unixLogErrorAtLine	.\src\os_unix.c	/^static int unixLogErrorAtLine($/;"	f	file:
unixMapfile	.\src\os_unix.c	/^static int unixMapfile(unixFile *pFd, i64 nByte){$/;"	f	file:
unixModeBit	.\src\os_unix.c	/^static void unixModeBit(unixFile *pFile, unsigned char mask, int *pArg){$/;"	f	file:
unixMutexHeld	.\src\os_unix.c	/^static int unixMutexHeld(void) {$/;"	f	file:
unixNextSystemCall	.\src\os_unix.c	/^static const char *unixNextSystemCall(sqlite3_vfs *p, const char *zName){$/;"	f	file:
unixOpen	.\src\os_unix.c	/^static int unixOpen($/;"	f	file:
unixOpenSharedMemory	.\src\os_unix.c	/^static int unixOpenSharedMemory(unixFile *pDbFd){$/;"	f	file:
unixRandomness	.\src\os_unix.c	/^static int unixRandomness(sqlite3_vfs *NotUsed, int nBuf, char *zBuf){$/;"	f	file:
unixRead	.\src\os_unix.c	/^static int unixRead($/;"	f	file:
unixRemapfile	.\src\os_unix.c	/^static void unixRemapfile($/;"	f	file:
unixSectorSize	.\src\os_unix.c	/^static int unixSectorSize(sqlite3_file *NotUsed){$/;"	f	file:
unixSectorSize	.\src\os_unix.c	/^static int unixSectorSize(sqlite3_file *id){$/;"	f	file:
unixSetSystemCall	.\src\os_unix.c	/^static int unixSetSystemCall($/;"	f	file:
unixShm	.\src\os_unix.c	/^struct unixShm {$/;"	s	file:
unixShm	.\src\os_unix.c	/^typedef struct unixShm unixShm;               \/* Connection shared memory *\/$/;"	t	typeref:struct:unixShm	file:
unixShmBarrier	.\src\os_unix.c	/^static void unixShmBarrier($/;"	f	file:
unixShmBarrier	.\src\os_unix.c	4723;"	d	file:
unixShmLock	.\src\os_unix.c	/^static int unixShmLock($/;"	f	file:
unixShmLock	.\src\os_unix.c	4722;"	d	file:
unixShmMap	.\src\os_unix.c	/^static int unixShmMap($/;"	f	file:
unixShmMap	.\src\os_unix.c	4721;"	d	file:
unixShmNode	.\src\os_unix.c	/^struct unixShmNode {$/;"	s	file:
unixShmNode	.\src\os_unix.c	/^typedef struct unixShmNode unixShmNode;       \/* Shared memory instance *\/$/;"	t	typeref:struct:unixShmNode	file:
unixShmPurge	.\src\os_unix.c	/^static void unixShmPurge(unixFile *pFd){$/;"	f	file:
unixShmRegionPerMap	.\src\os_unix.c	/^static int unixShmRegionPerMap(void){$/;"	f	file:
unixShmSystemLock	.\src\os_unix.c	/^static int unixShmSystemLock($/;"	f	file:
unixShmUnmap	.\src\os_unix.c	/^static int unixShmUnmap($/;"	f	file:
unixShmUnmap	.\src\os_unix.c	4724;"	d	file:
unixSleep	.\src\os_unix.c	/^static int unixSleep(sqlite3_vfs *NotUsed, int microseconds){$/;"	f	file:
unixSync	.\src\os_unix.c	/^static int unixSync(sqlite3_file *id, int flags){$/;"	f	file:
unixTempFileDir	.\src\os_unix.c	/^static const char *unixTempFileDir(void){$/;"	f	file:
unixTruncate	.\src\os_unix.c	/^static int unixTruncate(sqlite3_file *id, i64 nByte){$/;"	f	file:
unixUnfetch	.\src\os_unix.c	/^static int unixUnfetch(sqlite3_file *fd, i64 iOff, void *p){$/;"	f	file:
unixUnlock	.\src\os_unix.c	/^static int unixUnlock(sqlite3_file *id, int eFileLock){$/;"	f	file:
unixUnmapfile	.\src\os_unix.c	/^static void unixUnmapfile(unixFile *pFd){$/;"	f	file:
unixWrite	.\src\os_unix.c	/^static int unixWrite($/;"	f	file:
unix_syscall	.\src\os_unix.c	/^static struct unix_syscall {$/;"	s	file:
unlikely	.\src\sqliteInt.h	431;"	d
unlinkAsyncFile	.\ext\async\sqlite3async.c	/^static int unlinkAsyncFile(AsyncFileData *pData){$/;"	f	file:
unlockBtreeIfUnused	.\src\btree.c	/^static void unlockBtreeIfUnused(BtShared *pBt){$/;"	f	file:
unlockBtreeMutex	.\src\btmutex.c	/^static void SQLITE_NOINLINE unlockBtreeMutex(Btree *p){$/;"	f	file:
unlock_notify	.\src\sqlite3ext.h	/^  int (*unlock_notify)(sqlite3*,void(*)(void**,int),void*);$/;"	m	struct:sqlite3_api_routines
unlock_notify_cb	.\src\test_thread.c	/^static void unlock_notify_cb(void **apArg, int nArg){$/;"	f	file:
unrecognizedArguments	.\mptest\mptest.c	/^static void unrecognizedArguments($/;"	f	file:
unregister_demovfs	.\src\test_demovfs.c	/^static int unregister_demovfs($/;"	f	file:
untestedTerms	.\src\whereInt.h	/^  u8 untestedTerms;         \/* Not all WHERE terms resolved by outer loop *\/$/;"	m	struct:WhereInfo
unused	.\src\wal.c	/^  u32 unused;                     \/* Unused (padding) field *\/$/;"	m	struct:WalIndexHdr	file:
updateAccumulator	.\src\select.c	/^static void updateAccumulator(Parse *pParse, AggInfo *pAggInfo){$/;"	f	file:
updateCost	.\ext\misc\spellfix.c	/^static void updateCost($/;"	f	file:
updateMapping	.\ext\rtree\rtree.c	/^static int updateMapping($/;"	f	file:
updateMaxBlobsize	.\src\vdbe.c	/^static void updateMaxBlobsize(Mem *p){$/;"	f	file:
updateVirtualTable	.\src\update.c	/^static void updateVirtualTable($/;"	f	file:
update_hook	.\src\sqlite3ext.h	/^  void * (*update_hook)(sqlite3*,void(*)(void*,int ,char const*,char const*,$/;"	m	struct:sqlite3_api_routines
upperFunc	.\src\func.c	/^static void upperFunc(sqlite3_context *context, int argc, sqlite3_value **argv){$/;"	f	file:
uri_boolean	.\src\sqlite3ext.h	/^  int (*uri_boolean)(const char*,const char*,int);$/;"	m	struct:sqlite3_api_routines
uri_int64	.\src\sqlite3ext.h	/^  sqlite3_int64 (*uri_int64)(const char*,const char*,sqlite3_int64);$/;"	m	struct:sqlite3_api_routines
uri_parameter	.\src\sqlite3ext.h	/^  const char *(*uri_parameter)(const char*,const char*);$/;"	m	struct:sqlite3_api_routines
usableSize	.\src\btreeInt.h	/^  u32 usableSize;       \/* Number of usable bytes on each page *\/$/;"	m	struct:BtShared
usage	.\ext\fts3\fts3speed.tcl	/^proc usage {} {$/;"	p
usage	.\ext\fts3\tool\fts3view.c	/^static void usage(const char *argv0){$/;"	f	file:
usage	.\ext\fts3\unicode\mkunicode.tcl	/^proc usage {} {$/;"	p
usage	.\ext\fts5\tool\fts5txt2db.tcl	/^proc usage {} {$/;"	p
usage	.\ext\fts5\tool\loadfts5.tcl	/^proc usage {} {$/;"	p
usage	.\ext\fts5\tool\showfts5.tcl	/^proc usage {} {$/;"	p
usage	.\ext\rbu\rbu.c	/^void usage(const char *zArgv0){$/;"	f
usage	.\mptest\mptest.c	/^static void usage(const char *argv0){$/;"	f	file:
usage	.\src\shell.c	/^static void usage(int showDetail){$/;"	f	file:
usage	.\tool\build-all-msvc.bat	/^:usage$/;"	l
usage	.\tool\getlock.c	/^static void usage(const char *argv0){$/;"	f	file:
usage	.\tool\rollback-test.c	/^static void usage(char *argv0){$/;"	f	file:
usage	.\tool\showdb.c	/^static void usage(const char *argv0){$/;"	f	file:
usage	.\tool\spaceanal.tcl	/^proc usage {} {$/;"	p
useCnt	.\tool\lemon.c	/^  int useCnt;              \/* Number of times used *\/$/;"	m	struct:symbol	file:
useEvalObjv	.\src\tclsqlite.c	/^  int useEvalObjv;      \/* True if it is safe to use Tcl_EvalObjv *\/$/;"	m	struct:SqlFunc	file:
useJournal	.\src\pager.c	/^  u8 useJournal;              \/* Use a rollback journal on this file *\/$/;"	m	struct:Pager	file:
useRandomRowid	.\src\vdbeInt.h	/^  Bool useRandomRowid:1;\/* Generate new record numbers semi-randomly *\/$/;"	m	struct:VdbeCursor
useSortingIdx	.\src\sqliteInt.h	/^  u8 useSortingIdx;       \/* In direct mode, reference the sorting index rather$/;"	m	struct:AggInfo
usedAsColumnCache	.\src\expr.c	/^static int usedAsColumnCache(Parse *pParse, int iFrom, int iTo){$/;"	f	file:
userAuthCheckLogin	.\ext\userauth\userauth.c	/^static int userAuthCheckLogin($/;"	f	file:
userTableExists	.\ext\userauth\userauth.c	/^static int userTableExists(sqlite3 *db, const char *zDb){$/;"	f	file:
user_data	.\src\sqlite3ext.h	/^  void * (*user_data)(sqlite3_context*);$/;"	m	struct:sqlite3_api_routines
user_templatename	.\tool\lemon.c	/^static char *user_templatename = NULL;$/;"	v	file:
usesStmtJournal	.\src\vdbeInt.h	/^  bft usesStmtJournal:1;  \/* True if uses a statement journal *\/$/;"	m	struct:Vdbe
uses_stmt_journal	.\src\test1.c	/^static int uses_stmt_journal($/;"	f	file:
utf8Charlen	.\ext\misc\spellfix.c	/^static int utf8Charlen(const char *zIn, int nIn){$/;"	f	file:
utf8Len	.\ext\misc\spellfix.c	/^static int utf8Len(unsigned char c, int N){$/;"	f	file:
utf8Read	.\ext\misc\spellfix.c	/^static int utf8Read(const unsigned char *z, int n, int *pSize){$/;"	f	file:
utf8_to_utf8	.\src\test_hexio.c	/^static int utf8_to_utf8($/;"	f	file:
v	.\src\rowset.c	/^  i64 v;                        \/* ROWID value for this entry *\/$/;"	m	struct:RowSetEntry	file:
v	.\src\vdbeInt.h	/^  Vdbe *v;                \/* VM this frame belongs to *\/$/;"	m	struct:VdbeFrame
v	.\src\vdbeaux.c	/^  Vdbe *v;                   \/* Vdbe to iterate through the opcodes of *\/$/;"	m	struct:VdbeOpIter	file:
v1	.\src\btreeInt.h	/^  int v1, v2;       \/* Values for up to two %d fields in zPfx *\/$/;"	m	struct:IntegrityCk
v2	.\src\btreeInt.h	/^  int v1, v2;       \/* Values for up to two %d fields in zPfx *\/$/;"	m	struct:IntegrityCk
vacuum1	.\test\tt3_vacuum.c	/^static void vacuum1(int nMs){$/;"	f	file:
vacuum1_thread_vacuumer	.\test\tt3_vacuum.c	/^static char *vacuum1_thread_vacuumer(int iTid, void *pArg){$/;"	f	file:
vacuum1_thread_writer	.\test\tt3_vacuum.c	/^static char *vacuum1_thread_writer(int iTid, void *pArg){$/;"	f	file:
vacuumFinalize	.\src\vacuum.c	/^static int vacuumFinalize(sqlite3 *db, sqlite3_stmt *pStmt, char **pzErrMsg){$/;"	f	file:
vacuumFinalize	.\tool\fast_vacuum.c	/^static void vacuumFinalize(sqlite3_stmt *pStmt){$/;"	f	file:
valid	.\src\shell.c	/^  int valid;          \/* Is there legit data in here? *\/$/;"	m	struct:SavedModeInfo	file:
validHMS	.\src\date.c	/^  char validHMS;     \/* True (1) if h,m,s are valid *\/$/;"	m	struct:DateTime	file:
validJD	.\src\date.c	/^  char validJD;      \/* True (1) if iJD is valid *\/$/;"	m	struct:DateTime	file:
validTZ	.\src\date.c	/^  char validTZ;      \/* True (1) if tz is valid *\/$/;"	m	struct:DateTime	file:
validYMD	.\src\date.c	/^  char validYMD;     \/* True (1) if Y,M,D are valid *\/$/;"	m	struct:DateTime	file:
value	.\autoconf\tea\win\nmakehlp.c	/^    char * value;$/;"	m	struct:list_item_t	file:
valueBytes	.\src\vdbemem.c	/^static SQLITE_NOINLINE int valueBytes(sqlite3_value *pVal, u8 enc){$/;"	f	file:
valueFromExpr	.\src\vdbemem.c	/^static int valueFromExpr($/;"	f	file:
valueFromFunction	.\src\vdbemem.c	/^static int valueFromFunction($/;"	f	file:
valueFromFunction	.\src\vdbemem.c	1257;"	d	file:
valueNew	.\src\vdbemem.c	/^static sqlite3_value *valueNew(sqlite3 *db, struct ValueNewStat4Ctx *p){$/;"	f	file:
valueToText	.\src\vdbemem.c	/^static SQLITE_NOINLINE const void *valueToText(sqlite3_value* pVal, u8 enc){$/;"	f	file:
value_blob	.\src\sqlite3ext.h	/^  const void * (*value_blob)(sqlite3_value*);$/;"	m	struct:sqlite3_api_routines
value_bytes	.\src\sqlite3ext.h	/^  int  (*value_bytes)(sqlite3_value*);$/;"	m	struct:sqlite3_api_routines
value_bytes16	.\src\sqlite3ext.h	/^  int  (*value_bytes16)(sqlite3_value*);$/;"	m	struct:sqlite3_api_routines
value_double	.\src\sqlite3ext.h	/^  double  (*value_double)(sqlite3_value*);$/;"	m	struct:sqlite3_api_routines
value_dup	.\src\sqlite3ext.h	/^  sqlite3_value *(*value_dup)(const sqlite3_value*);$/;"	m	struct:sqlite3_api_routines
value_free	.\src\sqlite3ext.h	/^  void (*value_free)(sqlite3_value*);$/;"	m	struct:sqlite3_api_routines
value_int	.\src\sqlite3ext.h	/^  int  (*value_int)(sqlite3_value*);$/;"	m	struct:sqlite3_api_routines
value_int64	.\src\sqlite3ext.h	/^  sqlite_int64  (*value_int64)(sqlite3_value*);$/;"	m	struct:sqlite3_api_routines
value_numeric_type	.\src\sqlite3ext.h	/^  int  (*value_numeric_type)(sqlite3_value*);$/;"	m	struct:sqlite3_api_routines
value_subtype	.\src\sqlite3ext.h	/^  unsigned int (*value_subtype)(sqlite3_value*);$/;"	m	struct:sqlite3_api_routines
value_text	.\src\sqlite3ext.h	/^  const unsigned char * (*value_text)(sqlite3_value*);$/;"	m	struct:sqlite3_api_routines
value_text16	.\src\sqlite3ext.h	/^  const void * (*value_text16)(sqlite3_value*);$/;"	m	struct:sqlite3_api_routines
value_text16be	.\src\sqlite3ext.h	/^  const void * (*value_text16be)(sqlite3_value*);$/;"	m	struct:sqlite3_api_routines
value_text16le	.\src\sqlite3ext.h	/^  const void * (*value_text16le)(sqlite3_value*);$/;"	m	struct:sqlite3_api_routines
value_type	.\src\sqlite3ext.h	/^  int  (*value_type)(sqlite3_value*);$/;"	m	struct:sqlite3_api_routines
vardest	.\tool\lemon.c	/^  char *vardest;           \/* Code for the default non-terminal destructor *\/$/;"	m	struct:lemon	file:
vartype	.\tool\lemon.c	/^  char *vartype;           \/* The default type of non-terminal symbols *\/$/;"	m	struct:lemon	file:
vdbeAssertFieldCountWithinLimits	.\src\vdbeaux.c	/^static void vdbeAssertFieldCountWithinLimits($/;"	f	file:
vdbeAssertFieldCountWithinLimits	.\src\vdbeaux.c	3459;"	d	file:
vdbeClrCopy	.\src\vdbemem.c	/^static SQLITE_NOINLINE void vdbeClrCopy(Mem *pTo, const Mem *pFrom, int eType){$/;"	f	file:
vdbeCommit	.\src\vdbeaux.c	/^static int vdbeCommit(sqlite3 *db, Vdbe *p){$/;"	f	file:
vdbeCompareMemString	.\src\vdbeaux.c	/^static int vdbeCompareMemString($/;"	f	file:
vdbeFreeOpArray	.\src\vdbeaux.c	/^static void vdbeFreeOpArray(sqlite3 *db, Op *aOp, int nOp){$/;"	f	file:
vdbeIncrBgPopulate	.\src\vdbesort.c	/^static int vdbeIncrBgPopulate(IncrMerger *pIncr){$/;"	f	file:
vdbeIncrFree	.\src\vdbesort.c	/^static void vdbeIncrFree(IncrMerger *pIncr){$/;"	f	file:
vdbeIncrMergerNew	.\src\vdbesort.c	/^static int vdbeIncrMergerNew($/;"	f	file:
vdbeIncrMergerSetThreads	.\src\vdbesort.c	/^static void vdbeIncrMergerSetThreads(IncrMerger *pIncr){$/;"	f	file:
vdbeIncrPopulate	.\src\vdbesort.c	/^static int vdbeIncrPopulate(IncrMerger *pIncr){$/;"	f	file:
vdbeIncrPopulateThread	.\src\vdbesort.c	/^static void *vdbeIncrPopulateThread(void *pCtx){$/;"	f	file:
vdbeIncrSwap	.\src\vdbesort.c	/^static int vdbeIncrSwap(IncrMerger *pIncr){$/;"	f	file:
vdbeInvokeSqllog	.\src\vdbeaux.c	/^static void vdbeInvokeSqllog(Vdbe *v){$/;"	f	file:
vdbeInvokeSqllog	.\src\vdbeaux.c	2629;"	d	file:
vdbeLeave	.\src\vdbeaux.c	/^static SQLITE_NOINLINE void vdbeLeave(Vdbe *p){$/;"	f	file:
vdbeMemAddTerminator	.\src\vdbemem.c	/^static SQLITE_NOINLINE int vdbeMemAddTerminator(Mem *pMem){$/;"	f	file:
vdbeMemClear	.\src\vdbemem.c	/^static SQLITE_NOINLINE void vdbeMemClear(Mem *p){$/;"	f	file:
vdbeMemClearExternAndSetNull	.\src\vdbemem.c	/^static SQLITE_NOINLINE void vdbeMemClearExternAndSetNull(Mem *p){$/;"	f	file:
vdbeMemFromBtreeResize	.\src\vdbemem.c	/^static SQLITE_NOINLINE int vdbeMemFromBtreeResize($/;"	f	file:
vdbeMergeEngineCompare	.\src\vdbesort.c	/^static void vdbeMergeEngineCompare($/;"	f	file:
vdbeMergeEngineFree	.\src\vdbesort.c	/^static void vdbeMergeEngineFree(MergeEngine *pMerger){$/;"	f	file:
vdbeMergeEngineInit	.\src\vdbesort.c	/^static int vdbeMergeEngineInit($/;"	f	file:
vdbeMergeEngineLevel0	.\src\vdbesort.c	/^static int vdbeMergeEngineLevel0($/;"	f	file:
vdbeMergeEngineNew	.\src\vdbesort.c	/^static MergeEngine *vdbeMergeEngineNew(int nReader){$/;"	f	file:
vdbeMergeEngineStep	.\src\vdbesort.c	/^static int vdbeMergeEngineStep($/;"	f	file:
vdbePmaReadBlob	.\src\vdbesort.c	/^static int vdbePmaReadBlob($/;"	f	file:
vdbePmaReadVarint	.\src\vdbesort.c	/^static int vdbePmaReadVarint(PmaReader *p, u64 *pnOut){$/;"	f	file:
vdbePmaReaderBgIncrInit	.\src\vdbesort.c	/^static void *vdbePmaReaderBgIncrInit(void *pCtx){$/;"	f	file:
vdbePmaReaderClear	.\src\vdbesort.c	/^static void vdbePmaReaderClear(PmaReader *pReadr){$/;"	f	file:
vdbePmaReaderIncrInit	.\src\vdbesort.c	/^static int vdbePmaReaderIncrInit(PmaReader *pReadr, int eMode){$/;"	f	file:
vdbePmaReaderIncrMergeInit	.\src\vdbesort.c	/^static int vdbePmaReaderIncrMergeInit(PmaReader *pReadr, int eMode){$/;"	f	file:
vdbePmaReaderInit	.\src\vdbesort.c	/^static int vdbePmaReaderInit($/;"	f	file:
vdbePmaReaderNext	.\src\vdbesort.c	/^static int vdbePmaReaderNext(PmaReader *pReadr){$/;"	f	file:
vdbePmaReaderSeek	.\src\vdbesort.c	/^static int vdbePmaReaderSeek($/;"	f	file:
vdbePmaWriteBlob	.\src\vdbesort.c	/^static void vdbePmaWriteBlob(PmaWriter *p, u8 *pData, int nData){$/;"	f	file:
vdbePmaWriteVarint	.\src\vdbesort.c	/^static void vdbePmaWriteVarint(PmaWriter *p, u64 iVal){$/;"	f	file:
vdbePmaWriterFinish	.\src\vdbesort.c	/^static int vdbePmaWriterFinish(PmaWriter *p, i64 *piEof){$/;"	f	file:
vdbePmaWriterInit	.\src\vdbesort.c	/^static void vdbePmaWriterInit($/;"	f	file:
vdbeRecordCompareDebug	.\src\vdbeaux.c	/^static int vdbeRecordCompareDebug($/;"	f	file:
vdbeRecordCompareInt	.\src\vdbeaux.c	/^static int vdbeRecordCompareInt($/;"	f	file:
vdbeRecordCompareString	.\src\vdbeaux.c	/^static int vdbeRecordCompareString($/;"	f	file:
vdbeRecordDecodeInt	.\src\vdbeaux.c	/^static i64 vdbeRecordDecodeInt(u32 serial_type, const u8 *aKey){$/;"	f	file:
vdbeReleaseAndSetInt64	.\src\vdbemem.c	/^static SQLITE_NOINLINE void vdbeReleaseAndSetInt64(Mem *pMem, i64 val){$/;"	f	file:
vdbeSafety	.\src\vdbeapi.c	/^static int vdbeSafety(Vdbe *p){$/;"	f	file:
vdbeSafetyNotNull	.\src\vdbeapi.c	/^static int vdbeSafetyNotNull(Vdbe *p){$/;"	f	file:
vdbeSortAllocUnpacked	.\src\vdbesort.c	/^static int vdbeSortAllocUnpacked(SortSubtask *pTask){$/;"	f	file:
vdbeSortSubtaskCleanup	.\src\vdbesort.c	/^static void vdbeSortSubtaskCleanup(sqlite3 *db, SortSubtask *pTask){$/;"	f	file:
vdbeSorterAddToTree	.\src\vdbesort.c	/^static int vdbeSorterAddToTree($/;"	f	file:
vdbeSorterBlockDebug	.\src\vdbesort.c	/^static void vdbeSorterBlockDebug($/;"	f	file:
vdbeSorterBlockDebug	.\src\vdbesort.c	1093;"	d	file:
vdbeSorterCompare	.\src\vdbesort.c	/^static int vdbeSorterCompare($/;"	f	file:
vdbeSorterCompareInt	.\src\vdbesort.c	/^static int vdbeSorterCompareInt($/;"	f	file:
vdbeSorterCompareTail	.\src\vdbesort.c	/^static int vdbeSorterCompareTail($/;"	f	file:
vdbeSorterCompareText	.\src\vdbesort.c	/^static int vdbeSorterCompareText($/;"	f	file:
vdbeSorterCreateThread	.\src\vdbesort.c	/^static int vdbeSorterCreateThread($/;"	f	file:
vdbeSorterExtendFile	.\src\vdbesort.c	/^static void vdbeSorterExtendFile(sqlite3 *db, sqlite3_file *pFd, i64 nByte){$/;"	f	file:
vdbeSorterExtendFile	.\src\vdbesort.c	1282;"	d	file:
vdbeSorterFlushPMA	.\src\vdbesort.c	/^static int vdbeSorterFlushPMA(VdbeSorter *pSorter){$/;"	f	file:
vdbeSorterFlushThread	.\src\vdbesort.c	/^static void *vdbeSorterFlushThread(void *pCtx){$/;"	f	file:
vdbeSorterGetCompare	.\src\vdbesort.c	/^static SorterCompare vdbeSorterGetCompare(VdbeSorter *p){$/;"	f	file:
vdbeSorterJoinAll	.\src\vdbesort.c	/^static int vdbeSorterJoinAll(VdbeSorter *pSorter, int rcin){$/;"	f	file:
vdbeSorterJoinAll	.\src\vdbesort.c	1153;"	d	file:
vdbeSorterJoinThread	.\src\vdbesort.c	/^static int vdbeSorterJoinThread(SortSubtask *pTask){$/;"	f	file:
vdbeSorterJoinThread	.\src\vdbesort.c	1154;"	d	file:
vdbeSorterListToPMA	.\src\vdbesort.c	/^static int vdbeSorterListToPMA(SortSubtask *pTask, SorterList *pList){$/;"	f	file:
vdbeSorterMapFile	.\src\vdbesort.c	/^static int vdbeSorterMapFile(SortSubtask *pTask, SorterFile *pFile, u8 **pp){$/;"	f	file:
vdbeSorterMerge	.\src\vdbesort.c	/^static void vdbeSorterMerge($/;"	f	file:
vdbeSorterMergeTreeBuild	.\src\vdbesort.c	/^static int vdbeSorterMergeTreeBuild($/;"	f	file:
vdbeSorterOpenTempFile	.\src\vdbesort.c	/^static int vdbeSorterOpenTempFile($/;"	f	file:
vdbeSorterPopulateDebug	.\src\vdbesort.c	/^static void vdbeSorterPopulateDebug($/;"	f	file:
vdbeSorterPopulateDebug	.\src\vdbesort.c	1092;"	d	file:
vdbeSorterRecordFree	.\src\vdbesort.c	/^static void vdbeSorterRecordFree(sqlite3 *db, SorterRecord *pRecord){$/;"	f	file:
vdbeSorterRewindDebug	.\src\vdbesort.c	/^static void vdbeSorterRewindDebug(const char *zEvent){$/;"	f	file:
vdbeSorterRewindDebug	.\src\vdbesort.c	1091;"	d	file:
vdbeSorterRowkey	.\src\vdbesort.c	/^static void *vdbeSorterRowkey($/;"	f	file:
vdbeSorterSetupMerge	.\src\vdbesort.c	/^static int vdbeSorterSetupMerge(VdbeSorter *pSorter){$/;"	f	file:
vdbeSorterSort	.\src\vdbesort.c	/^static int vdbeSorterSort(SortSubtask *pTask, SorterList *pList){$/;"	f	file:
vdbeSorterTreeDepth	.\src\vdbesort.c	/^static int vdbeSorterTreeDepth(int nPMA){$/;"	f	file:
vdbeSorterWorkDebug	.\src\vdbesort.c	/^static void vdbeSorterWorkDebug(SortSubtask *pTask, const char *zEvent){$/;"	f	file:
vdbeSorterWorkDebug	.\src\vdbesort.c	1090;"	d	file:
vdbeTakeBranch	.\src\vdbe.c	/^  static void vdbeTakeBranch(int iSrcLine, u8 I, u8 M){$/;"	f	file:
vdbeUnbind	.\src\vdbeapi.c	/^static int vdbeUnbind(Vdbe *p, int i){$/;"	f	file:
vdbeVComment	.\src\vdbeaux.c	/^static void vdbeVComment(Vdbe *p, const char *zFormat, va_list ap){$/;"	f	file:
verbose	.\test\tester.tcl	/^proc verbose {} {$/;"	p
verbose	.\test\threadtest1.c	/^static int verbose = 0;$/;"	v	file:
verifyDbFile	.\src\os_unix.c	/^static void verifyDbFile(unixFile *pFile){$/;"	f	file:
verify_ex_errcode	.\test\tester.tcl	/^proc verify_ex_errcode {name expected {db db}} {$/;"	p
versionFunc	.\src\func.c	/^static void versionFunc($/;"	f	file:
vfsFlags	.\src\pager.c	/^  u32 vfsFlags;               \/* Flags for sqlite3_vfs.xOpen() *\/$/;"	m	struct:Pager	file:
vfsList	.\src\os.c	/^static sqlite3_vfs * SQLITE_WSD vfsList = 0;$/;"	v	file:
vfsList	.\src\os.c	306;"	d	file:
vfsNameFunc	.\mptest\mptest.c	/^static void vfsNameFunc($/;"	f	file:
vfsUnlink	.\src\os.c	/^static void vfsUnlink(sqlite3_vfs *pVfs){$/;"	f	file:
vfs_find	.\src\sqlite3ext.h	/^  sqlite3_vfs *(*vfs_find)(const char*);$/;"	m	struct:sqlite3_api_routines
vfs_initfail_test	.\src\test1.c	/^static int vfs_initfail_test($/;"	f	file:
vfs_list	.\src\test1.c	/^static int vfs_list($/;"	f	file:
vfs_register	.\src\sqlite3ext.h	/^  int (*vfs_register)(sqlite3_vfs*,int);$/;"	m	struct:sqlite3_api_routines
vfs_reregister_all	.\src\test1.c	/^static int vfs_reregister_all($/;"	f	file:
vfs_unlink_test	.\src\test1.c	/^static int vfs_unlink_test($/;"	f	file:
vfs_unregister	.\src\sqlite3ext.h	/^  int (*vfs_unregister)(sqlite3_vfs*);$/;"	m	struct:sqlite3_api_routines
vfs_unregister_all	.\src\test1.c	/^static int vfs_unregister_all($/;"	f	file:
vfslogAccess	.\src\test_osinst.c	/^static int vfslogAccess($/;"	f	file:
vfslogCheckReservedLock	.\src\test_osinst.c	/^static int vfslogCheckReservedLock(sqlite3_file *pFile, int *pResOut){$/;"	f	file:
vfslogClose	.\src\test_osinst.c	/^static int vfslogClose(sqlite3_file *pFile){$/;"	f	file:
vfslogCurrentTime	.\src\test_osinst.c	/^static int vfslogCurrentTime(sqlite3_vfs *pVfs, double *pTimeOut){$/;"	f	file:
vfslogCurrentTimeInt64	.\src\test_osinst.c	/^static int vfslogCurrentTimeInt64(sqlite3_vfs *pVfs, sqlite3_int64 *p){$/;"	f	file:
vfslogDelete	.\src\test_osinst.c	/^static int vfslogDelete(sqlite3_vfs *pVfs, const char *zPath, int dirSync){$/;"	f	file:
vfslogDeviceCharacteristics	.\src\test_osinst.c	/^static int vfslogDeviceCharacteristics(sqlite3_file *pFile){$/;"	f	file:
vfslogDlClose	.\src\test_osinst.c	/^static void vfslogDlClose(sqlite3_vfs *pVfs, void *pHandle){$/;"	f	file:
vfslogDlError	.\src\test_osinst.c	/^static void vfslogDlError(sqlite3_vfs *pVfs, int nByte, char *zErrMsg){$/;"	f	file:
vfslogDlOpen	.\src\test_osinst.c	/^static void *vfslogDlOpen(sqlite3_vfs *pVfs, const char *zPath){$/;"	f	file:
vfslogDlSym	.\src\test_osinst.c	/^static void (*vfslogDlSym(sqlite3_vfs *pVfs, void *p, const char *zSym))(void){$/;"	f	file:
vfslogFileControl	.\src\test_osinst.c	/^static int vfslogFileControl(sqlite3_file *pFile, int op, void *pArg){$/;"	f	file:
vfslogFileSize	.\src\test_osinst.c	/^static int vfslogFileSize(sqlite3_file *pFile, sqlite_int64 *pSize){$/;"	f	file:
vfslogFullPathname	.\src\test_osinst.c	/^static int vfslogFullPathname($/;"	f	file:
vfslogGetLastError	.\src\test_osinst.c	/^static int vfslogGetLastError(sqlite3_vfs *pVfs, int a, char *b){$/;"	f	file:
vfslogLock	.\src\test_osinst.c	/^static int vfslogLock(sqlite3_file *pFile, int eLock){$/;"	f	file:
vfslogOpen	.\src\test_osinst.c	/^static int vfslogOpen($/;"	f	file:
vfslogRandomness	.\src\test_osinst.c	/^static int vfslogRandomness(sqlite3_vfs *pVfs, int nByte, char *zBufOut){$/;"	f	file:
vfslogRead	.\src\test_osinst.c	/^static int vfslogRead($/;"	f	file:
vfslogSectorSize	.\src\test_osinst.c	/^static int vfslogSectorSize(sqlite3_file *pFile){$/;"	f	file:
vfslogShmBarrier	.\src\test_osinst.c	/^static void vfslogShmBarrier(sqlite3_file *pFile){$/;"	f	file:
vfslogShmLock	.\src\test_osinst.c	/^static int vfslogShmLock(sqlite3_file *pFile, int ofst, int n, int flags){$/;"	f	file:
vfslogShmMap	.\src\test_osinst.c	/^static int vfslogShmMap($/;"	f	file:
vfslogShmUnmap	.\src\test_osinst.c	/^static int vfslogShmUnmap(sqlite3_file *pFile, int deleteFlag){$/;"	f	file:
vfslogSleep	.\src\test_osinst.c	/^static int vfslogSleep(sqlite3_vfs *pVfs, int nMicro){$/;"	f	file:
vfslogSync	.\src\test_osinst.c	/^static int vfslogSync(sqlite3_file *pFile, int flags){$/;"	f	file:
vfslogTruncate	.\src\test_osinst.c	/^static int vfslogTruncate(sqlite3_file *pFile, sqlite_int64 size){$/;"	f	file:
vfslogUnlock	.\src\test_osinst.c	/^static int vfslogUnlock(sqlite3_file *pFile, int eLock){$/;"	f	file:
vfslogWrite	.\src\test_osinst.c	/^static int vfslogWrite($/;"	f	file:
vfslog_call	.\src\test_osinst.c	/^static void vfslog_call($/;"	f	file:
vfslog_eventname	.\src\test_osinst.c	/^static const char *vfslog_eventname(int eEvent){$/;"	f	file:
vfslog_finalize	.\src\test_osinst.c	/^static void vfslog_finalize(VfslogVfs *p){$/;"	f	file:
vfslog_flush	.\src\test_osinst.c	/^static void vfslog_flush(VfslogVfs *p){$/;"	f	file:
vfslog_io_methods	.\src\test_osinst.c	/^static sqlite3_io_methods vfslog_io_methods = {$/;"	v	file:
vfslog_string	.\src\test_osinst.c	/^static void vfslog_string(sqlite3_vfs *pVfs, const char *zStr){$/;"	f	file:
vfslog_time	.\src\test_osinst.c	/^static sqlite3_uint64 vfslog_time(){$/;"	f	file:
vfslog_vfs	.\src\test_osinst.c	/^static sqlite3_vfs vfslog_vfs = {$/;"	v	file:
vfstraceAccess	.\src\test_vfstrace.c	/^static int vfstraceAccess($/;"	f	file:
vfstraceCheckReservedLock	.\src\test_vfstrace.c	/^static int vfstraceCheckReservedLock(sqlite3_file *pFile, int *pResOut){$/;"	f	file:
vfstraceClose	.\src\test_vfstrace.c	/^static int vfstraceClose(sqlite3_file *pFile){$/;"	f	file:
vfstraceCurrentTime	.\src\test_vfstrace.c	/^static int vfstraceCurrentTime(sqlite3_vfs *pVfs, double *pTimeOut){$/;"	f	file:
vfstraceCurrentTimeInt64	.\src\test_vfstrace.c	/^static int vfstraceCurrentTimeInt64(sqlite3_vfs *pVfs, sqlite3_int64 *pTimeOut){$/;"	f	file:
vfstraceDelete	.\src\test_vfstrace.c	/^static int vfstraceDelete(sqlite3_vfs *pVfs, const char *zPath, int dirSync){$/;"	f	file:
vfstraceDeviceCharacteristics	.\src\test_vfstrace.c	/^static int vfstraceDeviceCharacteristics(sqlite3_file *pFile){$/;"	f	file:
vfstraceDlClose	.\src\test_vfstrace.c	/^static void vfstraceDlClose(sqlite3_vfs *pVfs, void *pHandle){$/;"	f	file:
vfstraceDlError	.\src\test_vfstrace.c	/^static void vfstraceDlError(sqlite3_vfs *pVfs, int nByte, char *zErrMsg){$/;"	f	file:
vfstraceDlOpen	.\src\test_vfstrace.c	/^static void *vfstraceDlOpen(sqlite3_vfs *pVfs, const char *zPath){$/;"	f	file:
vfstraceDlSym	.\src\test_vfstrace.c	/^static void (*vfstraceDlSym(sqlite3_vfs *pVfs,void *p,const char *zSym))(void){$/;"	f	file:
vfstraceFileControl	.\src\test_vfstrace.c	/^static int vfstraceFileControl(sqlite3_file *pFile, int op, void *pArg){$/;"	f	file:
vfstraceFileSize	.\src\test_vfstrace.c	/^static int vfstraceFileSize(sqlite3_file *pFile, sqlite_int64 *pSize){$/;"	f	file:
vfstraceFullPathname	.\src\test_vfstrace.c	/^static int vfstraceFullPathname($/;"	f	file:
vfstraceGetLastError	.\src\test_vfstrace.c	/^static int vfstraceGetLastError(sqlite3_vfs *pVfs, int iErr, char *zErr){$/;"	f	file:
vfstraceGetSystemCall	.\src\test_vfstrace.c	/^static sqlite3_syscall_ptr vfstraceGetSystemCall($/;"	f	file:
vfstraceLock	.\src\test_vfstrace.c	/^static int vfstraceLock(sqlite3_file *pFile, int eLock){$/;"	f	file:
vfstraceNextSystemCall	.\src\test_vfstrace.c	/^static const char *vfstraceNextSystemCall(sqlite3_vfs *pVfs, const char *zName){$/;"	f	file:
vfstraceOpen	.\src\test_vfstrace.c	/^static int vfstraceOpen($/;"	f	file:
vfstraceRandomness	.\src\test_vfstrace.c	/^static int vfstraceRandomness(sqlite3_vfs *pVfs, int nByte, char *zBufOut){$/;"	f	file:
vfstraceRead	.\src\test_vfstrace.c	/^static int vfstraceRead($/;"	f	file:
vfstraceSectorSize	.\src\test_vfstrace.c	/^static int vfstraceSectorSize(sqlite3_file *pFile){$/;"	f	file:
vfstraceSetSystemCall	.\src\test_vfstrace.c	/^static int vfstraceSetSystemCall($/;"	f	file:
vfstraceShmBarrier	.\src\test_vfstrace.c	/^static void vfstraceShmBarrier(sqlite3_file *pFile){$/;"	f	file:
vfstraceShmLock	.\src\test_vfstrace.c	/^static int vfstraceShmLock(sqlite3_file *pFile, int ofst, int n, int flags){$/;"	f	file:
vfstraceShmMap	.\src\test_vfstrace.c	/^static int vfstraceShmMap($/;"	f	file:
vfstraceShmUnmap	.\src\test_vfstrace.c	/^static int vfstraceShmUnmap(sqlite3_file *pFile, int delFlag){$/;"	f	file:
vfstraceSleep	.\src\test_vfstrace.c	/^static int vfstraceSleep(sqlite3_vfs *pVfs, int nMicro){$/;"	f	file:
vfstraceSync	.\src\test_vfstrace.c	/^static int vfstraceSync(sqlite3_file *pFile, int flags){$/;"	f	file:
vfstraceTruncate	.\src\test_vfstrace.c	/^static int vfstraceTruncate(sqlite3_file *pFile, sqlite_int64 size){$/;"	f	file:
vfstraceUnlock	.\src\test_vfstrace.c	/^static int vfstraceUnlock(sqlite3_file *pFile, int eLock){$/;"	f	file:
vfstraceWrite	.\src\test_vfstrace.c	/^static int vfstraceWrite($/;"	f	file:
vfstrace_file	.\src\test_vfstrace.c	/^struct vfstrace_file {$/;"	s	file:
vfstrace_file	.\src\test_vfstrace.c	/^typedef struct vfstrace_file vfstrace_file;$/;"	t	typeref:struct:vfstrace_file	file:
vfstrace_info	.\src\test_vfstrace.c	/^struct vfstrace_info {$/;"	s	file:
vfstrace_info	.\src\test_vfstrace.c	/^typedef struct vfstrace_info vfstrace_info;$/;"	t	typeref:struct:vfstrace_info	file:
vfstrace_print_errcode	.\src\test_vfstrace.c	/^static void vfstrace_print_errcode($/;"	f	file:
vfstrace_printf	.\src\test_vfstrace.c	/^static void vfstrace_printf($/;"	f	file:
vfstrace_register	.\src\test_vfstrace.c	/^int vfstrace_register($/;"	f
viaCoroutine	.\src\sqliteInt.h	/^      unsigned viaCoroutine :1;  \/* Implemented as a co-routine *\/$/;"	m	struct:SrcList::SrcList_item::__anon19
view_node	.\ext\rtree\viewrtree.tcl	/^proc view_node {} {$/;"	p
visit_file	.\tool\loadfts.c	/^void visit_file(void *pCtx, const char *zPath){$/;"	f
vlogAccess	.\ext\misc\vfslog.c	/^static int vlogAccess($/;"	f	file:
vlogBestIndex	.\src\test_osinst.c	/^static int vlogBestIndex(sqlite3_vtab *tab, sqlite3_index_info *pIdxInfo){$/;"	f	file:
vlogCheckReservedLock	.\ext\misc\vfslog.c	/^static int vlogCheckReservedLock(sqlite3_file *pFile, int *pResOut){$/;"	f	file:
vlogClose	.\ext\misc\vfslog.c	/^static int vlogClose(sqlite3_file *pFile){$/;"	f	file:
vlogClose	.\src\test_osinst.c	/^static int vlogClose(sqlite3_vtab_cursor *pCursor){$/;"	f	file:
vlogColumn	.\src\test_osinst.c	/^static int vlogColumn($/;"	f	file:
vlogConnect	.\src\test_osinst.c	/^static int vlogConnect($/;"	f	file:
vlogCurrentTime	.\ext\misc\vfslog.c	/^static int vlogCurrentTime(sqlite3_vfs *pVfs, double *pTimeOut){$/;"	f	file:
vlogCurrentTimeInt64	.\ext\misc\vfslog.c	/^static int vlogCurrentTimeInt64(sqlite3_vfs *pVfs, sqlite3_int64 *p){$/;"	f	file:
vlogDelete	.\ext\misc\vfslog.c	/^static int vlogDelete(sqlite3_vfs *pVfs, const char *zPath, int dirSync){$/;"	f	file:
vlogDeviceCharacteristics	.\ext\misc\vfslog.c	/^static int vlogDeviceCharacteristics(sqlite3_file *pFile){$/;"	f	file:
vlogDisconnect	.\src\test_osinst.c	/^static int vlogDisconnect(sqlite3_vtab *pVtab){$/;"	f	file:
vlogDlClose	.\ext\misc\vfslog.c	/^static void vlogDlClose(sqlite3_vfs *pVfs, void *pHandle){$/;"	f	file:
vlogDlError	.\ext\misc\vfslog.c	/^static void vlogDlError(sqlite3_vfs *pVfs, int nByte, char *zErrMsg){$/;"	f	file:
vlogDlOpen	.\ext\misc\vfslog.c	/^static void *vlogDlOpen(sqlite3_vfs *pVfs, const char *zPath){$/;"	f	file:
vlogDlSym	.\ext\misc\vfslog.c	/^static void (*vlogDlSym(sqlite3_vfs *pVfs, void *p, const char *zSym))(void){$/;"	f	file:
vlogEof	.\src\test_osinst.c	/^static int vlogEof(sqlite3_vtab_cursor *pCursor){$/;"	f	file:
vlogFileControl	.\ext\misc\vfslog.c	/^static int vlogFileControl(sqlite3_file *pFile, int op, void *pArg){$/;"	f	file:
vlogFileSize	.\ext\misc\vfslog.c	/^static int vlogFileSize(sqlite3_file *pFile, sqlite_int64 *pSize){$/;"	f	file:
vlogFilter	.\src\test_osinst.c	/^static int vlogFilter($/;"	f	file:
vlogFullPathname	.\ext\misc\vfslog.c	/^static int vlogFullPathname($/;"	f	file:
vlogGetLastError	.\ext\misc\vfslog.c	/^static int vlogGetLastError(sqlite3_vfs *pVfs, int a, char *b){$/;"	f	file:
vlogLock	.\ext\misc\vfslog.c	/^static int vlogLock(sqlite3_file *pFile, int eLock){$/;"	f	file:
vlogLogClose	.\ext\misc\vfslog.c	/^static void vlogLogClose(VLogLog *p){$/;"	f	file:
vlogLogOpen	.\ext\misc\vfslog.c	/^static VLogLog *vlogLogOpen(const char *zFilename){$/;"	f	file:
vlogLogPrint	.\ext\misc\vfslog.c	/^static void vlogLogPrint($/;"	f	file:
vlogNext	.\src\test_osinst.c	/^static int vlogNext(sqlite3_vtab_cursor *pCursor){$/;"	f	file:
vlogOpen	.\ext\misc\vfslog.c	/^static int vlogOpen($/;"	f	file:
vlogOpen	.\src\test_osinst.c	/^static int vlogOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor){$/;"	f	file:
vlogRandomness	.\ext\misc\vfslog.c	/^static int vlogRandomness(sqlite3_vfs *pVfs, int nByte, char *zBufOut){$/;"	f	file:
vlogRead	.\ext\misc\vfslog.c	/^static int vlogRead($/;"	f	file:
vlogRowid	.\src\test_osinst.c	/^static int vlogRowid(sqlite3_vtab_cursor *pCursor, sqlite_int64 *pRowid){$/;"	f	file:
vlogSectorSize	.\ext\misc\vfslog.c	/^static int vlogSectorSize(sqlite3_file *pFile){$/;"	f	file:
vlogSignature	.\ext\misc\vfslog.c	/^static void vlogSignature(unsigned char *p, int n, char *zCksum){$/;"	f	file:
vlogSignature	.\tool\pagesig.c	/^static void vlogSignature(unsigned char *p, int n, char *zCksum){$/;"	f	file:
vlogSleep	.\ext\misc\vfslog.c	/^static int vlogSleep(sqlite3_vfs *pVfs, int nMicro){$/;"	f	file:
vlogSync	.\ext\misc\vfslog.c	/^static int vlogSync(sqlite3_file *pFile, int flags){$/;"	f	file:
vlogTruncate	.\ext\misc\vfslog.c	/^static int vlogTruncate(sqlite3_file *pFile, sqlite_int64 size){$/;"	f	file:
vlogUnlock	.\ext\misc\vfslog.c	/^static int vlogUnlock(sqlite3_file *pFile, int eLock){$/;"	f	file:
vlogWrite	.\ext\misc\vfslog.c	/^static int vlogWrite($/;"	f	file:
vlog_io_methods	.\ext\misc\vfslog.c	/^static sqlite3_io_methods vlog_io_methods = {$/;"	v	file:
vlog_time	.\ext\misc\vfslog.c	/^static sqlite3_uint64 vlog_time(){$/;"	f	file:
vlog_vfs	.\ext\misc\vfslog.c	/^static VLogVfs vlog_vfs = {$/;"	v	file:
vmprintf	.\src\sqlite3ext.h	/^  char *(*vmprintf)(const char*,va_list);$/;"	m	struct:sqlite3_api_routines
vsnprintf	.\src\sqlite3ext.h	/^  char *(*vsnprintf)(int,char*,const char*,va_list);$/;"	m	struct:sqlite3_api_routines
vtab	.\src\whereInt.h	/^    } vtab;$/;"	m	union:WhereLoop::__anon28	typeref:struct:WhereLoop::__anon28::__anon30
vtabBestIndex	.\src\where.c	/^static int vtabBestIndex(Parse *pParse, Table *pTab, sqlite3_index_info *p){$/;"	f	file:
vtabCallConstructor	.\src\vtab.c	/^static int vtabCallConstructor($/;"	f	file:
vtabDisconnectAll	.\src\vtab.c	/^static VTable *vtabDisconnectAll(sqlite3 *db, Table *p){$/;"	f	file:
vtabOnConflict	.\src\sqliteInt.h	/^  u8 vtabOnConflict;            \/* Value to return for s3_vtab_on_conflict() *\/$/;"	m	struct:sqlite3
vtab_config	.\src\sqlite3ext.h	/^  int (*vtab_config)(sqlite3*,int op,...);$/;"	m	struct:sqlite3_api_routines
vtab_on_conflict	.\src\sqlite3ext.h	/^  int (*vtab_on_conflict)(sqlite3*);$/;"	m	struct:sqlite3_api_routines
vtabarg	.\src\parse.y	/^vtabarg ::= .                       {sqlite3VtabArgInit(pParse);}$/;"	l
vtabarg	.\src\parse.y	/^vtabarg ::= vtabarg vtabargtoken.$/;"	l
vtabarglist	.\src\parse.y	/^vtabarglist ::= vtabarg.$/;"	l
vtabarglist	.\src\parse.y	/^vtabarglist ::= vtabarglist COMMA vtabarg.$/;"	l
vtabargtoken	.\src\parse.y	/^vtabargtoken ::= ANY(X).            {sqlite3VtabArgExtend(pParse,&X);}$/;"	l
vtabargtoken	.\src\parse.y	/^vtabargtoken ::= lp anylist RP(X).  {sqlite3VtabArgExtend(pParse,&X);}$/;"	l
vtshimAuxDestructor	.\ext\misc\vtshim.c	/^static void vtshimAuxDestructor(void *pXAux){$/;"	f	file:
vtshimBegin	.\ext\misc\vtshim.c	/^static int vtshimBegin(sqlite3_vtab *pBase){$/;"	f	file:
vtshimBestIndex	.\ext\misc\vtshim.c	/^static int vtshimBestIndex($/;"	f	file:
vtshimClose	.\ext\misc\vtshim.c	/^static int vtshimClose(sqlite3_vtab_cursor *pX){$/;"	f	file:
vtshimColumn	.\ext\misc\vtshim.c	/^static int vtshimColumn(sqlite3_vtab_cursor *pX, sqlite3_context *ctx, int i){$/;"	f	file:
vtshimCommit	.\ext\misc\vtshim.c	/^static int vtshimCommit(sqlite3_vtab *pBase){$/;"	f	file:
vtshimConnect	.\ext\misc\vtshim.c	/^static int vtshimConnect($/;"	f	file:
vtshimCopyModule	.\ext\misc\vtshim.c	/^static int vtshimCopyModule($/;"	f	file:
vtshimCreate	.\ext\misc\vtshim.c	/^static int vtshimCreate($/;"	f	file:
vtshimDestroy	.\ext\misc\vtshim.c	/^static int vtshimDestroy(sqlite3_vtab *pBase){$/;"	f	file:
vtshimDisconnect	.\ext\misc\vtshim.c	/^static int vtshimDisconnect(sqlite3_vtab *pBase){$/;"	f	file:
vtshimEof	.\ext\misc\vtshim.c	/^static int vtshimEof(sqlite3_vtab_cursor *pX){$/;"	f	file:
vtshimFilter	.\ext\misc\vtshim.c	/^static int vtshimFilter($/;"	f	file:
vtshimFindFunction	.\ext\misc\vtshim.c	/^static int vtshimFindFunction($/;"	f	file:
vtshimNext	.\ext\misc\vtshim.c	/^static int vtshimNext(sqlite3_vtab_cursor *pX){$/;"	f	file:
vtshimOpen	.\ext\misc\vtshim.c	/^static int vtshimOpen(sqlite3_vtab *pBase, sqlite3_vtab_cursor **ppCursor){$/;"	f	file:
vtshimRelease	.\ext\misc\vtshim.c	/^static int vtshimRelease(sqlite3_vtab *pBase, int n){$/;"	f	file:
vtshimRename	.\ext\misc\vtshim.c	/^static int vtshimRename(sqlite3_vtab *pBase, const char *zNewName){$/;"	f	file:
vtshimRollback	.\ext\misc\vtshim.c	/^static int vtshimRollback(sqlite3_vtab *pBase){$/;"	f	file:
vtshimRollbackTo	.\ext\misc\vtshim.c	/^static int vtshimRollbackTo(sqlite3_vtab *pBase, int n){$/;"	f	file:
vtshimRowid	.\ext\misc\vtshim.c	/^static int vtshimRowid(sqlite3_vtab_cursor *pX, sqlite3_int64 *pRowid){$/;"	f	file:
vtshimSavepoint	.\ext\misc\vtshim.c	/^static int vtshimSavepoint(sqlite3_vtab *pBase, int n){$/;"	f	file:
vtshimSync	.\ext\misc\vtshim.c	/^static int vtshimSync(sqlite3_vtab *pBase){$/;"	f	file:
vtshimUpdate	.\ext\misc\vtshim.c	/^static int vtshimUpdate($/;"	f	file:
vtshim_aux	.\ext\misc\vtshim.c	/^struct vtshim_aux {$/;"	s	file:
vtshim_aux	.\ext\misc\vtshim.c	/^typedef struct vtshim_aux vtshim_aux;$/;"	t	typeref:struct:vtshim_aux	file:
vtshim_cursor	.\ext\misc\vtshim.c	/^struct vtshim_cursor {$/;"	s	file:
vtshim_cursor	.\ext\misc\vtshim.c	/^typedef struct vtshim_cursor vtshim_cursor;$/;"	t	typeref:struct:vtshim_cursor	file:
vtshim_vtab	.\ext\misc\vtshim.c	/^struct vtshim_vtab {$/;"	s	file:
vtshim_vtab	.\ext\misc\vtshim.c	/^typedef struct vtshim_vtab vtshim_vtab;$/;"	t	typeref:struct:vtshim_vtab	file:
vxworksFileId	.\src\os_unix.c	/^struct vxworksFileId {$/;"	s	file:
vxworksFileList	.\src\os_unix.c	/^static struct vxworksFileId *vxworksFileList = 0;$/;"	v	typeref:struct:vxworksFileId	file:
vxworksFindFileId	.\src\os_unix.c	/^static struct vxworksFileId *vxworksFindFileId(const char *zAbsoluteName){$/;"	f	file:
vxworksIoFinder	.\src\os_unix.c	/^  *(*const vxworksIoFinder)(const char*,unixFile*) = vxworksIoFinderImpl;$/;"	v	file:
vxworksIoFinderImpl	.\src\os_unix.c	/^static const sqlite3_io_methods *vxworksIoFinderImpl($/;"	f	file:
vxworksReleaseFileId	.\src\os_unix.c	/^static void vxworksReleaseFileId(struct vxworksFileId *pId){$/;"	f	file:
vxworksSimplifyName	.\src\os_unix.c	/^static int vxworksSimplifyName(char *z, int n){$/;"	f	file:
waitForClient	.\mptest\mptest.c	/^static void waitForClient(int iClient, int iTimeout, char *zErrPrefix){$/;"	f	file:
wait_for_unlock_notify	.\src\test_thread.c	/^static int wait_for_unlock_notify(sqlite3 *db){$/;"	f	file:
walBusyLock	.\src\wal.c	/^static int walBusyLock($/;"	f	file:
walCheckpoint	.\src\wal.c	/^static int walCheckpoint($/;"	f	file:
walChecksumBytes	.\src\wal.c	/^static void walChecksumBytes($/;"	f	file:
walCkptInfo	.\src\wal.c	/^static volatile WalCkptInfo *walCkptInfo(Wal *pWal){$/;"	f	file:
walCleanupHash	.\src\wal.c	/^static void walCleanupHash(Wal *pWal){$/;"	f	file:
walDecodeFrame	.\src\wal.c	/^static int walDecodeFrame($/;"	f	file:
walEncodeFrame	.\src\wal.c	/^static void walEncodeFrame($/;"	f	file:
walFrameOffset	.\src\wal.c	403;"	d	file:
walFramePage	.\src\wal.c	/^static int walFramePage(u32 iFrame){$/;"	f	file:
walFramePgno	.\src\wal.c	/^static u32 walFramePgno(Wal *pWal, u32 iFrame){$/;"	f	file:
walHash	.\src\wal.c	/^static int walHash(u32 iPage){$/;"	f	file:
walHashGet	.\src\wal.c	/^static int walHashGet($/;"	f	file:
walIndexAppend	.\src\wal.c	/^static int walIndexAppend(Wal *pWal, u32 iFrame, u32 iPage){$/;"	f	file:
walIndexClose	.\src\wal.c	/^static void walIndexClose(Wal *pWal, int isDelete){$/;"	f	file:
walIndexHdr	.\src\wal.c	/^static volatile WalIndexHdr *walIndexHdr(Wal *pWal){$/;"	f	file:
walIndexPage	.\src\wal.c	/^static int walIndexPage(Wal *pWal, int iPage, volatile u32 **ppPage){$/;"	f	file:
walIndexReadHdr	.\src\wal.c	/^static int walIndexReadHdr(Wal *pWal, int *pChanged){$/;"	f	file:
walIndexRecover	.\src\wal.c	/^static int walIndexRecover(Wal *pWal){$/;"	f	file:
walIndexTryHdr	.\src\wal.c	/^static int walIndexTryHdr(Wal *pWal, int *pChanged){$/;"	f	file:
walIndexWriteHdr	.\src\wal.c	/^static void walIndexWriteHdr(Wal *pWal){$/;"	f	file:
walIteratorFree	.\src\wal.c	/^static void walIteratorFree(WalIterator *p){$/;"	f	file:
walIteratorInit	.\src\wal.c	/^static int walIteratorInit(Wal *pWal, WalIterator **pp){$/;"	f	file:
walIteratorNext	.\src\wal.c	/^static int walIteratorNext($/;"	f	file:
walLimitSize	.\src\wal.c	/^static void walLimitSize(Wal *pWal, i64 nMax){$/;"	f	file:
walLockExclusive	.\src\wal.c	/^static int walLockExclusive(Wal *pWal, int lockIdx, int n, int fBlock){$/;"	f	file:
walLockName	.\src\wal.c	/^static const char *walLockName(int lockIdx){$/;"	f	file:
walLockShared	.\src\wal.c	/^static int walLockShared(Wal *pWal, int lockIdx){$/;"	f	file:
walMerge	.\src\wal.c	/^static void walMerge($/;"	f	file:
walMergesort	.\src\wal.c	/^static void walMergesort($/;"	f	file:
walNextHash	.\src\wal.c	/^static int walNextHash(int iPriorHash){$/;"	f	file:
walPagesize	.\src\wal.c	/^static int walPagesize(Wal *pWal){$/;"	f	file:
walRestartHdr	.\src\wal.c	/^static void walRestartHdr(Wal *pWal, u32 salt1){$/;"	f	file:
walRestartLog	.\src\wal.c	/^static int walRestartLog(Wal *pWal){$/;"	f	file:
walShmBarrier	.\src\wal.c	/^static void walShmBarrier(Wal *pWal){$/;"	f	file:
walSyncFlags	.\src\pager.c	/^  u8 walSyncFlags;            \/* SYNC_NORMAL or SYNC_FULL for wal writes *\/$/;"	m	struct:Pager	file:
walTryBeginRead	.\src\wal.c	/^static int walTryBeginRead(Wal *pWal, int *pChanged, int useWal, int cnt){$/;"	f	file:
walUnlockExclusive	.\src\wal.c	/^static void walUnlockExclusive(Wal *pWal, int lockIdx, int n){$/;"	f	file:
walUnlockShared	.\src\wal.c	/^static void walUnlockShared(Wal *pWal, int lockIdx){$/;"	f	file:
walWriteOneFrame	.\src\wal.c	/^static int walWriteOneFrame($/;"	f	file:
walWriteToLog	.\src\wal.c	/^static int walWriteToLog($/;"	f	file:
wal_autocheckpoint	.\src\sqlite3ext.h	/^  int (*wal_autocheckpoint)(sqlite3*,int);$/;"	m	struct:sqlite3_api_routines
wal_check_journal_mode	.\test\tester.tcl	/^proc wal_check_journal_mode {testname {db db}} {$/;"	p
wal_checkpoint	.\src\sqlite3ext.h	/^  int (*wal_checkpoint)(sqlite3*,const char*);$/;"	m	struct:sqlite3_api_routines
wal_checkpoint_v2	.\src\sqlite3ext.h	/^  int (*wal_checkpoint_v2)(sqlite3*,const char*,int,int*,int*);$/;"	m	struct:sqlite3_api_routines
wal_cksum	.\test\wal_common.tcl	/^proc wal_cksum {endian ckv1 ckv2 blob} {$/;"	p
wal_cksum_intlist	.\test\wal_common.tcl	/^proc wal_cksum_intlist {ckv1 ckv2 intlist} {$/;"	p
wal_file_size	.\test\wal_common.tcl	/^proc wal_file_size {nFrame pgsz} {$/;"	p
wal_fix_walindex_cksum	.\test\wal_common.tcl	/^proc wal_fix_walindex_cksum {hdrvar} {$/;"	p
wal_frame_count	.\test\wal_common.tcl	/^proc wal_frame_count {zFile pgsz} {$/;"	p
wal_hook	.\src\sqlite3ext.h	/^  void *(*wal_hook)(sqlite3*,int(*)(void*,sqlite3*,const char*,int),void*);$/;"	m	struct:sqlite3_api_routines
wal_is_wal_mode	.\test\tester.tcl	/^proc wal_is_wal_mode {} {$/;"	p
wal_set_journal_mode	.\test\tester.tcl	/^proc wal_set_journal_mode {{db db}} {$/;"	p
wal_set_walhdr	.\test\wal_common.tcl	/^proc wal_set_walhdr {filename {intlist {}}} {$/;"	p
walkerDepth	.\src\sqliteInt.h	/^  int walkerDepth;                          \/* Number of subqueries *\/$/;"	m	struct:Walker
walthread1	.\test\threadtest3.c	/^static void walthread1(int nMs){$/;"	f	file:
walthread1_ckpt_thread	.\test\threadtest3.c	/^static char *walthread1_ckpt_thread(int iTid, void *pArg){$/;"	f	file:
walthread1_thread	.\test\threadtest3.c	/^static char *walthread1_thread(int iTid, void *pArg){$/;"	f	file:
walthread2	.\test\threadtest3.c	/^static void walthread2(int nMs){$/;"	f	file:
walthread2_thread	.\test\threadtest3.c	/^static char *walthread2_thread(int iTid, void *pArg){$/;"	f	file:
walthread3	.\test\threadtest3.c	/^static void walthread3(int nMs){$/;"	f	file:
walthread3_thread	.\test\threadtest3.c	/^static char *walthread3_thread(int iTid, void *pArg){$/;"	f	file:
walthread4	.\test\threadtest3.c	/^static void walthread4(int nMs){$/;"	f	file:
walthread4_reader_thread	.\test\threadtest3.c	/^static char *walthread4_reader_thread(int iTid, void *pArg){$/;"	f	file:
walthread4_writer_thread	.\test\threadtest3.c	/^static char *walthread4_writer_thread(int iTid, void *pArg){$/;"	f	file:
walthread5	.\test\threadtest3.c	/^static void walthread5(int nMs){$/;"	f	file:
walthread5_thread	.\test\threadtest3.c	/^static char *walthread5_thread(int iTid, void *pArg){$/;"	f	file:
wantToLock	.\src\btreeInt.h	/^  int wantToLock;    \/* Number of nested calls to sqlite3BtreeEnter() *\/$/;"	m	struct:Btree
warning	.\test\tester.tcl	/^proc warning {msg {append 1}} {$/;"	p
wc	.\src\whereInt.h	/^  WhereClause wc;          \/* Decomposition into subterms *\/$/;"	m	struct:WhereOrInfo
wc	.\src\whereInt.h	/^  WhereClause wc;          \/* The subexpression broken out *\/$/;"	m	struct:WhereAndInfo
wctrlFlags	.\src\whereInt.h	/^  u16 wctrlFlags;           \/* Flags originally passed to sqlite3WhereBegin() *\/$/;"	m	struct:WhereInfo
whereAndInfoDelete	.\src\whereexpr.c	/^static void whereAndInfoDelete(sqlite3 *db, WhereAndInfo *p){$/;"	f	file:
whereClauseInsert	.\src\whereexpr.c	/^static int whereClauseInsert(WhereClause *pWC, Expr *p, u16 wtFlags){$/;"	f	file:
whereCombineDisjuncts	.\src\whereexpr.c	/^static void whereCombineDisjuncts($/;"	f	file:
whereEqualScanEst	.\src\where.c	/^static int whereEqualScanEst($/;"	f	file:
whereForeignKeys	.\src\alter.c	/^static char *whereForeignKeys(Parse *pParse, Table *pTab){$/;"	f	file:
whereInScanEst	.\src\where.c	/^static int whereInScanEst($/;"	f	file:
whereInfoFree	.\src\where.c	/^static void whereInfoFree(sqlite3 *db, WhereInfo *pWInfo){$/;"	f	file:
whereKeyStats	.\src\where.c	/^static int whereKeyStats($/;"	f	file:
whereLikeOptimizationStringFixup	.\src\wherecode.c	/^static void whereLikeOptimizationStringFixup($/;"	f	file:
whereLoopAddAll	.\src\where.c	/^static int whereLoopAddAll(WhereLoopBuilder *pBuilder){$/;"	f	file:
whereLoopAddBtree	.\src\where.c	/^static int whereLoopAddBtree($/;"	f	file:
whereLoopAddBtreeIndex	.\src\where.c	/^static int whereLoopAddBtreeIndex($/;"	f	file:
whereLoopAddOr	.\src\where.c	/^static int whereLoopAddOr($/;"	f	file:
whereLoopAddVirtual	.\src\where.c	/^static int whereLoopAddVirtual($/;"	f	file:
whereLoopAdjustCost	.\src\where.c	/^static void whereLoopAdjustCost(const WhereLoop *p, WhereLoop *pTemplate){$/;"	f	file:
whereLoopCheaperProperSubset	.\src\where.c	/^static int whereLoopCheaperProperSubset($/;"	f	file:
whereLoopClear	.\src\where.c	/^static void whereLoopClear(sqlite3 *db, WhereLoop *p){$/;"	f	file:
whereLoopClearUnion	.\src\where.c	/^static void whereLoopClearUnion(sqlite3 *db, WhereLoop *p){$/;"	f	file:
whereLoopDelete	.\src\where.c	/^static void whereLoopDelete(sqlite3 *db, WhereLoop *p){$/;"	f	file:
whereLoopFindLesser	.\src\where.c	/^static WhereLoop **whereLoopFindLesser($/;"	f	file:
whereLoopInit	.\src\where.c	/^static void whereLoopInit(WhereLoop *p){$/;"	f	file:
whereLoopInsert	.\src\where.c	/^static int whereLoopInsert(WhereLoopBuilder *pBuilder, WhereLoop *pTemplate){$/;"	f	file:
whereLoopOutputAdjust	.\src\where.c	/^static void whereLoopOutputAdjust($/;"	f	file:
whereLoopPrint	.\src\where.c	/^static void whereLoopPrint(WhereLoop *p, WhereClause *pWC){$/;"	f	file:
whereLoopResize	.\src\where.c	/^static int whereLoopResize(sqlite3 *db, WhereLoop *p, int n){$/;"	f	file:
whereLoopXfer	.\src\where.c	/^static int whereLoopXfer(sqlite3 *db, WhereLoop *pTo, WhereLoop *pFrom){$/;"	f	file:
whereNthSubterm	.\src\whereexpr.c	/^static WhereTerm *whereNthSubterm(WhereTerm *pTerm, int N){$/;"	f	file:
whereOrInfoDelete	.\src\whereexpr.c	/^static void whereOrInfoDelete(sqlite3 *db, WhereOrInfo *p){$/;"	f	file:
whereOrInsert	.\src\where.c	/^static int whereOrInsert($/;"	f	file:
whereOrMove	.\src\where.c	/^static void whereOrMove(WhereOrSet *pDest, WhereOrSet *pSrc){$/;"	f	file:
whereOrName	.\src\alter.c	/^static char *whereOrName(sqlite3 *db, char *zWhere, char *zConstant){$/;"	f	file:
wherePathName	.\src\where.c	/^static const char *wherePathName(WherePath *pPath, int nLoop, WhereLoop *pLast){$/;"	f	file:
wherePathSatisfiesOrderBy	.\src\where.c	/^static i8 wherePathSatisfiesOrderBy($/;"	f	file:
wherePathSolver	.\src\where.c	/^static int wherePathSolver(WhereInfo *pWInfo, LogEst nRowEst){$/;"	f	file:
whereRangeAdjust	.\src\where.c	/^static LogEst whereRangeAdjust(WhereTerm *pTerm, LogEst nNew){$/;"	f	file:
whereRangeScanEst	.\src\where.c	/^static int whereRangeScanEst($/;"	f	file:
whereRangeSkipScanEst	.\src\where.c	/^static int whereRangeSkipScanEst($/;"	f	file:
whereScanInit	.\src\where.c	/^static WhereTerm *whereScanInit($/;"	f	file:
whereScanNext	.\src\where.c	/^static WhereTerm *whereScanNext(WhereScan *pScan){$/;"	f	file:
whereShortCut	.\src\where.c	/^static int whereShortCut(WhereLoopBuilder *pBuilder){$/;"	f	file:
whereSortingCost	.\src\where.c	/^static LogEst whereSortingCost($/;"	f	file:
whereTempTriggers	.\src\alter.c	/^static char *whereTempTriggers(Parse *pParse, Table *pTab){$/;"	f	file:
whereTermPrint	.\src\where.c	/^static void whereTermPrint(WhereTerm *pTerm, int iTerm){$/;"	f	file:
whereUsablePartialIndex	.\src\where.c	/^static int whereUsablePartialIndex(int iTab, WhereClause *pWC, Expr *pWhere){$/;"	f	file:
wholenumberBestIndex	.\ext\misc\wholenumber.c	/^static int wholenumberBestIndex($/;"	f	file:
wholenumberClose	.\ext\misc\wholenumber.c	/^static int wholenumberClose(sqlite3_vtab_cursor *cur){$/;"	f	file:
wholenumberColumn	.\ext\misc\wholenumber.c	/^static int wholenumberColumn($/;"	f	file:
wholenumberConnect	.\ext\misc\wholenumber.c	/^static int wholenumberConnect($/;"	f	file:
wholenumberDisconnect	.\ext\misc\wholenumber.c	/^static int wholenumberDisconnect(sqlite3_vtab *pVtab){$/;"	f	file:
wholenumberEof	.\ext\misc\wholenumber.c	/^static int wholenumberEof(sqlite3_vtab_cursor *cur){$/;"	f	file:
wholenumberFilter	.\ext\misc\wholenumber.c	/^static int wholenumberFilter($/;"	f	file:
wholenumberModule	.\ext\misc\wholenumber.c	/^static sqlite3_module wholenumberModule = {$/;"	v	file:
wholenumberNext	.\ext\misc\wholenumber.c	/^static int wholenumberNext(sqlite3_vtab_cursor *cur){$/;"	f	file:
wholenumberOpen	.\ext\misc\wholenumber.c	/^static int wholenumberOpen(sqlite3_vtab *p, sqlite3_vtab_cursor **ppCursor){$/;"	f	file:
wholenumberRowid	.\ext\misc\wholenumber.c	/^static int wholenumberRowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid){$/;"	f	file:
wholenumber_cursor	.\ext\misc\wholenumber.c	/^struct wholenumber_cursor {$/;"	s	file:
wholenumber_cursor	.\ext\misc\wholenumber.c	/^typedef struct wholenumber_cursor wholenumber_cursor;$/;"	t	typeref:struct:wholenumber_cursor	file:
width	.\src\test_rtree.c	/^  double width;$/;"	m	struct:Cube	file:
wildcard	.\tool\lemon.c	/^  struct symbol *wildcard; \/* Token that matches anything *\/$/;"	m	struct:lemon	typeref:struct:lemon::symbol	file:
win32FileLocker	.\src\test1.c	/^struct win32FileLocker {$/;"	s	file:
win32_delete_file	.\src\test1.c	/^static int win32_delete_file($/;"	f	file:
win32_exists_path	.\src\test1.c	/^static int win32_exists_path($/;"	f	file:
win32_file_lock	.\src\test1.c	/^static int win32_file_lock($/;"	f	file:
win32_file_locker	.\src\test1.c	/^static void win32_file_locker(void *pAppData){$/;"	f	file:
win32_find_file	.\src\test1.c	/^static int win32_find_file($/;"	f	file:
win32_mkdir	.\src\test1.c	/^static int win32_mkdir($/;"	f	file:
win32_rmdir	.\src\test1.c	/^static int win32_rmdir($/;"	f	file:
winAccess	.\src\os_win.c	/^static int winAccess($/;"	f	file:
winCheckReservedLock	.\src\os_win.c	/^static int winCheckReservedLock(sqlite3_file *id, int *pResOut){$/;"	f	file:
winClose	.\src\os_win.c	/^static int winClose(sqlite3_file *id){$/;"	f	file:
winConvertFromUtf8Filename	.\src\os_win.c	/^static void *winConvertFromUtf8Filename(const char *zFilename){$/;"	f	file:
winConvertToUtf8Filename	.\src\os_win.c	/^static char *winConvertToUtf8Filename(const void *zFilename){$/;"	f	file:
winCurrentTime	.\src\os_win.c	/^static int winCurrentTime(sqlite3_vfs *pVfs, double *prNow){$/;"	f	file:
winCurrentTimeInt64	.\src\os_win.c	/^static int winCurrentTimeInt64(sqlite3_vfs *pVfs, sqlite3_int64 *piNow){$/;"	f	file:
winDelete	.\src\os_win.c	/^static int winDelete($/;"	f	file:
winDeviceCharacteristics	.\src\os_win.c	/^static int winDeviceCharacteristics(sqlite3_file *id){$/;"	f	file:
winDlClose	.\src\os_win.c	/^static void winDlClose(sqlite3_vfs *pVfs, void *pHandle){$/;"	f	file:
winDlClose	.\src\os_win.c	5371;"	d	file:
winDlError	.\src\os_win.c	/^static void winDlError(sqlite3_vfs *pVfs, int nBuf, char *zBufOut){$/;"	f	file:
winDlError	.\src\os_win.c	5369;"	d	file:
winDlOpen	.\src\os_win.c	/^static void *winDlOpen(sqlite3_vfs *pVfs, const char *zFilename){$/;"	f	file:
winDlOpen	.\src\os_win.c	5368;"	d	file:
winDlSym	.\src\os_win.c	/^static void (*winDlSym(sqlite3_vfs *pVfs,void *pH,const char *zSym))(void){$/;"	f	file:
winDlSym	.\src\os_win.c	5370;"	d	file:
winFetch	.\src\os_win.c	/^static int winFetch(sqlite3_file *fd, i64 iOff, int nAmt, void **pp){$/;"	f	file:
winFile	.\src\os_win.c	/^struct winFile {$/;"	s	file:
winFile	.\src\os_win.c	/^typedef struct winFile winFile;$/;"	t	typeref:struct:winFile	file:
winFileControl	.\src\os_win.c	/^static int winFileControl(sqlite3_file *id, int op, void *pArg){$/;"	f	file:
winFileSize	.\src\os_win.c	/^static int winFileSize(sqlite3_file *id, sqlite3_int64 *pSize){$/;"	f	file:
winFullPathname	.\src\os_win.c	/^static int winFullPathname($/;"	f	file:
winGetDirSep	.\src\os_win.c	166;"	d	file:
winGetLastError	.\src\os_win.c	/^static int winGetLastError(sqlite3_vfs *pVfs, int nBuf, char *zBuf){$/;"	f	file:
winGetLastErrorMsg	.\src\os_win.c	/^static int winGetLastErrorMsg(DWORD lastErrno, int nBuf, char *zBuf){$/;"	f	file:
winGetReadLock	.\src\os_win.c	/^static int winGetReadLock(winFile *pFile){$/;"	f	file:
winGetSystemCall	.\src\os_win.c	/^static sqlite3_syscall_ptr winGetSystemCall($/;"	f	file:
winGetTempname	.\src\os_win.c	/^static int winGetTempname(sqlite3_vfs *pVfs, char **pzBuf){$/;"	f	file:
winIoMethod	.\src\os_win.c	/^static const sqlite3_io_methods winIoMethod = {$/;"	v	file:
winIoerrCanRetry1	.\src\os_win.c	1937;"	d	file:
winIoerrRetry	.\src\os_win.c	/^static int winIoerrRetry = SQLITE_WIN32_IOERR_RETRY;$/;"	v	file:
winIoerrRetryDelay	.\src\os_win.c	/^static int winIoerrRetryDelay = SQLITE_WIN32_IOERR_RETRY_DELAY;$/;"	v	file:
winIsDir	.\src\os_win.c	/^static int winIsDir(const void *zConverted){$/;"	f	file:
winIsDirSep	.\src\os_win.c	151;"	d	file:
winIsDriveLetterAndColon	.\src\os_win.c	/^static BOOL winIsDriveLetterAndColon($/;"	f	file:
winIsVerbatimPathname	.\src\os_win.c	/^static BOOL winIsVerbatimPathname($/;"	f	file:
winLock	.\src\os_win.c	/^static int winLock(sqlite3_file *id, int locktype){$/;"	f	file:
winLockFile	.\src\os_win.c	/^static BOOL winLockFile($/;"	f	file:
winLogError	.\src\os_win.c	1880;"	d	file:
winLogErrorAtLine	.\src\os_win.c	/^static int winLogErrorAtLine($/;"	f	file:
winLogIoerr	.\src\os_win.c	/^static void winLogIoerr(int nRetry, int lineno){$/;"	f	file:
winMakeEndInDirSep	.\src\os_win.c	/^static int winMakeEndInDirSep(int nBuf, char *zBuf){$/;"	f	file:
winMapfile	.\src\os_win.c	/^static int winMapfile(winFile *pFd, sqlite3_int64 nByte){$/;"	f	file:
winMbcsToUnicode	.\src\os_win.c	/^static LPWSTR winMbcsToUnicode(const char *zFilename){$/;"	f	file:
winMemAssertMagic	.\src\os_win.c	388;"	d	file:
winMemAssertMagic	.\src\os_win.c	390;"	d	file:
winMemAssertMagic1	.\src\os_win.c	386;"	d	file:
winMemAssertMagic2	.\src\os_win.c	387;"	d	file:
winMemData	.\src\os_win.c	/^struct winMemData {$/;"	s	file:
winMemData	.\src\os_win.c	/^typedef struct winMemData winMemData;$/;"	t	typeref:struct:winMemData	file:
winMemFree	.\src\os_win.c	/^static void winMemFree(void *pPrior){$/;"	f	file:
winMemGetDataPtr	.\src\os_win.c	393;"	d	file:
winMemGetHeap	.\src\os_win.c	394;"	d	file:
winMemGetOwned	.\src\os_win.c	395;"	d	file:
winMemInit	.\src\os_win.c	/^static int winMemInit(void *pAppData){$/;"	f	file:
winMemMalloc	.\src\os_win.c	/^static void *winMemMalloc(int nBytes){$/;"	f	file:
winMemRealloc	.\src\os_win.c	/^static void *winMemRealloc(void *pPrior, int nBytes){$/;"	f	file:
winMemRoundup	.\src\os_win.c	/^static int winMemRoundup(int n){$/;"	f	file:
winMemShutdown	.\src\os_win.c	/^static void winMemShutdown(void *pAppData){$/;"	f	file:
winMemSize	.\src\os_win.c	/^static int winMemSize(void *p){$/;"	f	file:
winModeBit	.\src\os_win.c	/^static void winModeBit(winFile *pFile, unsigned char mask, int *pArg){$/;"	f	file:
winMutexAlloc	.\src\mutex_w32.c	/^static sqlite3_mutex *winMutexAlloc(int iType){$/;"	f	file:
winMutexEnd	.\src\mutex_w32.c	/^static int winMutexEnd(void){$/;"	f	file:
winMutexEnter	.\src\mutex_w32.c	/^static void winMutexEnter(sqlite3_mutex *p){$/;"	f	file:
winMutexFree	.\src\mutex_w32.c	/^static void winMutexFree(sqlite3_mutex *p){$/;"	f	file:
winMutexHeld	.\src\mutex_w32.c	/^static int winMutexHeld(sqlite3_mutex *p){$/;"	f	file:
winMutexInit	.\src\mutex_w32.c	/^static int winMutexInit(void){$/;"	f	file:
winMutexLeave	.\src\mutex_w32.c	/^static void winMutexLeave(sqlite3_mutex *p){$/;"	f	file:
winMutexNotheld	.\src\mutex_w32.c	/^static int winMutexNotheld(sqlite3_mutex *p){$/;"	f	file:
winMutexNotheld2	.\src\mutex_w32.c	/^static int winMutexNotheld2(sqlite3_mutex *p, DWORD tid){$/;"	f	file:
winMutexTry	.\src\mutex_w32.c	/^static int winMutexTry(sqlite3_mutex *p){$/;"	f	file:
winMutex_isInit	.\src\mutex_w32.c	/^static int winMutex_isInit = 0;$/;"	v	file:
winMutex_isNt	.\src\mutex_w32.c	/^static int winMutex_isNt = -1; \/* <0 means "need to query" *\/$/;"	v	file:
winMutex_lock	.\src\mutex_w32.c	/^static LONG SQLITE_WIN32_VOLATILE winMutex_lock = 0;$/;"	v	file:
winMutex_staticMutexes	.\src\mutex_w32.c	/^static sqlite3_mutex winMutex_staticMutexes[] = {$/;"	v	file:
winNextSystemCall	.\src\os_win.c	/^static const char *winNextSystemCall(sqlite3_vfs *p, const char *zName){$/;"	f	file:
winOpen	.\src\os_win.c	/^static int winOpen($/;"	f	file:
winOpenSharedMemory	.\src\os_win.c	/^static int winOpenSharedMemory(winFile *pDbFd){$/;"	f	file:
winRandomness	.\src\os_win.c	/^static int winRandomness(sqlite3_vfs *pVfs, int nBuf, char *zBuf){$/;"	f	file:
winRead	.\src\os_win.c	/^static int winRead($/;"	f	file:
winRetryIoerr	.\src\os_win.c	/^static int winRetryIoerr(int *pnRetry, DWORD *pError){$/;"	f	file:
winSectorSize	.\src\os_win.c	/^static int winSectorSize(sqlite3_file *id){$/;"	f	file:
winSeekFile	.\src\os_win.c	/^static int winSeekFile(winFile *pFile, sqlite3_int64 iOffset){$/;"	f	file:
winSetSystemCall	.\src\os_win.c	/^static int winSetSystemCall($/;"	f	file:
winShm	.\src\os_win.c	/^struct winShm {$/;"	s	file:
winShm	.\src\os_win.c	/^typedef struct winShm winShm;           \/* A connection to shared-memory *\/$/;"	t	typeref:struct:winShm	file:
winShmBarrier	.\src\os_win.c	/^static void winShmBarrier($/;"	f	file:
winShmBarrier	.\src\os_win.c	4009;"	d	file:
winShmEnterMutex	.\src\os_win.c	/^static void winShmEnterMutex(void){$/;"	f	file:
winShmLeaveMutex	.\src\os_win.c	/^static void winShmLeaveMutex(void){$/;"	f	file:
winShmLock	.\src\os_win.c	/^static int winShmLock($/;"	f	file:
winShmLock	.\src\os_win.c	4008;"	d	file:
winShmMap	.\src\os_win.c	/^static int winShmMap($/;"	f	file:
winShmMap	.\src\os_win.c	4007;"	d	file:
winShmMutexHeld	.\src\os_win.c	/^static int winShmMutexHeld(void) {$/;"	f	file:
winShmNode	.\src\os_win.c	/^struct winShmNode {$/;"	s	file:
winShmNode	.\src\os_win.c	/^typedef struct winShmNode winShmNode;   \/* A region of shared-memory *\/$/;"	t	typeref:struct:winShmNode	file:
winShmNodeList	.\src\os_win.c	/^static winShmNode *winShmNodeList = 0;$/;"	v	file:
winShmPurge	.\src\os_win.c	/^static void winShmPurge(sqlite3_vfs *pVfs, int deleteFlag){$/;"	f	file:
winShmSystemLock	.\src\os_win.c	/^static int winShmSystemLock($/;"	f	file:
winShmUnmap	.\src\os_win.c	/^static int winShmUnmap($/;"	f	file:
winShmUnmap	.\src\os_win.c	4010;"	d	file:
winSleep	.\src\os_win.c	/^static int winSleep(sqlite3_vfs *pVfs, int microsec){$/;"	f	file:
winSync	.\src\os_win.c	/^static int winSync(sqlite3_file *id, int flags){$/;"	f	file:
winSysInfo	.\src\os_win.c	/^static SYSTEM_INFO winSysInfo;$/;"	v	file:
winTruncate	.\src\os_win.c	/^static int winTruncate(sqlite3_file *id, sqlite3_int64 nByte){$/;"	f	file:
winUnfetch	.\src\os_win.c	/^static int winUnfetch(sqlite3_file *fd, i64 iOff, void *p){$/;"	f	file:
winUnicodeToMbcs	.\src\os_win.c	/^static char *winUnicodeToMbcs(LPCWSTR zWideFilename){$/;"	f	file:
winUnicodeToUtf8	.\src\os_win.c	/^static char *winUnicodeToUtf8(LPCWSTR zWideFilename){$/;"	f	file:
winUnlock	.\src\os_win.c	/^static int winUnlock(sqlite3_file *id, int locktype){$/;"	f	file:
winUnlockFile	.\src\os_win.c	/^static BOOL winUnlockFile($/;"	f	file:
winUnlockReadLock	.\src\os_win.c	/^static int winUnlockReadLock(winFile *pFile){$/;"	f	file:
winUnmapfile	.\src\os_win.c	/^static int winUnmapfile(winFile *pFile){$/;"	f	file:
winUtf8ToUnicode	.\src\os_win.c	/^static LPWSTR winUtf8ToUnicode(const char *zFilename){$/;"	f	file:
winWrite	.\src\os_win.c	/^static int winWrite($/;"	f	file:
win_mem_data	.\src\os_win.c	/^static struct winMemData win_mem_data = {$/;"	v	typeref:struct:winMemData	file:
win_syscall	.\src\os_win.c	/^static struct win_syscall {$/;"	s	file:
winceCreateLock	.\src\os_win.c	/^static int winceCreateLock(const char *zFilename, winFile *pFile){$/;"	f	file:
winceDestroyLock	.\src\os_win.c	/^static void winceDestroyLock(winFile *pFile){$/;"	f	file:
winceLock	.\src\os_win.c	/^typedef struct winceLock {$/;"	s	file:
winceLock	.\src\os_win.c	/^} winceLock;$/;"	t	typeref:struct:winceLock	file:
winceLockFile	.\src\os_win.c	/^static BOOL winceLockFile($/;"	f	file:
winceMutexAcquire	.\src\os_win.c	/^static void winceMutexAcquire(HANDLE h){$/;"	f	file:
winceMutexRelease	.\src\os_win.c	2036;"	d	file:
winceUnlockFile	.\src\os_win.c	/^static BOOL winceUnlockFile($/;"	f	file:
withDup	.\src\expr.c	/^static With *withDup(sqlite3 *db, With *p){$/;"	f	file:
withDup	.\src\expr.c	961;"	d	file:
withExpand	.\src\select.c	/^static int withExpand($/;"	f	file:
wkrFlags	.\test\threadtest4.c	/^  unsigned wkrFlags;          \/* Flags *\/$/;"	m	struct:WorkerInfo	file:
wordBoundary	.\ext\fts1\fts1.c	/^static int wordBoundary($/;"	f	file:
wordBoundary	.\ext\fts2\fts2.c	/^static int wordBoundary($/;"	f	file:
worker	.\test\threadtest2.c	/^void *worker(void *workerArg){$/;"	f
worker_add_content	.\test\threadtest4.c	/^static void worker_add_content(WorkerInfo *p, int mn, int mx, int iTab){$/;"	f	file:
worker_bee	.\test\threadtest1.c	/^static void *worker_bee(void *pArg){$/;"	f	file:
worker_close_connection	.\test\threadtest4.c	/^static void worker_close_connection(WorkerInfo *p){$/;"	f	file:
worker_delete_all_content	.\test\threadtest4.c	/^static void worker_delete_all_content(WorkerInfo *p, int inTrans){$/;"	f	file:
worker_error	.\test\threadtest4.c	/^static void worker_error(WorkerInfo *p, const char *zFormat, ...){$/;"	f	file:
worker_open_connection	.\test\threadtest4.c	/^static void worker_open_connection(WorkerInfo *p, int iCnt){$/;"	f	file:
worker_thread	.\test\threadtest4.c	/^static void *worker_thread(void *pArg){$/;"	f	file:
worker_trace	.\test\threadtest4.c	/^static void worker_trace(WorkerInfo *p, const char *zFormat, ...){$/;"	f	file:
working_64bit_int	.\src\test1.c	/^static int working_64bit_int($/;"	f	file:
wrMemFree	.\src\test_init.c	/^static void wrMemFree(void *p)            {wrapped.mem.xFree(p);}$/;"	f	file:
wrMemInit	.\src\test_init.c	/^static int wrMemInit(void *pAppData){$/;"	f	file:
wrMemMalloc	.\src\test_init.c	/^static void *wrMemMalloc(int n)           {return wrapped.mem.xMalloc(n);}$/;"	f	file:
wrMemRealloc	.\src\test_init.c	/^static void *wrMemRealloc(void *p, int n) {return wrapped.mem.xRealloc(p, n);}$/;"	f	file:
wrMemRoundup	.\src\test_init.c	/^static int wrMemRoundup(int n)            {return wrapped.mem.xRoundup(n);}$/;"	f	file:
wrMemShutdown	.\src\test_init.c	/^static void wrMemShutdown(void *pAppData){$/;"	f	file:
wrMemSize	.\src\test_init.c	/^static int wrMemSize(void *p)             {return wrapped.mem.xSize(p);}$/;"	f	file:
wrMutexAlloc	.\src\test_init.c	/^static sqlite3_mutex *wrMutexAlloc(int e){$/;"	f	file:
wrMutexEnd	.\src\test_init.c	/^static int wrMutexEnd(void){$/;"	f	file:
wrMutexEnter	.\src\test_init.c	/^static void wrMutexEnter(sqlite3_mutex *p){$/;"	f	file:
wrMutexFree	.\src\test_init.c	/^static void wrMutexFree(sqlite3_mutex *p){$/;"	f	file:
wrMutexHeld	.\src\test_init.c	/^static int wrMutexHeld(sqlite3_mutex *p){$/;"	f	file:
wrMutexInit	.\src\test_init.c	/^static int wrMutexInit(void){$/;"	f	file:
wrMutexLeave	.\src\test_init.c	/^static void wrMutexLeave(sqlite3_mutex *p){$/;"	f	file:
wrMutexNotheld	.\src\test_init.c	/^static int wrMutexNotheld(sqlite3_mutex *p){$/;"	f	file:
wrMutexTry	.\src\test_init.c	/^static int wrMutexTry(sqlite3_mutex *p){$/;"	f	file:
wrPCacheCachesize	.\src\test_init.c	/^static void wrPCacheCachesize(sqlite3_pcache *p, int n){$/;"	f	file:
wrPCacheCreate	.\src\test_init.c	/^static sqlite3_pcache *wrPCacheCreate(int a, int b, int c){$/;"	f	file:
wrPCacheDestroy	.\src\test_init.c	/^static void wrPCacheDestroy(sqlite3_pcache *p){$/;"	f	file:
wrPCacheFetch	.\src\test_init.c	/^static sqlite3_pcache_page *wrPCacheFetch(sqlite3_pcache *p, unsigned a, int b){$/;"	f	file:
wrPCacheInit	.\src\test_init.c	/^static int wrPCacheInit(void *pArg){$/;"	f	file:
wrPCachePagecount	.\src\test_init.c	/^static int wrPCachePagecount(sqlite3_pcache *p){$/;"	f	file:
wrPCacheRekey	.\src\test_init.c	/^static void wrPCacheRekey($/;"	f	file:
wrPCacheShutdown	.\src\test_init.c	/^static void wrPCacheShutdown(void *pArg){$/;"	f	file:
wrPCacheTruncate	.\src\test_init.c	/^static void wrPCacheTruncate(sqlite3_pcache *p, unsigned a){$/;"	f	file:
wrPCacheUnpin	.\src\test_init.c	/^static void wrPCacheUnpin(sqlite3_pcache *p, sqlite3_pcache_page *a, int b){$/;"	f	file:
wrapped	.\src\test_init.c	/^} wrapped;$/;"	v	typeref:struct:Wrapped	file:
writableSchema	.\src\shell.c	/^  int writableSchema;    \/* True if PRAGMA writable_schema=ON *\/$/;"	m	struct:ShellState	file:
write32bits	.\src\pager.c	/^static int write32bits(sqlite3_file *fd, i64 offset, u32 val){$/;"	f	file:
writeCoord	.\ext\rtree\rtree.c	/^static int writeCoord(u8 *p, RtreeCoord *pCoord){$/;"	f	file:
writeDbFile	.\src\test6.c	/^static int writeDbFile(CrashFile *p, u8 *z, i64 iAmt, i64 iOff){$/;"	f	file:
writeFile	.\tool\mkvsix.tcl	/^proc writeFile { fileName data } {$/;"	p
writeInt16	.\ext\rtree\rtree.c	/^static int writeInt16(u8 *p, int i){$/;"	f	file:
writeInt64	.\ext\rtree\rtree.c	/^static int writeInt64(u8 *p, i64 i){$/;"	f	file:
writeJournalHdr	.\src\pager.c	/^static int writeJournalHdr(Pager *pPager){$/;"	f	file:
writeListAppend	.\src\test6.c	/^static int writeListAppend($/;"	f	file:
writeListSync	.\src\test6.c	/^static int writeListSync(CrashFile *pFile, int isCrash){$/;"	f	file:
writeLock	.\src\wal.c	/^  u8 writeLock;              \/* True if in a write transaction *\/$/;"	m	struct:Wal	file:
writeMask	.\src\sqliteInt.h	/^  yDbMask writeMask;   \/* Start a write transaction on these databases *\/$/;"	m	struct:Parse
writeMasterJournal	.\src\pager.c	/^static int writeMasterJournal(Pager *pPager, const char *zMaster){$/;"	f	file:
writeRuleText	.\tool\lemon.c	/^static void writeRuleText(FILE *out, struct rule *rp){$/;"	f	file:
writeUtf8	.\ext\misc\nextchar.c	/^static int writeUtf8(unsigned char *z, unsigned c){$/;"	f	file:
writeZeroSegment	.\ext\fts2\fts2.c	/^static int writeZeroSegment(fulltext_vtab *v, fts2Hash *pTerms){$/;"	f	file:
write_main_loop	.\test\lock_common.tcl	/^proc write_main_loop {} {$/;"	p
write_one_file	.\tool\split-sqlite3c.tcl	/^proc write_one_file {content} {$/;"	p
writefileFunc	.\ext\misc\fileio.c	/^static void writefileFunc($/;"	f	file:
writefileFunc	.\src\shell.c	/^static void writefileFunc($/;"	f	file:
writefileFunc	.\test\fuzzcheck.c	/^static void writefileFunc($/;"	f	file:
writer	.\ext\fts5\fts5_expr.c	/^  Fts5PoslistWriter writer;       \/* Writer context *\/$/;"	m	struct:Fts5NearTrimmer	file:
writer	.\ext\fts5\fts5_index.c	/^  Fts5PageWriter writer;          \/* PageWriter object *\/$/;"	m	struct:Fts5SegWriter	file:
writer	.\ext\fts5\fts5_index.c	/^  Fts5SegWriter writer; $/;"	m	struct:Fts5FlushCtx	file:
wsFlags	.\src\whereInt.h	/^  u32 wsFlags;          \/* WHERE_* flags describing the plan *\/$/;"	m	struct:WhereLoop
wsdAutoext	.\src\loadext.c	644;"	d	file:
wsdAutoext	.\src\loadext.c	647;"	d	file:
wsdAutoextInit	.\src\loadext.c	642;"	d	file:
wsdAutoextInit	.\src\loadext.c	646;"	d	file:
wsdHooks	.\src\fault.c	49;"	d	file:
wsdHooks	.\src\fault.c	52;"	d	file:
wsdHooksInit	.\src\fault.c	47;"	d	file:
wsdHooksInit	.\src\fault.c	51;"	d	file:
wsdPrng	.\src\random.c	45;"	d	file:
wsdStat	.\src\status.c	59;"	d	file:
wsdStat	.\src\status.c	62;"	d	file:
wsdStatInit	.\src\status.c	58;"	d	file:
wsdStatInit	.\src\status.c	61;"	d	file:
wtFlags	.\src\whereInt.h	/^  u16 wtFlags;            \/* TERM_xxx bit flags.  See below *\/$/;"	m	struct:WhereTerm
x	.\ext\fts5\fts5_main.c	/^  fts5_tokenizer x;               \/* Tokenizer functions *\/$/;"	m	struct:Fts5TokenizerModule	file:
x	.\src\sqliteInt.h	/^      } x;$/;"	m	union:ExprList::ExprList_item::__anon17	typeref:struct:ExprList::ExprList_item::__anon17::__anon18
x	.\src\sqliteInt.h	/^  } x;$/;"	m	struct:Expr	typeref:union:Expr::__anon16
x	.\src\test_rtree.c	/^  double x;$/;"	m	struct:Cube	file:
x	.\test\speedtest1.c	/^  unsigned int x, y;         \/* Pseudo-random number generator state *\/$/;"	m	struct:Global	file:
x	.\tool\lemon.c	/^  } x;$/;"	m	struct:action	typeref:union:action::__anon34	file:
x1a	.\tool\lemon.c	/^static struct s_x1 *x1a;$/;"	v	typeref:struct:s_x1	file:
x1node	.\tool\lemon.c	/^} x1node;$/;"	t	typeref:struct:s_x1node	file:
x2a	.\tool\lemon.c	/^static struct s_x2 *x2a;$/;"	v	typeref:struct:s_x2	file:
x2node	.\tool\lemon.c	/^} x2node;$/;"	t	typeref:struct:s_x2node	file:
x3a	.\tool\lemon.c	/^static struct s_x3 *x3a;$/;"	v	typeref:struct:s_x3	file:
x3node	.\tool\lemon.c	/^} x3node;$/;"	t	typeref:struct:s_x3node	file:
x4a	.\tool\lemon.c	/^static struct s_x4 *x4a;$/;"	v	typeref:struct:s_x4	file:
x4node	.\tool\lemon.c	/^} x4node;$/;"	t	typeref:struct:s_x4node	file:
xAdvance	.\src\vdbe.h	/^    int (*xAdvance)(BtCursor *, int *);$/;"	m	union:VdbeOp::p4union
xAuth	.\src\sqliteInt.h	/^  sqlite3_xauth xAuth;          \/* Access authorization function *\/$/;"	m	struct:sqlite3
xBacktrace	.\src\mem2.c	/^  void (*xBacktrace)(int, int, void **);$/;"	m	struct:__anon10	file:
xBenignBegin	.\src\fault.c	/^  void (*xBenignBegin)(void);$/;"	m	struct:BenignMallocHooks	file:
xBenignEnd	.\src\fault.c	/^  void (*xBenignEnd)(void);$/;"	m	struct:BenignMallocHooks	file:
xBusy	.\src\test_superlock.c	/^  int (*xBusy)(void*,int);        \/* Pointer to busy-handler function *\/$/;"	m	struct:SuperlockBusy	file:
xBusy	.\src\test_thread.c	/^static int xBusy(void *pArg, int nBusy){$/;"	f	file:
xBusyHandler	.\src\pager.c	/^  int (*xBusyHandler)(void*); \/* Function to call when busy *\/$/;"	m	struct:Pager	file:
xCallback	.\src\test_quota.c	/^  void (*xCallback)(             \/* Callback invoked when going over quota *\/$/;"	m	struct:quotaGroup	file:
xCellSize	.\src\btreeInt.h	/^  u16 (*xCellSize)(MemPage*,u8*);             \/* cellSizePtr method *\/$/;"	m	struct:MemPage
xChildDestroy	.\ext\misc\vtshim.c	/^  void (*xChildDestroy)(void*); \/* Destructor for pChildAux *\/$/;"	m	struct:vtshim_aux	file:
xClose	.\ext\fts1\fts1_tokenizer.h	/^  int (*xClose)(sqlite3_tokenizer_cursor *pCursor);$/;"	m	struct:sqlite3_tokenizer_module
xClose	.\ext\fts1\tokenizer.h	/^  int (*xClose)(sqlite3_tokenizer_cursor *pCursor);$/;"	m	struct:sqlite3_tokenizer_module
xClose	.\ext\fts2\fts2_tokenizer.h	/^  int (*xClose)(sqlite3_tokenizer_cursor *pCursor);$/;"	m	struct:sqlite3_tokenizer_module
xClose	.\ext\fts3\fts3_tokenizer.h	/^  int (*xClose)(sqlite3_tokenizer_cursor *pCursor);$/;"	m	struct:sqlite3_tokenizer_module
xCmp	.\src\sqliteInt.h	/^  int (*xCmp)(void*,int, const void*, int, const void*);$/;"	m	struct:CollSeq
xCodec	.\src\pager.c	/^  void *(*xCodec)(void*,void*,Pgno,int); \/* Routine for en\/decoding data *\/$/;"	m	struct:Pager	file:
xCodecFree	.\src\pager.c	/^  void (*xCodecFree)(void*);             \/* Destructor for the codec *\/$/;"	m	struct:Pager	file:
xCodecSizeChng	.\src\pager.c	/^  void (*xCodecSizeChng)(void*,int,int); \/* Notify of page size changes *\/$/;"	m	struct:Pager	file:
xCollNeeded	.\src\sqliteInt.h	/^  void(*xCollNeeded)(void*,sqlite3*,int eTextRep,const char*);$/;"	m	struct:sqlite3
xCollNeeded16	.\src\sqliteInt.h	/^  void(*xCollNeeded16)(void*,sqlite3*,int eTextRep,const void*);$/;"	m	struct:sqlite3
xColumnCount	.\ext\fts5\fts5.h	/^  int (*xColumnCount)(Fts5Context*);$/;"	m	struct:Fts5ExtensionApi
xColumnSize	.\ext\fts5\fts5.h	/^  int (*xColumnSize)(Fts5Context*, int iCol, int *pnToken);$/;"	m	struct:Fts5ExtensionApi
xColumnText	.\ext\fts5\fts5.h	/^  int (*xColumnText)(Fts5Context*, int iCol, const char **pz, int *pn);$/;"	m	struct:Fts5ExtensionApi
xColumnTotalSize	.\ext\fts5\fts5.h	/^  int (*xColumnTotalSize)(Fts5Context*, int iCol, sqlite3_int64 *pnToken);$/;"	m	struct:Fts5ExtensionApi
xCommitCallback	.\src\sqliteInt.h	/^  int (*xCommitCallback)(void*);    \/* Invoked at every commit. *\/$/;"	m	struct:sqlite3
xCompare	.\src\vdbesort.c	/^  SorterCompare xCompare;         \/* Compare function to use *\/$/;"	m	struct:SortSubtask	file:
xCond	.\ext\fts5\fts5_tokenize.c	/^  int (*xCond)(char *zStem, int nStem);$/;"	m	struct:PorterRule	file:
xCreate	.\ext\fts1\fts1_tokenizer.h	/^  int (*xCreate)(int argc, const char *const*argv,$/;"	m	struct:sqlite3_tokenizer_module
xCreate	.\ext\fts1\tokenizer.h	/^  int (*xCreate)(int argc, const char **argv,$/;"	m	struct:sqlite3_tokenizer_module
xCreate	.\ext\fts2\fts2_tokenizer.h	/^  int (*xCreate)($/;"	m	struct:sqlite3_tokenizer_module
xCreate	.\ext\fts3\fts3_tokenizer.h	/^  int (*xCreate)($/;"	m	struct:sqlite3_tokenizer_module
xCreate	.\ext\fts5\fts5.h	/^  int (*xCreate)(void*, const char **azArg, int nArg, Fts5Tokenizer **ppOut);$/;"	m	struct:fts5_tokenizer
xCreateFunction	.\ext\fts5\fts5.h	/^  int (*xCreateFunction)($/;"	m	struct:fts5_api
xCreateTokenizer	.\ext\fts5\fts5.h	/^  int (*xCreateTokenizer)($/;"	m	struct:fts5_api
xDel	.\src\sqliteInt.h	/^  void (*xDel)(void*);  \/* Destructor for pUser *\/$/;"	m	struct:CollSeq
xDel	.\src\vdbeInt.h	/^  void (*xDel)(void*);\/* Destructor for Mem.z - only valid if MEM_Dyn *\/$/;"	m	struct:Mem
xDelUser	.\ext\rtree\sqlite3rtree.h	/^  void (*xDelUser)(void *);       \/* Called by SQLite to clean up pUser *\/$/;"	m	struct:sqlite3_rtree_geometry
xDelUser	.\ext\rtree\sqlite3rtree.h	/^  void (*xDelUser)(void*);          \/* function to free pUser *\/$/;"	m	struct:sqlite3_rtree_query_info
xDelete	.\ext\fts5\fts5.h	/^  void (*xDelete)(Fts5Tokenizer*);$/;"	m	struct:fts5_tokenizer
xDelete	.\ext\fts5\fts5_main.c	/^  void(*xDelete)(void*);          \/* Destructor *\/$/;"	m	struct:Fts5Auxdata	file:
xDelete	.\src\vdbeInt.h	/^  void (*xDelete)(void *);        \/* Destructor for the aux data *\/$/;"	m	struct:AuxData
xDestroy	.\ext\fts1\fts1_tokenizer.h	/^  int (*xDestroy)(sqlite3_tokenizer *pTokenizer);$/;"	m	struct:sqlite3_tokenizer_module
xDestroy	.\ext\fts1\tokenizer.h	/^  int (*xDestroy)(sqlite3_tokenizer *pTokenizer);$/;"	m	struct:sqlite3_tokenizer_module
xDestroy	.\ext\fts2\fts2_tokenizer.h	/^  int (*xDestroy)(sqlite3_tokenizer *pTokenizer);$/;"	m	struct:sqlite3_tokenizer_module
xDestroy	.\ext\fts3\fts3_tokenizer.h	/^  int (*xDestroy)(sqlite3_tokenizer *pTokenizer);$/;"	m	struct:sqlite3_tokenizer_module
xDestroy	.\ext\fts5\fts5_main.c	/^  void (*xDestroy)(void*);        \/* Destructor function *\/$/;"	m	struct:Fts5Auxiliary	file:
xDestroy	.\ext\fts5\fts5_main.c	/^  void (*xDestroy)(void*);        \/* Destructor function *\/$/;"	m	struct:Fts5TokenizerModule	file:
xDestroy	.\src\sqliteInt.h	/^  void (*xDestroy)(void *);            \/* Module destructor function *\/$/;"	m	struct:Module
xDestroy	.\src\sqliteInt.h	/^  void (*xDestroy)(void *);$/;"	m	struct:FuncDestructor
xDestroy	.\src\test_quota.c	/^  void (*xDestroy)(void*);       \/* Optional destructor for pArg *\/$/;"	m	struct:quotaGroup	file:
xDestructor	.\ext\rtree\rtree.c	/^  void (*xDestructor)(void*);$/;"	m	struct:RtreeGeomCallback	file:
xExprCallback	.\src\sqliteInt.h	/^  int (*xExprCallback)(Walker*, Expr*);     \/* Callback for expressions *\/$/;"	m	struct:Walker
xF5tApi	.\ext\fts5\fts5_tcl.c	/^static int xF5tApi($/;"	f	file:
xF5tDestroy	.\ext\fts5\fts5_tcl.c	/^static void xF5tDestroy(void *pCtx){$/;"	f	file:
xF5tFree	.\ext\fts5\fts5_tcl.c	/^static void xF5tFree(ClientData clientData){$/;"	f	file:
xF5tFunction	.\ext\fts5\fts5_tcl.c	/^static void xF5tFunction($/;"	f	file:
xFinalize	.\src\sqliteInt.h	/^  void (*xFinalize)(sqlite3_context*);                \/* Aggregate finalizer *\/$/;"	m	struct:FuncDef
xFindTokenizer	.\ext\fts5\fts5.h	/^  int (*xFindTokenizer)($/;"	m	struct:fts5_api
xFree	.\ext\fts1\ft_hash.h	/^  void (*xFree)(void *);  \/* free() function to use *\/$/;"	m	struct:Hash
xFree	.\ext\fts1\fts1_hash.h	/^  void (*xFree)(void *);  \/* free() function to use *\/$/;"	m	struct:fts1Hash
xFree	.\ext\icu\icu.c	/^static void xFree(void *p){$/;"	f	file:
xFree	.\src\test_intarray.c	/^  void (*xFree)(void*);     \/* Function used to free a[] *\/$/;"	m	struct:sqlite3_intarray	file:
xFreeSchema	.\src\btreeInt.h	/^  void (*xFreeSchema)(void*);  \/* Destructor for BtShared.pSchema *\/$/;"	m	struct:BtShared
xFunc	.\ext\fts5\fts5_main.c	/^  fts5_extension_function xFunc;  \/* Callback function *\/$/;"	m	struct:Fts5Auxiliary	file:
xFunc	.\src\sqliteInt.h	/^  int (*xFunc)(void *,int);  \/* The busy callback *\/$/;"	m	struct:BusyHandler
xFunc	.\src\sqliteInt.h	/^  void (*xFunc)(sqlite3_context*,int,sqlite3_value**); \/* Regular function *\/$/;"	m	struct:FuncDef
xGeom	.\ext\rtree\rtree.c	/^    int (*xGeom)(sqlite3_rtree_geometry*,int,RtreeDValue*,int*);$/;"	m	union:RtreeConstraint::__anon6	file:
xGeom	.\ext\rtree\rtree.c	/^  int (*xGeom)(sqlite3_rtree_geometry*, int, RtreeDValue*, int*);$/;"	m	struct:RtreeGeomCallback	file:
xGetAuxdata	.\ext\fts5\fts5.h	/^  void *(*xGetAuxdata)(Fts5Context*, int bClear);$/;"	m	struct:Fts5ExtensionApi
xInst	.\ext\fts5\fts5.h	/^  int (*xInst)(Fts5Context*, int iIdx, int *piPhrase, int *piCol, int *piOff);$/;"	m	struct:Fts5ExtensionApi
xInstCount	.\ext\fts5\fts5.h	/^  int (*xInstCount)(Fts5Context*, int *pnInst);$/;"	m	struct:Fts5ExtensionApi
xLanguageid	.\ext\fts3\fts3_tokenizer.h	/^  int (*xLanguageid)(sqlite3_tokenizer_cursor *pCsr, int iLangid);$/;"	m	struct:sqlite3_tokenizer_module
xLog	.\src\sqliteInt.h	/^  void (*xLog)(void*,int,const char*); \/* Function for logging *\/$/;"	m	struct:Sqlite3Config
xLogcallback	.\src\test1.c	/^static void xLogcallback(void *unused, int err, char *zMsg){$/;"	f	file:
xMalloc	.\ext\fts1\ft_hash.h	/^  void *(*xMalloc)(int);  \/* malloc() function to use *\/$/;"	m	struct:Hash
xMalloc	.\ext\fts1\fts1_hash.h	/^  void *(*xMalloc)(int);  \/* malloc() function to use *\/$/;"	m	struct:fts1Hash
xNext	.\ext\fts1\fts1_tokenizer.h	/^  int (*xNext)(sqlite3_tokenizer_cursor *pCursor,$/;"	m	struct:sqlite3_tokenizer_module
xNext	.\ext\fts1\tokenizer.h	/^  int (*xNext)(sqlite3_tokenizer_cursor *pCursor,$/;"	m	struct:sqlite3_tokenizer_module
xNext	.\ext\fts2\fts2_tokenizer.h	/^  int (*xNext)($/;"	m	struct:sqlite3_tokenizer_module
xNext	.\ext\fts3\fts3_tokenizer.h	/^  int (*xNext)($/;"	m	struct:sqlite3_tokenizer_module
xNextChar	.\ext\misc\regexp.c	/^  unsigned (*xNextChar)(ReInput*);  \/* Next character function *\/$/;"	m	struct:ReCompiled	file:
xOp	.\src\test4.c	/^  void (*xOp)(Thread*);  \/* next operation to do *\/$/;"	m	struct:Thread	file:
xOp	.\src\test7.c	/^  void (*xOp)(Thread*);    \/* next operation to do *\/$/;"	m	struct:Thread	file:
xOpen	.\ext\fts1\fts1_tokenizer.h	/^  int (*xOpen)(sqlite3_tokenizer *pTokenizer,$/;"	m	struct:sqlite3_tokenizer_module
xOpen	.\ext\fts1\tokenizer.h	/^  int (*xOpen)(sqlite3_tokenizer *pTokenizer,$/;"	m	struct:sqlite3_tokenizer_module
xOpen	.\ext\fts2\fts2_tokenizer.h	/^  int (*xOpen)($/;"	m	struct:sqlite3_tokenizer_module
xOpen	.\ext\fts3\fts3_tokenizer.h	/^  int (*xOpen)($/;"	m	struct:sqlite3_tokenizer_module
xOrig	.\src\test_syscall.c	/^  sqlite3_syscall_ptr xOrig;$/;"	m	struct:TestSyscallArray	file:
xOut	.\src\test_vfstrace.c	/^  int (*xOut)(const char*, void*);    \/* Send output here *\/$/;"	m	struct:vfstrace_info	file:
xParseCell	.\src\btreeInt.h	/^  void (*xParseCell)(MemPage*,u8*,CellInfo*); \/* btreeParseCell method *\/$/;"	m	struct:MemPage
xPhraseCount	.\ext\fts5\fts5.h	/^  int (*xPhraseCount)(Fts5Context*);$/;"	m	struct:Fts5ExtensionApi
xPhraseFirst	.\ext\fts5\fts5.h	/^  void (*xPhraseFirst)(Fts5Context*, int iPhrase, Fts5PhraseIter*, int*, int*);$/;"	m	struct:Fts5ExtensionApi
xPhraseNext	.\ext\fts5\fts5.h	/^  void (*xPhraseNext)(Fts5Context*, Fts5PhraseIter*, int *piCol, int *piOff);$/;"	m	struct:Fts5ExtensionApi
xPhraseSize	.\ext\fts5\fts5.h	/^  int (*xPhraseSize)(Fts5Context*, int iPhrase);$/;"	m	struct:Fts5ExtensionApi
xProc	.\test\threadtest3.c	/^  char *(*xProc)(int, void*);     \/* Thread main proc *\/$/;"	m	struct:Thread	file:
xProc	.\test\tt3_stress.c	/^  void (*xProc)(Error*, Sqlite*, int);$/;"	m	struct:Stress2Ctx	file:
xProfile	.\src\sqliteInt.h	/^  void (*xProfile)(void*,const char*,u64);  \/* Profiling function *\/$/;"	m	struct:sqlite3
xProgress	.\src\sqliteInt.h	/^  int (*xProgress)(void *);     \/* The progress callback *\/$/;"	m	struct:sqlite3
xQueryFunc	.\ext\rtree\rtree.c	/^    int (*xQueryFunc)(sqlite3_rtree_query_info*);$/;"	m	union:RtreeConstraint::__anon6	file:
xQueryFunc	.\ext\rtree\rtree.c	/^  int (*xQueryFunc)(sqlite3_rtree_query_info*);$/;"	m	struct:RtreeGeomCallback	file:
xQueryPhrase	.\ext\fts5\fts5.h	/^  int (*xQueryPhrase)(Fts5Context*, int iPhrase, void *pUserData,$/;"	m	struct:Fts5ExtensionApi
xQueryPhraseCb	.\ext\fts5\fts5_tcl.c	/^static int xQueryPhraseCb($/;"	f	file:
xReiniter	.\src\pager.c	/^  void (*xReiniter)(DbPage*); \/* Call this routine when reloading pages *\/$/;"	m	struct:Pager	file:
xRollbackCallback	.\src\sqliteInt.h	/^  void (*xRollbackCallback)(void*); \/* Invoked at every commit. *\/$/;"	m	struct:sqlite3
xRowCount	.\ext\fts5\fts5.h	/^  int (*xRowCount)(Fts5Context*, sqlite3_int64 *pnRow);$/;"	m	struct:Fts5ExtensionApi
xRowid	.\ext\fts5\fts5.h	/^  sqlite3_int64 (*xRowid)(Fts5Context*);$/;"	m	struct:Fts5ExtensionApi
xSelectCallback	.\src\sqliteInt.h	/^  int (*xSelectCallback)(Walker*,Select*);  \/* Callback for SELECTs *\/$/;"	m	struct:Walker
xSelectCallback2	.\src\sqliteInt.h	/^  void (*xSelectCallback2)(Walker*,Select*);\/* Second callback for SELECTs *\/$/;"	m	struct:Walker
xSetAuxdata	.\ext\fts5\fts5.h	/^  int (*xSetAuxdata)(Fts5Context*, void *pAux, void(*xDelete)(void*));$/;"	m	struct:Fts5ExtensionApi
xSetAuxdataDestructor	.\ext\fts5\fts5_tcl.c	/^static void xSetAuxdataDestructor(void *p){$/;"	f	file:
xSqllog	.\src\sqliteInt.h	/^  void(*xSqllog)(void*,sqlite3*,const char*, int);$/;"	m	struct:Sqlite3Config
xStep	.\src\sqliteInt.h	/^  void (*xStep)(sqlite3_context*,int,sqlite3_value**); \/* Aggregate step *\/$/;"	m	struct:FuncDef
xStress	.\src\pcache.c	/^  int (*xStress)(void*,PgHdr*);       \/* Call to try make a page clean *\/$/;"	m	struct:PCache	file:
xTask	.\src\threads.c	/^  void *(*xTask)(void*);         \/* The thread routine *\/$/;"	m	struct:SQLiteThread	file:
xTask	.\src\threads.c	/^  void *(*xTask)(void*);   \/* The routine to run as a thread *\/$/;"	m	struct:SQLiteThread	file:
xTest	.\src\test_syscall.c	/^  sqlite3_syscall_ptr xTest;$/;"	m	struct:TestSyscallArray	file:
xTestCallback	.\src\sqliteInt.h	/^  int (*xTestCallback)(int);        \/* Invoked by sqlite3FaultSim() *\/$/;"	m	struct:Sqlite3Config
xToken	.\ext\fts5\fts5_tcl.c	/^  int (*xToken)(void*, int, const char*, int, int, int);$/;"	m	struct:F5tTokenizerContext	file:
xToken	.\ext\fts5\fts5_tokenize.c	/^  int (*xToken)(void*, int, const char*, int, int, int);$/;"	m	struct:PorterContext	file:
xTokenize	.\ext\fts5\fts5.h	/^  int (*xTokenize)(Fts5Context*, $/;"	m	struct:Fts5ExtensionApi
xTokenize	.\ext\fts5\fts5.h	/^  int (*xTokenize)(Fts5Tokenizer*, $/;"	m	struct:fts5_tokenizer
xTokenizeCb	.\ext\fts5\fts5_tcl.c	/^static int xTokenizeCb($/;"	f	file:
xTokenizeCb2	.\ext\fts5\fts5_tcl.c	/^static int xTokenizeCb2($/;"	f	file:
xTrace	.\src\sqliteInt.h	/^  void (*xTrace)(void*,const char*);        \/* Trace function *\/$/;"	m	struct:sqlite3
xUnlockNotify	.\src\sqliteInt.h	/^  void (*xUnlockNotify)(void **, int);  \/* Unlock notify callback *\/$/;"	m	struct:sqlite3
xUpdateCallback	.\src\sqliteInt.h	/^  void (*xUpdateCallback)(void*,int, const char*,const char*,sqlite_int64);$/;"	m	struct:sqlite3
xUserData	.\ext\fts5\fts5.h	/^  void *(*xUserData)(Fts5Context*);$/;"	m	struct:Fts5ExtensionApi
xVdbeBranch	.\src\sqliteInt.h	/^  void (*xVdbeBranch)(void*,int iSrcLine,u8 eThis,u8 eMx);  \/* Callback *\/$/;"	m	struct:Sqlite3Config
xWalCallback	.\src\sqliteInt.h	/^  int (*xWalCallback)(void *, sqlite3 *, const char *, int);$/;"	m	struct:sqlite3
xferCompatibleCollation	.\src\insert.c	/^static int xferCompatibleCollation(const char *z1, const char *z2){$/;"	f	file:
xferCompatibleIndex	.\src\insert.c	/^static int xferCompatibleIndex(Index *pDest, Index *pSrc){$/;"	f	file:
xferOptimization	.\src\insert.c	/^static int xferOptimization($/;"	f	file:
xmax	.\src\test_rtree.c	/^    double xmax;$/;"	m	struct:Circle::Box	file:
xmin	.\src\test_rtree.c	/^    double xmin;$/;"	m	struct:Circle::Box	file:
xsliceGeometryCallback	.\test\speedtest1.c	/^static int xsliceGeometryCallback($/;"	f	file:
xthreadsafe	.\src\sqlite3ext.h	/^  int (*xthreadsafe)(void);$/;"	m	struct:sqlite3_api_routines
y	.\src\test_rtree.c	/^  double y;$/;"	m	struct:Cube	file:
y	.\test\speedtest1.c	/^  unsigned int x, y;         \/* Pseudo-random number generator state *\/$/;"	m	struct:Global	file:
yColCache	.\src\sqliteInt.h	/^  struct yColCache {$/;"	s	struct:Parse
yDbMask	.\src\sqliteInt.h	/^  typedef unsigned char yDbMask[(SQLITE_MAX_ATTACHED+9)\/8];$/;"	t
yDbMask	.\src\sqliteInt.h	/^  typedef unsigned int yDbMask;$/;"	t
ymax	.\src\test_rtree.c	/^    double ymax;$/;"	m	struct:Circle::Box	file:
ymin	.\src\test_rtree.c	/^    double ymin;$/;"	m	struct:Circle::Box	file:
ynVar	.\src\sqliteInt.h	/^typedef i16 ynVar;$/;"	t
ynVar	.\src\sqliteInt.h	/^typedef int ynVar;$/;"	t
yyFallback	.\src\lempar.c	/^static const YYCODETYPE yyFallback[] = {$/;"	v	file:
yyFallback	.\tool\lempar.c	/^static const YYCODETYPE yyFallback[] = {$/;"	v	file:
yyGrowStack	.\src\lempar.c	/^static void yyGrowStack(yyParser *p){$/;"	f	file:
yyGrowStack	.\tool\lempar.c	/^static void yyGrowStack(yyParser *p){$/;"	f	file:
yyParser	.\src\lempar.c	/^struct yyParser {$/;"	s	file:
yyParser	.\src\lempar.c	/^typedef struct yyParser yyParser;$/;"	t	typeref:struct:yyParser	file:
yyParser	.\tool\lempar.c	/^struct yyParser {$/;"	s	file:
yyParser	.\tool\lempar.c	/^typedef struct yyParser yyParser;$/;"	t	typeref:struct:yyParser	file:
yyRuleInfo	.\src\lempar.c	/^} yyRuleInfo[] = {$/;"	v	typeref:struct:__anon9	file:
yyRuleInfo	.\tool\lempar.c	/^} yyRuleInfo[] = {$/;"	v	typeref:struct:__anon35	file:
yyRuleName	.\src\lempar.c	/^static const char *const yyRuleName[] = {$/;"	v	file:
yyRuleName	.\tool\lempar.c	/^static const char *const yyRuleName[] = {$/;"	v	file:
yyStackEntry	.\src\lempar.c	/^struct yyStackEntry {$/;"	s	file:
yyStackEntry	.\src\lempar.c	/^typedef struct yyStackEntry yyStackEntry;$/;"	t	typeref:struct:yyStackEntry	file:
yyStackEntry	.\tool\lempar.c	/^struct yyStackEntry {$/;"	s	file:
yyStackEntry	.\tool\lempar.c	/^typedef struct yyStackEntry yyStackEntry;$/;"	t	typeref:struct:yyStackEntry	file:
yyStackOverflow	.\src\lempar.c	/^static void yyStackOverflow(yyParser *yypParser, YYMINORTYPE *yypMinor){$/;"	f	file:
yyStackOverflow	.\tool\lempar.c	/^static void yyStackOverflow(yyParser *yypParser, YYMINORTYPE *yypMinor){$/;"	f	file:
yyTokenName	.\src\lempar.c	/^static const char *const yyTokenName[] = { $/;"	v	file:
yyTokenName	.\tool\lempar.c	/^static const char *const yyTokenName[] = { $/;"	v	file:
yyTraceFILE	.\src\lempar.c	/^static FILE *yyTraceFILE = 0;$/;"	v	file:
yyTraceFILE	.\tool\lempar.c	/^static FILE *yyTraceFILE = 0;$/;"	v	file:
yyTracePrompt	.\src\lempar.c	/^static char *yyTracePrompt = 0;$/;"	v	file:
yyTracePrompt	.\tool\lempar.c	/^static char *yyTracePrompt = 0;$/;"	v	file:
yyTraceShift	.\src\lempar.c	/^static void yyTraceShift(yyParser *yypParser, int yyNewState){$/;"	f	file:
yyTraceShift	.\src\lempar.c	532;"	d	file:
yyTraceShift	.\tool\lempar.c	/^static void yyTraceShift(yyParser *yypParser, int yyNewState){$/;"	f	file:
yyTraceShift	.\tool\lempar.c	522;"	d	file:
yy_accept	.\src\lempar.c	/^static void yy_accept($/;"	f	file:
yy_accept	.\tool\lempar.c	/^static void yy_accept($/;"	f	file:
yy_destructor	.\src\lempar.c	/^static void yy_destructor($/;"	f	file:
yy_destructor	.\tool\lempar.c	/^static void yy_destructor($/;"	f	file:
yy_find_reduce_action	.\src\lempar.c	/^static int yy_find_reduce_action($/;"	f	file:
yy_find_reduce_action	.\tool\lempar.c	/^static int yy_find_reduce_action($/;"	f	file:
yy_find_shift_action	.\src\lempar.c	/^static int yy_find_shift_action($/;"	f	file:
yy_find_shift_action	.\tool\lempar.c	/^static int yy_find_shift_action($/;"	f	file:
yy_parse_failed	.\src\lempar.c	/^static void yy_parse_failed($/;"	f	file:
yy_parse_failed	.\tool\lempar.c	/^static void yy_parse_failed($/;"	f	file:
yy_pop_parser_stack	.\src\lempar.c	/^static int yy_pop_parser_stack(yyParser *pParser){$/;"	f	file:
yy_pop_parser_stack	.\tool\lempar.c	/^static int yy_pop_parser_stack(yyParser *pParser){$/;"	f	file:
yy_reduce	.\src\lempar.c	/^static void yy_reduce($/;"	f	file:
yy_reduce	.\tool\lempar.c	/^static void yy_reduce($/;"	f	file:
yy_shift	.\src\lempar.c	/^static void yy_shift($/;"	f	file:
yy_shift	.\tool\lempar.c	/^static void yy_shift($/;"	f	file:
yy_syntax_error	.\src\lempar.c	/^static void yy_syntax_error($/;"	f	file:
yy_syntax_error	.\tool\lempar.c	/^static void yy_syntax_error($/;"	f	file:
yyerrcnt	.\src\lempar.c	/^  int yyerrcnt;                 \/* Shifts left before out of the error *\/$/;"	m	struct:yyParser	file:
yyerrcnt	.\tool\lempar.c	/^  int yyerrcnt;                 \/* Shifts left before out of the error *\/$/;"	m	struct:yyParser	file:
yyidx	.\src\lempar.c	/^  int yyidx;                    \/* Index of top element in stack *\/$/;"	m	struct:yyParser	file:
yyidx	.\tool\lempar.c	/^  int yyidx;                    \/* Index of top element in stack *\/$/;"	m	struct:yyParser	file:
yyidxMax	.\src\lempar.c	/^  int yyidxMax;                 \/* Maximum value of yyidx *\/$/;"	m	struct:yyParser	file:
yyidxMax	.\tool\lempar.c	/^  int yyidxMax;                 \/* Maximum value of yyidx *\/$/;"	m	struct:yyParser	file:
yystack	.\src\lempar.c	/^  yyStackEntry *yystack;        \/* The parser's stack *\/$/;"	m	struct:yyParser	file:
yystack	.\tool\lempar.c	/^  yyStackEntry *yystack;        \/* The parser's stack *\/$/;"	m	struct:yyParser	file:
yystksz	.\src\lempar.c	/^  int yystksz;                  \/* Current side of the stack *\/$/;"	m	struct:yyParser	file:
yystksz	.\tool\lempar.c	/^  int yystksz;                  \/* Current side of the stack *\/$/;"	m	struct:yyParser	file:
yytestcase	.\src\lempar.c	86;"	d	file:
yytestcase	.\tool\lempar.c	80;"	d	file:
yyzerominor	.\src\lempar.c	/^static const YYMINORTYPE yyzerominor = { 0 };$/;"	v	file:
yyzerominor	.\tool\lempar.c	/^static const YYMINORTYPE yyzerominor = { 0 };$/;"	v	file:
z	.\ext\fts1\fts1.c	/^  const char *z;       \/* Pointer to token text.  Not '\\000' terminated *\/$/;"	m	struct:Token	file:
z	.\ext\fts2\fts2.c	/^  const char *z;       \/* Pointer to token text.  Not '\\000' terminated *\/$/;"	m	struct:Token	file:
z	.\ext\fts3\fts3Int.h	/^  char *z;                        \/* Text of the token *\/$/;"	m	struct:Fts3PhraseToken
z	.\ext\fts3\fts3_snippet.c	/^  char *z;                        \/* Pointer to buffer containing string *\/$/;"	m	struct:StrBuffer	file:
z	.\ext\fts3\fts3_test.c	/^  const char *z;                  \/* Pointer to token string *\/$/;"	m	struct:NearToken	file:
z	.\ext\misc\eval.c	/^  char *z;               \/* Accumulated output *\/$/;"	m	struct:EvalResult	file:
z	.\ext\misc\regexp.c	/^  const unsigned char *z;  \/* All text *\/$/;"	m	struct:ReInput	file:
z	.\ext\misc\spellfix.c	/^  char *z;                 \/* The complete text of the FROM string *\/$/;"	m	struct:EditDist3FromString	file:
z	.\ext\misc\spellfix.c	/^  char *z;                 \/* The complete text of the TO string *\/$/;"	m	struct:EditDist3ToString	file:
z	.\mptest\mptest.c	/^  char *z;         \/* the string *\/$/;"	m	struct:String	file:
z	.\src\shell.c	/^  char *z;            \/* Accumulated text for a field *\/$/;"	m	struct:ImportCtx	file:
z	.\src\sqliteInt.h	/^  const char *z;     \/* Text of the token.  Not NULL-terminated! *\/$/;"	m	struct:Token
z	.\src\test1.c	/^  char *z;     \/* The space *\/$/;"	m	struct:dstr	file:
z	.\src\test_multiplex.c	/^    char *z;                          \/* Name of this chunk *\/$/;"	m	struct:multiplexGroup::multiplexReal	file:
z	.\src\test_rtree.c	/^  double z;$/;"	m	struct:Cube	file:
z	.\src\vdbe.h	/^    char *z;               \/* Pointer to data for string (char array) types *\/$/;"	m	union:VdbeOp::p4union
z	.\src\vdbeInt.h	/^  char *z;            \/* String or BLOB value *\/$/;"	m	struct:Mem
z	.\tool\fuzzershell.c	/^  char *z;               \/* Accumulated output *\/$/;"	m	struct:EvalResult	file:
z	.\tool\sqldiff.c	/^  char *z;        \/* Text of the string *\/$/;"	m	struct:Str	file:
z	.\tool\sqldiff.c	/^  char z[NHASH];    \/* The values that have been hashed *\/$/;"	m	struct:hash	file:
zAlias	.\src\sqliteInt.h	/^    char *zAlias;     \/* The "B" part of a "A AS B" phrase.  zName is the "A" *\/$/;"	m	struct:SrcList::SrcList_item
zAlloc	.\src\test_onefile.c	/^  char *zAlloc;$/;"	m	struct:tmp_file	file:
zArg	.\ext\fts5\fts5_test_mi.c	/^  char *zArg;                     \/* nul-term'd copy of 2nd arg *\/$/;"	m	struct:Fts5MatchinfoCtx	file:
zArg	.\src\test4.c	/^  char *zArg;            \/* argument usable by xOp *\/$/;"	m	struct:Thread	file:
zArg	.\src\test7.c	/^  char *zArg;              \/* argument usable by xOp *\/$/;"	m	struct:Thread	file:
zArgv0	.\test\fuzzcheck.c	/^  const char *zArgv0;              \/* Name of program *\/$/;"	m	struct:GlobalVars	file:
zArgv0	.\tool\fuzzershell.c	/^  const char *zArgv0;              \/* Name of program *\/$/;"	m	struct:GlobalVars	file:
zArgv0	.\tool\sqldiff.c	/^  const char *zArgv0;       \/* Name of program *\/$/;"	m	struct:GlobalVars	file:
zAuth	.\src\tclsqlite.c	/^  char *zAuth;               \/* The authorization callback routine *\/$/;"	m	struct:SqliteDb	file:
zAuthContext	.\src\sqliteInt.h	/^  const char *zAuthContext;   \/* Put saved Parse.zAuthContext here *\/$/;"	m	struct:AuthContext
zAuthContext	.\src\sqliteInt.h	/^  const char *zAuthContext; \/* The 6th parameter to db->xAuth callbacks *\/$/;"	m	struct:Parse
zAuthPW	.\src\sqliteInt.h	/^  char *zAuthPW;                \/* Password used to authenticate *\/$/;"	m	struct:sqlite3_userauth
zAuthUser	.\src\sqliteInt.h	/^  char *zAuthUser;              \/* User name used to authenticate *\/$/;"	m	struct:sqlite3_userauth
zBase	.\src\sqliteInt.h	/^  char *zBase;         \/* A base allocation.  Not from malloc. *\/$/;"	m	struct:StrAccum
zBase	.\src\vdbeInt.h	/^  char zBase[100];   \/* Initial space *\/$/;"	m	struct:Explain
zBasis	.\ext\misc\fuzzer.c	/^  char *zBasis;              \/* Word being fuzzed *\/$/;"	m	struct:fuzzer_stem	file:
zBuf	.\ext\async\sqlite3async.c	/^  char *zBuf;         \/* Data to write to file (or NULL if op!=ASYNC_WRITE) *\/$/;"	m	struct:AsyncWrite	file:
zBuf	.\ext\misc\amatch.c	/^  char *zBuf;                \/* Temp-use buffer space *\/$/;"	m	struct:amatch_cursor	file:
zBuf	.\ext\misc\fuzzer.c	/^  char *zBuf;                \/* Temporary use buffer *\/$/;"	m	struct:fuzzer_cursor	file:
zBuf	.\ext\misc\json1.c	/^  char *zBuf;              \/* Append JSON content here *\/$/;"	m	struct:JsonString	file:
zBuf	.\src\journal.c	/^  char *zBuf;                     \/* Space to buffer journal writes *\/$/;"	m	struct:JournalFile	file:
zBuf	.\src\test6.c	/^  u8 *zBuf;                    \/* Pointer to copy of written data *\/$/;"	m	struct:WriteBuffer	file:
zBuf	.\src\test_fs.c	/^  char *zBuf;$/;"	m	struct:fs_cursor	file:
zBuffer	.\ext\fts2\fts2_icu.c	/^  char *zBuffer;$/;"	m	struct:IcuCursor	file:
zBuffer	.\ext\fts3\fts3_icu.c	/^  char *zBuffer;$/;"	m	struct:IcuCursor	file:
zBusy	.\src\tclsqlite.c	/^  char *zBusy;               \/* The busy callback routine *\/$/;"	m	struct:SqliteDb	file:
zCanonicalName	.\src\os_unix.c	/^  char *zCanonicalName;         \/* Canonical filename *\/$/;"	m	struct:vxworksFileId	file:
zChunk	.\src\memjournal.c	/^  u8 zChunk[JOURNAL_CHUNKSIZE];   \/* Content of this chunk *\/$/;"	m	struct:FileChunk	file:
zClassName	.\ext\misc\amatch.c	/^  char *zClassName;          \/* Name of this class.  Default: "amatch" *\/$/;"	m	struct:amatch_vtab	file:
zClassName	.\ext\misc\fuzzer.c	/^  char *zClassName;          \/* Name of this class.  Default: "fuzzer" *\/$/;"	m	struct:fuzzer_vtab	file:
zClose	.\ext\fts5\fts5_aux.c	/^  const char *zClose;             \/* Closing highlight *\/$/;"	m	struct:HighlightContext	file:
zCol	.\src\sqliteInt.h	/^    char *zCol;           \/* Name of column in zTo.  If NULL use PRIMARY KEY *\/$/;"	m	struct:FKey::sColMap
zColAff	.\src\sqliteInt.h	/^  char *zColAff;           \/* String defining the affinity of each column *\/$/;"	m	struct:Index
zColAff	.\src\sqliteInt.h	/^  char *zColAff;       \/* String defining the affinity of each column *\/$/;"	m	struct:Table
zColl	.\src\sqliteInt.h	/^  char *zColl;     \/* Collating sequence.  If NULL, use the default *\/$/;"	m	struct:Column
zCollName	.\src\whereInt.h	/^  char *zCollName;           \/* Required collating sequence, if not NULL *\/$/;"	m	struct:WhereScan
zComment	.\src\vdbe.h	/^  char *zComment;          \/* Comment to improve readability *\/$/;"	m	struct:VdbeOp
zCommit	.\src\tclsqlite.c	/^  char *zCommit;             \/* The commit hook callback routine *\/$/;"	m	struct:SqliteDb	file:
zContent	.\ext\fts5\fts5Int.h	/^  char *zContent;                 \/* content table *\/ $/;"	m	struct:Fts5Config
zContentExprlist	.\ext\fts5\fts5Int.h	/^  char *zContentExprlist;$/;"	m	struct:Fts5Config
zContentRowid	.\ext\fts5\fts5Int.h	/^  char *zContentRowid;            \/* "content_rowid=" option value *\/ $/;"	m	struct:Fts5Config
zContentTbl	.\ext\fts3\fts3Int.h	/^  char *zContentTbl;              \/* content=xxx option, or NULL *\/$/;"	m	struct:Fts3Table
zCost	.\ext\misc\amatch.c	/^  char zCost[10];       \/* Cost key (text rendering of rCost) *\/$/;"	m	struct:amatch_word	file:
zCostTab	.\ext\misc\amatch.c	/^  char *zCostTab;            \/* Name of edit-cost-table *\/$/;"	m	struct:amatch_vtab	file:
zCostTable	.\ext\misc\spellfix.c	/^  char *zCostTable;          \/* Table holding edit-distance cost numbers *\/$/;"	m	struct:spellfix1_vtab	file:
zCrashFile	.\src\test6.c	/^  char zCrashFile[500];        \/* Crash during an xSync() on this file *\/ $/;"	m	struct:CrashGlobal	file:
zCteErr	.\src\sqliteInt.h	/^    const char *zCteErr;            \/* Error message for circular references *\/$/;"	m	struct:With::Cte
zData	.\ext\rtree\rtree.c	/^  u8 *zData;                  \/* Content of the node, as should be on disk *\/$/;"	m	struct:RtreeNode	file:
zData	.\src\test6.c	/^  u8 *zData;                           \/* Buffer containing file contents *\/$/;"	m	struct:CrashFile	file:
zDataTbl	.\ext\fts5\fts5_index.c	/^  char *zDataTbl;                 \/* Name of %_data table *\/$/;"	m	struct:Fts5Index	file:
zDataTbl	.\ext\rbu\sqlite3rbu.c	/^  const char *zDataTbl;           \/* Name of rbu db table (or null) *\/$/;"	m	struct:RbuObjIter	file:
zDatabase	.\src\analyze.c	/^  const char *zDatabase;$/;"	m	struct:analysisInfo	file:
zDatabase	.\src\sqliteInt.h	/^    char *zDatabase;  \/* Name of database holding this table *\/$/;"	m	struct:SrcList::SrcList_item
zDb	.\ext\fts1\fts1.c	/^  const char *zDb;                 \/* logical database name *\/$/;"	m	struct:fulltext_vtab	file:
zDb	.\ext\fts1\fts1.c	/^  const char *zDb;         \/* Logical database name *\/$/;"	m	struct:TableSpec	file:
zDb	.\ext\fts2\fts2.c	/^  const char *zDb;                 \/* logical database name *\/$/;"	m	struct:fulltext_vtab	file:
zDb	.\ext\fts2\fts2.c	/^  const char *zDb;         \/* Logical database name *\/$/;"	m	struct:TableSpec	file:
zDb	.\ext\fts3\fts3Int.h	/^  const char *zDb;                \/* logical database name *\/$/;"	m	struct:Fts3Table
zDb	.\ext\fts5\fts5Int.h	/^  char *zDb;                      \/* Database holding FTS index (e.g. "main") *\/$/;"	m	struct:Fts5Config
zDb	.\ext\misc\amatch.c	/^  char *zDb;                 \/* Name of database.  (ex: "main") *\/$/;"	m	struct:amatch_vtab	file:
zDb	.\ext\misc\closure.c	/^  char *zDb;                 \/* Name of database.  (ex: "main") *\/$/;"	m	struct:closure_vtab	file:
zDb	.\ext\rtree\rtree.c	/^  char *zDb;                  \/* Name of database containing r-tree table *\/$/;"	m	struct:Rtree	file:
zDb	.\src\sqliteInt.h	/^  const char *zDb;    \/* Make sure all objects are contained in this database *\/$/;"	m	struct:DbFixer
zDb	.\src\test_fs.c	/^  char *zDb;                      \/* Name of db containing zTbl *\/$/;"	m	struct:fs_vtab	file:
zDb	.\test\tt3_stress.c	/^  const char *zDb;$/;"	m	struct:Stress2Ctx	file:
zDbFile	.\mptest\mptest.c	/^  char *zDbFile;         \/* Name of the database *\/$/;"	m	struct:Global	file:
zDbFilename	.\src\shell.c	/^  const char *zDbFilename;    \/* name of the database file *\/$/;"	m	struct:ShellState	file:
zDbName	.\ext\misc\spellfix.c	/^  char *zDbName;             \/* Name of database holding this table *\/$/;"	m	struct:spellfix1_vtab	file:
zDel	.\ext\rbu\sqlite3rbu.c	/^  char *zDel;                     \/* Delete this when closing file *\/$/;"	m	struct:rbu_file	file:
zDeleteOnClose	.\src\os_win.c	/^  LPWSTR zDeleteOnClose;  \/* Name of file to delete when closing *\/$/;"	m	struct:winFile	file:
zDelim	.\ext\fts1\simple_tokenizer.c	/^  const char *zDelim;          \/* token delimiters *\/$/;"	m	struct:simple_tokenizer	file:
zDestTable	.\src\shell.c	/^  char *zDestTable;      \/* Name of destination table when MODE_Insert *\/$/;"	m	struct:ShellState	file:
zDflt	.\src\sqliteInt.h	/^  char *zDflt;     \/* Original text of the default value *\/$/;"	m	struct:Column
zDots	.\test\speedtest1.c	/^static const char zDots[] =$/;"	v	file:
zEnd	.\src\sqliteInt.h	/^  const char *zEnd;     \/* One character past the end of input text *\/$/;"	m	struct:ExprSpan
zErr	.\ext\fts5\fts5_expr.c	/^  char *zErr;$/;"	m	struct:Fts5Parse	file:
zErr	.\ext\misc\regexp.c	/^  const char *zErr;           \/* Error message to return *\/$/;"	m	struct:ReCompiled	file:
zErr	.\src\test4.c	/^  char *zErr;           \/* operation error *\/$/;"	m	struct:Thread	file:
zErr	.\src\test7.c	/^  char *zErr;              \/* operation error *\/$/;"	m	struct:Thread	file:
zErr	.\test\threadtest3.c	/^  char *zErr;$/;"	m	struct:Error	file:
zErr	.\tool\offsets.c	/^  char *zErr;           \/* Error message text *\/$/;"	m	struct:GState	file:
zErrLog	.\mptest\mptest.c	/^  char *zErrLog;         \/* Filename for error log *\/$/;"	m	struct:Global	file:
zErrMsg	.\src\sqliteInt.h	/^  char *zErrMsg;       \/* An error message *\/$/;"	m	struct:Parse
zErrMsg	.\src\table.c	/^  char *zErrMsg;     \/* Error message text, if an error occurs *\/$/;"	m	struct:TabResult	file:
zErrMsg	.\src\vdbeInt.h	/^  char *zErrMsg;          \/* Error message written here *\/$/;"	m	struct:Vdbe
zErrmsg	.\ext\rbu\sqlite3rbu.c	/^  char *zErrmsg;                  \/* Error message if rc!=SQLITE_OK *\/$/;"	m	struct:sqlite3rbu	file:
zFName	.\src\test_vfstrace.c	/^  const char *zFName;       \/* Base name of the file *\/$/;"	m	struct:vfstrace_file	file:
zFile	.\ext\async\sqlite3async.c	/^  char *zFile;$/;"	m	struct:AsyncLock	file:
zFile	.\src\shell.c	/^  const char *zFile;  \/* Name of the input file *\/$/;"	m	struct:ImportCtx	file:
zFile	.\src\test_osinst.c	/^  char *zFile;                    \/* File name for pFd *\/$/;"	m	struct:VfslogVtab	file:
zFile	.\src\test_vfs.c	/^  char *zFile;                    \/* Associated file name *\/$/;"	m	struct:TestvfsBuffer	file:
zFile	.\test\threadtest1.c	/^  const char *zFile;  \/* Filename - used for error reporting *\/$/;"	m	struct:QueryResult	file:
zFilename	.\ext\misc\vfslog.c	/^  char *zFilename;                \/* Name of database file.  NULL for journal *\/$/;"	m	struct:VLogLog	file:
zFilename	.\src\os_unix.c	/^  char *zFilename;           \/* Name of the mmapped file *\/$/;"	m	struct:unixShmNode	file:
zFilename	.\src\os_win.c	/^  char *zFilename;           \/* Name of the file *\/$/;"	m	struct:winShmNode	file:
zFilename	.\src\pager.c	/^  char *zFilename;            \/* Name of the database file *\/$/;"	m	struct:Pager	file:
zFilename	.\src\test4.c	/^  char *zFilename;       \/* Name of database file *\/$/;"	m	struct:Thread	file:
zFilename	.\src\test7.c	/^  char *zFilename;         \/* Name of database file *\/$/;"	m	struct:Thread	file:
zFilename	.\src\test_quota.c	/^  char *zFilename;                \/* Name of this file *\/$/;"	m	struct:quotaFile	file:
zFilename	.\src\test_vfs.c	/^  const char *zFilename;          \/* Filename as passed to xOpen() *\/$/;"	m	struct:TestvfsFd	file:
zFilename	.\test\fuzzcheck.c	/^  char *zFilename;        \/* Filename.  NULL for delete-on-close. From malloc() *\/$/;"	m	struct:VFile	file:
zFreeOnClose	.\src\shell.c	/^  char *zFreeOnClose;         \/* Filename to free when closing *\/$/;"	m	struct:ShellState	file:
zFrom	.\ext\misc\amatch.c	/^  char *zFrom;             \/* Transform from (a string from user input) *\/$/;"	m	struct:amatch_rule	file:
zFrom	.\ext\misc\fuzzer.c	/^  char *zFrom;                \/* Transform from *\/$/;"	m	struct:fuzzer_rule	file:
zFts5Db	.\ext\fts5\fts5_vocab.c	/^  char *zFts5Db;                  \/* Db containing fts5 table *\/$/;"	m	struct:Fts5VocabTable	file:
zFts5Tbl	.\ext\fts5\fts5_vocab.c	/^  char *zFts5Tbl;                 \/* Name of fts5 table *\/$/;"	m	struct:Fts5VocabTable	file:
zFunc	.\ext\fts5\fts5_main.c	/^  char *zFunc;                    \/* Function name (nul-terminated) *\/$/;"	m	struct:Fts5Auxiliary	file:
zHash	.\ext\misc\spellfix.c	/^    char zHash[SPELLFIX_MX_HASH]; \/* the phonehash used for this match *\/$/;"	m	struct:spellfix1_cursor::spellfix1_row	file:
zHash	.\ext\misc\spellfix.c	/^  char zHash[SPELLFIX_MX_HASH];    \/* The current phonehash for zPattern *\/$/;"	m	struct:MatchQuery	file:
zHdr	.\tool\mkkeywordhash.c	/^static const char zHdr[] = $/;"	v	file:
zHelp	.\src\shell.c	/^static char zHelp[] =$/;"	v	file:
zHelp	.\test\speedtest1.c	/^static const char zHelp[] =$/;"	v	file:
zIdColumn	.\ext\misc\closure.c	/^  char *zIdColumn;           \/* Name of ID column of zTableName *\/$/;"	m	struct:closure_cursor	file:
zIdColumn	.\ext\misc\closure.c	/^  char *zIdColumn;           \/* Name of ID column of zTableName *\/$/;"	m	struct:closure_vtab	file:
zIdx	.\ext\rbu\sqlite3rbu.c	/^  char *zIdx;$/;"	m	struct:RbuState	file:
zIdx	.\ext\rbu\sqlite3rbu.c	/^  const char *zIdx;               \/* Name of target db index (or null) *\/$/;"	m	struct:RbuObjIter	file:
zIdx	.\src\test_sqllog.c	/^  char zIdx[SQLLOG_NAMESZ];       \/* Full path to *.idx file *\/$/;"	m	struct:SLGlobal	file:
zIn	.\ext\fts5\fts5_aux.c	/^  const char *zIn;                \/* Input text *\/$/;"	m	struct:HighlightContext	file:
zIn	.\src\test_server.c	/^  const char *zIn;             \/* Input filename or SQL statement *\/$/;"	m	struct:SqlMessage	file:
zIndexedBy	.\src\sqliteInt.h	/^      char *zIndexedBy;    \/* Identifier from "INDEXED BY <zIndex>" clause *\/$/;"	m	union:SrcList::SrcList_item::__anon20
zInit	.\ext\misc\regexp.c	/^  unsigned char zInit[12];    \/* Initial text to match *\/$/;"	m	struct:ReCompiled	file:
zInput	.\ext\fts1\fts1_porter.c	/^  const char *zInput;          \/* input we are tokenizing *\/$/;"	m	struct:porter_tokenizer_cursor	file:
zInput	.\ext\fts2\fts2_porter.c	/^  const char *zInput;          \/* input we are tokenizing *\/$/;"	m	struct:porter_tokenizer_cursor	file:
zInput	.\ext\fts3\fts3_porter.c	/^  const char *zInput;          \/* input we are tokenizing *\/$/;"	m	struct:porter_tokenizer_cursor	file:
zInput	.\ext\fts3\fts3_tokenize_vtab.c	/^  char *zInput;                   \/* Input string *\/$/;"	m	struct:Fts3tokCursor	file:
zInput	.\ext\fts5\fts5_tcl.c	/^  const char *zInput;$/;"	m	struct:F5tTokenizeCtx	file:
zInput	.\ext\misc\amatch.c	/^  char *zInput;              \/* Input word to match against *\/$/;"	m	struct:amatch_cursor	file:
zJContent	.\ext\misc\json1.c	/^    const char *zJContent; \/* Content for INT, REAL, and STRING *\/$/;"	m	union:JsonNode::__anon4	file:
zJournal	.\src\journal.c	/^  const char *zJournal;           \/* Name of the journal file *\/$/;"	m	struct:JournalFile	file:
zJournal	.\src\pager.c	/^  char *zJournal;             \/* Name of the journal file *\/$/;"	m	struct:Pager	file:
zJson	.\ext\misc\json1.c	/^  char *zJson;               \/* Input JSON *\/$/;"	m	struct:JsonEachCursor	file:
zJson	.\ext\misc\json1.c	/^  const char *zJson; \/* Original JSON string *\/$/;"	m	struct:JsonParse	file:
zKey	.\ext\fts5\fts5_hash.c	/^  char zKey[8];                   \/* Nul-terminated entry key *\/$/;"	m	struct:Fts5HashEntry	file:
zKey	.\ext\misc\amatch.c	/^  char *zKey;           \/* Key.  zero-terminated string.  Must be unique *\/$/;"	m	struct:amatch_avl	file:
zLanguageid	.\ext\fts3\fts3Int.h	/^  char *zLanguageid;              \/* languageid=xxx option, or NULL *\/$/;"	m	struct:Fts3Table
zLocale	.\ext\fts2\fts2_icu.c	/^  char *zLocale;$/;"	m	struct:IcuTokenizer	file:
zLocale	.\ext\fts3\fts3_icu.c	/^  char *zLocale;$/;"	m	struct:IcuTokenizer	file:
zLog	.\mptest\mptest.c	/^  char *zLog;            \/* Name of output log file *\/$/;"	m	struct:Global	file:
zLogName	.\src\test8.c	/^  char *zLogName;         \/* Name of the log table *\/$/;"	m	struct:echo_vtab	file:
zMagicHeader	.\src\btree.c	/^static const char zMagicHeader[] = SQLITE_FILE_HEADER;$/;"	v	file:
zMainloop	.\main.mk	/^	echo "static const char *zMainloop = " >> $@$/;"	m
zMalloc	.\ext\fts3\fts3_write.c	/^  char *zMalloc;                  \/* Malloc'd space (possibly) used for zTerm *\/$/;"	m	struct:SegmentNode	file:
zMalloc	.\ext\fts3\fts3_write.c	/^  char *zMalloc;                  \/* Malloc'd space (possibly) used for zTerm *\/$/;"	m	struct:SegmentWriter	file:
zMalloc	.\src\vdbeInt.h	/^  char *zMalloc;      \/* Space to hold MEM_Str or MEM_Blob if szMalloc>0 *\/$/;"	m	struct:Mem
zMask	.\ext\rbu\sqlite3rbu.c	/^  char *zMask;                    \/* Copy of update mask used with pUpdate *\/$/;"	m	struct:RbuUpdateStmt	file:
zMatchinfo	.\ext\fts3\fts3_snippet.c	/^  char *zMatchinfo;$/;"	m	struct:MatchinfoBuffer	file:
zMbcsName	.\src\test_quota.c	/^  char *zMbcsName;        \/* Full MBCS pathname of the file *\/$/;"	m	struct:quota_FILE	file:
zMsg	.\test\threadtest4.c	/^  char *zMsg;                 \/* Message returned by this thread *\/$/;"	m	struct:WorkerInfo	file:
zNN	.\test\speedtest1.c	/^  const char *zNN;           \/* Might be NOT NULL *\/$/;"	m	struct:Global	file:
zName	.\ext\async\sqlite3async.c	/^  char *zName;               \/* Underlying OS filename - used for debugging *\/$/;"	m	struct:AsyncFileData	file:
zName	.\ext\fts1\fts1.c	/^  const char *zName;               \/* virtual table name *\/$/;"	m	struct:fulltext_vtab	file:
zName	.\ext\fts1\fts1.c	/^  const char *zName;       \/* Name of the full-text index *\/$/;"	m	struct:TableSpec	file:
zName	.\ext\fts1\fulltext.c	/^  const char *zName;               \/* virtual table name *\/$/;"	m	struct:fulltext_vtab	file:
zName	.\ext\fts2\fts2.c	/^  const char *zName;               \/* virtual table name *\/$/;"	m	struct:fulltext_vtab	file:
zName	.\ext\fts2\fts2.c	/^  const char *zName;       \/* Name of the full-text index *\/$/;"	m	struct:TableSpec	file:
zName	.\ext\fts3\fts3Int.h	/^  const char *zName;              \/* virtual table name *\/$/;"	m	struct:Fts3Table
zName	.\ext\fts5\fts5Int.h	/^  char *zName;                    \/* Name of FTS index *\/$/;"	m	struct:Fts5Config
zName	.\ext\fts5\fts5_main.c	/^  char *zName;                    \/* Name of tokenizer *\/$/;"	m	struct:Fts5TokenizerModule	file:
zName	.\ext\misc\vtshim.c	/^  char *zName;                  \/* Name of the module *\/$/;"	m	struct:vtshim_aux	file:
zName	.\ext\rtree\rtree.c	/^  char *zName;                \/* Name of r-tree table *\/ $/;"	m	struct:Rtree	file:
zName	.\mptest\mptest.c	/^  char zName[32];        \/* Symbolic name of this process *\/$/;"	m	struct:Global	file:
zName	.\src\build.c	/^  const char *zName;   \/* Name of the table *\/$/;"	m	struct:TableLock	file:
zName	.\src\dbstat.c	/^  char *zName;                    \/* Value of 'name' column *\/$/;"	m	struct:StatCursor	file:
zName	.\src\os_unix.c	/^  const char *zName;            \/* Name of the system call *\/$/;"	m	struct:unix_syscall	file:
zName	.\src\os_win.c	/^  const char *zName;            \/* Name of the system call *\/$/;"	m	struct:win_syscall	file:
zName	.\src\pragma.h	/^  const char *const zName;  \/* Name of pragma *\/$/;"	m	struct:sPragmaNames
zName	.\src\sqliteInt.h	/^    char *zName;                    \/* Name of this CTE *\/$/;"	m	struct:With::Cte
zName	.\src\sqliteInt.h	/^    char *zName;            \/* Token associated with this expression *\/$/;"	m	struct:ExprList::ExprList_item
zName	.\src\sqliteInt.h	/^    char *zName;      \/* Name of the identifier *\/$/;"	m	struct:IdList::IdList_item
zName	.\src\sqliteInt.h	/^    char *zName;      \/* Name of the table *\/$/;"	m	struct:SrcList::SrcList_item
zName	.\src\sqliteInt.h	/^  char *zName;                        \/* Savepoint name (nul-terminated) *\/$/;"	m	struct:Savepoint
zName	.\src\sqliteInt.h	/^  char *zName;             \/* Name of this index *\/$/;"	m	struct:Index
zName	.\src\sqliteInt.h	/^  char *zName;            \/* The name of the trigger                        *\/$/;"	m	struct:Trigger
zName	.\src\sqliteInt.h	/^  char *zName;          \/* Name of the collating sequence, UTF-8 encoded *\/$/;"	m	struct:CollSeq
zName	.\src\sqliteInt.h	/^  char *zName;         \/* Name of the table or view *\/$/;"	m	struct:Table
zName	.\src\sqliteInt.h	/^  char *zName;         \/* Name of this database *\/$/;"	m	struct:Db
zName	.\src\sqliteInt.h	/^  char *zName;         \/* SQL name of the function. *\/$/;"	m	struct:FuncDef
zName	.\src\sqliteInt.h	/^  char *zName;     \/* Name of this column *\/$/;"	m	struct:Column
zName	.\src\sqliteInt.h	/^  const char *zName;                   \/* Name passed to create_module() *\/$/;"	m	struct:Module
zName	.\src\tclsqlite.c	/^  char *zName;          \/* Name of this function *\/$/;"	m	struct:SqlFunc	file:
zName	.\src\test6.c	/^  char *zName;$/;"	m	struct:CrashFile	file:
zName	.\src\test_journal.c	/^  const char *zName;       \/* Name of open file *\/$/;"	m	struct:jt_file	file:
zName	.\src\test_multiplex.c	/^  char *zName;                     \/* Base filename of this group *\/$/;"	m	struct:multiplexGroup	file:
zName	.\src\test_onefile.c	/^  const char *zName;$/;"	m	struct:fs_real_file	file:
zName	.\src\test_syscall.c	/^  const char *zName;$/;"	m	struct:TestSyscallArray	file:
zName	.\src\test_vfs.c	/^  char *zName;                    \/* Name of this VFS *\/$/;"	m	struct:Testvfs	file:
zName	.\src\vdbeInt.h	/^  char *zName;                    \/* Name of table or index *\/$/;"	m	struct:ScanStatus
zName	.\tool\mkkeywordhash.c	/^  char *zName;         \/* The keyword name *\/$/;"	m	struct:Keyword	file:
zNeededCollation	.\src\test1.c	/^static char zNeededCollation[200];$/;"	v	file:
zNull	.\src\tclsqlite.c	/^  char *zNull;               \/* Text to substitute for an SQL NULL value *\/$/;"	m	struct:SqliteDb	file:
zOffset	.\ext\fts1\fts1.c	/^  char *zOffset;  \/* Text rendering of aMatch[] *\/$/;"	m	struct:Snippet	file:
zOffset	.\ext\fts2\fts2.c	/^  char *zOffset;  \/* Text rendering of aMatch[] *\/$/;"	m	struct:Snippet	file:
zOpen	.\ext\fts5\fts5_aux.c	/^  const char *zOpen;              \/* Opening highlight *\/$/;"	m	struct:HighlightContext	file:
zOptions	.\src\shell.c	/^static const char zOptions[] = $/;"	v	file:
zOrigName	.\tool\mkkeywordhash.c	/^  char zOrigName[20];  \/* Original keyword name before processing *\/$/;"	m	struct:Keyword	file:
zOut	.\ext\fts5\fts5_aux.c	/^  char *zOut;                     \/* Output value *\/$/;"	m	struct:HighlightContext	file:
zOut	.\src\test_server.c	/^  const char *zOut;            \/* Tail of the SQL statement *\/$/;"	m	struct:SqlMessage	file:
zOutput	.\ext\fts5\fts5_tokenize.c	/^  const char *zOutput;$/;"	m	struct:PorterRule	file:
zPK	.\test\speedtest1.c	/^  const char *zPK;           \/* Might be UNIQUE or PRIMARY KEY *\/$/;"	m	struct:Global	file:
zPageUse	.\tool\showdb.c	/^static char **zPageUse;$/;"	v	file:
zPagetype	.\src\dbstat.c	/^  char *zPagetype;                \/* Value of 'pagetype' column *\/$/;"	m	struct:StatCursor	file:
zParentColumn	.\ext\misc\closure.c	/^  char *zParentColumn;       \/* Name of PARENT column in zTableName *\/$/;"	m	struct:closure_cursor	file:
zParentColumn	.\ext\misc\closure.c	/^  char *zParentColumn;       \/* Name of PARENT column in zTableName *\/$/;"	m	struct:closure_vtab	file:
zPath	.\src\dbstat.c	/^  char *zPath;                    \/* Path to this page *\/$/;"	m	struct:StatPage	file:
zPath	.\src\dbstat.c	/^  char *zPath;                    \/* Value of 'path' column *\/$/;"	m	struct:StatCursor	file:
zPath	.\src\os_unix.c	/^  const char *zPath;                  \/* Name of the file *\/$/;"	m	struct:unixFile	file:
zPath	.\src\os_win.c	/^  const char *zPath;      \/* Full pathname of this file *\/$/;"	m	struct:winFile	file:
zPattern	.\ext\misc\spellfix.c	/^  char *zPattern;              \/* rhs of MATCH clause *\/$/;"	m	struct:spellfix1_cursor	file:
zPattern	.\ext\misc\spellfix.c	/^  const char *zPattern;            \/* Transliterated input string *\/$/;"	m	struct:MatchQuery	file:
zPattern	.\src\test_quota.c	/^  const char *zPattern;          \/* Filename pattern to be quotaed *\/$/;"	m	struct:quotaGroup	file:
zPfx	.\src\btreeInt.h	/^  const char *zPfx; \/* Error message prefix *\/$/;"	m	struct:IntegrityCk
zPool	.\src\mem5.c	/^  u8 *zPool;       \/* Memory available to be allocated *\/$/;"	m	struct:Mem5Global	file:
zPrefix	.\ext\misc\nextchar.c	/^  const unsigned char *zPrefix;     \/* Prefix to scan *\/$/;"	m	struct:nextCharContext	file:
zPrefix	.\src\test_sqllog.c	/^  char zPrefix[SQLLOG_NAMESZ];    \/* Prefix for all created files *\/$/;"	m	struct:SLGlobal	file:
zProfile	.\src\tclsqlite.c	/^  char *zProfile;            \/* The profile callback routine *\/$/;"	m	struct:SqliteDb	file:
zProgress	.\src\tclsqlite.c	/^  char *zProgress;           \/* The progress callback routine *\/$/;"	m	struct:SqliteDb	file:
zRank	.\ext\fts5\fts5Int.h	/^  char *zRank;                    \/* Name of rank function *\/$/;"	m	struct:Fts5Config
zRank	.\ext\fts5\fts5_main.c	/^  char *zRank;                    \/* Custom rank function *\/$/;"	m	struct:Fts5Cursor	file:
zRankArgs	.\ext\fts5\fts5Int.h	/^  char *zRankArgs;                \/* Arguments to rank function *\/$/;"	m	struct:Fts5Config
zRankArgs	.\ext\fts5\fts5_main.c	/^  char *zRankArgs;                \/* Custom rank function args *\/$/;"	m	struct:Fts5Cursor	file:
zRbu	.\ext\rbu\sqlite3rbu.c	/^  char *zRbu;                     \/* Path to rbu db *\/$/;"	m	struct:sqlite3rbu	file:
zReadExprlist	.\ext\fts3\fts3Int.h	/^  char *zReadExprlist;$/;"	m	struct:Fts3Table
zReply	.\tool\rollback-test.c	/^static char zReply[1000];$/;"	v	file:
zResult	.\test\speedtest1.c	/^  char zResult[3000];        \/* Text of the current result *\/$/;"	m	struct:Global	file:
zRoot	.\ext\misc\json1.c	/^  char *zRoot;               \/* Path by which to filter zJson *\/$/;"	m	struct:JsonEachCursor	file:
zScript	.\src\tclsqlite.c	/^  char *zScript;        \/* The script to be run *\/$/;"	m	struct:SqlCollate	file:
zScript	.\src\test_thread.c	/^  char *zScript;           \/* The script to execute. *\/$/;"	m	struct:EvalEvent	file:
zScript	.\src\test_thread.c	/^  char *zScript;           \/* The script to execute. *\/$/;"	m	struct:SqlThread	file:
zSegmentsTbl	.\ext\fts3\fts3Int.h	/^  char *zSegmentsTbl;             \/* Name of %_segments table *\/$/;"	m	struct:Fts3Table
zSelName	.\src\sqliteInt.h	/^  char zSelName[12];     \/* Symbolic name of this SELECT use for debugging *\/$/;"	m	struct:Select
zSelf	.\ext\misc\amatch.c	/^  char *zSelf;               \/* Name of this virtual table *\/$/;"	m	struct:amatch_vtab	file:
zSelf	.\ext\misc\closure.c	/^  char *zSelf;               \/* Name of this virtual table *\/$/;"	m	struct:closure_vtab	file:
zSep	.\ext\misc\eval.c	/^  const char *zSep;      \/* Separator *\/$/;"	m	struct:EvalResult	file:
zSep	.\tool\fuzzershell.c	/^  const char *zSep;      \/* Separator *\/$/;"	m	struct:EvalResult	file:
zShellStatic	.\src\shell.c	/^static const char *zShellStatic = 0;$/;"	v	file:
zSnippet	.\ext\fts1\fts1.c	/^  char *zSnippet; \/* Snippet text *\/$/;"	m	struct:Snippet	file:
zSnippet	.\ext\fts2\fts2.c	/^  char *zSnippet; \/* Snippet text *\/$/;"	m	struct:Snippet	file:
zSpace	.\ext\misc\json1.c	/^  char zSpace[100];        \/* Initial static space *\/$/;"	m	struct:JsonString	file:
zSpan	.\src\sqliteInt.h	/^    char *zSpan;            \/* Original text of the expression *\/$/;"	m	struct:ExprList::ExprList_item
zSql	.\src\tclsqlite.c	/^  const char *zSql;               \/* Remaining SQL to execute *\/$/;"	m	struct:DbEvalContext	file:
zSql	.\src\tclsqlite.c	/^  const char *zSql;        \/* Text of the SQL statement *\/$/;"	m	struct:SqlPreparedStmt	file:
zSql	.\src\vdbeInt.h	/^  char *zSql;             \/* Text of the SQL statement that generated this *\/$/;"	m	struct:Vdbe
zStart	.\src\sqliteInt.h	/^  const char *zStart;   \/* First character of input text *\/$/;"	m	struct:ExprSpan
zState	.\ext\rbu\sqlite3rbu.c	/^  char *zState;                   \/* Path to state db (or NULL if zRbu) *\/$/;"	m	struct:sqlite3rbu	file:
zStateDb	.\ext\rbu\sqlite3rbu.c	/^  char zStateDb[5];               \/* Db name for state ("stat" or "main") *\/$/;"	m	struct:sqlite3rbu	file:
zStaticErr	.\src\test4.c	/^  char *zStaticErr;     \/* Static error message *\/$/;"	m	struct:Thread	file:
zStaticErr	.\src\test7.c	/^  char *zStaticErr;        \/* Static error message *\/$/;"	m	struct:Thread	file:
zStop	.\ext\fts3\fts3_aux.c	/^  char *zStop;$/;"	m	struct:Fts3auxCursor	file:
zSuffix	.\ext\fts5\fts5_tokenize.c	/^  const char *zSuffix;$/;"	m	struct:PorterRule	file:
zTableName	.\ext\misc\closure.c	/^  char *zTableName;          \/* Name of table holding parent\/child relation *\/$/;"	m	struct:closure_cursor	file:
zTableName	.\ext\misc\closure.c	/^  char *zTableName;          \/* Name of table holding parent\/child relation *\/$/;"	m	struct:closure_vtab	file:
zTableName	.\ext\misc\spellfix.c	/^  char *zTableName;          \/* Name of the virtual table *\/$/;"	m	struct:spellfix1_vtab	file:
zTableName	.\src\test8.c	/^  char *zTableName;       \/* Name of the real table *\/$/;"	m	struct:echo_vtab	file:
zTail	.\src\sqliteInt.h	/^  const char *zTail;        \/* All SQL text past the last semicolon parsed *\/$/;"	m	struct:Parse
zTarget	.\ext\rbu\sqlite3rbu.c	/^  char *zTarget;                  \/* Path to target db *\/$/;"	m	struct:sqlite3rbu	file:
zTarget	.\src\sqliteInt.h	/^  char *zTarget;       \/* Target table for DELETE, UPDATE, INSERT *\/$/;"	m	struct:TriggerStep
zTbl	.\ext\rbu\sqlite3rbu.c	/^  char *zTbl;$/;"	m	struct:RbuState	file:
zTbl	.\ext\rbu\sqlite3rbu.c	/^  const char *zTbl;               \/* Name of target db table *\/$/;"	m	struct:RbuObjIter	file:
zTbl	.\src\test_fs.c	/^  char *zTbl;                     \/* Name of docid->file map table *\/$/;"	m	struct:fs_vtab	file:
zTerm	.\ext\fts1\fulltext.c	/^  const char *zTerm;$/;"	m	struct:QueryTerm	file:
zTerm	.\ext\fts3\fts3Int.h	/^  char *zTerm;                    \/* Pointer to term buffer *\/$/;"	m	struct:Fts3MultiSegReader
zTerm	.\ext\fts3\fts3Int.h	/^  const char *zTerm;$/;"	m	struct:Fts3SegFilter
zTerm	.\ext\fts3\fts3_write.c	/^  char *zTerm;                    \/* Pointer to current term *\/$/;"	m	struct:Fts3SegReader	file:
zTerm	.\ext\fts3\fts3_write.c	/^  char *zTerm;                    \/* Pointer to previous term buffer *\/$/;"	m	struct:SegmentNode	file:
zTerm	.\ext\fts3\fts3_write.c	/^  char *zTerm;                    \/* Pointer to previous term buffer *\/$/;"	m	struct:SegmentWriter	file:
zTerm	.\ext\fts5\fts5_expr.c	/^  char *zTerm;                    \/* nul-terminated term *\/$/;"	m	struct:Fts5ExprTerm	file:
zTestName	.\test\fuzzcheck.c	/^  char zTestName[100];             \/* Name of current test *\/$/;"	m	struct:GlobalVars	file:
zTestName	.\tool\fuzzershell.c	/^  char zTestName[100];             \/* Name of current test *\/$/;"	m	struct:GlobalVars	file:
zText	.\src\sqliteInt.h	/^  char *zText;         \/* The string collected so far *\/$/;"	m	struct:StrAccum
zThis	.\src\test8.c	/^  char *zThis;            \/* Name of the echo table *\/$/;"	m	struct:echo_vtab	file:
zTitle	.\src\mem2.c	/^  char zTitle[100];  \/* The title text *\/$/;"	m	struct:__anon10	file:
zTo	.\ext\misc\amatch.c	/^  char zTo[4];             \/* Tranform to V.W value (extra space appended) *\/$/;"	m	struct:amatch_rule	file:
zTo	.\ext\misc\fuzzer.c	/^  char zTo[4];                \/* Transform to (extra space appended) *\/$/;"	m	struct:fuzzer_rule	file:
zTo	.\src\sqliteInt.h	/^  char *zTo;        \/* Name of table that the key points to (aka: Parent) *\/$/;"	m	struct:FKey
zToken	.\ext\fts1\fts1_porter.c	/^  char *zToken;                \/* storage for current token *\/$/;"	m	struct:porter_tokenizer_cursor	file:
zToken	.\ext\fts1\simple_tokenizer.c	/^  char *zToken;                \/* storage for current token *\/$/;"	m	struct:simple_tokenizer_cursor	file:
zToken	.\ext\fts2\fts2_porter.c	/^  char *zToken;                \/* storage for current token *\/$/;"	m	struct:porter_tokenizer_cursor	file:
zToken	.\ext\fts3\fts3_porter.c	/^  char *zToken;                \/* storage for current token *\/$/;"	m	struct:porter_tokenizer_cursor	file:
zToken	.\ext\fts3\fts3_tokenize_vtab.c	/^  const char *zToken;             \/* Current 'token' value *\/$/;"	m	struct:Fts3tokCursor	file:
zToken	.\ext\fts3\fts3_unicode.c	/^  char *zToken;                   \/* storage for current token *\/$/;"	m	struct:unicode_cursor	file:
zToken	.\src\sqliteInt.h	/^    char *zToken;          \/* Token value. Zero terminated and dequoted *\/$/;"	m	union:Expr::__anon15
zTokenType	.\tool\mkkeywordhash.c	/^  char *zTokenType;    \/* Token value for this keyword *\/$/;"	m	struct:Keyword	file:
zTrace	.\src\tclsqlite.c	/^  char *zTrace;              \/* The trace callback routine *\/$/;"	m	struct:SqliteDb	file:
zTransient	.\src\test_osinst.c	/^  char *zTransient;               \/* Transient 'file' string *\/$/;"	m	struct:VfslogCsr	file:
zType	.\src\sqliteInt.h	/^  char *zType;     \/* Data type for this column *\/$/;"	m	struct:Column
zType	.\src\sqliteInt.h	/^  const char *zType;  \/* Type of the container - used for error messages *\/$/;"	m	struct:DbFixer
zVarname	.\src\test_thread.c	/^  char *zVarname;          \/* Varname in parent script *\/$/;"	m	struct:SqlThread	file:
zVfs	.\mptest\mptest.c	/^  const char *zVfs;      \/* Name of VFS to use. Often NULL meaning "default" *\/$/;"	m	struct:Global	file:
zVfs	.\src\shell.c	/^  const char *zVfs;           \/* Name of VFS to use *\/$/;"	m	struct:ShellState	file:
zVfsName	.\ext\rbu\sqlite3rbu.c	/^  const char *zVfsName;           \/* Name of automatically created rbu vfs *\/$/;"	m	struct:sqlite3rbu	file:
zVfsName	.\src\test_vfstrace.c	/^  const char *zVfsName;               \/* Name of this trace-VFS *\/$/;"	m	struct:vfstrace_info	file:
zVocabLang	.\ext\misc\amatch.c	/^  char *zVocabLang;          \/* Name of vocabulary table language column *\/$/;"	m	struct:amatch_vtab	file:
zVocabTab	.\ext\misc\amatch.c	/^  char *zVocabTab;           \/* Name of vocabulary table *\/$/;"	m	struct:amatch_vtab	file:
zVocabWord	.\ext\misc\amatch.c	/^  char *zVocabWord;          \/* Name of vocabulary table word column *\/$/;"	m	struct:amatch_vtab	file:
zWR	.\test\speedtest1.c	/^  const char *zWR;           \/* Might be WITHOUT ROWID *\/$/;"	m	struct:Global	file:
zWal	.\ext\rbu\sqlite3rbu.c	/^  const char *zWal;               \/* Wal filename for this main db file *\/$/;"	m	struct:rbu_file	file:
zWal	.\src\pager.c	/^  char *zWal;                 \/* File name for write-ahead log *\/$/;"	m	struct:Pager	file:
zWalName	.\src\wal.c	/^  const char *zWalName;      \/* Name of WAL file *\/$/;"	m	struct:Wal	file:
zWord	.\ext\misc\amatch.c	/^  char zWord[4];        \/* Text of the word.  Extra space appended as needed *\/$/;"	m	struct:amatch_word	file:
zWord	.\ext\misc\spellfix.c	/^    char *zWord;                  \/* Text for this row *\/$/;"	m	struct:spellfix1_cursor::spellfix1_row	file:
zWriteExprlist	.\ext\fts3\fts3Int.h	/^  char *zWriteExprlist;$/;"	m	struct:Fts3Table
zeroJournalHdr	.\src\pager.c	/^static int zeroJournalHdr(Pager *pPager, int doTruncate){$/;"	f	file:
zeroPage	.\src\btree.c	/^static void zeroPage(MemPage *pPage, int flags){$/;"	f	file:
zeroblobFunc	.\src\func.c	/^static void zeroblobFunc($/;"	f	file:
